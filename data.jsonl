{"completion":"","prompt":"Elixir.Mix.compilers(): Returns the default compilers used by Mix.\n\nIt can be used in your `mix.exs` to prepend or\nappend new compilers to Mix:\n\n    def project do\n      [compilers: Mix.compilers() ++ [:foo, :bar]]\n    end\n\n"}
{"completion":"","prompt":"Elixir.Mix.debug(debug): Sets Mix debug mode.\n"}
{"completion":"","prompt":"Elixir.Mix.debug?(): Returns `true` if Mix is in debug mode, `false` otherwise.\n"}
{"completion":"","prompt":"Elixir.Mix.env(): Returns the current Mix environment.\n\nThis function should not be used at runtime in application code (as opposed\nto infrastructure and build code like Mix tasks). Mix is a build tool and may\nnot be available after the code is compiled (for example in a release).\n\nTo differentiate the program behavior depending on the environment, it is\nrecommended to use application environment through `Application.get_env/3`.\nProper configuration can be set in config files, often per-environment\n(see the `Config` module for more information).\n"}
{"completion":"","prompt":"Elixir.Mix.env(env): Changes the current Mix environment to `env`.\n\nBe careful when invoking this function as any project\nconfiguration won't be reloaded.\n\nThis function should not be used at runtime in application code\n(see `env/0` for more information).\n"}
{"completion":"","prompt":"Elixir.Mix.install(deps, opts \\\\ []): Installs and starts dependencies.\n\nThe given `deps` should be in the same format as defined in a regular Mix\nproject. See `mix help deps` for more information. As a shortcut, an atom\ncan be given as dependency to mean the latest version. In other words,\nspecifying `:decimal` is the same as `{:decimal, \">= 0.0.0\"}`.\n\nAfter each successful installation, a given set of dependencies is cached\nso starting another VM and calling `Mix.install/2` with the same dependencies\nwill avoid unnecessary downloads and compilations. The location of the cache\ndirectory can be controlled using the `MIX_INSTALL_DIR` environment variable.\n\nThis function can only be called outside of a Mix project and only with the\nsame dependencies in the given VM.\n\n**Note:** this feature is currently experimental and it may change\nin future releases.\n\n## Options\n\n  * `:force` - if `true`, runs with empty install cache. This is useful when you want\n    to update your dependencies or your install got into an inconsistent state.\n    To use this option, you can also set the `MIX_INSTALL_FORCE` environment variable.\n    (Default: `false`)\n\n  * `:verbose` - if `true`, prints additional debugging information\n    (Default: `false`)\n\n  * `:consolidate_protocols` - if `true`, runs protocol\n    consolidation via the `mix compile.protocols` task (Default: `true`)\n\n  * `:elixir` - if set, ensures the current Elixir version matches the given\n    version requirement (Default: `nil`)\n\n  * `:system_env` (since v1.13.0) - a list or a map of system environment variable\n    names with respective values as binaries. The system environment is made part\n    of the `Mix.install/2` cache, so different configurations will lead to different apps\n\n  * `:config` (since v1.13.0) - a keyword list of keyword lists with application\n    configuration to be set before the apps loaded. The configuration is part of\n    the `Mix.install/2` cache, so different configurations will lead to different\n    apps\n\n  * `:config_path` (since v1.14.0) - path to a configuration file. If a `runtime.exs`\n    file exists in the same directory as the given path, it is loaded too.\n\n  * `:lockfile` (since v1.14.0) - path to a lockfile to be used as a basis of\n    dependency resolution.\n\n## Examples\n\nInstalling `:decimal` and `:jason`:\n\n    Mix.install([\n      :decimal,\n      {:jason, \"~> 1.0\"}\n    ])\n\nInstalling `:nx` & `:exla`, and configuring the underlying applications\nand environment variables:\n\n    Mix.install(\n      [:nx, :exla],\n      config: [\n        nx: [default_backend: EXLA]\n      ],\n      system_env: [\n        XLA_TARGET: \"cuda111\"\n      ]\n    )\n\nInstalling a Mix project as a path dependency along with its configuration\nand deps:\n\n    # $ git clone https://github.com/hexpm/hexpm /tmp/hexpm\n    # $ cd /tmp/hexpm && mix setup\n\n    Mix.install(\n      [\n        {:hexpm, path: \"/tmp/hexpm\", env: :dev},\n      ],\n      config_path: \"/tmp/hexpm/config/config.exs\",\n      lockfile: \"/tmp/hexpm/mix.lock\"\n    )\n\n    Hexpm.Repo.query!(\"SELECT COUNT(1) from packages\")\n    #=> ...\n\nThe example above can be simplified by passing the application\nname as an atom for `:config_path` and `:lockfile`:\n\n    Mix.install(\n      [\n        {:hexpm, path: \"/tmp/hexpm\", env: :dev},\n      ],\n      config_path: :hexpm,\n      lockfile: :hexpm\n    )\n\n## Limitations\n\nThere is one limitation to `Mix.install/2`, which is actually an Elixir\nbehaviour. If you are installing a dependency that defines a struct or\nmacro, you cannot use the struct or macro immediately after the install\ncall. For example, this won't work:\n\n    Mix.install([:decimal])\n    %Decimal{} = Decimal.new(42)\n\nThat's because Elixir first expands all structs and all macros, and then\nit executes the code. This means that, by the time Elixir tries to expand\nthe `%Decimal{}` struct, the dependency has not been installed yet.\n\nLuckily this has a straightforward solution, which is move the code to\ninside a module:\n\n    Mix.install([:decimal])\n\n    defmodule Script do\n      def run do\n        %Decimal{} = Decimal.new(42)\n      end\n    end\n\n    Script.run()\n\nThe contents inside `defmodule` will only be expanded and executed\nafter `Mix.install/2` runs, which means that any struct, macros,\nand imports will be correctly handled.\n"}
{"completion":"","prompt":"Elixir.Mix.installed?(): Returns whether `Mix.install/2` was called in the current node.\n"}
{"completion":"","prompt":"Elixir.Mix.path_for(atom): The path for local archives or escripts.\n"}
{"completion":"","prompt":"Elixir.Mix.raise(message): Raises a Mix error that is nicely formatted, defaulting to exit status `1`.\n"}
{"completion":"","prompt":"Elixir.Mix.raise(message, opts): Raises a Mix error that is nicely formatted.\n\n## Options\n\n  * `:exit_status` - defines exit status, defaults to `1`\n\n"}
{"completion":"","prompt":"Elixir.Mix.shell(): Returns the current shell.\n\n`shell/0` can be used as a wrapper for the current shell. It contains\nconveniences for requesting information from the user, printing to the\nshell and so forth. The Mix shell is swappable (see `shell/1`), allowing\ndevelopers to use a test shell that simply sends messages to the current\nprocess instead of performing IO (see `Mix.Shell.Process`).\n\nBy default, this returns `Mix.Shell.IO`.\n\n## Examples\n\n    Mix.shell().info(\"Preparing to do something dangerous...\")\n\n    if Mix.shell().yes?(\"Are you sure?\") do\n      # do something dangerous\n    end\n\n"}
{"completion":"","prompt":"Elixir.Mix.shell(shell): Sets the current shell.\n\nAs an argument you may pass `Mix.Shell.IO`, `Mix.Shell.Process`,\n`Mix.Shell.Quiet`, or any module that implements the `Mix.Shell`\nbehaviour.\n\nAfter calling this function, `shell` becomes the shell that is\nreturned by `shell/0`.\n\n## Examples\n\n    iex> Mix.shell(Mix.Shell.IO)\n    :ok\n\nYou can use `shell/0` and `shell/1` to temporarily switch shells,\nfor example, if you want to run a Mix Task that normally produces\na lot of output:\n\n    shell = Mix.shell()\n    Mix.shell(Mix.Shell.Quiet)\n\n    try do\n      Mix.Task.run(\"noisy.task\")\n    after\n      Mix.shell(shell)\n    end\n\n"}
{"completion":"","prompt":"Elixir.Mix.target(): Returns the Mix target.\n"}
{"completion":"","prompt":"Elixir.Mix.target(target): Changes the current Mix target to `target`.\n\nBe careful when invoking this function as any project\nconfiguration won't be reloaded.\n"}
{"completion":"","prompt":"Elixir.Mix.CLI.main(args \\\\ System.argv()): Runs Mix according to the command line arguments.\n"}
{"completion":"","prompt":"Elixir.Mix.Compilers.Elixir.clean(manifest, compile_path): Removes compiled files for the given `manifest`.\n"}
{"completion":"","prompt":"Elixir.Mix.Compilers.Elixir.compile(manifest, srcs, dest, new_cache_key, new_parent_manifests, new_parents, opts): Compiles stale Elixir files.\n\nIt expects a `manifest` file, the source directories, the destination\ndirectory, the cache key based on compiler configuration, external\nmanifests, and external modules, followed by opts.\n\nThe `manifest` is written down with information including dependencies\nbetween modules, which helps it recompile only the modules that\nhave changed at runtime.\n"}
{"completion":"","prompt":"Elixir.Mix.Compilers.Elixir.protocols_and_impls(manifest, compile_path): Returns protocols and implementations for the given `manifest`.\n"}
{"completion":"","prompt":"Elixir.Mix.Compilers.Elixir.read_manifest(manifest): Reads the manifest for external consumption.\n"}
{"completion":"","prompt":"Elixir.Mix.Compilers.Erlang.assert_valid_erlc_paths(erlc_paths): Asserts that the `:erlc_paths` configuration option that many Mix tasks\nrely on is valid.\n\nRaises a `Mix.Error` exception if the option is not valid, returns `:ok`\notherwise.\n"}
{"completion":"","prompt":"Elixir.Mix.Compilers.Erlang.clean(manifest): Removes compiled files for the given `manifest`.\n"}
{"completion":"","prompt":"Elixir.Mix.Compilers.Erlang.compile(manifest, mappings, opts \\\\ [], callback): Compiles the given `mappings`.\n\n`mappings` should be a list of tuples in the form of `{src, dest}`.\n\nA `manifest` file and a `callback` to be invoked for each src/dest pair\nmust be given. A src/dest pair where destination is `nil` is considered\nto be up to date and won't be (re-)compiled.\n\n## Options\n\n  * `:force` - forces compilation regardless of modification times\n\n  * `:parallel` - a mapset of files to compile in parallel\n\n"}
{"completion":"","prompt":"Elixir.Mix.Compilers.Erlang.compile(manifest, mappings, src_ext, dest_ext, opts, callback): Compiles the files in `mappings` with given extensions into\nthe destination, automatically invoking the callback for each\nstale input and output pair (or for all if `force` is `true`) and\nremoving files that no longer have a source, while keeping the\n`manifest` up to date.\n\n`mappings` should be a list of tuples in the form of `{src, dest}` paths.\n\n## Options\n\n  * `:force` - forces compilation regardless of modification times\n\n  * `:parallel` - a mapset of files to compile in parallel\n\n## Examples\n\nFor example, a simple compiler for Lisp Flavored Erlang\nwould be implemented like:\n\n    manifest = Path.join(Mix.Project.manifest_path(), \"compile.lfe\")\n    dest = Mix.Project.compile_path()\n\n    compile(manifest, [{\"src\", dest}], :lfe, :beam, opts, fn input, output ->\n      :lfe_comp.file(\n        to_erl_file(input),\n        [{:outdir, Path.dirname(output)}, :return, :report]\n      )\n    end)\n\nThe command above will:\n\n  1. look for files ending with the `lfe` extension in `src` path\n     and their `beam` counterpart in `ebin` path\n\n  2. for each stale file (or for all if `force` is `true`),\n     invoke the callback passing the calculated input\n     and output\n\n  3. update the manifest with the newly compiled outputs\n\n  4. remove any output in the manifest that does not\n     have an equivalent source\n\nThe callback must return `{:ok, term, warnings}` or\n`{:error, errors, warnings}` in case of error. This function returns\n`{status, diagnostics}` as specified in `Mix.Task.Compiler`.\n"}
{"completion":"","prompt":"Elixir.Mix.Compilers.Erlang.ensure_application!(app, input): Ensures the native OTP application is available.\n"}
{"completion":"","prompt":"Elixir.Mix.Compilers.Erlang.outputs(manifest): Returns the output paths in the manifest.\n"}
{"completion":"","prompt":"Elixir.Mix.Compilers.Erlang.to_erl_file(file): Converts the given `file` to a format accepted by\nthe Erlang compilation tools.\n"}
{"completion":"","prompt":"Elixir.Mix.Compilers.Test.require_and_run(matched_test_files, test_paths, elixirc_opts, opts): Requires and runs test files.\n\nIt expects all of the test patterns, the test files that were matched for the\ntest patterns, the test paths, and the opts from the test task.\n"}
{"completion":"","prompt":"Elixir.Mix.Config.config(root_key, opts): Configures the given `root_key`.\n\nKeyword lists are always deep merged.\n\n## Examples\n\nThe given `opts` are merged into the existing configuration\nfor the given `root_key`. Conflicting keys are overridden by the\nones specified in `opts`. For example, the application\nconfiguration below\n\n    config :logger,\n      level: :warn,\n      backends: [:console]\n\n    config :logger,\n      level: :info,\n      truncate: 1024\n\nwill have a final configuration for `:logger` of:\n\n    [level: :info, backends: [:console], truncate: 1024]\n\n"}
{"completion":"","prompt":"Elixir.Mix.Config.config(root_key, key, opts): Configures the given `key` for the given `root_key`.\n\nKeyword lists are always deep merged.\n\n## Examples\n\nThe given `opts` are merged into the existing values for `key`\nin the given `root_key`. Conflicting keys are overridden by the\nones specified in `opts`. For example, the application\nconfiguration below\n\n    config :ecto, Repo,\n      log_level: :warn,\n      adapter: Ecto.Adapters.Postgres\n\n    config :ecto, Repo,\n      log_level: :info,\n      pool_size: 10\n\nwill have a final value of the configuration for the `Repo`\nkey in the `:ecto` application of:\n\n    [log_level: :info, pool_size: 10, adapter: Ecto.Adapters.Postgres]\n\n"}
{"completion":"","prompt":"Elixir.Mix.Config.eval!(file, imported_paths \\\\ []): Evaluates the given configuration file.\n\nIt accepts a list of `imported_paths` that should raise if attempted\nto be imported again (to avoid recursive imports).\n\nIt returns a tuple with the configuration and the imported paths.\n"}
{"completion":"","prompt":"Elixir.Mix.Config.merge(config1, config2): Merges two configurations.\n\nThe configurations are merged together with the values in\nthe second one having higher preference than the first in\ncase of conflicts. In case both values are set to keyword\nlists, it deep merges them.\n\n## Examples\n\n    iex> Mix.Config.merge([app: [k: :v1]], [app: [k: :v2]])\n    [app: [k: :v2]]\n\n    iex> Mix.Config.merge([app: [k: [v1: 1, v2: 2]]], [app: [k: [v2: :a, v3: :b]]])\n    [app: [k: [v1: 1, v2: :a, v3: :b]]]\n\n    iex> Mix.Config.merge([app1: []], [app2: []])\n    [app1: [], app2: []]\n\n"}
{"completion":"","prompt":"Elixir.Mix.Config.persist(config): Persists the given configuration by modifying\nthe configured applications environment.\n\n`config` should be a list of `{app, app_config}` tuples or a\n`%{app => app_config}` map where `app` are the applications to\nbe configured and `app_config` are the configuration (as key-value\npairs) for each of those applications.\n\nReturns the configured applications.\n\n## Examples\n\n    Mix.Config.persist(logger: [level: :error], my_app: [my_config: 1])\n    #=> [:logger, :my_app]\n\n"}
{"completion":"","prompt":"Elixir.Mix.Config.read!(file, imported_paths \\\\ []): Reads the configuration file.\n\nThe same as `eval!/2` but only returns the configuration\nin the given file, without returning the imported paths.\n\nIt exists for convenience purposes. For example, you could\ninvoke it inside your `mix.exs` to read some external data\nyou decided to move to a configuration file:\n\n    subsystem: Mix.Config.read!(\"rel/subsystem.exs\")\n\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.%Mix.Dep{}: The Mix.Dep struct keeps information about your project dependencies.\n\nIt contains:\n\n  * `scm` - a module representing the source code management tool (SCM)\n    operations\n\n  * `app` - the application name as an atom\n\n  * `requirement` - a binary or regular expression with the dependency's requirement\n\n  * `status` - the current status of the dependency, check\n    `Mix.Dep.format_status/1` for more information\n\n  * `opts` - the options given by the developer\n\n  * `deps` - dependencies of this dependency\n\n  * `top_level` - true if dependency was defined in the top-level project\n\n  * `manager` - the project management, possible values:\n    `:rebar3` | `:mix` | `:make` | `nil`\n\n  * `from` - path to the file where the dependency was defined\n\n  * `extra` - a slot for adding extra configuration based on the manager;\n    the information on this field is private to the manager and should not be\n    relied on\n\n  * `system_env` - an enumerable of key-value tuples of binaries to be set as environment variables\n    when loading or compiling the dependency\n\nA dependency is in two specific states: loaded and unloaded.\n\nWhen a dependency is unloaded, it means Mix only parsed its specification\nand made no attempt to actually load the dependency or validate its\nstatus. When the dependency is loaded, it means Mix attempted to fetch,\nload and validate it, the status is set in the status field.\n\nFurthermore, in the `opts` fields, Mix keeps some internal options, which\ncan be accessed by SCMs:\n\n  * `:app`   - the application name\n  * `:dest`  - the destination path for the dependency\n  * `:lock`  - the lock information retrieved from mix.lock\n  * `:build` - the build path for the dependency\n\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.available?(dep): Checks if a dependency is available.\n\nAvailable dependencies are the ones that can be loaded.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.cached(): Returns loaded dependencies from the cache for the current environment.\n\nIf dependencies have not been cached yet, they are loaded\nand then cached.\n\nBecause the dependencies are cached during deps.loadpaths,\ntheir status may be outdated (for example, `:compile` did not\nyet become `:ok`). Therefore it is recommended to not rely\non their status, also given they haven't been checked\nagainst the lock.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.check_lock(dep): Checks the lock for the given dependency and update its status accordingly.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.clear_cached(): Clears loaded dependencies from the cache for the current environment.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.compilable?(arg1): Returns `true` if the dependency is compilable.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.diverged?(dep): Checks if a dependency has diverged.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.filter_by_name(given, all_deps, opts \\\\ []): Filters the given dependencies by name.\n\nRaises if any of the names are missing.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.format_dep(dep): Formats a dependency for printing.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.format_status(dep): Formats the status of a dependency.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.in_dependency(dep, post_config \\\\ [], fun): Runs the given `fun` inside the given dependency project by\nchanging the current working directory and loading the given\nproject onto the project stack.\n\nIt expects a loaded dependency as argument.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.load_and_cache(): Returns loaded dependencies recursively and caches it.\n\nThe result is cached for future `cached/0` calls.\n\n## Exceptions\n\nThis function raises an exception if any of the dependencies\nprovided in the project are in the wrong format.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.load_on_environment(opts): Returns loaded dependencies recursively on the given environment.\n\nIf no environment is passed, dependencies are loaded across all\nenvironments. The result is not cached.\n\n## Exceptions\n\nThis function raises an exception if any of the dependencies\nprovided in the project are in the wrong format.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.load_paths(dep): Returns all load paths for the given dependency.\n\nAutomatically derived from source paths.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.make?(dep): Returns `true` if dependency is a Make project.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.mix?(dep): Returns `true` if dependency is a Mix project.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.ok?(dep): Returns `true` if the dependency is ok.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.rebar?(dep): Returns `true` if dependency is a Rebar project.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.Converger.converge(acc, lock, opts, callback): Converges all dependencies from the current project,\nincluding nested dependencies.\n\nThere is a callback that is invoked for each dependency and\nmust return an updated dependency in case some processing\nis done.\n\nSee `Mix.Dep.Loader.children/1` for options.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.Converger.find_cycle(graph): A Depth-First Search to find where is the dependency graph cycle\nand then display the cyclic dependencies back to the developer.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.Converger.topological_sort(deps): Topologically sorts the given dependencies.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.Fetcher.all(old_lock, new_lock, opts): Fetches all dependencies.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.Fetcher.by_name(names, old_lock, new_lock, opts): Fetches the dependencies with the given names and their children recursively.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.Loader.children(): Gets all direct children of the current `Mix.Project`\nas a `Mix.Dep` struct. Umbrella project dependencies\nare included as children.\n\nBy default, it will filter all dependencies that does not match\ncurrent environment, behaviour can be overridden via options.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.Loader.load(dep, children): Loads the given dependency information, including its\nlatest status and children.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.Loader.skip?(dep, arg2): Checks if a dependency must be skipped according to the environment.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.Loader.split_by_env_and_target(deps, env_target): Partitions loaded dependencies by environment.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.Loader.vsn_match(req, actual, app): Checks if a requirement from a dependency matches\nthe given version.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.Lock.read(lockfile \\\\ lockfile()): Reads the lockfile, returns a map containing\neach app name and its current lock information.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.Lock.write(lockfile \\\\ lockfile(), map): Receives a map and writes it as the latest lock.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.Umbrella.cached(): Gets all umbrella dependencies in the loaded format from cache (if available).\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.Umbrella.loaded(): Gets all umbrella dependencies in the loaded format.\n"}
{"completion":"","prompt":"Elixir.Mix.Dep.Umbrella.unloaded(): Gets all umbrella dependencies in unloaded format.\n"}
{"completion":"","prompt":"Elixir.Mix.Generator.copy_file(source, target, options \\\\ []): Copies `source` to `target`.\n\nIf `target` already exists and the contents are not the same,\nit asks for user confirmation.\n\n## Options\n\n  * `:force` - forces copying without a shell prompt\n  * `:quiet` - does not log command output\n\n## Examples\n\n    iex> Mix.Generator.copy_file(\"source/gitignore\", \".gitignore\")\n    * creating .gitignore\n    true\n\n"}
{"completion":"","prompt":"Elixir.Mix.Generator.copy_template(source, target, assigns, options \\\\ []): Evaluates and copy templates at `source` to `target`.\n\nThe template in `source` is evaluated with the given `assigns`.\n\nIf `target` already exists and the contents are not the same,\nit asks for user confirmation.\n\n## Options\n\n  * `:force` - forces copying without a shell prompt\n  * `:quiet` - does not log command output\n\n## Examples\n\n    iex> assigns = [project_path: \"/Users/joe/newproject\"]\n    iex> Mix.Generator.copy_template(\"source/gitignore\", \".gitignore\", assigns)\n    * creating .gitignore\n    true\n\n"}
{"completion":"","prompt":"Elixir.Mix.Generator.create_directory(path, options \\\\ []): Creates a directory if one does not exist yet.\n\nThis function does nothing if the given directory already exists; in this\ncase, it still logs the directory creation.\n\n## Options\n\n  * `:quiet` - does not log command output\n\n## Examples\n\n    iex> Mix.Generator.create_directory(\"path/to/dir\")\n    * creating path/to/dir\n    true\n\n"}
{"completion":"","prompt":"Elixir.Mix.Generator.create_file(path, contents, opts \\\\ []): Creates a file with the given contents.\n\nIf the file already exists and the contents are not the same,\nit asks for user confirmation.\n\n## Options\n\n  * `:force` - forces creation without a shell prompt\n  * `:quiet` - does not log command output\n\n## Examples\n\n    iex> Mix.Generator.create_file(\".gitignore\", \"_build\\ndeps\\n\")\n    * creating .gitignore\n    true\n\n"}
{"completion":"","prompt":"Elixir.Mix.Generator.overwrite?(path): Prompts the user to overwrite the file if it exists.\n\nReturns false if the file exists and the user forbade\nto override it. Returns true otherwise.\n"}
{"completion":"","prompt":"Elixir.Mix.Generator.overwrite?(path, contents): Prompts the user to overwrite the file if it exists.\n\nThe contents are compared to avoid asking the user to\noverride if the contents did not change. Returns false\nif the file exists and the content is the same or the\nuser forbade to override it. Returns true otherwise.\n"}
{"completion":"","prompt":"Elixir.Mix.Hex.ensure_installed?(app): Returns `true` if `Hex` is loaded or installed. Otherwise returns `false`.\n"}
{"completion":"","prompt":"Elixir.Mix.Hex.ensure_updated?(): Returns `true` if it has the required `Hex`. If an update is performed, it then exits.\nOtherwise returns `false` without updating anything.\n"}
{"completion":"","prompt":"Elixir.Mix.Hex.mirror(): Returns the URL to the Hex mirror.\n"}
{"completion":"","prompt":"Elixir.Mix.Hex.start(): Ensures `Hex` is started.\n"}
{"completion":"","prompt":"Elixir.Mix.Local.append_archives(): Appends archive paths to the Erlang code path.\n"}
{"completion":"","prompt":"Elixir.Mix.Local.append_paths(): Appends Mix paths to the Erlang code path.\n"}
{"completion":"","prompt":"Elixir.Mix.Local.archive_ebin(path): Returns the ebin path of an archive.\n"}
{"completion":"","prompt":"Elixir.Mix.Local.archive_name(path): Returns the name of an archive given a path.\n"}
{"completion":"","prompt":"Elixir.Mix.Local.archives_tasks(): Returns all tasks in local archives.\n"}
{"completion":"","prompt":"Elixir.Mix.Local.check_elixir_version_in_ebin(ebin): Checks Elixir version requirement stored in the ebin directory\nand print a warning if it is not satisfied.\n"}
{"completion":"","prompt":"Elixir.Mix.Local.find_matching_versions_from_signed_csv!(name, version, path): Fetches the given signed CSV files, verifies and returns the matching\nElixir version, artifact version and artifact's checksum.\n\nUsed to install both Rebar and Hex from S3.\n"}
{"completion":"","prompt":"Elixir.Mix.Local.name_for(atom, project): Returns the name for an archive or an escript, based on the project config.\n\n## Examples\n\n    iex> Mix.Local.name_for(:archives, app: \"foo\", version: \"0.1.0\")\n    \"foo-0.1.0.ez\"\n\n    iex> Mix.Local.name_for(:escripts, escript: [name: \"foo\"])\n    \"foo\"\n\n"}
{"completion":"","prompt":"Elixir.Mix.Local.remove_archives(): Removes archive paths from Erlang code path.\n"}
{"completion":"","prompt":"Elixir.Mix.Local.Installer.fetch(dep_spec, in_fetcher \\\\ &in_fetcher/1, in_package): Fetches `dep_spec` with `in_fetcher` and then runs `in_package`.\n\nGenerates a new Mix project in a temporary directory with the given `dep_spec`\nadded to a mix.exs. Then, `in_fetcher` is executed in the fetcher project. By\ndefault, this fetches the dependency, but you can provide an `in_fetcher`\nduring test or for other purposes. After the `in_fetcher` is executed,\n`in_package` is executed in the now (presumably) fetched package, with the\npackage's config overridden with the deps_path and lockfile of the fetcher\npackage. Also, the Mix env is set to :prod.\n"}
{"completion":"","prompt":"Elixir.Mix.Local.Installer.install(module, argv, switches): Common implementation of installation for archives and escripts.\n\nRelies on a few callbacks provided by respective callback modules\nfor customizing certain steps in the installation process.\n"}
{"completion":"","prompt":"Elixir.Mix.Local.Installer.parse_args(argv, opts): Receives `argv` and `opts` from options parsing and returns an `install_spec`.\n"}
{"completion":"","prompt":"Elixir.Mix.Local.Installer.uninstall(root, listing, argv, switches): A common implementation for uninstalling archives and scripts.\n"}
{"completion":"","prompt":"Elixir.Mix.Project.app_path(config \\\\ config()): Returns the application path inside the build.\n\nThe returned path will be expanded.\n\n## Examples\n\nIf your project defines the app `my_app`:\n\n    Mix.Project.app_path()\n    #=> \"/path/to/project/_build/shared/lib/my_app\"\n\n"}
{"completion":"","prompt":"Elixir.Mix.Project.apps_paths(config \\\\ config()): Returns a map with the umbrella child applications paths.\n\nThese paths are based on the `:apps_path` and `:apps` configurations.\n\nIf the given project configuration identifies an umbrella project, the return\nvalue is a map of `app => path` where `app` is a child app of the umbrella and\n`path` is its path relative to the root of the umbrella project.\n\nIf the given project configuration does not identify an umbrella project,\n`nil` is returned.\n\n## Examples\n\n    Mix.Project.apps_paths()\n    #=> %{my_app1: \"apps/my_app1\", my_app2: \"apps/my_app2\"}\n\n"}
{"completion":"","prompt":"Elixir.Mix.Project.build_path(config \\\\ config()): Returns the build path for the given project.\n\nIf no configuration is given, the one for the current project is used.\n\nThe returned path will be expanded.\n\n## Examples\n\n    Mix.Project.build_path()\n    #=> \"/path/to/project/_build/shared\"\n\nIf `:build_per_environment` is set to `true`, it will create a new build per\nenvironment:\n\n    Mix.env()\n    #=> :dev\n    Mix.Project.build_path()\n    #=> \"/path/to/project/_build/dev\"\n\n"}
{"completion":"","prompt":"Elixir.Mix.Project.build_structure(config \\\\ config(), opts \\\\ []): Builds the project structure for the given application.\n\n## Options\n\n  * `:symlink_ebin` - symlink ebin instead of copying it\n\n"}
{"completion":"","prompt":"Elixir.Mix.Project.clear_deps_cache(): Clears the dependency for the current environment.\n\nUseful when dependencies need to be reloaded due to change of global state.\n\nFor example, Nerves uses this function to force all dependencies to be\nreloaded after it updates the system environment. It goes roughly like\nthis:\n\n  1. Nerves fetches all dependencies and looks for the system specific deps\n  2. Once the system specific dep is found, it loads it alongside env vars\n  3. Nerves then clears the cache, forcing dependencies to be loaded again\n  4. Dependencies are loaded again, now with an updated env environment\n\n"}
{"completion":"","prompt":"Elixir.Mix.Project.compile_path(config \\\\ config()): Returns the paths the given project compiles to.\n\nIf no configuration is given, the one for the current project will be used.\n\nThe returned path will be expanded.\n\n## Examples\n\nIf your project defines the app `my_app`:\n\n    Mix.Project.compile_path()\n    #=> \"/path/to/project/_build/dev/lib/my_app/ebin\"\n\n"}
{"completion":"","prompt":"Elixir.Mix.Project.config(): Returns the project configuration.\n\nIf there is no project defined, it still returns a keyword\nlist with default values. This allows many Mix tasks to work\nwithout the need for an underlying project.\n\nNote this configuration is cached once the project is\npushed onto the stack. Calling it multiple times won't\ncause it to be recomputed.\n\nDo not use `Mix.Project.config/0` to find the runtime configuration.\nUse it only to configure aspects of your project (like\ncompilation directories) and not your application runtime.\n"}
{"completion":"","prompt":"Elixir.Mix.Project.config_files(): Returns a list of project configuration files for this project.\n\nThis function is usually used in compilation tasks to trigger\na full recompilation whenever such configuration files change.\n\nIt returns the lock manifest, and all config files in the `config`\ndirectory that do not start with a leading period (for example,\n`.my_config.exs`).\n\nNote: before Elixir v1.13.0, the `mix.exs` file was also included\nas a config file, but since then it has been moved to its own\nfunction called `project_file/0`.\n"}
{"completion":"","prompt":"Elixir.Mix.Project.config_mtime(): Returns the latest modification time from config files.\n\nThis function is usually used in compilation tasks to trigger\na full recompilation whenever such configuration files change.\nFor this reason, the mtime is cached to avoid file system lookups.\n\nNote: before Elixir v1.13.0, the `mix.exs` file was also included\nin the mtimes, but not anymore. You can compute its modification\ndate by calling `project_file/0`.\n"}
{"completion":"","prompt":"Elixir.Mix.Project.consolidation_path(config \\\\ config()): Returns the path where protocol consolidations are stored.\n\nThe returned path will be expanded.\n\n## Examples\n\nIf your project defines the app `my_app`:\n\n    Mix.Project.consolidation_path()\n    #=> \"/path/to/project/_build/dev/lib/my_app/consolidated\"\n\nInside umbrellas:\n\n    Mix.Project.consolidation_path()\n    #=> \"/path/to/project/_build/dev/consolidated\"\n\n"}
{"completion":"","prompt":"Elixir.Mix.Project.deps_apps(): Returns all dependencies app names.\n\nThe order they are returned is guaranteed to be sorted\nfor proper dependency resolution. For example, if A\ndepends on B, then B will listed before A.\n"}
{"completion":"","prompt":"Elixir.Mix.Project.deps_path(config \\\\ config()): Returns the path where dependencies are stored for the given project.\n\nIf no configuration is given, the one for the current project is used.\n\nThe returned path will be expanded.\n\n## Examples\n\n    Mix.Project.deps_path()\n    #=> \"/path/to/project/deps\"\n\n"}
{"completion":"","prompt":"Elixir.Mix.Project.deps_paths(opts \\\\ []): Returns the full path of all dependencies as a map.\n\n## Options\n\n  * `:depth` - only returns dependencies to the depth level,\n    a depth of `1` will only return top-level dependencies\n  * `:parents` - starts the dependency traversal from the\n    given parents instead of the application root\n\n## Examples\n\n    Mix.Project.deps_paths()\n    #=> %{foo: \"deps/foo\", bar: \"custom/path/dep\"}\n\n"}
{"completion":"","prompt":"Elixir.Mix.Project.deps_scms(opts \\\\ []): Returns the SCMs of all dependencies as a map.\n\nSee `Mix.SCM` module documentation to learn more about SCMs.\n\n## Options\n\n  * `:depth` - only returns dependencies to the depth level,\n    a depth of `1` will only return top-level dependencies\n  * `:parents` - starts the dependency traversal from the\n    given parents instead of the application root\n\n## Examples\n\n    Mix.Project.deps_scms()\n    #=> %{foo: Mix.SCM.Path, bar: Mix.SCM.Git}\n\n"}
{"completion":"","prompt":"Elixir.Mix.Project.ensure_structure(config \\\\ config(), opts \\\\ []): Ensures the project structure for the given project exists.\n\nIn case it does exist, it is a no-op. Otherwise, it is built.\n\n`opts` are the same options that can be passed to `build_structure/2`.\n"}
{"completion":"","prompt":"Elixir.Mix.Project.get(): Retrieves the current project if there is one.\n\nIf there is no current project, `nil` is returned. This\nmay happen in cases there is no `mix.exs` in the current\ndirectory.\n\nIf you expect a project to be defined, i.e., it is a\nrequirement of the current task, you should call\n`get!/0` instead.\n"}
{"completion":"","prompt":"Elixir.Mix.Project.get!(): Same as `get/0`, but raises an exception if there is no current project.\n\nThis is usually called by tasks that need additional\nfunctions on the project to be defined. Since such\ntasks usually depend on a project being defined, this\nfunction raises a `Mix.NoProjectError` exception in\ncase no project is available.\n"}
{"completion":"","prompt":"Elixir.Mix.Project.in_project(app, path, post_config \\\\ [], fun): Runs the given `fun` inside the given project.\n\nThis function changes the current working directory and\nloads the project at the given directory onto the project\nstack.\n\nA `post_config` can be passed that will be merged into\nthe project configuration.\n\n`fun` is called with the module name of the given `Mix.Project`.\nThe return value of this function is the return value of `fun`.\n\n## Examples\n\n    Mix.Project.in_project(:my_app, \"/path/to/my_app\", fn module ->\n      \"Mix project is: #{inspect(module)}\"\n    end)\n    #=> \"Mix project is: MyApp.MixProject\"\n\n"}
{"completion":"","prompt":"Elixir.Mix.Project.manifest_path(config \\\\ config()): Returns the path where manifests are stored.\n\nBy default they are stored in the app path inside\nthe build directory. Umbrella applications have\nthe manifest path set to the root of the build directory.\nDirectories may be changed in future releases.\n\nThe returned path will be expanded.\n\n## Examples\n\nIf your project defines the app `my_app`:\n\n    Mix.Project.manifest_path()\n    #=> \"/path/to/project/_build/shared/lib/my_app/.mix\"\n\n"}
{"completion":"","prompt":"Elixir.Mix.Project.project_file(): Returns the path to the file that defines the current project.\n\nThe majority of the time, it will point to a `mix.exs` file.\nReturns `nil` if not inside a project.\n"}
{"completion":"","prompt":"Elixir.Mix.Project.umbrella?(config \\\\ config()): Returns `true` if `config` is the configuration for an umbrella project.\n\nWhen called with no arguments, tells whether the current project is\nan umbrella project.\n"}
{"completion":"","prompt":"Elixir.Mix.ProjectStack.child_spec(init_arg): Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.\n"}
{"completion":"","prompt":"Elixir.Mix.PublicKey.decode!(id, key): Decodes a public key and raises if the key is invalid.\n"}
{"completion":"","prompt":"Elixir.Mix.PublicKey.public_keys(): Returns all public keys as a list.\n"}
{"completion":"","prompt":"Elixir.Mix.PublicKey.public_keys_path(): Returns the file system path for public keys.\n"}
{"completion":"","prompt":"Elixir.Mix.PublicKey.verify(binary, hash, signature): Verifies the given binary has the proper signature using the system public keys.\n"}
{"completion":"","prompt":"Elixir.Mix.Rebar.apply_overrides(app, config, overrides): Applies the given overrides for app config.\n"}
{"completion":"","prompt":"Elixir.Mix.Rebar.dependency_config(config): Updates Rebar configuration to be more suitable for dependencies.\n"}
{"completion":"","prompt":"Elixir.Mix.Rebar.deps(config): Parses the dependencies in given `rebar.config` to Mix's dependency format.\n"}
{"completion":"","prompt":"Elixir.Mix.Rebar.global_rebar_cmd(atom): Returns the path to the global copy of `rebar` defined by the\nenvironment variable `MIX_REBAR3`.\n"}
{"completion":"","prompt":"Elixir.Mix.Rebar.load_config(dir): Loads `rebar.config` and evaluates `rebar.config.script` if it\nexists in the given directory.\n"}
{"completion":"","prompt":"Elixir.Mix.Rebar.local_rebar_cmd(manager): Returns the path to the local copy of `rebar`, if one exists.\n"}
{"completion":"","prompt":"Elixir.Mix.Rebar.local_rebar_path(atom): Returns the path supposed to host the local copy of `rebar`.\n\nThe rebar3 installation is specific to the Elixir version,\nin order to force updates when new Elixir versions come out.\n"}
{"completion":"","prompt":"Elixir.Mix.Rebar.rebar_cmd(manager): Returns the path to the available `rebar` command.\n"}
{"completion":"","prompt":"Elixir.Mix.Rebar.serialize_config(config): Serializes a Rebar config to a term file.\n"}
{"completion":"","prompt":"Elixir.Mix.Release.%Mix.Release{}: The Mix.Release struct has the following read-only fields:\n\n  * `:name` - the name of the release as an atom\n  * `:version` - the version of the release as a string\n  * `:path` - the path to the release root\n  * `:version_path` - the path to the release version inside the release\n  * `:applications` - a map of application with their definitions\n  * `:erts_source` - the ERTS source as a charlist (or nil)\n  * `:erts_version` - the ERTS version as a charlist\n\nThe following fields may be modified as long as they keep their defined types:\n\n  * `:boot_scripts` - a map of boot scripts with the boot script name\n    as key and a keyword list with **all** applications that are part of\n    it and their modes as value\n  * `:config_providers` - a list of `{config_provider, term}` tuples where the\n    first element is a module that implements the `Config.Provider` behaviour\n    and `term` is the value given to it on `c:Config.Provider.init/1`\n  * `:options` - a keyword list with all other user supplied release options\n  * `:overlays` - a list of extra files added to the release. If you have a custom\n    step adding extra files to a release, you can add these files to the `:overlays`\n    field so they are also considered on further commands, such as tar/zip. Each entry\n    in overlays is the relative path to the release root of each file\n  * `:steps` - a list of functions that receive the release and returns a release.\n    Must also contain the atom `:assemble` which is the internal assembling step.\n    May also contain the atom `:tar` to create a tarball of the release.\n\n"}
{"completion":"","prompt":"Elixir.Mix.Release.copy_app(release, app): Copies the given application specification into the release.\n\nIt assumes the application exists in the release.\n"}
{"completion":"","prompt":"Elixir.Mix.Release.copy_ebin(release, source, target): Copies the ebin directory at `source` to `target`\nrespecting release options such a `:strip_beams`.\n"}
{"completion":"","prompt":"Elixir.Mix.Release.copy_erts(release): Copies ERTS if the release is configured to do so.\n\nReturns true if the release was copied, false otherwise.\n"}
{"completion":"","prompt":"Elixir.Mix.Release.make_boot_script(release, path, modes, prepend_paths \\\\ []): Makes boot scripts.\n\nIt receives a path to the boot file, without extension, such as\n`releases/0.1.0/start` and this command will write `start.rel`,\n`start.boot`, and `start.script` to the given path, returning\n`{:ok, rel_path}` or `{:error, message}`.\n\nThe boot script uses the RELEASE_LIB environment variable, which must\nbe accordingly set with `--boot-var` and point to the release lib dir.\n"}
{"completion":"","prompt":"Elixir.Mix.Release.make_cookie(release, path): Copies the cookie to the given path.\n\nIf a cookie option was given, we compare it with\nthe contents of the file (if any), and ask the user\nif they want to override.\n\nIf there is no option, we generate a random one\nthe first time.\n"}
{"completion":"","prompt":"Elixir.Mix.Release.make_start_erl(release, path): Makes the start_erl.data file with the\nERTS version and release versions.\n"}
{"completion":"","prompt":"Elixir.Mix.Release.make_sys_config(release, sys_config, config_provider_path): Makes the `sys.config` structure.\n\nIf there are config providers, then a value is injected into\nthe `:elixir` application configuration in `sys_config` to be\nread during boot and trigger the providers.\n\nIt uses the following release options to customize its behaviour:\n\n  * `:reboot_system_after_config`\n  * `:start_distribution_during_config`\n  * `:prune_runtime_sys_config_after_boot`\n\nIn case there are no config providers, it doesn't change `sys_config`.\n"}
{"completion":"","prompt":"Elixir.Mix.Release.rel_templates_path(release, path): Finds a template path for the release.\n"}
{"completion":"","prompt":"Elixir.Mix.Release.strip_beam(binary, options \\\\ []): Strips a beam file for a release.\n\nThis keeps only significant chunks necessary for the VM operation,\ndiscarding documentation, debug info, compile information and others.\n\nThe exact chunks that are kept are not documented and may change in\nfuture versions.\n"}
{"completion":"","prompt":"Elixir.Mix.RemoteConverger.get(): Gets registered remote converger.\n"}
{"completion":"","prompt":"Elixir.Mix.RemoteConverger.register(mod): Registers a remote converger.\n"}
{"completion":"","prompt":"Elixir.Mix.SCM.append(mod): Appends the given SCM module to the list of available SCMs.\n"}
{"completion":"","prompt":"Elixir.Mix.SCM.available(): Returns all available SCMs. Each SCM is tried in order\nuntil a matching one is found.\n"}
{"completion":"","prompt":"Elixir.Mix.SCM.prepend(mod): Prepends the given SCM module to the list of available SCMs.\n"}
{"completion":"","prompt":"Elixir.Mix.Shell.cmd(command, options \\\\ [], callback): Executes the given `command` as a shell command and\ninvokes the `callback` for the streamed response.\n\nThis is most commonly used by shell implementations\nbut can also be invoked directly.\n\n## Options\n\n  * `:cd` - (since v1.11.0) the directory to run the command in\n\n  * `:stderr_to_stdout` - redirects stderr to stdout, defaults to true\n\n  * `:env` - a list of environment variables, defaults to `[]`\n\n  * `:quiet` - overrides the callback to no-op\n\n"}
{"completion":"","prompt":"Elixir.Mix.Shell.printable_app_name(): Returns the printable app name.\n\nThis function returns the current application name,\nbut only if the application name should be printed.\n\nCalling this function automatically toggles its value\nto `false` until the current project is re-entered. The\ngoal is to avoid printing the application name\nmultiple times.\n"}
{"completion":"","prompt":"Elixir.Mix.Shell.IO.cmd(command, opts \\\\ []): Executes the given command and prints its output\nto stdout as it comes.\n"}
{"completion":"","prompt":"Elixir.Mix.Shell.IO.error(message): Prints the given ANSI error to the shell followed by a newline.\n"}
{"completion":"","prompt":"Elixir.Mix.Shell.IO.info(message): Prints the given ANSI message to the shell followed by a newline.\n"}
{"completion":"","prompt":"Elixir.Mix.Shell.IO.print_app(): Prints the current application to the shell if it\nwas not printed yet.\n"}
{"completion":"","prompt":"Elixir.Mix.Shell.IO.prompt(message): Prints a message and prompts the user for input.\n\nInput will be consumed until Enter is pressed.\n"}
{"completion":"","prompt":"Elixir.Mix.Shell.IO.yes?(message, options \\\\ []): Prints a message and asks the user to confirm if they\nwant to proceed. The user must type and submit one of\n\"y\", \"yes\", \"Y\", \"YES\" or \"Yes\".\n\nThe user may also press Enter; this can be configured\nto either accept or reject the prompt. The latter case\nmay be useful for a potentially dangerous operation that\nshould require explicit confirmation from the user.\n\n## Options\n\n  * `:default` - (:yes or :no) if `:yes` pressing Enter\n    accepts the prompt; if `:no` pressing Enter rejects\n    the prompt instead. Defaults to `:yes`.\n\n## Examples\n\n    if Mix.shell().yes?(\"Are you sure?\") do\n      # do something...\n    end\n\n"}
{"completion":"","prompt":"Elixir.Mix.Shell.Process.cmd(command, opts \\\\ []): Executes the given command and forwards its messages to\nthe current process.\n"}
{"completion":"","prompt":"Elixir.Mix.Shell.Process.error(message): Forwards the error to the current process.\n"}
{"completion":"","prompt":"Elixir.Mix.Shell.Process.flush(callback \\\\ fn x -> x end): Flushes all `:mix_shell` and `:mix_shell_input` messages from the current process.\n\nIf a callback is given, it is invoked for each received message.\n\n## Examples\n\n    flush(&IO.inspect/1)\n\n"}
{"completion":"","prompt":"Elixir.Mix.Shell.Process.info(message): Forwards the message to the current process.\n"}
{"completion":"","prompt":"Elixir.Mix.Shell.Process.print_app(): Prints the current application if it\nwas not printed yet.\n"}
{"completion":"","prompt":"Elixir.Mix.Shell.Process.prompt(message): Forwards the message to the current process.\n\nIt also checks the inbox for an input message matching:\n\n    {:mix_shell_input, :prompt, value}\n\nIf one does not exist, it will abort since there was no shell\nprocess inputs given. `value` must be a string.\n\n## Examples\n\nThe following will answer with `\"Meg\"` to the prompt\n`\"What's your name?\"`:\n\n    # The response is sent before calling prompt/1 so that prompt/1 can read it\n    send(self(), {:mix_shell_input, :prompt, \"Meg\"})\n    Mix.shell().prompt(\"What's your name?\")\n\n"}
{"completion":"","prompt":"Elixir.Mix.Shell.Process.yes?(message, options \\\\ []): Forwards the message to the current process.\n\nIt also checks the inbox for an input message matching:\n\n    {:mix_shell_input, :yes?, value}\n\nIf one does not exist, it will abort since there was no shell\nprocess inputs given. `value` must be `true` or `false`.\n\n## Example\n\n    # Send the response to self() first so that yes?/2 will be able to read it\n    send(self(), {:mix_shell_input, :yes?, true})\n    Mix.shell().yes?(\"Are you sure you want to continue?\")\n\n"}
{"completion":"","prompt":"Elixir.Mix.Shell.Quiet.cmd(command, opts \\\\ []): Executes the given command quietly without outputting anything.\n"}
{"completion":"","prompt":"Elixir.Mix.Shell.Quiet.error(message): Prints the error to the shell followed by a newline.\n"}
{"completion":"","prompt":"Elixir.Mix.Shell.Quiet.info(message): Prints nothing to the shell.\n"}
{"completion":"","prompt":"Elixir.Mix.Shell.Quiet.print_app(): Prints the current application if it\nwas not printed yet.\n"}
{"completion":"","prompt":"Elixir.Mix.Shell.Quiet.prompt(message): Prints a message and prompts the user for input.\n\nInput will be consumed until Enter is pressed.\n"}
{"completion":"","prompt":"Elixir.Mix.Shell.Quiet.yes?(message, options \\\\ []): Prints a message and asks the user to confirm if they\nwant to proceed. The user must type and submit one of\n\"y\", \"yes\", \"Y\", \"YES\" or \"Yes\".\n\nThe user may also press Enter; this can be configured\nto either accept or reject the prompt. The latter case\nmay be useful for a potentially dangerous operation that\nshould require explicit confirmation from the user.\n\n## Options\n\n  * `:default` - (:yes or :no) if `:yes` pressing Enter\n    accepts the prompt; if `:no` pressing Enter rejects\n    the prompt instead. Defaults to `:yes`.\n\n"}
{"completion":"","prompt":"Elixir.Mix.State.child_spec(init_arg): Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.\n"}
{"completion":"","prompt":"Elixir.Mix.Task.alias?(task): Checks if the given `task` name is an alias.\n\nReturns false if the given name is not an alias or if it is not a task.\n\nFor more information about task aliasing, take a look at the\n[\"Aliases\"](https://hexdocs.pm/mix/Mix.html#module-aliases) section in the\ndocs for `Mix`.\n"}
{"completion":"","prompt":"Elixir.Mix.Task.all_modules(): Returns all loaded task modules.\n\nModules that are not yet loaded won't show up.\nCheck `load_all/0` if you want to preload all tasks.\n"}
{"completion":"","prompt":"Elixir.Mix.Task.clear(): Clears all invoked tasks, allowing them to be reinvoked.\n\nThis operation is not recursive.\n"}
{"completion":"","prompt":"Elixir.Mix.Task.get(task): Receives a task name and returns the corresponding task module if one exists.\n\nReturns `nil` if the module cannot be found, if it is an alias, or if it is\nnot a valid `Mix.Task`.\n"}
{"completion":"","prompt":"Elixir.Mix.Task.get!(task): Receives a task name and retrieves the corresponding task module.\n\n## Exceptions\n\n  * `Mix.NoTaskError`      - raised if the task could not be found\n  * `Mix.InvalidTaskError` - raised if the task is not a valid `Mix.Task`\n\n"}
{"completion":"","prompt":"Elixir.Mix.Task.load_all(): Loads all tasks in all code paths.\n"}
{"completion":"","prompt":"Elixir.Mix.Task.load_tasks(dirs): Loads all tasks in the given `paths`.\n"}
{"completion":"","prompt":"Elixir.Mix.Task.moduledoc(module): Gets the moduledoc for the given task `module`.\n\nReturns the moduledoc or `nil`.\n"}
{"completion":"","prompt":"Elixir.Mix.Task.preferred_cli_env(task): Gets preferred CLI environment for the task.\n\nReturns environment (for example, `:test`, or `:prod`), or `nil`.\n"}
{"completion":"","prompt":"Elixir.Mix.Task.recursing?(): Indicates if the current task is recursing.\n\nThis returns true if a task is marked as recursive\nand it is being executed inside an umbrella project.\n"}
{"completion":"","prompt":"Elixir.Mix.Task.recursive(module): Checks if the task should be run recursively for all sub-apps in\numbrella projects.\n\nReturns `true` or `false`.\n"}
{"completion":"","prompt":"Elixir.Mix.Task.reenable(task): Reenables a given task so it can be executed again down the stack.\n\nBoth alias and the regular stack are re-enabled when this function\nis called.\n\nIf an umbrella project reenables a task, it is re-enabled for all\nchild projects.\n"}
{"completion":"","prompt":"Elixir.Mix.Task.requirements(module): Gets the list of requirements for the given task.\n\nReturns a list of strings, where the string is expected\nto be a task optionally followed by its arguments.\n"}
{"completion":"","prompt":"Elixir.Mix.Task.rerun(task, args \\\\ []): Reruns `task` with the given arguments.\n\nThis function reruns the given task; to do that, it first re-enables the task\nand then runs it as normal.\n"}
{"completion":"","prompt":"Elixir.Mix.Task.run(task, args \\\\ []): Conditionally runs the task (or alias) with the given `args`.\n\nIf there exists a task matching the given task name and it has not yet been\ninvoked, this will run the task with the given `args` and return the result.\n\nIf there is an [alias](https://hexdocs.pm/mix/Mix.html#module-aliases) defined\nfor the given task name, the alias will be invoked instead of the original\ntask.\n\nIf the task or alias has already been invoked, subsequent calls to `run/2`\nwill _abort_ without executing and return `:noop`.\n\nRemember: by default, tasks will only run _once_, even when called repeatedly!\nIf you need to run a task multiple times, you need to re-enable it via\n`reenable/1` or call it using `rerun/2`.\n\n`run/2` raises an exception if an alias or a task cannot be found or if the\ntask is invalid. See `get!/1` for more information.\n"}
{"completion":"","prompt":"Elixir.Mix.Task.run_in_apps(task, apps, args \\\\ []): Runs recursive tasks in the specified list of children apps for umbrella projects.\n\nIf the task is not recursive (whose purpose is to be run in children\napplications), it runs at the project root level as usual. Calling\nthis function outside of an umbrella project root fails.\n"}
{"completion":"","prompt":"Elixir.Mix.Task.shortdoc(module): Gets the shortdoc for the given task `module`.\n\nReturns the shortdoc or `nil`.\n"}
{"completion":"","prompt":"Elixir.Mix.Task.task?(module): Returns `true` if given module is a task.\n"}
{"completion":"","prompt":"Elixir.Mix.Task.task_name(module): Returns the task name for the given `module`.\n\n## Examples\n\n    iex> Mix.Task.task_name(Mix.Tasks.Test)\n    \"test\"\n\n"}
{"completion":"","prompt":"Elixir.Mix.Task.Compiler.after_compiler(name, fun): Adds a callback that runs after a given compiler.\n\nThe callback is invoked after the compiler runs and\nit receives a tuple with current status and the list\nof diagnostic. It must return the updated status and\ndiagnostics.\n\nIf the given compiler does not run (for instance,\nbecause an earlier compiler in the stack has aborted),\nthe callback will not be executed.\n"}
{"completion":"","prompt":"Elixir.Mix.Tasks.Compile.compilers(config \\\\ Mix.Project.config()): Returns all compilers.\n"}
{"completion":"","prompt":"Elixir.Mix.Tasks.Compile.Protocols.consolidated?(): Returns if protocols have been consolidated at least once.\n"}
{"completion":"","prompt":"Elixir.Mix.Tasks.Format.formatter_for_file(file, opts \\\\ []): Returns a formatter function and the formatter options to\nbe used for the given file.\n\nThe function must be called with the contents of the file\nto be formatted. The options are returned for reflection\npurposes.\n"}
{"completion":"","prompt":"Elixir.Mix.Tasks.Format.formatter_opts_for_file(file, opts \\\\ []): Returns formatter options to be used for the given file.\n"}
{"completion":"","prompt":"Elixir.Mix.Tasks.New.reserved_application_names(): Returns a list of reserved application names.\n"}
{"completion":"","prompt":"Elixir.Mix.Tasks.Profile.Cprof.profile(fun, opts \\\\ []): Allows to programmatically run the `cprof` profiler on expression in `fun`.\n\nReturns the return value of `fun`.\n\n## Options\n\n  * `:matching` - only profile calls matching the given pattern in form of\n    `{module, function, arity}`, where each element may be replaced by `:_`\n    to allow any value\n  * `:limit` - filters out any results with a call count less than the limit\n  * `:module` - filters out any results not pertaining to the given module\n\n"}
{"completion":"","prompt":"Elixir.Mix.Tasks.Profile.Eprof.profile(fun, opts \\\\ []): Allows to programmatically run the `eprof` profiler on expression in `fun`.\n\nReturns the return value of `fun`.\n\n## Options\n\n  * `:matching` - only profile calls matching the given pattern in form of\n    `{module, function, arity}`, where each element may be replaced by `:_`\n    to allow any value\n  * `:calls` - filters out any results with a call count lower than this\n  * `:time` - filters out any results that took lower than specified (in Âµs)\n  * `:sort` - sort the results by `:time` or `:calls` (default: `:time`)\n\n"}
{"completion":"","prompt":"Elixir.Mix.Tasks.Profile.Fprof.profile(fun, opts \\\\ []): Allows to programmatically run the `fprof` profiler on expression in `fun`.\n\nReturns the return value of `fun`.\n\n## Options\n\n  * `:callers` - prints detailed information about immediate callers and called functions\n  * `:details` - includes profile data for each profiled process\n  * `:sort` - sorts the output by given key: `:acc` (default) or `:own`\n\n"}
{"completion":"","prompt":"Elixir.Mix.Tasks.WillRecompile.run(_): Annotates the current project will recompile.\n"}
{"completion":"","prompt":"Elixir.Mix.Tasks.Xref.calls(opts \\\\ []): Returns a list of information of all the runtime function calls in the project.\n\nEach item in the list is a map with the following keys:\n\n  * `:callee` - a tuple containing the module, function, and arity of the call\n  * `:line` - an integer representing the line where the function is called\n  * `:file` - a binary representing the file where the function is called\n  * `:caller_module` - the module where the function is called\n\nThis function returns an empty list when used at the root of an umbrella\nproject because there is no compile manifest to extract the function call\ninformation from. To get the function calls of each child in an umbrella,\nexecute the function at the root of each individual application.\n"}
{"completion":"","prompt":"Elixir.Mix.TasksServer.child_spec(arg): Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.\n"}
{"completion":"","prompt":"Elixir.Mix.Utils.command_to_module(command, at \\\\ Elixir): Takes a `command` name and attempts to load a module\nwith the command name converted to a module name\nin the given `at` scope.\n\nReturns `{:module, module}` in case a module\nexists and is loaded, `{:error, reason}` otherwise.\n\n## Examples\n\n    iex> Mix.Utils.command_to_module(\"compile\", Mix.Tasks)\n    {:module, Mix.Tasks.Compile}\n\n"}
{"completion":"","prompt":"Elixir.Mix.Utils.command_to_module_name(command): Takes a command and converts it to the module name format.\n\n## Examples\n\n    iex> Mix.Utils.command_to_module_name(\"compile.elixir\")\n    \"Compile.Elixir\"\n\n"}
{"completion":"","prompt":"Elixir.Mix.Utils.compiling_n(n, ext): Prints n files are being compiled with the given extension.\n"}
{"completion":"","prompt":"Elixir.Mix.Utils.extract_files(paths, exts_or_pattern): Extracts files from a list of paths.\n\n`exts_or_pattern` may be a list of extensions or a\n`Path.wildcard/1` pattern.\n\nIf the path in `paths` is a file, it is included in\nthe return result. If it is a directory, it is searched\nrecursively for files with the given extensions or matching\nthe given patterns.\n"}
{"completion":"","prompt":"Elixir.Mix.Utils.extract_stale(sources, targets): Extracts all stale `sources` compared to the given `targets`.\n"}
{"completion":"","prompt":"Elixir.Mix.Utils.last_modified(path): Returns the date the given path was last modified in posix time.\n\nIf the path does not exist, it returns the Unix epoch\n(1970-01-01 00:00:00).\n"}
{"completion":"","prompt":"Elixir.Mix.Utils.last_modified_and_size(path): Returns the date the given path was last modified in posix time\nand the size.\n\nIf the path does not exist, it returns the Unix epoch\n(1970-01-01 00:00:00).\n"}
{"completion":"","prompt":"Elixir.Mix.Utils.mix_cache(): Gets possible location of Mix cache.\n\nPossible locations:\n\n * `XDG_CACHE_HOME/mix` (if `MIX_XDG` is set)\n * `:filename.basedir(:user_cache, \"mix\")`\n\n"}
{"completion":"","prompt":"Elixir.Mix.Utils.mix_config(): Gets possible location of global Mix configuration.\n\nPossible locations:\n\n   * `MIX_HOME`\n   * `XDG_CONFIG_HOME/mix` (if `MIX_XDG` is set)\n   * `~/.mix`\n\n"}
{"completion":"","prompt":"Elixir.Mix.Utils.mix_home(): Gets the Mix home.\n\nIt uses the the locations `MIX_HOME`, `XDG_DATA_HOME/mix`,\n`~/.mix` with decreasing priority.\n\nDevelopers should only store entries in the\n`MIX_HOME` directory which are guaranteed to\nwork across multiple Elixir versions, as it is\nnot recommended to swap the `MIX_HOME` directory\nas configuration and other important data may be\nstored there.\n"}
{"completion":"","prompt":"Elixir.Mix.Utils.module_name_to_command(module, nesting \\\\ 0): Takes a module and converts it to a command.\n\nThe nesting argument can be given in order to remove\nthe nesting of a module.\n\n## Examples\n\n    iex> Mix.Utils.module_name_to_command(Mix.Tasks.Compile, 2)\n    \"compile\"\n\n    iex> Mix.Utils.module_name_to_command(\"Mix.Tasks.Compile.Elixir\", 2)\n    \"compile.elixir\"\n\n"}
{"completion":"","prompt":"Elixir.Mix.Utils.parse_mfa(mfa): Parses a string into module, function and arity.\n\nIt returns `{:ok, mfa_list}`, where a `mfa_list` is\n`[module, function, arity]`, `[module, function]` or `[module]`,\nor the atom `:error`.\n\n    iex> Mix.Utils.parse_mfa(\"Foo.bar/1\")\n    {:ok, [Foo, :bar, 1]}\n    iex> Mix.Utils.parse_mfa(\":foo.bar/1\")\n    {:ok, [:foo, :bar, 1]}\n    iex> Mix.Utils.parse_mfa(\":foo.bar\")\n    {:ok, [:foo, :bar]}\n    iex> Mix.Utils.parse_mfa(\":foo\")\n    {:ok, [:foo]}\n    iex> Mix.Utils.parse_mfa(\"Foo\")\n    {:ok, [Foo]}\n\n    iex> Mix.Utils.parse_mfa(\"Foo.\")\n    :error\n    iex> Mix.Utils.parse_mfa(\"Foo.bar.baz\")\n    :error\n    iex> Mix.Utils.parse_mfa(\"Foo.bar/2/2\")\n    :error\n\n"}
{"completion":"","prompt":"Elixir.Mix.Utils.print_tree(nodes, callback, opts \\\\ []): Prints the given tree according to the callback.\n\nThe callback will be invoked for each node and it\nmust return a `{printed, children}` tuple.\n"}
{"completion":"","prompt":"Elixir.Mix.Utils.read_path(path, opts \\\\ []): Opens and reads content from either a URL or a local file system path.\n\nReturns the contents as a `{:ok, binary}`, `:badpath` for invalid\npaths or `{:local, message}` for local errors and `{:remote, message}`\nfor remote ones.\n\n## Options\n\n  * `:sha512` - checks against the given SHA-512 checksum. Returns\n    `{:checksum, message}` in case it fails. This option is required\n    for URLs unless the `:unsafe_uri` is given (WHICH IS NOT RECOMMENDED\n    unless another security mechanism is in place, such as private keys)\n\n  * `:timeout` - times out the request after the given milliseconds.\n    Returns `{:remote, timeout_message}` if it fails. Defaults to 60\n    seconds\n\n"}
{"completion":"","prompt":"Elixir.Mix.Utils.stale?(sources, targets): Returns `true` if any of the `sources` are stale\ncompared to the given `targets`.\n"}
{"completion":"","prompt":"Elixir.Mix.Utils.symlink_or_copy(source, target): Symlinks directory `source` to `target` or copies it recursively\nin case symlink fails.\n\nIn case of conflicts, it copies files only if they have been\nrecently touched.\n\nExpects source and target to be absolute paths as it generates\na relative symlink.\n"}
{"completion":"","prompt":"Elixir.Mix.Utils.symlink_or_copy(hard_copy?, source, target): Symlinks or copy with the option to force a hard copy.\nSee `symlink_or_copy/2`.\n"}
{"completion":"","prompt":"Elixir.Mix.Utils.write_dot_graph!(path, title, nodes, callback, opts \\\\ []): Outputs the given tree according to the callback as a DOT graph.\n\nThe callback will be invoked for each node and it\nmust return a `{printed, children}` tuple.\n"}
{"completion":"","prompt":"Elixir.Access.all(): Returns a function that accesses all the elements in a list.\n\nThe returned function is typically passed as an accessor to `Kernel.get_in/2`,\n`Kernel.get_and_update_in/3`, and friends.\n\n## Examples\n\n    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n    iex> get_in(list, [Access.all(), :name])\n    [\"john\", \"mary\"]\n    iex> get_and_update_in(list, [Access.all(), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {[\"john\", \"mary\"], [%{name: \"JOHN\"}, %{name: \"MARY\"}]}\n    iex> pop_in(list, [Access.all(), :name])\n    {[\"john\", \"mary\"], [%{}, %{}]}\n\nHere is an example that traverses the list dropping even\nnumbers and multiplying odd numbers by 2:\n\n    iex> require Integer\n    iex> get_and_update_in([1, 2, 3, 4, 5], [Access.all()], fn num ->\n    ...>   if Integer.is_even(num), do: :pop, else: {num, num * 2}\n    ...> end)\n    {[1, 2, 3, 4, 5], [2, 6, 10]}\n\nAn error is raised if the accessed structure is not a list:\n\n    iex> get_in(%{}, [Access.all()])\n    ** (RuntimeError) Access.all/0 expected a list, got: %{}\n\n"}
{"completion":"","prompt":"Elixir.Access.at(index): Returns a function that accesses the element at `index` (zero based) of a list.\n\nThe returned function is typically passed as an accessor to `Kernel.get_in/2`,\n`Kernel.get_and_update_in/3`, and friends.\n\n## Examples\n\n    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n    iex> get_in(list, [Access.at(1), :name])\n    \"mary\"\n    iex> get_in(list, [Access.at(-1), :name])\n    \"mary\"\n    iex> get_and_update_in(list, [Access.at(0), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {\"john\", [%{name: \"JOHN\"}, %{name: \"mary\"}]}\n    iex> get_and_update_in(list, [Access.at(-1), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {\"mary\", [%{name: \"john\"}, %{name: \"MARY\"}]}\n\n`at/1` can also be used to pop elements out of a list or\na key inside of a list:\n\n    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n    iex> pop_in(list, [Access.at(0)])\n    {%{name: \"john\"}, [%{name: \"mary\"}]}\n    iex> pop_in(list, [Access.at(0), :name])\n    {\"john\", [%{}, %{name: \"mary\"}]}\n\nWhen the index is out of bounds, `nil` is returned and the update function is never called:\n\n    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n    iex> get_in(list, [Access.at(10), :name])\n    nil\n    iex> get_and_update_in(list, [Access.at(10), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {nil, [%{name: \"john\"}, %{name: \"mary\"}]}\n\nAn error is raised if the accessed structure is not a list:\n\n    iex> get_in(%{}, [Access.at(1)])\n    ** (RuntimeError) Access.at/1 expected a list, got: %{}\n\n"}
{"completion":"","prompt":"Elixir.Access.at!(index): Same as `at/1` except that it raises `Enum.OutOfBoundsError`\nif the given index is out of bounds.\n\n## Examples\n\n    iex> get_in([:a, :b, :c], [Access.at!(2)])\n    :c\n    iex> get_in([:a, :b, :c], [Access.at!(3)])\n    ** (Enum.OutOfBoundsError) out of bounds error\n\n"}
{"completion":"","prompt":"Elixir.Access.elem(index): Returns a function that accesses the element at the given index in a tuple.\n\nThe returned function is typically passed as an accessor to `Kernel.get_in/2`,\n`Kernel.get_and_update_in/3`, and friends.\n\nThe returned function raises if `index` is out of bounds.\n\nNote that popping elements out of tuples is not possible and raises an\nerror.\n\n## Examples\n\n    iex> map = %{user: {\"john\", 27}}\n    iex> get_in(map, [:user, Access.elem(0)])\n    \"john\"\n    iex> get_and_update_in(map, [:user, Access.elem(0)], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {\"john\", %{user: {\"JOHN\", 27}}}\n    iex> pop_in(map, [:user, Access.elem(0)])\n    ** (RuntimeError) cannot pop data from a tuple\n\nAn error is raised if the accessed structure is not a tuple:\n\n    iex> get_in(%{}, [Access.elem(0)])\n    ** (RuntimeError) Access.elem/1 expected a tuple, got: %{}\n\n"}
{"completion":"","prompt":"Elixir.Access.fetch(container, key): Fetches the value for the given key in a container (a map, keyword\nlist, or struct that implements the `Access` behaviour).\n\nReturns `{:ok, value}` where `value` is the value under `key` if there is such\na key, or `:error` if `key` is not found.\n\n## Examples\n\n    iex> Access.fetch(%{name: \"meg\", age: 26}, :name)\n    {:ok, \"meg\"}\n\n    iex> Access.fetch([ordered: true, on_timeout: :exit], :timeout)\n    :error\n\n"}
{"completion":"","prompt":"Elixir.Access.fetch!(container, key): Same as `fetch/2` but returns the value directly,\nor raises a `KeyError` exception if `key` is not found.\n\n## Examples\n\n    iex> Access.fetch!(%{name: \"meg\", age: 26}, :name)\n    \"meg\"\n\n"}
{"completion":"","prompt":"Elixir.Access.filter(func): Returns a function that accesses all elements of a list that match the provided predicate.\n\nThe returned function is typically passed as an accessor to `Kernel.get_in/2`,\n`Kernel.get_and_update_in/3`, and friends.\n\n## Examples\n\n    iex> list = [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}]\n    iex> get_in(list, [Access.filter(&(&1.salary > 20)), :name])\n    [\"francine\"]\n    iex> get_and_update_in(list, [Access.filter(&(&1.salary <= 20)), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {[\"john\"], [%{name: \"JOHN\", salary: 10}, %{name: \"francine\", salary: 30}]}\n\n`filter/1` can also be used to pop elements out of a list or\na key inside of a list:\n\n    iex> list = [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}]\n    iex> pop_in(list, [Access.filter(&(&1.salary >= 20))])\n    {[%{name: \"francine\", salary: 30}], [%{name: \"john\", salary: 10}]}\n    iex> pop_in(list, [Access.filter(&(&1.salary >= 20)), :name])\n    {[\"francine\"], [%{name: \"john\", salary: 10}, %{salary: 30}]}\n\nWhen no match is found, an empty list is returned and the update function is never called\n\n    iex> list = [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}]\n    iex> get_in(list, [Access.filter(&(&1.salary >= 50)), :name])\n    []\n    iex> get_and_update_in(list, [Access.filter(&(&1.salary >= 50)), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {[], [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}]}\n\nAn error is raised if the predicate is not a function or is of the incorrect arity:\n\n    iex> get_in([], [Access.filter(5)])\n    ** (FunctionClauseError) no function clause matching in Access.filter/1\n\nAn error is raised if the accessed structure is not a list:\n\n    iex> get_in(%{}, [Access.filter(fn a -> a == 10 end)])\n    ** (RuntimeError) Access.filter/1 expected a list, got: %{}\n\n"}
{"completion":"","prompt":"Elixir.Access.get(container, key, default \\\\ nil): Gets the value for the given key in a container (a map, keyword\nlist, or struct that implements the `Access` behaviour).\n\nReturns the value under `key` if there is such a key, or `default` if `key` is\nnot found.\n\n## Examples\n\n    iex> Access.get(%{name: \"john\"}, :name, \"default name\")\n    \"john\"\n    iex> Access.get(%{name: \"john\"}, :age, 25)\n    25\n\n    iex> Access.get([ordered: true], :timeout)\n    nil\n\n"}
{"completion":"","prompt":"Elixir.Access.get_and_update(container, key, fun): Gets and updates the given key in a `container` (a map, a keyword list,\na struct that implements the `Access` behaviour).\n\nThe `fun` argument receives the value of `key` (or `nil` if `key` is not\npresent in `container`) and must return a two-element tuple `{current_value, new_value}`:\nthe \"get\" value `current_value` (the retrieved value, which can be operated on before\nbeing returned) and the new value to be stored under `key` (`new_value`).\n`fun` may also return `:pop`, which means the current value\nshould be removed from the container and returned.\n\nThe returned value is a two-element tuple with the \"get\" value returned by\n`fun` and a new container with the updated value under `key`.\n\n## Examples\n\n    iex> Access.get_and_update([a: 1], :a, fn current_value ->\n    ...>   {current_value, current_value + 1}\n    ...> end)\n    {1, [a: 2]}\n\n"}
{"completion":"","prompt":"Elixir.Access.key(key, default \\\\ nil): Returns a function that accesses the given key in a map/struct.\n\nThe returned function is typically passed as an accessor to `Kernel.get_in/2`,\n`Kernel.get_and_update_in/3`, and friends.\n\nThe returned function uses the default value if the key does not exist.\nThis can be used to specify defaults and safely traverse missing keys:\n\n    iex> get_in(%{}, [Access.key(:user, %{}), Access.key(:name, \"meg\")])\n    \"meg\"\n\nSuch is also useful when using update functions, allowing us to introduce\nvalues as we traverse the data structure for updates:\n\n    iex> put_in(%{}, [Access.key(:user, %{}), Access.key(:name)], \"Mary\")\n    %{user: %{name: \"Mary\"}}\n\n## Examples\n\n    iex> map = %{user: %{name: \"john\"}}\n    iex> get_in(map, [Access.key(:unknown, %{}), Access.key(:name, \"john\")])\n    \"john\"\n    iex> get_and_update_in(map, [Access.key(:user), Access.key(:name)], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {\"john\", %{user: %{name: \"JOHN\"}}}\n    iex> pop_in(map, [Access.key(:user), Access.key(:name)])\n    {\"john\", %{user: %{}}}\n\nAn error is raised if the accessed structure is not a map or a struct:\n\n    iex> get_in([], [Access.key(:foo)])\n    ** (BadMapError) expected a map, got: []\n\n"}
{"completion":"","prompt":"Elixir.Access.key!(key): Returns a function that accesses the given key in a map/struct.\n\nThe returned function is typically passed as an accessor to `Kernel.get_in/2`,\n`Kernel.get_and_update_in/3`, and friends.\n\nSimilar to `key/2`, but the returned function raises if the key does not exist.\n\n## Examples\n\n    iex> map = %{user: %{name: \"john\"}}\n    iex> get_in(map, [Access.key!(:user), Access.key!(:name)])\n    \"john\"\n    iex> get_and_update_in(map, [Access.key!(:user), Access.key!(:name)], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {\"john\", %{user: %{name: \"JOHN\"}}}\n    iex> pop_in(map, [Access.key!(:user), Access.key!(:name)])\n    {\"john\", %{user: %{}}}\n    iex> get_in(map, [Access.key!(:user), Access.key!(:unknown)])\n    ** (KeyError) key :unknown not found in: %{name: \"john\"}\n\nAn error is raised if the accessed structure is not a map/struct:\n\n    iex> get_in([], [Access.key!(:foo)])\n    ** (RuntimeError) Access.key!/1 expected a map/struct, got: []\n\n"}
{"completion":"","prompt":"Elixir.Access.pop(container, key): Removes the entry with a given key from a container (a map, keyword\nlist, or struct that implements the `Access` behaviour).\n\nReturns a tuple containing the value associated with the key and the\nupdated container. `nil` is returned for the value if the key isn't\nin the container.\n\n## Examples\n\nWith a map:\n\n    iex> Access.pop(%{name: \"Elixir\", creator: \"Valim\"}, :name)\n    {\"Elixir\", %{creator: \"Valim\"}}\n\nA keyword list:\n\n    iex> Access.pop([name: \"Elixir\", creator: \"Valim\"], :name)\n    {\"Elixir\", [creator: \"Valim\"]}\n\nAn unknown key:\n\n    iex> Access.pop(%{name: \"Elixir\", creator: \"Valim\"}, :year)\n    {nil, %{creator: \"Valim\", name: \"Elixir\"}}\n\n"}
{"completion":"","prompt":"Elixir.Access.slice(range): Returns a function that accesses all items of a list that are within the provided range.\n\nThe range will be normalized following the same rules from `Enum.slice/2`.\n\nThe returned function is typically passed as an accessor to `Kernel.get_in/2`,\n`Kernel.get_and_update_in/3`, and friends.\n\n## Examples\n\n    iex> list = [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}, %{name: \"vitor\", salary: 25}]\n    iex> get_in(list, [Access.slice(1..2), :name])\n    [\"francine\", \"vitor\"]\n    iex> get_and_update_in(list, [Access.slice(1..3//2), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {[\"francine\"], [%{name: \"john\", salary: 10}, %{name: \"FRANCINE\", salary: 30}, %{name: \"vitor\", salary: 25}]}\n\n`slice/1` can also be used to pop elements out of a list or\na key inside of a list:\n\n    iex> list = [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}, %{name: \"vitor\", salary: 25}]\n    iex> pop_in(list, [Access.slice(-2..-1)])\n    {[%{name: \"francine\", salary: 30}, %{name: \"vitor\", salary: 25}], [%{name: \"john\", salary: 10}]}\n    iex> pop_in(list, [Access.slice(-2..-1), :name])\n    {[\"francine\", \"vitor\"], [%{name: \"john\", salary: 10}, %{salary: 30}, %{salary: 25}]}\n\nWhen no match is found, an empty list is returned and the update function is never called\n\n    iex> list = [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}, %{name: \"vitor\", salary: 25}]\n    iex> get_in(list, [Access.slice(5..10//2), :name])\n    []\n    iex> get_and_update_in(list, [Access.slice(5..10//2), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {[], [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}, %{name: \"vitor\", salary: 25}]}\n\nAn error is raised if the accessed structure is not a list:\n\n    iex> get_in(%{}, [Access.slice(2..10//3)])\n    ** (ArgumentError) Access.slice/1 expected a list, got: %{}\n\nAn error is raised if the step of the range is negative:\n\n    iex> get_in([], [Access.slice(2..10//-1)])\n    ** (ArgumentError) Access.slice/1 does not accept ranges with negative steps, got: 2..10//-1\n\n"}
{"completion":"","prompt":"Elixir.Agent.Server.child_spec(init_arg): Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.\n"}
{"completion":"","prompt":"Elixir.Agent.cast(agent, fun): Performs a cast (*fire and forget*) operation on the agent state.\n\nThe function `fun` is sent to the `agent` which invokes the function\npassing the agent state. The return value of `fun` becomes the new\nstate of the agent.\n\nNote that `cast` returns `:ok` immediately, regardless of whether `agent` (or\nthe node it should live on) exists.\n\n## Examples\n\n    iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.cast(pid, fn state -> state + 1 end)\n    :ok\n    iex> Agent.get(pid, fn state -> state end)\n    43\n\n"}
{"completion":"","prompt":"Elixir.Agent.cast(agent, module, fun, args): Performs a cast (*fire and forget*) operation on the agent state.\n\nSame as `cast/2` but a module, function, and arguments are expected\ninstead of an anonymous function. The state is added as first\nargument to the given list of arguments.\n\n## Examples\n\n    iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.cast(pid, Kernel, :+, [12])\n    :ok\n    iex> Agent.get(pid, fn state -> state end)\n    54\n\n"}
{"completion":"","prompt":"Elixir.Agent.child_spec(arg): Returns a specification to start an agent under a supervisor.\n\nSee the \"Child specification\" section in the `Supervisor` module for more detailed information.\n"}
{"completion":"","prompt":"Elixir.Agent.get(agent, fun, timeout \\\\ 5000): Gets an agent value via the given anonymous function.\n\nThe function `fun` is sent to the `agent` which invokes the function\npassing the agent state. The result of the function invocation is\nreturned from this function.\n\n`timeout` is an integer greater than zero which specifies how many\nmilliseconds are allowed before the agent executes the function and returns\nthe result value, or the atom `:infinity` to wait indefinitely. If no result\nis received within the specified time, the function call fails and the caller\nexits.\n\n## Examples\n\n    iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.get(pid, fn state -> state end)\n    42\n\n"}
{"completion":"","prompt":"Elixir.Agent.get(agent, module, fun, args, timeout \\\\ 5000): Gets an agent value via the given function.\n\nSame as `get/3` but a module, function, and arguments are expected\ninstead of an anonymous function. The state is added as first\nargument to the given list of arguments.\n"}
{"completion":"","prompt":"Elixir.Agent.get_and_update(agent, fun, timeout \\\\ 5000): Gets and updates the agent state in one operation via the given anonymous\nfunction.\n\nThe function `fun` is sent to the `agent` which invokes the function\npassing the agent state. The function must return a tuple with two\nelements, the first being the value to return (that is, the \"get\" value)\nand the second one being the new state of the agent.\n\n`timeout` is an integer greater than zero which specifies how many\nmilliseconds are allowed before the agent executes the function and returns\nthe result value, or the atom `:infinity` to wait indefinitely. If no result\nis received within the specified time, the function call fails and the caller\nexits.\n\n## Examples\n\n    iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.get_and_update(pid, fn state -> {state, state + 1} end)\n    42\n    iex> Agent.get(pid, fn state -> state end)\n    43\n\n"}
{"completion":"","prompt":"Elixir.Agent.get_and_update(agent, module, fun, args, timeout \\\\ 5000): Gets and updates the agent state in one operation via the given function.\n\nSame as `get_and_update/3` but a module, function, and arguments are expected\ninstead of an anonymous function. The state is added as first\nargument to the given list of arguments.\n"}
{"completion":"","prompt":"Elixir.Agent.start(fun, options \\\\ []): Starts an agent process without links (outside of a supervision tree).\n\nSee `start_link/2` for more information.\n\n## Examples\n\n    iex> {:ok, pid} = Agent.start(fn -> 42 end)\n    iex> Agent.get(pid, fn state -> state end)\n    42\n\n"}
{"completion":"","prompt":"Elixir.Agent.start(module, fun, args, options \\\\ []): Starts an agent without links with the given module, function, and arguments.\n\nSee `start_link/4` for more information.\n"}
{"completion":"","prompt":"Elixir.Agent.start_link(fun, options \\\\ []): Starts an agent linked to the current process with the given function.\n\nThis is often used to start the agent as part of a supervision tree.\n\nOnce the agent is spawned, the given function `fun` is invoked in the server\nprocess, and should return the initial agent state. Note that `start_link/2`\ndoes not return until the given function has returned.\n\n## Options\n\nThe `:name` option is used for registration as described in the module\ndocumentation.\n\nIf the `:timeout` option is present, the agent is allowed to spend at most\nthe given number of milliseconds on initialization or it will be terminated\nand the start function will return `{:error, :timeout}`.\n\nIf the `:debug` option is present, the corresponding function in the\n[`:sys` module](`:sys`) will be invoked.\n\nIf the `:spawn_opt` option is present, its value will be passed as options\nto the underlying process as in `Process.spawn/4`.\n\n## Return values\n\nIf the server is successfully created and initialized, the function returns\n`{:ok, pid}`, where `pid` is the PID of the server. If an agent with the\nspecified name already exists, the function returns\n`{:error, {:already_started, pid}}` with the PID of that process.\n\nIf the given function callback fails, the function returns `{:error, reason}`.\n\n## Examples\n\n    iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.get(pid, fn state -> state end)\n    42\n\n    iex> {:error, {exception, _stacktrace}} = Agent.start(fn -> raise \"oops\" end)\n    iex> exception\n    %RuntimeError{message: \"oops\"}\n\n"}
{"completion":"","prompt":"Elixir.Agent.start_link(module, fun, args, options \\\\ []): Starts an agent linked to the current process.\n\nSame as `start_link/2` but a module, function, and arguments are expected\ninstead of an anonymous function; `fun` in `module` will be called with the\ngiven arguments `args` to initialize the state.\n"}
{"completion":"","prompt":"Elixir.Agent.stop(agent, reason \\\\ :normal, timeout \\\\ :infinity): Synchronously stops the agent with the given `reason`.\n\nIt returns `:ok` if the agent terminates with the given\nreason. If the agent terminates with another reason, the call will\nexit.\n\nThis function keeps OTP semantics regarding error reporting.\nIf the reason is any other than `:normal`, `:shutdown` or\n`{:shutdown, _}`, an error report will be logged.\n\n## Examples\n\n    iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.stop(pid)\n    :ok\n\n"}
{"completion":"","prompt":"Elixir.Agent.update(agent, fun, timeout \\\\ 5000): Updates the agent state via the given anonymous function.\n\nThe function `fun` is sent to the `agent` which invokes the function\npassing the agent state. The return value of `fun` becomes the new\nstate of the agent.\n\nThis function always returns `:ok`.\n\n`timeout` is an integer greater than zero which specifies how many\nmilliseconds are allowed before the agent executes the function and returns\nthe result value, or the atom `:infinity` to wait indefinitely. If no result\nis received within the specified time, the function call fails and the caller\nexits.\n\n## Examples\n\n    iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.update(pid, fn state -> state + 1 end)\n    :ok\n    iex> Agent.get(pid, fn state -> state end)\n    43\n\n"}
{"completion":"","prompt":"Elixir.Agent.update(agent, module, fun, args, timeout \\\\ 5000): Updates the agent state via the given function.\n\nSame as `update/3` but a module, function, and arguments are expected\ninstead of an anonymous function. The state is added as first\nargument to the given list of arguments.\n\n## Examples\n\n    iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.update(pid, Kernel, :+, [12])\n    :ok\n    iex> Agent.get(pid, fn state -> state end)\n    54\n\n"}
{"completion":"","prompt":"Elixir.Application.app_dir(app): Gets the directory for app.\n\nThis information is returned based on the code path. Here is an\nexample:\n\n    File.mkdir_p!(\"foo/ebin\")\n    Code.prepend_path(\"foo/ebin\")\n    Application.app_dir(:foo)\n    #=> \"foo\"\n\nEven though the directory is empty and there is no `.app` file\nit is considered the application directory based on the name\n\"foo/ebin\". The name may contain a dash `-` which is considered\nto be the app version and it is removed for the lookup purposes:\n\n    File.mkdir_p!(\"bar-123/ebin\")\n    Code.prepend_path(\"bar-123/ebin\")\n    Application.app_dir(:bar)\n    #=> \"bar-123\"\n\nFor more information on code paths, check the `Code` module in\nElixir and also Erlang's [`:code` module](`:code`).\n"}
{"completion":"","prompt":"Elixir.Application.app_dir(app, path): Returns the given path inside `app_dir/1`.\n\nIf `path` is a string, then it will be used as the path inside `app_dir/1`. If\n`path` is a list of strings, it will be joined (see `Path.join/1`) and the result\nwill be used as the path inside `app_dir/1`.\n\n## Examples\n\n    File.mkdir_p!(\"foo/ebin\")\n    Code.prepend_path(\"foo/ebin\")\n\n    Application.app_dir(:foo, \"my_path\")\n    #=> \"foo/my_path\"\n\n    Application.app_dir(:foo, [\"my\", \"nested\", \"path\"])\n    #=> \"foo/my/nested/path\"\n\n"}
{"completion":"","prompt":"Elixir.Application.compile_env(env, app, key_or_path, default): Reads the application environment at compilation time from a macro.\n\nTypically, developers will use `compile_env/3`. This function must\nonly be invoked from macros which aim to read the compilation environment\ndynamically.\n\nIt expects a `Macro.Env` as first argument, where the `Macro.Env` is\ntypically the `__CALLER__` in a macro. It raises if `Macro.Env` comes\nfrom a function.\n"}
{"completion":"","prompt":"Elixir.Application.compile_env!(env, app, key_or_path): Reads the application environment at compilation time from a macro\nor raises.\n\nTypically, developers will use `compile_env!/2`. This function must\nonly be invoked from macros which aim to read the compilation environment\ndynamically.\n\nIt expects a `Macro.Env` as first argument, where the `Macro.Env` is\ntypically the `__CALLER__` in a macro. It raises if `Macro.Env` comes\nfrom a function.\n"}
{"completion":"","prompt":"Elixir.Application.delete_env(app, key, opts \\\\ []): Deletes the `key` from the given `app` environment.\n\nIt receives the same options as `put_env/4`. Returns `:ok`.\n"}
{"completion":"","prompt":"Elixir.Application.ensure_all_started(app, type \\\\ :temporary): Ensures the given `app` and its applications are started.\n\nSame as `start/2` but also starts the applications listed under\n`:applications` in the `.app` file in case they were not previously\nstarted.\n"}
{"completion":"","prompt":"Elixir.Application.ensure_loaded(app): Ensures the given `app` is loaded.\n\nSame as `load/1` but returns `:ok` if the application was already\nloaded.\n"}
{"completion":"","prompt":"Elixir.Application.ensure_started(app, type \\\\ :temporary): Ensures the given `app` is started.\n\nSame as `start/2` but returns `:ok` if the application was already\nstarted. This is useful in scripts and in test setup, where test\napplications need to be explicitly started:\n\n    :ok = Application.ensure_started(:my_test_dep)\n\n"}
{"completion":"","prompt":"Elixir.Application.fetch_env(app, key): Returns the value for `key` in `app`'s environment in a tuple.\n\nIf the configuration parameter does not exist, the function returns `:error`.\n\n> **Important:** you must use this function to read only your own application\n> environment. Do not read the environment of other applications.\n\n> **Important:** if you are writing a library to be used by other developers,\n> it is generally recommended to avoid the application environment, as the\n> application environment is effectively a global storage. For more information,\n> read our [library guidelines](library-guidelines.md).\n"}
{"completion":"","prompt":"Elixir.Application.fetch_env!(app, key): Returns the value for `key` in `app`'s environment.\n\nIf the configuration parameter does not exist, raises `ArgumentError`.\n\n> **Important:** you must use this function to read only your own application\n> environment. Do not read the environment of other applications.\n\n> **Important:** if you are writing a library to be used by other developers,\n> it is generally recommended to avoid the application environment, as the\n> application environment is effectively a global storage. For more information,\n> read our [library guidelines](library-guidelines.md).\n"}
{"completion":"","prompt":"Elixir.Application.format_error(reason): Formats the error reason returned by `start/2`,\n`ensure_started/2`, `stop/1`, `load/1` and `unload/1`,\nreturns a string.\n"}
{"completion":"","prompt":"Elixir.Application.get_all_env(app): Returns all key-value pairs for `app`.\n"}
{"completion":"","prompt":"Elixir.Application.get_application(module): Gets the application for the given module.\n\nThe application is located by analyzing the spec\nof all loaded applications. Returns `nil` if\nthe module is not listed in any application spec.\n"}
{"completion":"","prompt":"Elixir.Application.get_env(app, key, default \\\\ nil): Returns the value for `key` in `app`'s environment.\n\nIf the configuration parameter does not exist, the function returns the\n`default` value.\n\n> **Important:** you must use this function to read only your own application\n> environment. Do not read the environment of other applications.\n\n> **Important:** if you are writing a library to be used by other developers,\n> it is generally recommended to avoid the application environment, as the\n> application environment is effectively a global storage. For more information,\n> read our [library guidelines](library-guidelines.md).\n\n## Examples\n\n`get_env/3` is commonly used to read the configuration of your OTP applications.\nSince Mix configurations are commonly used to configure applications, we will use\nthis as a point of illustration.\n\nConsider a new application `:my_app`. `:my_app` contains a database engine which\nsupports a pool of databases. The database engine needs to know the configuration for\neach of those databases, and that configuration is supplied by key-value pairs in\nenvironment of `:my_app`.\n\n    config :my_app, Databases.RepoOne,\n      # A database configuration\n      ip: \"localhost\",\n      port: 5433\n\n    config :my_app, Databases.RepoTwo,\n      # Another database configuration (for the same OTP app)\n      ip: \"localhost\",\n      port: 20717\n\n    config :my_app, my_app_databases: [Databases.RepoOne, Databases.RepoTwo]\n\nOur database engine used by `:my_app` needs to know what databases exist, and\nwhat the database configurations are. The database engine can make a call to\n`Application.get_env(:my_app, :my_app_databases, [])` to retrieve the list of\ndatabases (specified by module names).\n\nThe engine can then traverse each repository in the list and call\n`Application.get_env(:my_app, Databases.RepoOne)` and so forth to retrieve the\nconfiguration of each one. In this case, each configuration will be a keyword\nlist, so you can use the functions in the `Keyword` module or even the `Access`\nmodule to traverse it, for example:\n\n    config = Application.get_env(:my_app, Databases.RepoOne)\n    config[:ip]\n\n"}
{"completion":"","prompt":"Elixir.Application.load(app): Loads the given `app`.\n\nIn order to be loaded, an `.app` file must be in the load paths.\nAll `:included_applications` will also be loaded.\n\nLoading the application does not start it nor load its modules, but\nit does load its environment.\n"}
{"completion":"","prompt":"Elixir.Application.loaded_applications(): Returns a list with information about the applications which have been loaded.\n"}
{"completion":"","prompt":"Elixir.Application.put_all_env(config, opts \\\\ []): Puts the environment for multiple apps at the same time.\n\nThe given config should not:\n\n  * have the same application listed more than once\n  * have the same key inside the same application listed more than once\n\nIf those conditions are not met, it will raise.\n\nIt receives the same options as `put_env/4`. Returns `:ok`.\n"}
{"completion":"","prompt":"Elixir.Application.put_env(app, key, value, opts \\\\ []): Puts the `value` in `key` for the given `app`.\n\n## Options\n\n  * `:timeout` - the timeout for the change (defaults to `5_000` milliseconds)\n  * `:persistent` - persists the given value on application load and reloads\n\nIf `put_env/4` is called before the application is loaded, the application\nenvironment values specified in the `.app` file will override the ones\npreviously set.\n\nThe `:persistent` option can be set to `true` when there is a need to guarantee\nparameters set with this function will not be overridden by the ones defined\nin the application resource file on load. This means persistent values will\nstick after the application is loaded and also on application reload.\n"}
{"completion":"","prompt":"Elixir.Application.spec(app): Returns the spec for `app`.\n\nThe following keys are returned:\n\n  * `:description`\n  * `:id`\n  * `:vsn`\n  * `:modules`\n  * `:maxP`\n  * `:maxT`\n  * `:registered`\n  * `:included_applications`\n  * `:optional_applications`\n  * `:applications`\n  * `:mod`\n  * `:start_phases`\n\nNote the environment is not returned as it can be accessed via\n`fetch_env/2`. Returns `nil` if the application is not loaded.\n"}
{"completion":"","prompt":"Elixir.Application.spec(app, key): Returns the value for `key` in `app`'s specification.\n\nSee `spec/1` for the supported keys. If the given\nspecification parameter does not exist, this function\nwill raise. Returns `nil` if the application is not loaded.\n"}
{"completion":"","prompt":"Elixir.Application.start(app, type \\\\ :temporary): Starts the given `app`.\n\nIf the `app` is not loaded, the application will first be loaded using `load/1`.\nAny included application, defined in the `:included_applications` key of the\n`.app` file will also be loaded, but they won't be started.\n\nFurthermore, all applications listed in the `:applications` key must be explicitly\nstarted before this application is. If not, `{:error, {:not_started, app}}` is\nreturned, where `app` is the name of the missing application.\n\nIn case you want to automatically load **and start** all of `app`'s dependencies,\nsee `ensure_all_started/2`.\n\nThe `type` argument specifies the type of the application:\n\n  * `:permanent` - if `app` terminates, all other applications and the entire\n    node are also terminated.\n\n  * `:transient` - if `app` terminates with `:normal` reason, it is reported\n    but no other applications are terminated. If a transient application\n    terminates abnormally, all other applications and the entire node are\n    also terminated.\n\n  * `:temporary` - if `app` terminates, it is reported but no other\n    applications are terminated (the default).\n\nNote that it is always possible to stop an application explicitly by calling\n`stop/1`. Regardless of the type of the application, no other applications will\nbe affected.\n\nNote also that the `:transient` type is of little practical use, since when a\nsupervision tree terminates, the reason is set to `:shutdown`, not `:normal`.\n"}
{"completion":"","prompt":"Elixir.Application.started_applications(timeout \\\\ 5000): Returns a list with information about the applications which are currently running.\n"}
{"completion":"","prompt":"Elixir.Application.stop(app): Stops the given `app`.\n\nWhen stopped, the application is still loaded.\n"}
{"completion":"","prompt":"Elixir.Application.unload(app): Unloads the given `app`.\n\nIt will also unload all `:included_applications`.\nNote that the function does not purge the application modules.\n"}
{"completion":"","prompt":"Elixir.Atom.to_charlist(atom): Converts an atom to a charlist.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Atom.to_charlist(:\"An atom\")\n    'An atom'\n\n"}
{"completion":"","prompt":"Elixir.Atom.to_string(atom): Converts an atom to a string.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Atom.to_string(:foo)\n    \"foo\"\n\n"}
{"completion":"","prompt":"Elixir.Base.decode16(string, opts \\\\ []): Decodes a base 16 encoded string into a binary string.\n\n## Options\n\nThe accepted options are:\n\n  * `:case` - specifies the character case to accept when decoding\n\nThe values for `:case` can be:\n\n  * `:upper` - only allows upper case characters (default)\n  * `:lower` - only allows lower case characters\n  * `:mixed` - allows mixed case characters\n\n## Examples\n\n    iex> Base.decode16(\"666F6F626172\")\n    {:ok, \"foobar\"}\n\n    iex> Base.decode16(\"666f6f626172\", case: :lower)\n    {:ok, \"foobar\"}\n\n    iex> Base.decode16(\"666f6F626172\", case: :mixed)\n    {:ok, \"foobar\"}\n\n"}
{"completion":"","prompt":"Elixir.Base.decode16!(string, opts \\\\ []): Decodes a base 16 encoded string into a binary string.\n\n## Options\n\nThe accepted options are:\n\n  * `:case` - specifies the character case to accept when decoding\n\nThe values for `:case` can be:\n\n  * `:upper` - only allows upper case characters (default)\n  * `:lower` - only allows lower case characters\n  * `:mixed` - allows mixed case characters\n\nAn `ArgumentError` exception is raised if the padding is incorrect or\na non-alphabet character is present in the string.\n\n## Examples\n\n    iex> Base.decode16!(\"666F6F626172\")\n    \"foobar\"\n\n    iex> Base.decode16!(\"666f6f626172\", case: :lower)\n    \"foobar\"\n\n    iex> Base.decode16!(\"666f6F626172\", case: :mixed)\n    \"foobar\"\n\n"}
{"completion":"","prompt":"Elixir.Base.decode32(string, opts \\\\ []): Decodes a base 32 encoded string into a binary string.\n\n## Options\n\nThe accepted options are:\n\n  * `:case` - specifies the character case to accept when decoding\n  * `:padding` - specifies whether to require padding\n\nThe values for `:case` can be:\n\n  * `:upper` - only allows  upper case characters (default)\n  * `:lower` - only allows lower case characters\n  * `:mixed` - allows mixed case characters\n\nThe values for `:padding` can be:\n\n  * `true` - requires the input string to be padded to the nearest multiple of 8 (default)\n  * `false` - ignores padding from the input string\n\n## Examples\n\n    iex> Base.decode32(\"MZXW6YTBOI======\")\n    {:ok, \"foobar\"}\n\n    iex> Base.decode32(\"mzxw6ytboi======\", case: :lower)\n    {:ok, \"foobar\"}\n\n    iex> Base.decode32(\"mzXW6ytBOi======\", case: :mixed)\n    {:ok, \"foobar\"}\n\n    iex> Base.decode32(\"MZXW6YTBOI\", padding: false)\n    {:ok, \"foobar\"}\n\n"}
{"completion":"","prompt":"Elixir.Base.decode32!(string, opts \\\\ []): Decodes a base 32 encoded string into a binary string.\n\nAn `ArgumentError` exception is raised if the padding is incorrect or\na non-alphabet character is present in the string.\n\n## Options\n\nThe accepted options are:\n\n  * `:case` - specifies the character case to accept when decoding\n  * `:padding` - specifies whether to require padding\n\nThe values for `:case` can be:\n\n  * `:upper` - only allows upper case characters (default)\n  * `:lower` - only allows lower case characters\n  * `:mixed` - allows mixed case characters\n\nThe values for `:padding` can be:\n\n  * `true` - requires the input string to be padded to the nearest multiple of 8 (default)\n  * `false` - ignores padding from the input string\n\n## Examples\n\n    iex> Base.decode32!(\"MZXW6YTBOI======\")\n    \"foobar\"\n\n    iex> Base.decode32!(\"mzxw6ytboi======\", case: :lower)\n    \"foobar\"\n\n    iex> Base.decode32!(\"mzXW6ytBOi======\", case: :mixed)\n    \"foobar\"\n\n    iex> Base.decode32!(\"MZXW6YTBOI\", padding: false)\n    \"foobar\"\n\n"}
{"completion":"","prompt":"Elixir.Base.decode64(string, opts \\\\ []): Decodes a base 64 encoded string into a binary string.\n\nAccepts `ignore: :whitespace` option which will ignore all the\nwhitespace characters in the input string.\n\nAccepts `padding: false` option which will ignore padding from\nthe input string.\n\n## Examples\n\n    iex> Base.decode64(\"Zm9vYmFy\")\n    {:ok, \"foobar\"}\n\n    iex> Base.decode64(\"Zm9vYmFy\\n\", ignore: :whitespace)\n    {:ok, \"foobar\"}\n\n    iex> Base.decode64(\"Zm9vYg==\")\n    {:ok, \"foob\"}\n\n    iex> Base.decode64(\"Zm9vYg\", padding: false)\n    {:ok, \"foob\"}\n\n"}
{"completion":"","prompt":"Elixir.Base.decode64!(string, opts \\\\ []): Decodes a base 64 encoded string into a binary string.\n\nAccepts `ignore: :whitespace` option which will ignore all the\nwhitespace characters in the input string.\n\nAccepts `padding: false` option which will ignore padding from\nthe input string.\n\nAn `ArgumentError` exception is raised if the padding is incorrect or\na non-alphabet character is present in the string.\n\n## Examples\n\n    iex> Base.decode64!(\"Zm9vYmFy\")\n    \"foobar\"\n\n    iex> Base.decode64!(\"Zm9vYmFy\\n\", ignore: :whitespace)\n    \"foobar\"\n\n    iex> Base.decode64!(\"Zm9vYg==\")\n    \"foob\"\n\n    iex> Base.decode64!(\"Zm9vYg\", padding: false)\n    \"foob\"\n\n"}
{"completion":"","prompt":"Elixir.Base.encode16(data, opts \\\\ []): Encodes a binary string into a base 16 encoded string.\n\n## Options\n\nThe accepted options are:\n\n  * `:case` - specifies the character case to use when encoding\n\nThe values for `:case` can be:\n\n  * `:upper` - uses upper case characters (default)\n  * `:lower` - uses lower case characters\n\n## Examples\n\n    iex> Base.encode16(\"foobar\")\n    \"666F6F626172\"\n\n    iex> Base.encode16(\"foobar\", case: :lower)\n    \"666f6f626172\"\n\n"}
{"completion":"","prompt":"Elixir.Base.encode32(data, opts \\\\ []): Encodes a binary string into a base 32 encoded string.\n\n## Options\n\nThe accepted options are:\n\n  * `:case` - specifies the character case to use when encoding\n  * `:padding` - specifies whether to apply padding\n\nThe values for `:case` can be:\n\n  * `:upper` - uses upper case characters (default)\n  * `:lower` - uses lower case characters\n\nThe values for `:padding` can be:\n\n  * `true` - pad the output string to the nearest multiple of 8 (default)\n  * `false` - omit padding from the output string\n\n## Examples\n\n    iex> Base.encode32(\"foobar\")\n    \"MZXW6YTBOI======\"\n\n    iex> Base.encode32(\"foobar\", case: :lower)\n    \"mzxw6ytboi======\"\n\n    iex> Base.encode32(\"foobar\", padding: false)\n    \"MZXW6YTBOI\"\n\n"}
{"completion":"","prompt":"Elixir.Base.encode64(data, opts \\\\ []): Encodes a binary string into a base 64 encoded string.\n\nAccepts `padding: false` option which will omit padding from\nthe output string.\n\n## Examples\n\n    iex> Base.encode64(\"foobar\")\n    \"Zm9vYmFy\"\n\n    iex> Base.encode64(\"foob\")\n    \"Zm9vYg==\"\n\n    iex> Base.encode64(\"foob\", padding: false)\n    \"Zm9vYg\"\n\n"}
{"completion":"","prompt":"Elixir.Base.hex_decode32(string, opts \\\\ []): Decodes a base 32 encoded string with extended hexadecimal alphabet\ninto a binary string.\n\n## Options\n\nThe accepted options are:\n\n  * `:case` - specifies the character case to accept when decoding\n  * `:padding` - specifies whether to require padding\n\nThe values for `:case` can be:\n\n  * `:upper` - only allows upper case characters (default)\n  * `:lower` - only allows lower case characters\n  * `:mixed` - allows mixed case characters\n\nThe values for `:padding` can be:\n\n  * `true` - requires the input string to be padded to the nearest multiple of 8 (default)\n  * `false` - ignores padding from the input string\n\n## Examples\n\n    iex> Base.hex_decode32(\"CPNMUOJ1E8======\")\n    {:ok, \"foobar\"}\n\n    iex> Base.hex_decode32(\"cpnmuoj1e8======\", case: :lower)\n    {:ok, \"foobar\"}\n\n    iex> Base.hex_decode32(\"cpnMuOJ1E8======\", case: :mixed)\n    {:ok, \"foobar\"}\n\n    iex> Base.hex_decode32(\"CPNMUOJ1E8\", padding: false)\n    {:ok, \"foobar\"}\n\n"}
{"completion":"","prompt":"Elixir.Base.hex_decode32!(string, opts \\\\ []): Decodes a base 32 encoded string with extended hexadecimal alphabet\ninto a binary string.\n\nAn `ArgumentError` exception is raised if the padding is incorrect or\na non-alphabet character is present in the string.\n\n## Options\n\nThe accepted options are:\n\n  * `:case` - specifies the character case to accept when decoding\n  * `:padding` - specifies whether to require padding\n\nThe values for `:case` can be:\n\n  * `:upper` - only allows upper case characters (default)\n  * `:lower` - only allows lower case characters\n  * `:mixed` - allows mixed case characters\n\nThe values for `:padding` can be:\n\n  * `true` - requires the input string to be padded to the nearest multiple of 8 (default)\n  * `false` - ignores padding from the input string\n\n## Examples\n\n    iex> Base.hex_decode32!(\"CPNMUOJ1E8======\")\n    \"foobar\"\n\n    iex> Base.hex_decode32!(\"cpnmuoj1e8======\", case: :lower)\n    \"foobar\"\n\n    iex> Base.hex_decode32!(\"cpnMuOJ1E8======\", case: :mixed)\n    \"foobar\"\n\n    iex> Base.hex_decode32!(\"CPNMUOJ1E8\", padding: false)\n    \"foobar\"\n\n"}
{"completion":"","prompt":"Elixir.Base.hex_encode32(data, opts \\\\ []): Encodes a binary string into a base 32 encoded string with an\nextended hexadecimal alphabet.\n\n## Options\n\nThe accepted options are:\n\n  * `:case` - specifies the character case to use when encoding\n  * `:padding` - specifies whether to apply padding\n\nThe values for `:case` can be:\n\n  * `:upper` - uses upper case characters (default)\n  * `:lower` - uses lower case characters\n\nThe values for `:padding` can be:\n\n  * `true` - pad the output string to the nearest multiple of 8 (default)\n  * `false` - omit padding from the output string\n\n## Examples\n\n    iex> Base.hex_encode32(\"foobar\")\n    \"CPNMUOJ1E8======\"\n\n    iex> Base.hex_encode32(\"foobar\", case: :lower)\n    \"cpnmuoj1e8======\"\n\n    iex> Base.hex_encode32(\"foobar\", padding: false)\n    \"CPNMUOJ1E8\"\n\n"}
{"completion":"","prompt":"Elixir.Base.url_decode64(string, opts \\\\ []): Decodes a base 64 encoded string with URL and filename safe alphabet\ninto a binary string.\n\nAccepts `ignore: :whitespace` option which will ignore all the\nwhitespace characters in the input string.\n\nAccepts `padding: false` option which will ignore padding from\nthe input string.\n\n## Examples\n\n    iex> Base.url_decode64(\"_3_-_A==\")\n    {:ok, <<255, 127, 254, 252>>}\n\n    iex> Base.url_decode64(\"_3_-_A==\\n\", ignore: :whitespace)\n    {:ok, <<255, 127, 254, 252>>}\n\n    iex> Base.url_decode64(\"_3_-_A\", padding: false)\n    {:ok, <<255, 127, 254, 252>>}\n\n"}
{"completion":"","prompt":"Elixir.Base.url_decode64!(string, opts \\\\ []): Decodes a base 64 encoded string with URL and filename safe alphabet\ninto a binary string.\n\nAccepts `ignore: :whitespace` option which will ignore all the\nwhitespace characters in the input string.\n\nAccepts `padding: false` option which will ignore padding from\nthe input string.\n\nAn `ArgumentError` exception is raised if the padding is incorrect or\na non-alphabet character is present in the string.\n\n## Examples\n\n    iex> Base.url_decode64!(\"_3_-_A==\")\n    <<255, 127, 254, 252>>\n\n    iex> Base.url_decode64!(\"_3_-_A==\\n\", ignore: :whitespace)\n    <<255, 127, 254, 252>>\n\n    iex> Base.url_decode64!(\"_3_-_A\", padding: false)\n    <<255, 127, 254, 252>>\n\n"}
{"completion":"","prompt":"Elixir.Base.url_encode64(data, opts \\\\ []): Encodes a binary string into a base 64 encoded string with URL and filename\nsafe alphabet.\n\nAccepts `padding: false` option which will omit padding from\nthe output string.\n\n## Examples\n\n    iex> Base.url_encode64(<<255, 127, 254, 252>>)\n    \"_3_-_A==\"\n\n    iex> Base.url_encode64(<<255, 127, 254, 252>>, padding: false)\n    \"_3_-_A\"\n\n"}
{"completion":"","prompt":"Elixir.Bitwise.left &&& right: Bitwise AND operator.\n\nCalculates the bitwise AND of its arguments.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 9 &&& 3\n    1\n\n"}
{"completion":"","prompt":"Elixir.Bitwise.left <<< right: Arithmetic left bitshift operator.\n\nCalculates the result of an arithmetic left bitshift.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 <<< 2\n    4\n\n    iex> 1 <<< -2\n    0\n\n    iex> -1 <<< 2\n    -4\n\n    iex> -1 <<< -2\n    -1\n\n"}
{"completion":"","prompt":"Elixir.Bitwise.left >>> right: Arithmetic right bitshift operator.\n\nCalculates the result of an arithmetic right bitshift.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 >>> 2\n    0\n\n    iex> 1 >>> -2\n    4\n\n    iex> -1 >>> 2\n    -1\n\n    iex> -1 >>> -2\n    -4\n\n"}
{"completion":"","prompt":"Elixir.Bitwise.band(left, right): Calculates the bitwise AND of its arguments.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> band(9, 3)\n    1\n\n"}
{"completion":"","prompt":"Elixir.Bitwise.bnot(expr): Calculates the bitwise NOT of the argument.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> bnot(2)\n    -3\n\n    iex> bnot(2) &&& 3\n    1\n\n"}
{"completion":"","prompt":"Elixir.Bitwise.bor(left, right): Calculates the bitwise OR of its arguments.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> bor(9, 3)\n    11\n\n"}
{"completion":"","prompt":"Elixir.Bitwise.bsl(left, right): Calculates the result of an arithmetic left bitshift.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> bsl(1, 2)\n    4\n\n    iex> bsl(1, -2)\n    0\n\n    iex> bsl(-1, 2)\n    -4\n\n    iex> bsl(-1, -2)\n    -1\n\n"}
{"completion":"","prompt":"Elixir.Bitwise.bsr(left, right): Calculates the result of an arithmetic right bitshift.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> bsr(1, 2)\n    0\n\n    iex> bsr(1, -2)\n    4\n\n    iex> bsr(-1, 2)\n    -1\n\n    iex> bsr(-1, -2)\n    -4\n\n"}
{"completion":"","prompt":"Elixir.Bitwise.bxor(left, right): Calculates the bitwise XOR of its arguments.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> bxor(9, 3)\n    10\n\n"}
{"completion":"","prompt":"Elixir.Bitwise.left ||| right: Bitwise OR operator.\n\nCalculates the bitwise OR of its arguments.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 9 ||| 3\n    11\n\n"}
{"completion":"","prompt":"Elixir.Calendar.ISO.date_to_string(year, month, day, format \\\\ :extended): Converts the given date into a string.\n\nBy default, returns dates formatted in the \"extended\" format,\nfor human readability. It also supports the \"basic\" format\nby passing the `:basic` option.\n\n## Examples\n\n    iex> Calendar.ISO.date_to_string(2015, 2, 28)\n    \"2015-02-28\"\n    iex> Calendar.ISO.date_to_string(2017, 8, 1)\n    \"2017-08-01\"\n    iex> Calendar.ISO.date_to_string(-99, 1, 31)\n    \"-0099-01-31\"\n\n    iex> Calendar.ISO.date_to_string(2015, 2, 28, :basic)\n    \"20150228\"\n    iex> Calendar.ISO.date_to_string(-99, 1, 31, :basic)\n    \"-00990131\"\n\n"}
{"completion":"","prompt":"Elixir.Calendar.ISO.datetime_to_string(year, month, day, hour, minute, second, microsecond, time_zone, zone_abbr, utc_offset, std_offset, format \\\\ :extended): Converts the datetime (with time zone) into a string.\n\nBy default, returns datetimes formatted in the \"extended\" format,\nfor human readability. It also supports the \"basic\" format\nby passing the `:basic` option.\n\n## Examples\n\n    iex> time_zone = \"Etc/UTC\"\n    iex> Calendar.ISO.datetime_to_string(2017, 8, 1, 1, 2, 3, {4, 5}, time_zone, \"UTC\", 0, 0)\n    \"2017-08-01 01:02:03.00000Z\"\n    iex> Calendar.ISO.datetime_to_string(2017, 8, 1, 1, 2, 3, {4, 5}, time_zone, \"UTC\", 3600, 0)\n    \"2017-08-01 01:02:03.00000+01:00\"\n    iex> Calendar.ISO.datetime_to_string(2017, 8, 1, 1, 2, 3, {4, 5}, time_zone, \"UTC\", 3600, 3600)\n    \"2017-08-01 01:02:03.00000+02:00\"\n\n    iex> time_zone = \"Europe/Berlin\"\n    iex> Calendar.ISO.datetime_to_string(2017, 8, 1, 1, 2, 3, {4, 5}, time_zone, \"CET\", 3600, 0)\n    \"2017-08-01 01:02:03.00000+01:00 CET Europe/Berlin\"\n    iex> Calendar.ISO.datetime_to_string(2017, 8, 1, 1, 2, 3, {4, 5}, time_zone, \"CDT\", 3600, 3600)\n    \"2017-08-01 01:02:03.00000+02:00 CDT Europe/Berlin\"\n\n    iex> time_zone = \"America/Los_Angeles\"\n    iex> Calendar.ISO.datetime_to_string(2015, 2, 28, 1, 2, 3, {4, 5}, time_zone, \"PST\", -28800, 0)\n    \"2015-02-28 01:02:03.00000-08:00 PST America/Los_Angeles\"\n    iex> Calendar.ISO.datetime_to_string(2015, 2, 28, 1, 2, 3, {4, 5}, time_zone, \"PDT\", -28800, 3600)\n    \"2015-02-28 01:02:03.00000-07:00 PDT America/Los_Angeles\"\n\n    iex> time_zone = \"Europe/Berlin\"\n    iex> Calendar.ISO.datetime_to_string(2017, 8, 1, 1, 2, 3, {4, 5}, time_zone, \"CET\", 3600, 0, :basic)\n    \"20170801 010203.00000+0100 CET Europe/Berlin\"\n\n"}
{"completion":"","prompt":"Elixir.Calendar.ISO.day_of_era(year, month, day): Calculates the day and era from the given `year`, `month`, and `day`.\n\n## Examples\n\n    iex> Calendar.ISO.day_of_era(0, 1, 1)\n    {366, 0}\n    iex> Calendar.ISO.day_of_era(1, 1, 1)\n    {1, 1}\n    iex> Calendar.ISO.day_of_era(0, 12, 31)\n    {1, 0}\n    iex> Calendar.ISO.day_of_era(0, 12, 30)\n    {2, 0}\n    iex> Calendar.ISO.day_of_era(-1, 12, 31)\n    {367, 0}\n\n"}
{"completion":"","prompt":"Elixir.Calendar.ISO.day_of_week(year, month, day, starting_on): Calculates the day of the week from the given `year`, `month`, and `day`.\n\nIt is an integer from 1 to 7, where 1 is the given `starting_on` weekday.\nFor example, if `starting_on` is set to `:monday`, then 1 is Monday and\n7 is Sunday.\n\n`starting_on` can also be `:default`, which is equivalent to `:monday`.\n\n## Examples\n\n    iex> Calendar.ISO.day_of_week(2016, 10, 31, :monday)\n    {1, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 1, :monday)\n    {2, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 2, :monday)\n    {3, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 3, :monday)\n    {4, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 4, :monday)\n    {5, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 5, :monday)\n    {6, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 6, :monday)\n    {7, 1, 7}\n    iex> Calendar.ISO.day_of_week(-99, 1, 31, :monday)\n    {4, 1, 7}\n\n    iex> Calendar.ISO.day_of_week(2016, 10, 31, :sunday)\n    {2, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 1, :sunday)\n    {3, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 2, :sunday)\n    {4, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 3, :sunday)\n    {5, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 4, :sunday)\n    {6, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 5, :sunday)\n    {7, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 6, :sunday)\n    {1, 1, 7}\n    iex> Calendar.ISO.day_of_week(-99, 1, 31, :sunday)\n    {5, 1, 7}\n\n    iex> Calendar.ISO.day_of_week(2016, 10, 31, :saturday)\n    {3, 1, 7}\n\n"}
{"completion":"","prompt":"Elixir.Calendar.ISO.day_of_year(year, month, day): Calculates the day of the year from the given `year`, `month`, and `day`.\n\nIt is an integer from 1 to 366.\n\n## Examples\n\n    iex> Calendar.ISO.day_of_year(2016, 1, 31)\n    31\n    iex> Calendar.ISO.day_of_year(-99, 2, 1)\n    32\n    iex> Calendar.ISO.day_of_year(2018, 2, 28)\n    59\n\n"}
{"completion":"","prompt":"Elixir.Calendar.ISO.day_rollover_relative_to_midnight_utc(): See `c:Calendar.day_rollover_relative_to_midnight_utc/0` for documentation.\n"}
{"completion":"","prompt":"Elixir.Calendar.ISO.days_in_month(year, month): Returns how many days there are in the given year-month.\n\n## Examples\n\n    iex> Calendar.ISO.days_in_month(1900, 1)\n    31\n    iex> Calendar.ISO.days_in_month(1900, 2)\n    28\n    iex> Calendar.ISO.days_in_month(2000, 2)\n    29\n    iex> Calendar.ISO.days_in_month(2001, 2)\n    28\n    iex> Calendar.ISO.days_in_month(2004, 2)\n    29\n    iex> Calendar.ISO.days_in_month(2004, 4)\n    30\n    iex> Calendar.ISO.days_in_month(-1, 5)\n    31\n\n"}
{"completion":"","prompt":"Elixir.Calendar.ISO.leap_year?(year): Returns if the given year is a leap year.\n\n## Examples\n\n    iex> Calendar.ISO.leap_year?(2000)\n    true\n    iex> Calendar.ISO.leap_year?(2001)\n    false\n    iex> Calendar.ISO.leap_year?(2004)\n    true\n    iex> Calendar.ISO.leap_year?(1900)\n    false\n    iex> Calendar.ISO.leap_year?(-4)\n    true\n\n"}
{"completion":"","prompt":"Elixir.Calendar.ISO.months_in_year(year): Returns how many months there are in the given year.\n\n## Example\n\n    iex> Calendar.ISO.months_in_year(2004)\n    12\n\n"}
{"completion":"","prompt":"Elixir.Calendar.ISO.naive_datetime_from_iso_days(arg): Converts the `t:Calendar.iso_days/0` format to the datetime format specified by this calendar.\n\n## Examples\n\n    iex> Calendar.ISO.naive_datetime_from_iso_days({0, {0, 86400}})\n    {0, 1, 1, 0, 0, 0, {0, 6}}\n    iex> Calendar.ISO.naive_datetime_from_iso_days({730_485, {0, 86400}})\n    {2000, 1, 1, 0, 0, 0, {0, 6}}\n    iex> Calendar.ISO.naive_datetime_from_iso_days({730_485, {43200, 86400}})\n    {2000, 1, 1, 12, 0, 0, {0, 6}}\n    iex> Calendar.ISO.naive_datetime_from_iso_days({-365, {0, 86400000000}})\n    {-1, 1, 1, 0, 0, 0, {0, 6}}\n\n"}
{"completion":"","prompt":"Elixir.Calendar.ISO.naive_datetime_to_iso_days(year, month, day, hour, minute, second, microsecond): Returns the `t:Calendar.iso_days/0` format of the specified date.\n\n## Examples\n\n    iex> Calendar.ISO.naive_datetime_to_iso_days(0, 1, 1, 0, 0, 0, {0, 6})\n    {0, {0, 86400000000}}\n    iex> Calendar.ISO.naive_datetime_to_iso_days(2000, 1, 1, 12, 0, 0, {0, 6})\n    {730485, {43200000000, 86400000000}}\n    iex> Calendar.ISO.naive_datetime_to_iso_days(2000, 1, 1, 13, 0, 0, {0, 6})\n    {730485, {46800000000, 86400000000}}\n    iex> Calendar.ISO.naive_datetime_to_iso_days(-1, 1, 1, 0, 0, 0, {0, 6})\n    {-365, {0, 86400000000}}\n\n"}
{"completion":"","prompt":"Elixir.Calendar.ISO.naive_datetime_to_string(year, month, day, hour, minute, second, microsecond, format \\\\ :extended): Converts the datetime (without time zone) into a string.\n\nBy default, returns datetimes formatted in the \"extended\" format,\nfor human readability. It also supports the \"basic\" format\nby passing the `:basic` option.\n\n## Examples\n\n    iex> Calendar.ISO.naive_datetime_to_string(2015, 2, 28, 1, 2, 3, {4, 6})\n    \"2015-02-28 01:02:03.000004\"\n    iex> Calendar.ISO.naive_datetime_to_string(2017, 8, 1, 1, 2, 3, {4, 5})\n    \"2017-08-01 01:02:03.00000\"\n\n    iex> Calendar.ISO.naive_datetime_to_string(2015, 2, 28, 1, 2, 3, {4, 6}, :basic)\n    \"20150228 010203.000004\"\n\n"}
{"completion":"","prompt":"Elixir.Calendar.ISO.parse_date(string): Parses a date `string` in the `:extended` format.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).\n\n## Examples\n\n    iex> Calendar.ISO.parse_date(\"2015-01-23\")\n    {:ok, {2015, 1, 23}}\n\n    iex> Calendar.ISO.parse_date(\"2015:01:23\")\n    {:error, :invalid_format}\n    iex> Calendar.ISO.parse_date(\"2015-01-32\")\n    {:error, :invalid_date}\n\n"}
{"completion":"","prompt":"Elixir.Calendar.ISO.parse_date(string, format): Parses a date `string` according to a given `format`.\n\nThe `format` can either be `:basic` or `:extended`.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).\n\n## Examples\n\n    iex> Calendar.ISO.parse_date(\"20150123\", :basic)\n    {:ok, {2015, 1, 23}}\n    iex> Calendar.ISO.parse_date(\"20150123\", :extended)\n    {:error, :invalid_format}\n\n"}
{"completion":"","prompt":"Elixir.Calendar.ISO.parse_naive_datetime(string): Parses a naive datetime `string` in the `:extended` format.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).\n\n## Examples\n\n    iex> Calendar.ISO.parse_naive_datetime(\"2015-01-23 23:50:07\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_naive_datetime(\"2015-01-23 23:50:07Z\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_naive_datetime(\"2015-01-23 23:50:07-02:30\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}}\n\n    iex> Calendar.ISO.parse_naive_datetime(\"2015-01-23 23:50:07.0\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 1}}}\n    iex> Calendar.ISO.parse_naive_datetime(\"2015-01-23 23:50:07,0123456\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {12345, 6}}}\n\n"}
{"completion":"","prompt":"Elixir.Calendar.ISO.parse_naive_datetime(string, format): Parses a naive datetime `string` according to a given `format`.\n\nThe `format` can either be `:basic` or `:extended`.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).\n\n## Examples\n\n    iex> Calendar.ISO.parse_naive_datetime(\"20150123 235007\", :basic)\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_naive_datetime(\"20150123 235007\", :extended)\n    {:error, :invalid_format}\n\n"}
{"completion":"","prompt":"Elixir.Calendar.ISO.parse_time(string): Parses a time `string` in the `:extended` format.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).\n\n## Examples\n\n    iex> Calendar.ISO.parse_time(\"23:50:07\")\n    {:ok, {23, 50, 7, {0, 0}}}\n\n    iex> Calendar.ISO.parse_time(\"23:50:07Z\")\n    {:ok, {23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_time(\"T23:50:07Z\")\n    {:ok, {23, 50, 7, {0, 0}}}\n\n"}
{"completion":"","prompt":"Elixir.Calendar.ISO.parse_time(string, format): Parses a time `string` according to a given `format`.\n\nThe `format` can either be `:basic` or `:extended`.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).\n\n## Examples\n\n    iex> Calendar.ISO.parse_time(\"235007\", :basic)\n    {:ok, {23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_time(\"235007\", :extended)\n    {:error, :invalid_format}\n\n"}
{"completion":"","prompt":"Elixir.Calendar.ISO.parse_utc_datetime(string): Parses a UTC datetime `string` in the `:extended` format.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).\n\n## Examples\n\n    iex> Calendar.ISO.parse_utc_datetime(\"2015-01-23 23:50:07Z\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}, 0}\n\n    iex> Calendar.ISO.parse_utc_datetime(\"2015-01-23 23:50:07+02:30\")\n    {:ok, {2015, 1, 23, 21, 20, 7, {0, 0}}, 9000}\n\n    iex> Calendar.ISO.parse_utc_datetime(\"2015-01-23 23:50:07\")\n    {:error, :missing_offset}\n\n"}
{"completion":"","prompt":"Elixir.Calendar.ISO.parse_utc_datetime(string, format): Parses a UTC datetime `string` according to a given `format`.\n\nThe `format` can either be `:basic` or `:extended`.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).\n\n## Examples\n\n    iex> Calendar.ISO.parse_utc_datetime(\"20150123 235007Z\", :basic)\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}, 0}\n    iex> Calendar.ISO.parse_utc_datetime(\"20150123 235007Z\", :extended)\n    {:error, :invalid_format}\n\n"}
{"completion":"","prompt":"Elixir.Calendar.ISO.quarter_of_year(year, month, day): Calculates the quarter of the year from the given `year`, `month`, and `day`.\n\nIt is an integer from 1 to 4.\n\n## Examples\n\n    iex> Calendar.ISO.quarter_of_year(2016, 1, 31)\n    1\n    iex> Calendar.ISO.quarter_of_year(2016, 4, 3)\n    2\n    iex> Calendar.ISO.quarter_of_year(-99, 9, 31)\n    3\n    iex> Calendar.ISO.quarter_of_year(2018, 12, 28)\n    4\n\n"}
{"completion":"","prompt":"Elixir.Calendar.ISO.time_from_day_fraction(arg): Converts a day fraction to this Calendar's representation of time.\n\n## Examples\n\n    iex> Calendar.ISO.time_from_day_fraction({1, 2})\n    {12, 0, 0, {0, 6}}\n    iex> Calendar.ISO.time_from_day_fraction({13, 24})\n    {13, 0, 0, {0, 6}}\n\n"}
{"completion":"","prompt":"Elixir.Calendar.ISO.time_to_day_fraction(hour, minute, second, arg): Returns the normalized day fraction of the specified time.\n\n## Examples\n\n    iex> Calendar.ISO.time_to_day_fraction(0, 0, 0, {0, 6})\n    {0, 86400000000}\n    iex> Calendar.ISO.time_to_day_fraction(12, 34, 56, {123, 6})\n    {45296000123, 86400000000}\n\n"}
{"completion":"","prompt":"Elixir.Calendar.ISO.time_to_string(hour, minute, second, microsecond, format \\\\ :extended): Converts the given time into a string.\n\nBy default, returns times formatted in the \"extended\" format,\nfor human readability. It also supports the \"basic\" format\nby passing the `:basic` option.\n\n## Examples\n\n    iex> Calendar.ISO.time_to_string(2, 2, 2, {2, 6})\n    \"02:02:02.000002\"\n    iex> Calendar.ISO.time_to_string(2, 2, 2, {2, 2})\n    \"02:02:02.00\"\n    iex> Calendar.ISO.time_to_string(2, 2, 2, {2, 0})\n    \"02:02:02\"\n\n    iex> Calendar.ISO.time_to_string(2, 2, 2, {2, 6}, :basic)\n    \"020202.000002\"\n    iex> Calendar.ISO.time_to_string(2, 2, 2, {2, 6}, :extended)\n    \"02:02:02.000002\"\n\n"}
{"completion":"","prompt":"Elixir.Calendar.ISO.time_unit_to_precision(arg1): Converts a `t:System.time_unit/0` to precision.\n\nInteger-based time units always get maximum precision.\n"}
{"completion":"","prompt":"Elixir.Calendar.ISO.valid_date?(year, month, day): Determines if the date given is valid according to the proleptic Gregorian calendar.\n\n## Examples\n\n    iex> Calendar.ISO.valid_date?(2015, 2, 28)\n    true\n    iex> Calendar.ISO.valid_date?(2015, 2, 30)\n    false\n    iex> Calendar.ISO.valid_date?(-1, 12, 31)\n    true\n    iex> Calendar.ISO.valid_date?(-1, 12, 32)\n    false\n\n"}
{"completion":"","prompt":"Elixir.Calendar.ISO.valid_time?(hour, minute, second, microsecond): Determines if the date given is valid according to the proleptic Gregorian calendar.\n\nLeap seconds are not supported by the built-in Calendar.ISO.\n\n## Examples\n\n    iex> Calendar.ISO.valid_time?(10, 50, 25, {3006, 6})\n    true\n    iex> Calendar.ISO.valid_time?(23, 59, 60, {0, 0})\n    false\n    iex> Calendar.ISO.valid_time?(24, 0, 0, {0, 0})\n    false\n\n"}
{"completion":"","prompt":"Elixir.Calendar.ISO.year_of_era(year): Calculates the year and era from the given `year`.\n\nThe ISO calendar has two eras: the \"current era\" (CE) which\nstarts in year `1` and is defined as era `1`. And \"before the current\nera\" (BCE) for those years less than `1`, defined as era `0`.\n\n## Examples\n\n    iex> Calendar.ISO.year_of_era(1)\n    {1, 1}\n    iex> Calendar.ISO.year_of_era(2018)\n    {2018, 1}\n    iex> Calendar.ISO.year_of_era(0)\n    {1, 0}\n    iex> Calendar.ISO.year_of_era(-1)\n    {2, 0}\n\n"}
{"completion":"","prompt":"Elixir.Calendar.ISO.year_of_era(year, month, day): Calendar callback to compute the year and era from the\ngiven `year`, `month` and `day`.\n\nIn the ISO calendar, the new year coincides with the new era,\nso the `month` and `day` arguments are discarded. If you only\nhave the year available, you can `year_of_era/1` instead.\n\n## Examples\n\n    iex> Calendar.ISO.year_of_era(1, 1, 1)\n    {1, 1}\n    iex> Calendar.ISO.year_of_era(2018, 12, 1)\n    {2018, 1}\n    iex> Calendar.ISO.year_of_era(0, 1, 1)\n    {1, 0}\n    iex> Calendar.ISO.year_of_era(-1, 12, 1)\n    {2, 0}\n\n"}
{"completion":"","prompt":"Elixir.Calendar.compatible_calendars?(calendar, calendar): Returns `true` if two calendars have the same moment of starting a new day,\n`false` otherwise.\n\nIf two calendars are not compatible, we can only convert datetimes and times\nbetween them. If they are compatible, this means that we can also convert\ndates as well as naive datetimes between them.\n"}
{"completion":"","prompt":"Elixir.Calendar.get_time_zone_database(): Gets the current time zone database.\n"}
{"completion":"","prompt":"Elixir.Calendar.put_time_zone_database(database): Sets the current time zone database.\n"}
{"completion":"","prompt":"Elixir.Calendar.strftime(date_or_time_or_datetime, string_format, user_options \\\\ []): Formats received datetime into a string.\n\nThe datetime can be any of the Calendar types (`Time`, `Date`,\n`NaiveDateTime`, and `DateTime`) or any map, as long as they\ncontain all of the relevant fields necessary for formatting.\nFor example, if you use `%Y` to format the year, the datetime\nmust have the `:year` field. Therefore, if you pass a `Time`,\nor a map without the `:year` field to a format that expects `%Y`,\nan error will be raised.\n\n## Options\n\n  * `:preferred_datetime` - a string for the preferred format to show datetimes,\n    it can't contain the `%c` format and defaults to `\"%Y-%m-%d %H:%M:%S\"`\n    if the option is not received\n\n  * `:preferred_date` - a string for the preferred format to show dates,\n    it can't contain the `%x` format and defaults to `\"%Y-%m-%d\"`\n    if the option is not received\n\n  * `:preferred_time` - a string for the preferred format to show times,\n    it can't contain the `%X` format and defaults to `\"%H:%M:%S\"`\n    if the option is not received\n\n  * `:am_pm_names` - a function that receives either `:am` or `:pm` and returns\n    the name of the period of the day, if the option is not received it defaults\n    to a function that returns `\"am\"` and `\"pm\"`, respectively\n\n  *  `:month_names` - a function that receives a number and returns the name of\n    the corresponding month, if the option is not received it defaults to a\n    function that returns the month names in English\n\n  * `:abbreviated_month_names` - a function that receives a number and returns the\n    abbreviated name of the corresponding month, if the option is not received it\n    defaults to a function that returns the abbreviated month names in English\n\n  * `:day_of_week_names` - a function that receives a number and returns the name of\n    the corresponding day of week, if the option is not received it defaults to a\n    function that returns the day of week names in English\n\n  * `:abbreviated_day_of_week_names` - a function that receives a number and returns\n    the abbreviated name of the corresponding day of week, if the option is not received\n    it defaults to a function that returns the abbreviated day of week names in English\n\n## Formatting syntax\n\nThe formatting syntax for strftime is a sequence of characters in the following format:\n\n    %<padding><width><format>\n\nwhere:\n\n  * `%`: indicates the start of a formatted section\n  * `<padding>`: set the padding (see below)\n  * `<width>`: a number indicating the minimum size of the formatted section\n  * `<format>`: the format itself (see below)\n\n### Accepted padding options\n\n  * `-`: no padding, removes all padding from the format\n  * `_`: pad with spaces\n  * `0`: pad with zeroes\n\n### Accepted formats\n\nThe accepted formats are:\n\nFormat | Description                                                             | Examples (in ISO)\n:----- | :-----------------------------------------------------------------------| :------------------------\na      | Abbreviated name of day                                                 | Mon\nA      | Full name of day                                                        | Monday\nb      | Abbreviated month name                                                  | Jan\nB      | Full month name                                                         | January\nc      | Preferred date+time representation                                      | 2018-10-17 12:34:56\nd      | Day of the month                                                        | 01, 31\nf      | Microseconds *(does not support width and padding modifiers)*           | 000000, 999999, 0123\nH      | Hour using a 24-hour clock                                              | 00, 23\nI      | Hour using a 12-hour clock                                              | 01, 12\nj      | Day of the year                                                         | 001, 366\nm      | Month                                                                   | 01, 12\nM      | Minute                                                                  | 00, 59\np      | \"AM\" or \"PM\" (noon is \"PM\", midnight as \"AM\")                           | AM, PM\nP      | \"am\" or \"pm\" (noon is \"pm\", midnight as \"am\")                           | am, pm\nq      | Quarter                                                                 | 1, 2, 3, 4\nS      | Second                                                                  | 00, 59, 60\nu      | Day of the week                                                         | 1 (Monday), 7 (Sunday)\nx      | Preferred date (without time) representation                            | 2018-10-17\nX      | Preferred time (without date) representation                            | 12:34:56\ny      | Year as 2-digits                                                        | 01, 01, 86, 18\nY      | Year                                                                    | -0001, 0001, 1986\nz      | +hhmm/-hhmm time zone offset from UTC (empty string if naive)           | +0300, -0530\nZ      | Time zone abbreviation (empty string if naive)                          | CET, BRST\n%      | Literal \"%\" character                                                   | %\n\nAny other character will be interpreted as an invalid format and raise an error\n\n## Examples\n\nWithout options:\n\n    iex> Calendar.strftime(~U[2019-08-26 13:52:06.0Z], \"%y-%m-%d %I:%M:%S %p\")\n    \"19-08-26 01:52:06 PM\"\n\n    iex> Calendar.strftime(~U[2019-08-26 13:52:06.0Z], \"%a, %B %d %Y\")\n    \"Mon, August 26 2019\"\n\n    iex> Calendar.strftime(~U[2020-04-02 13:52:06.0Z], \"%B %-d, %Y\")\n    \"April 2, 2020\"\n\n    iex> Calendar.strftime(~U[2019-08-26 13:52:06.0Z], \"%c\")\n    \"2019-08-26 13:52:06\"\n\nWith options:\n\n    iex> Calendar.strftime(~U[2019-08-26 13:52:06.0Z], \"%c\", preferred_datetime: \"%H:%M:%S %d-%m-%y\")\n    \"13:52:06 26-08-19\"\n\n    iex> Calendar.strftime(\n    ...>  ~U[2019-08-26 13:52:06.0Z],\n    ...>  \"%A\",\n    ...>  day_of_week_names: fn day_of_week ->\n    ...>    {\"segunda-feira\", \"terÃ§a-feira\", \"quarta-feira\", \"quinta-feira\",\n    ...>    \"sexta-feira\", \"sÃ¡bado\", \"domingo\"}\n    ...>    |> elem(day_of_week - 1)\n    ...>  end\n    ...>)\n    \"segunda-feira\"\n\n    iex> Calendar.strftime(\n    ...>  ~U[2019-08-26 13:52:06.0Z],\n    ...>  \"%B\",\n    ...>  month_names: fn month ->\n    ...>    {\"ÑÐ½Ð²Ð°ÑÑ\", \"ÑÐµÐ²ÑÐ°Ð»Ñ\", \"Ð¼Ð°ÑÑ\", \"Ð°Ð¿ÑÐµÐ»Ñ\", \"Ð¼Ð°Ð¹\", \"Ð¸ÑÐ½Ñ\",\n    ...>    \"Ð¸ÑÐ»Ñ\", \"Ð°Ð²Ð³ÑÑÑ\", \"ÑÐµÐ½ÑÑÐ±ÑÑ\", \"Ð¾ÐºÑÑÐ±ÑÑ\", \"Ð½Ð¾ÑÐ±ÑÑ\", \"Ð´ÐµÐºÐ°Ð±ÑÑ\"}\n    ...>    |> elem(month - 1)\n    ...>  end\n    ...>)\n    \"Ð°Ð²Ð³ÑÑÑ\"\n"}
{"completion":"","prompt":"Elixir.Calendar.truncate(microsecond_tuple, atom): Returns a microsecond tuple truncated to a given precision (`:microsecond`,\n`:millisecond` or `:second`).\n"}
{"completion":"","prompt":"Elixir.Code.Formatter.local_without_parens?(fun, arity, locals_without_parens): Checks if a function is a local without parens.\n"}
{"completion":"","prompt":"Elixir.Code.Formatter.locals_without_parens(): Lists all default locals without parens.\n"}
{"completion":"","prompt":"Elixir.Code.Formatter.to_algebra(quoted, opts \\\\ []): Converts the quoted expression into an algebra document.\n"}
{"completion":"","prompt":"Elixir.Code.Fragment.container_cursor_to_quoted(fragment, opts \\\\ []): Receives a string and returns a quoted expression\nwith a cursor at the nearest argument position.\n\nThis function receives a string with an Elixir code fragment,\nrepresenting a cursor position, and converts such string to\nAST with the inclusion of special `__cursor__()` node based\non the position of the cursor with a container.\n\nA container is any Elixir expression starting with `(`,\n`{`, and `[`. This includes function calls, tuples, lists,\nmaps, and so on. For example, take this code, which would\nbe given as input:\n\n    max(some_value,\n\nThis function will return the AST equivalent to:\n\n    max(some_value, __cursor__())\n\nIn other words, this function is capable of closing any open\nbrackets and insert the cursor position. Any content at the\ncursor position that is after a comma or an opening bracket\nis discarded. For example, if this is given as input:\n\n    max(some_value, another_val\n\nIt will return the same AST:\n\n    max(some_value, __cursor__())\n\nSimilarly, if only this is given:\n\n    max(some_va\n\nThen it returns:\n\n    max(__cursor__())\n\nCalls without parenthesis are also supported, as we assume the\nbrackets are implicit.\n\nOperators and anonymous functions are not containers, and therefore\nwill be discarded. The following will all return the same AST:\n\n    max(some_value,\n    max(some_value, fn x -> x end\n    max(some_value, 1 + another_val\n    max(some_value, 1 |> some_fun() |> another_fun\n\nOn the other hand, tuples, lists, maps, and binaries all retain the\ncursor position:\n\n    max(some_value, [1, 2,\n\nReturns the following AST:\n\n    max(some_value, [1, 2, __cursor__()])\n\nKeyword lists (and do-end blocks) are also retained. The following:\n\n    if(some_value, do:\n    if(some_value, do: :token\n    if(some_value, do: 1 + val\n\nall return:\n\n    if(some_value, do: __cursor__())\n\nThe AST returned by this function is not safe to evaluate but\nit can be analyzed and expanded.\n\n## Examples\n\nFunction call:\n\n    iex> Code.Fragment.container_cursor_to_quoted(\"max(some_value, \")\n    {:ok, {:max, [line: 1], [{:some_value, [line: 1], nil}, {:__cursor__, [line: 1], []}]}}\n\nContainers (for example, a list):\n\n    iex> Code.Fragment.container_cursor_to_quoted(\"[some, value\")\n    {:ok, [{:some, [line: 1], nil}, {:__cursor__, [line: 1], []}]}\n\nFor binaries, the `::` is exclusively kept as an operator:\n\n    iex> Code.Fragment.container_cursor_to_quoted(\"<<some::integer\")\n    {:ok, {:<<>>, [line: 1], [{:\"::\", [line: 1], [{:some, [line: 1], nil}, {:__cursor__, [line: 1], []}]}]}}\n\n## Options\n\n  * `:file` - the filename to be reported in case of parsing errors.\n    Defaults to `\"nofile\"`.\n\n  * `:line` - the starting line of the string being parsed.\n    Defaults to 1.\n\n  * `:column` - the starting column of the string being parsed.\n    Defaults to 1.\n\n  * `:columns` - when `true`, attach a `:column` key to the quoted\n    metadata. Defaults to `false`.\n\n  * `:token_metadata` - when `true`, includes token-related\n    metadata in the expression AST, such as metadata for `do` and `end`\n    tokens, for closing tokens, end of expressions, as well as delimiters\n    for sigils. See `t:Macro.metadata/0`. Defaults to `false`.\n\n  * `:literal_encoder` - a function to encode literals in the AST.\n    See the documentation for `Code.string_to_quoted/2` for more information.\n\n"}
{"completion":"","prompt":"Elixir.Code.Fragment.cursor_context(fragment, opts \\\\ []): Receives a string and returns the cursor context.\n\nThis function receives a string with an Elixir code fragment,\nrepresenting a cursor position, and based on the string, it\nprovides contextual information about said position. The\nreturn of this function can then be used to provide tips,\nsuggestions, and autocompletion functionality.\n\nThis function provides a best-effort detection and may not be\naccurate under all circumstances. See the \"Limitations\"\nsection below.\n\nConsider adding a catch-all clause when handling the return\ntype of this function as new cursor information may be added\nin future releases.\n\n## Examples\n\n    iex> Code.Fragment.cursor_context(\"\")\n    :expr\n\n    iex> Code.Fragment.cursor_context(\"hello_wor\")\n    {:local_or_var, 'hello_wor'}\n\n## Return values\n\n  * `{:alias, charlist}` - the context is an alias, potentially\n    a nested one, such as `Hello.Wor` or `HelloWor`\n\n  * `{:alias, inside_alias, charlist}` - the context is an alias, potentially\n    a nested one, where `inside_alias` is an expression `{:module_attribute, charlist}`\n    or `{:local_or_var, charlist}` and `charlist` is a static part\n    Examples are `__MODULE__.Submodule` or `@hello.Submodule`\n\n  * `{:dot, inside_dot, charlist}` - the context is a dot\n    where `inside_dot` is either a `{:var, charlist}`, `{:alias, charlist}`,\n    `{:module_attribute, charlist}`, `{:unquoted_atom, charlist}` or a `dot`\n    itself. If a var is given, this may either be a remote call or a map\n    field access. Examples are `Hello.wor`, `:hello.wor`, `hello.wor`,\n    `Hello.nested.wor`, `hello.nested.wor`, and `@hello.world`. If `charlist`\n    is empty and `inside_dot` is an alias, then the autocompletion may either\n    be an alias or a remote call.\n\n  * `{:dot_arity, inside_dot, charlist}` - the context is a dot arity\n    where `inside_dot` is either a `{:var, charlist}`, `{:alias, charlist}`,\n    `{:module_attribute, charlist}`, `{:unquoted_atom, charlist}` or a `dot`\n    itself. If a var is given, it must be a remote arity. Examples are\n    `Hello.world/`, `:hello.world/`, `hello.world/2`, and `@hello.world/2`\n\n  * `{:dot_call, inside_dot, charlist}` - the context is a dot\n    call. This means parentheses or space have been added after the expression.\n    where `inside_dot` is either a `{:var, charlist}`, `{:alias, charlist}`,\n    `{:module_attribute, charlist}`, `{:unquoted_atom, charlist}` or a `dot`\n    itself. If a var is given, it must be a remote call. Examples are\n    `Hello.world(`, `:hello.world(`, `Hello.world `, `hello.world(`, `hello.world `,\n    and `@hello.world(`\n\n  * `:expr` - may be any expression. Autocompletion may suggest an alias,\n    local or var\n\n  * `{:local_or_var, charlist}` - the context is a variable or a local\n    (import or local) call, such as `hello_wor`\n\n  * `{:local_arity, charlist}` - the context is a local (import or local)\n    arity, such as `hello_world/`\n\n  * `{:local_call, charlist}` - the context is a local (import or local)\n    call, such as `hello_world(` and `hello_world `\n\n  * `{:module_attribute, charlist}` - the context is a module attribute,\n    such as `@hello_wor`\n\n  * `{:operator, charlist}` - the context is an operator, such as `+` or\n    `==`. Note textual operators, such as `when` do not appear as operators\n    but rather as `:local_or_var`. `@` is never an `:operator` and always a\n    `:module_attribute`\n\n  * `{:operator_arity, charlist}` - the context is an operator arity, which\n    is an operator followed by /, such as `+/`, `not/` or `when/`\n\n  * `{:operator_call, charlist}` - the context is an operator call, which is\n    an operator followed by space, such as `left + `, `not ` or `x when `\n\n  * `:none` - no context possible\n\n  * `{:sigil, charlist}` - the context is a sigil. It may be either the beginning\n    of a sigil, such as `~` or `~s`, or an operator starting with `~`, such as\n    `~>` and `~>>`\n\n  * `{:struct, inside_struct}` - the context is a struct, such as `%`, `%UR` or `%URI`.\n    `inside_struct` can either be a `charlist` in case of a static alias or an\n    expression `{:alias, inside_alias, charlist}`, `{:module_attribute, charlist}`,\n    `{:local_or_var, charlist}`, `{:dot, inside_dot, charlist}`\n\n  * `{:unquoted_atom, charlist}` - the context is an unquoted atom. This\n    can be any atom or an atom representing a module\n\n## Limitations\n\nThe current algorithm only considers the last line of the input. This means\nit will also show suggestions inside strings, heredocs, etc, which is\nintentional as it helps with doctests, references, and more.\n"}
{"completion":"","prompt":"Elixir.Code.Fragment.surround_context(fragment, position, options \\\\ []): Receives a string and returns the surround context.\n\nThis function receives a string with an Elixir code fragment\nand a `position`. It returns a map containing the beginning\nand ending of the identifier alongside its context, or `:none`\nif there is nothing with a known context.\n\nThe difference between `cursor_context/2` and `surround_context/3`\nis that the former assumes the expression in the code fragment\nis incomplete. For example, `do` in `cursor_context/2` may be\na keyword or a variable or a local call, while `surround_context/3`\nassumes the expression in the code fragment is complete, therefore\n`do` would always be a keyword.\n\nThe `position` contains both the `line` and `column`, both starting\nwith the index of 1. The column must precede the surrounding expression.\nFor example, the expression `foo`, will return something for the columns\n1, 2, and 3, but not 4:\n\n    foo\n    ^ column 1\n\n    foo\n     ^ column 2\n\n    foo\n      ^ column 3\n\n    foo\n       ^ column 4\n\nThe returned map contains the column the expression starts and the\nfirst column after the expression ends.\n\nSimilar to `cursor_context/2`, this function also provides a best-effort\ndetection and may not be accurate under all circumstances. See the\n\"Return values\" and \"Limitations\" section under `cursor_context/2` for\nmore information.\n\n## Examples\n\n    iex> Code.Fragment.surround_context(\"foo\", {1, 1})\n    %{begin: {1, 1}, context: {:local_or_var, 'foo'}, end: {1, 4}}\n\n## Differences to `cursor_context/2`\n\nBecause `surround_context/3` deals with complete code, it has some\ndifference to `cursor_context/2`:\n\n  * `dot_call`/`dot_arity` and `operator_call`/`operator_arity`\n    are collapsed into `dot` and `operator` contexts respectively\n    as there aren't any meaningful distinctions between them\n\n  * On the other hand, this function still makes a distinction between\n    `local_call`/`local_arity` and `local_or_var`, since the latter can\n    be a local or variable\n\n  * `@` when not followed by any identifier is returned as `{:operator, '@'}`\n    (in contrast to `{:module_attribute, ''}` in `cursor_context/2`\n\n  * This function never returns empty sigils `{:sigil, ''}` or empty structs\n    `{:struct, ''}` as context\n\n  * This function returns keywords as `{:keyword, 'do'}`\n\n  * This function never returns `:expr`\n\n"}
{"completion":"","prompt":"Elixir.Code.Identifier.binary_op(op): Checks if the given identifier is a binary op.\n\n## Examples\n\n    iex> Code.Identifier.binary_op(:+)\n    {:left, 210}\n\n"}
{"completion":"","prompt":"Elixir.Code.Identifier.escape(binary, char, limit \\\\ :infinity, fun \\\\ &escape_map/1): Escapes the given identifier.\n"}
{"completion":"","prompt":"Elixir.Code.Identifier.extract_anonymous_fun_parent(atom): Extracts the name and arity of the parent from the anonymous function identifier.\n"}
{"completion":"","prompt":"Elixir.Code.Identifier.unary_op(op): Checks if the given identifier is an unary op.\n\n## Examples\n\n    iex> Code.Identifier.unary_op(:+)\n    {:non_associative, 300}\n\n"}
{"completion":"","prompt":"Elixir.Code.Normalizer.normalize(quoted, opts \\\\ []): Wraps literals in the quoted expression to conform to the AST format expected\nby the formatter.\n"}
{"completion":"","prompt":"Elixir.Code.Typespec.fetch_callbacks(module): Returns all callbacks available from the module's BEAM code.\n\nThe result is returned as a list of tuples where the first\nelement is spec name and arity and the second is the spec.\n\nThe module must have a corresponding BEAM file\nwhich can be located by the runtime system. The types will be\nin the Erlang Abstract Format.\n"}
{"completion":"","prompt":"Elixir.Code.Typespec.fetch_specs(module): Returns all specs available from the module's BEAM code.\n\nThe result is returned as a list of tuples where the first\nelement is spec name and arity and the second is the spec.\n\nThe module must have a corresponding BEAM file which can be\nlocated by the runtime system. The types will be in the Erlang\nAbstract Format.\n"}
{"completion":"","prompt":"Elixir.Code.Typespec.fetch_types(module): Returns all types available from the module's BEAM code.\n\nThe result is returned as a list of tuples where the first\nelement is the type (`:typep`, `:type` and `:opaque`).\n\nThe module must have a corresponding BEAM file which can be\nlocated by the runtime system. The types will be in the Erlang\nAbstract Format.\n"}
{"completion":"","prompt":"Elixir.Code.Typespec.spec_to_quoted(name, spec): Converts a spec clause back to Elixir quoted expression.\n"}
{"completion":"","prompt":"Elixir.Code.Typespec.type_to_quoted(type): Converts a type clause back to Elixir AST.\n"}
{"completion":"","prompt":"Elixir.Code.append_path(path): Appends a path to the end of the Erlang VM code path list.\n\nThis is the list of directories the Erlang VM uses for\nfinding module code. The list of files is managed per Erlang\nVM node.\n\nThe path is expanded with `Path.expand/1` before being appended.\nIf this path does not exist, an error is returned.\n\n## Examples\n\n    Code.append_path(\".\")\n    #=> true\n\n    Code.append_path(\"/does_not_exist\")\n    #=> {:error, :bad_directory}\n\n"}
{"completion":"","prompt":"Elixir.Code.available_compiler_options(): Returns a list with all available compiler options.\n\nFor a description of all options, see `put_compiler_option/2`.\n\n## Examples\n\n    Code.available_compiler_options()\n    #=> [:docs, :debug_info, ...]\n\n"}
{"completion":"","prompt":"Elixir.Code.can_await_module_compilation?(): Returns true if the current process can await for module compilation.\n\nWhen compiling Elixir code via `Kernel.ParallelCompiler`, which is\nused by Mix and `elixirc`, calling a module that has not yet been\ncompiled will block the caller until the module becomes available.\nExecuting Elixir scripts, such as passing a filename to `elixir`,\ndoes not await.\n"}
{"completion":"","prompt":"Elixir.Code.compile_file(file, relative_to \\\\ nil): Compiles the given file.\n\nAccepts `relative_to` as an argument to tell where the file is located.\n\nReturns a list of tuples where the first element is the module name and\nthe second one is its bytecode (as a binary). Opposite to `require_file/2`,\nit does not track the filename of the compiled file.\n\nIf you would like to get the result of evaluating file rather than the\nmodules defined in it, see `eval_file/2`.\n\nFor compiling many files concurrently, see `Kernel.ParallelCompiler.compile/2`.\n"}
{"completion":"","prompt":"Elixir.Code.compile_quoted(quoted, file \\\\ \"nofile\"): Compiles the quoted expression.\n\nReturns a list of tuples where the first element is the module name and\nthe second one is its bytecode (as a binary). A `file` can be\ngiven as second argument which will be used for reporting warnings\nand errors.\n"}
{"completion":"","prompt":"Elixir.Code.compile_string(string, file \\\\ \"nofile\"): Compiles the given string.\n\nReturns a list of tuples where the first element is the module name\nand the second one is its bytecode (as a binary). A `file` can be\ngiven as second argument which will be used for reporting warnings\nand errors.\n\n**Warning**: `string` can be any Elixir code and code can be executed with\nthe same privileges as the Erlang VM: this means that such code could\ncompromise the machine (for example by executing system commands).\nDon't use `compile_string/2` with untrusted input (such as strings coming\nfrom the network).\n"}
{"completion":"","prompt":"Elixir.Code.compiler_options(): Gets all compilation options from the code server.\n\nTo get individual options, see `get_compiler_option/1`.\nFor a description of all options, see `put_compiler_option/2`.\n\n## Examples\n\n    Code.compiler_options()\n    #=> %{debug_info: true, docs: true, ...}\n\n"}
{"completion":"","prompt":"Elixir.Code.compiler_options(opts): Stores all given compilation options.\n\nChanging the compilation options affect all processes\nrunning in a given Erlang VM node. To store individual\noptions and for a description of all options, see\n`put_compiler_option/2`.\n\n## Examples\n\n    Code.compiler_options()\n    #=> %{debug_info: true, docs: true, ...}\n\n"}
{"completion":"","prompt":"Elixir.Code.delete_path(path): Deletes a path from the Erlang VM code path list.\n\nThis is the list of directories the Erlang VM uses for finding\nmodule code. The list of files is managed per Erlang VM node.\n\nThe path is expanded with `Path.expand/1` before being deleted. If the\npath does not exist, this function returns `false`.\n\n## Examples\n\n    Code.prepend_path(\".\")\n    Code.delete_path(\".\")\n    #=> true\n\n    Code.delete_path(\"/does_not_exist\")\n    #=> false\n\n"}
{"completion":"","prompt":"Elixir.Code.ensure_compiled(module): Similar to `ensure_compiled!/1` but indicates you can continue without said module.\n\nWhile `ensure_compiled!/1` indicates to the Elixir compiler you can\nonly continue when said module is available, this function indicates\nyou may continue compilation without said module.\n\nIf it succeeds in loading the module, it returns `{:module, module}`.\nIf not, returns `{:error, reason}` with the error reason.\nIf the module being checked is currently in a compiler deadlock,\nthis function returns `{:error, :unavailable}`. Unavailable doesn't\nnecessarily mean the module doesn't exist, just that it is not currently\navailable, but it (or may not) become available in the future.\n\nTherefore, if you can only continue if the module is available, use\n`ensure_compiled!/1` instead. In particular, do not do this:\n\n    case Code.ensure_compiled(module) do\n      {:module, _} -> module\n      {:error, _} -> raise ...\n    end\n\nSee the module documentation for more information on code loading.\n"}
{"completion":"","prompt":"Elixir.Code.ensure_compiled!(module): Ensures the given module is compiled and loaded.\n\nIf the module is already loaded, it works as no-op. If the module was\nnot compiled yet, `ensure_compiled!/1` halts the compilation of the caller\nuntil the module given to `ensure_compiled!/1` becomes available or\nall files for the current project have been compiled. If compilation\nfinishes and the module is not available or is in a deadlock, an error\nis raised.\n\nGiven this function halts compilation, use it carefully. In particular,\navoid using it to guess which modules are in the system. Overuse of this\nfunction can also lead to deadlocks, where two modules check at the same time\nif the other is compiled. This returns a specific unavailable error code,\nwhere we cannot successfully verify a module is available or not.\n\nSee the module documentation for more information on code loading.\n"}
{"completion":"","prompt":"Elixir.Code.ensure_loaded(module): Ensures the given module is loaded.\n\nIf the module is already loaded, this works as no-op. If the module\nwas not yet loaded, it tries to load it.\n\nIf it succeeds in loading the module, it returns `{:module, module}`.\nIf not, returns `{:error, reason}` with the error reason.\n\nSee the module documentation for more information on code loading.\n\n## Examples\n\n    iex> Code.ensure_loaded(Atom)\n    {:module, Atom}\n\n    iex> Code.ensure_loaded(DoesNotExist)\n    {:error, :nofile}\n\n"}
{"completion":"","prompt":"Elixir.Code.ensure_loaded!(module): Same as `ensure_loaded/1` but raises if the module cannot be loaded.\n"}
{"completion":"","prompt":"Elixir.Code.ensure_loaded?(module): Ensures the given module is loaded.\n\nSimilar to `ensure_loaded/1`, but returns `true` if the module\nis already loaded or was successfully loaded. Returns `false`\notherwise.\n\n## Examples\n\n    iex> Code.ensure_loaded?(Atom)\n    true\n\n"}
{"completion":"","prompt":"Elixir.Code.env_for_eval(env_or_opts): Returns an environment for evaluation.\n\nIt accepts either a `Macro.Env`, that is then pruned and prepared,\nor a list of options. It returns an environment that is ready for\nevaluation.\n\nMost functions in this module will automatically prepare the given\nenvironment for evaluation, so you don't need to explicitly call\nthis function, with the exception of `eval_quoted_with_env/3`,\nwhich was designed precisely to be called in a loop, to implement\nfeatures such as interactive shells or anything else with multiple\nevaluations.\n\n## Options\n\nIf an env is not given, the options can be:\n\n  * `:file` - the file to be considered in the evaluation\n\n  * `:line` - the line on which the script starts\n"}
{"completion":"","prompt":"Elixir.Code.eval_file(file, relative_to \\\\ nil): Evaluates the given file.\n\nAccepts `relative_to` as an argument to tell where the file is located.\n\nWhile `require_file/2` and `compile_file/2` return the loaded modules and their\nbytecode, `eval_file/2` simply evaluates the file contents and returns the\nevaluation result and its binding (exactly the same return value as `eval_string/3`).\n"}
{"completion":"","prompt":"Elixir.Code.eval_quoted(quoted, binding \\\\ [], env_or_opts \\\\ []): Evaluates the quoted contents.\n\n**Warning**: Calling this function inside a macro is considered bad\npractice as it will attempt to evaluate runtime values at compile time.\nMacro arguments are typically transformed by unquoting them into the\nreturned quoted expressions (instead of evaluated).\n\nSee `eval_string/3` for a description of `binding` and `opts`.\n\n## Examples\n\n    iex> contents = quote(do: var!(a) + var!(b))\n    iex> {result, binding} = Code.eval_quoted(contents, [a: 1, b: 2], file: __ENV__.file, line: __ENV__.line)\n    iex> result\n    3\n    iex> Enum.sort(binding)\n    [a: 1, b: 2]\n\nFor convenience, you can pass `__ENV__/0` as the `opts` argument and\nall options will be automatically extracted from the current environment:\n\n    iex> contents = quote(do: var!(a) + var!(b))\n    iex> {result, binding} = Code.eval_quoted(contents, [a: 1, b: 2], __ENV__)\n    iex> result\n    3\n    iex> Enum.sort(binding)\n    [a: 1, b: 2]\n\n"}
{"completion":"","prompt":"Elixir.Code.eval_quoted_with_env(quoted, binding, env, opts \\\\ []): Evaluates the given `quoted` contents with `binding` and `env`.\n\nThis function is meant to be called in a loop, to implement features\nsuch as interactive shells or anything else with multiple evaluations.\nTherefore, the first time you call this function, you must compute\nthe initial environment with `env_for_eval/1`. The remaining calls\nmust pass the environment that was returned by this function.\n\n## Options\n\n  * `:prune_binding` - (since v1.14.2) prune binding to keep only\n    variables read or written by the evaluated code. Note that\n    variables used by modules are always pruned, even if later used\n    by the modules. You can submit to the `:on_module` tracer event\n    and access the variables used by the module from its environment.\n\n"}
{"completion":"","prompt":"Elixir.Code.eval_string(string, binding \\\\ [], opts \\\\ []): Evaluates the contents given by `string`.\n\nThe `binding` argument is a list of all variables and their values.\nThe `opts` argument is a keyword list of environment options.\n\n**Warning**: `string` can be any Elixir code and will be executed with\nthe same privileges as the Erlang VM: this means that such code could\ncompromise the machine (for example by executing system commands).\nDon't use `eval_string/3` with untrusted input (such as strings coming\nfrom the network).\n\n## Options\n\nOptions can be:\n\n  * `:file` - the file to be considered in the evaluation\n\n  * `:line` - the line on which the script starts\n\nAdditionally, you may also pass an environment as second argument,\nso the evaluation happens within that environment.\n\nReturns a tuple of the form `{value, binding}`, where `value` is the value\nreturned from evaluating `string`. If an error occurs while evaluating\n`string`, an exception will be raised.\n\n`binding` is a list with all variable names and their values after evaluating\n`string`. The binding keys are usually atoms, but they may be a tuple for variables\ndefined in a different context. The names are in no particular order.\n\n## Examples\n\n    iex> {result, binding} = Code.eval_string(\"a + b\", [a: 1, b: 2], file: __ENV__.file, line: __ENV__.line)\n    iex> result\n    3\n    iex> Enum.sort(binding)\n    [a: 1, b: 2]\n\n    iex> {result, binding} = Code.eval_string(\"c = a + b\", [a: 1, b: 2], __ENV__)\n    iex> result\n    3\n    iex> Enum.sort(binding)\n    [a: 1, b: 2, c: 3]\n\n    iex> {result, binding} = Code.eval_string(\"a = a + b\", [a: 1, b: 2])\n    iex> result\n    3\n    iex> Enum.sort(binding)\n    [a: 3, b: 2]\n\nFor convenience, you can pass `__ENV__/0` as the `opts` argument and\nall imports, requires and aliases defined in the current environment\nwill be automatically carried over:\n\n    iex> {result, binding} = Code.eval_string(\"a + b\", [a: 1, b: 2], __ENV__)\n    iex> result\n    3\n    iex> Enum.sort(binding)\n    [a: 1, b: 2]\n\n"}
{"completion":"","prompt":"Elixir.Code.fetch_docs(module_or_path): Returns the docs for the given module or path to `.beam` file.\n\nWhen given a module name, it finds its BEAM code and reads the docs from it.\n\nWhen given a path to a `.beam` file, it will load the docs directly from that\nfile.\n\nIt returns the term stored in the documentation chunk in the format defined by\n[EEP 48](https://www.erlang.org/eeps/eep-0048.html) or `{:error, reason}` if\nthe chunk is not available.\n\n## Examples\n\n    # Module documentation of an existing module\n    iex> {:docs_v1, _, :elixir, _, %{\"en\" => module_doc}, _, _} = Code.fetch_docs(Atom)\n    iex> module_doc |> String.split(\"\\n\") |> Enum.at(0)\n    \"Atoms are constants whose values are their own name.\"\n\n    # A module that doesn't exist\n    iex> Code.fetch_docs(ModuleNotGood)\n    {:error, :module_not_found}\n\n"}
{"completion":"","prompt":"Elixir.Code.format_file!(file, opts \\\\ []): Formats a file.\n\nSee `format_string!/2` for more information on code formatting and\navailable options.\n"}
{"completion":"","prompt":"Elixir.Code.format_string!(string, opts \\\\ []): Formats the given code `string`.\n\nThe formatter receives a string representing Elixir code and\nreturns iodata representing the formatted code according to\npre-defined rules.\n\n## Options\n\n  * `:file` - the file which contains the string, used for error\n    reporting\n\n  * `:line` - the line the string starts, used for error reporting\n\n  * `:line_length` - the line length to aim for when formatting\n    the document. Defaults to 98. Note this value is used as\n    guideline but there are situations where it is not enforced.\n    See the \"Line length\" section below for more information\n\n  * `:locals_without_parens` - a keyword list of name and arity\n    pairs that should be kept without parens whenever possible.\n    The arity may be the atom `:*`, which implies all arities of\n    that name. The formatter already includes a list of functions\n    and this option augments this list.\n\n  * `:force_do_end_blocks` (since v1.9.0) - when `true`, converts all\n    inline usages of `do: ...`,  `else: ...` and friends into `do`-`end`\n    blocks. Defaults to `false`. Note that this option is convergent:\n    once you set it to `true`, **all keywords** will be converted.\n    If you set it to `false` later on, `do`-`end` blocks won't be\n    converted back to keywords.\n\n  * `:normalize_bitstring_modifiers` (since v1.14.0) - when `true`,\n    removes unnecessary parentheses in known bitstring\n    [modifiers](`<<>>/1`), for example `<<foo::binary()>>`\n    becomes `<<foo::binary>>`, or adds parentheses for custom\n    modifiers, where `<<foo::custom_type>>` becomes `<<foo::custom_type()>>`.\n    Defaults to `true`. This option changes the AST.\n\n## Design principles\n\nThe formatter was designed under three principles.\n\nFirst, the formatter never changes the semantics of the code.\nThis means the input AST and the output AST are almost always equivalent.\nThe only cases where the formatter will change the AST is when the input AST\nwould cause *compiler warnings* and the output AST won't. The cases where\nthe formatter changes the AST can be disabled through formatting options\nif desired.\n\nThe second principle is to provide as little configuration as possible.\nThis eases the formatter adoption by removing contention points while\nmaking sure a single style is followed consistently by the community as\na whole.\n\nThe formatter does not hard code names. The formatter will not behave\nspecially because a function is named `defmodule`, `def`, or the like. This\nprinciple mirrors Elixir's goal of being an extensible language where\ndevelopers can extend the language with new constructs as if they were\npart of the language. When it is absolutely necessary to change behaviour\nbased on the name, this behaviour should be configurable, such as the\n`:locals_without_parens` option.\n\n## Running the formatter\n\nThe formatter attempts to fit the most it can on a single line and\nintroduces line breaks wherever possible when it cannot.\n\nIn some cases, this may lead to undesired formatting. Therefore, **some\ncode generated by the formatter may not be aesthetically pleasing and\nmay require explicit intervention from the developer**. That's why we\ndo not recommend to run the formatter blindly in an existing codebase.\nInstead you should format and sanity check each formatted file.\n\nFor example, the formatter may break a long function definition over\nmultiple clauses:\n\n    def my_function(\n      %User{name: name, age: age, ...},\n      arg1,\n      arg2\n    ) do\n      ...\n    end\n\nWhile the code above is completely valid, you may prefer to match on\nthe struct variables inside the function body in order to keep the\ndefinition on a single line:\n\n    def my_function(%User{} = user, arg1, arg2) do\n      %{name: name, age: age, ...} = user\n      ...\n    end\n\nIn some situations, you can use the fact the formatter does not generate\nelegant code as a hint for refactoring. Take this code:\n\n    def board?(board_id, %User{} = user, available_permissions, required_permissions) do\n      Tracker.OrganizationMembers.user_in_organization?(user.id, board.organization_id) and\n        required_permissions == Enum.to_list(MapSet.intersection(MapSet.new(required_permissions), MapSet.new(available_permissions)))\n    end\n\nThe code above has very long lines and running the formatter is not going\nto address this issue. In fact, the formatter may make it more obvious that\nyou have complex expressions:\n\n    def board?(board_id, %User{} = user, available_permissions, required_permissions) do\n      Tracker.OrganizationMembers.user_in_organization?(user.id, board.organization_id) and\n        required_permissions ==\n          Enum.to_list(\n            MapSet.intersection(\n              MapSet.new(required_permissions),\n              MapSet.new(available_permissions)\n            )\n          )\n    end\n\nTake such cases as a suggestion that your code should be refactored:\n\n    def board?(board_id, %User{} = user, available_permissions, required_permissions) do\n      Tracker.OrganizationMembers.user_in_organization?(user.id, board.organization_id) and\n        matching_permissions?(required_permissions, available_permissions)\n    end\n\n    defp matching_permissions?(required_permissions, available_permissions) do\n      intersection =\n        required_permissions\n        |> MapSet.new()\n        |> MapSet.intersection(MapSet.new(available_permissions))\n        |> Enum.to_list()\n\n      required_permissions == intersection\n    end\n\nTo sum it up: since the formatter cannot change the semantics of your\ncode, sometimes it is necessary to tweak or refactor the code to get\noptimal formatting. To help better understand how to control the formatter,\nwe describe in the next sections the cases where the formatter keeps the\nuser encoding and how to control multiline expressions.\n\n## Line length\n\nAnother point about the formatter is that the `:line_length` configuration\nis a guideline. In many cases, it is not possible for the formatter to break\nyour code apart, which means it will go over the line length. For example,\nif you have a long string:\n\n    \"this is a very long string that will go over the line length\"\n\nThe formatter doesn't know how to break it apart without changing the\ncode underlying syntax representation, so it is up to you to step in:\n\n    \"this is a very long string \" <>\n       \"that will go over the line length\"\n\nThe string concatenation makes the code fit on a single line and also\ngives more options to the formatter.\n\nThis may also appear in do/end blocks, where the `do` keyword (or `->`)\nmay go over the line length because there is no opportunity for the\nformatter to introduce a line break in a readable way. For example,\nif you do:\n\n    case very_long_expression() do\n    end\n\nAnd only the `do` keyword is above the line length, Elixir **will not**\nemit this:\n\n    case very_long_expression()\n    do\n    end\n\nSo it prefers to not touch the line at all and leave `do` above the\nline limit.\n\n## Keeping user's formatting\n\nThe formatter respects the input format in some cases. Those are\nlisted below:\n\n  * Insignificant digits in numbers are kept as is. The formatter\n    however always inserts underscores for decimal numbers with more\n    than 5 digits and converts hexadecimal digits to uppercase\n\n  * Strings, charlists, atoms and sigils are kept as is. No character\n    is automatically escaped or unescaped. The choice of delimiter is\n    also respected from the input\n\n  * Newlines inside blocks are kept as in the input except for:\n    1) expressions that take multiple lines will always have an empty\n    line before and after and 2) empty lines are always squeezed\n    together into a single empty line\n\n  * The choice between `:do` keyword and `do`-`end` blocks is left\n    to the user\n\n  * Lists, tuples, bitstrings, maps, structs and function calls will be\n    broken into multiple lines if they are followed by a newline in the\n    opening bracket and preceded by a new line in the closing bracket\n\n  * Newlines before certain operators (such as the pipeline operators)\n    and before other operators (such as comparison operators)\n\nThe behaviours above are not guaranteed. We may remove or add new\nrules in the future. The goal of documenting them is to provide better\nunderstanding on what to expect from the formatter.\n\n### Multi-line lists, maps, tuples, and the like\n\nYou can force lists, tuples, bitstrings, maps, structs and function\ncalls to have one entry per line by adding a newline after the opening\nbracket and a new line before the closing bracket lines. For example:\n\n    [\n      foo,\n      bar\n    ]\n\nIf there are no newlines around the brackets, then the formatter will\ntry to fit everything on a single line, such that the snippet below\n\n    [foo,\n     bar]\n\nwill be formatted as\n\n    [foo, bar]\n\nYou can also force function calls and keywords to be rendered on multiple\nlines by having each entry on its own line:\n\n    defstruct name: nil,\n              age: 0\n\nThe code above will be kept with one keyword entry per line by the\nformatter. To avoid that, just squash everything into a single line.\n\n### Parens and no parens in function calls\n\nElixir has two syntaxes for function calls. With parens and no parens.\nBy default, Elixir will add parens to all calls except for:\n\n  1. calls that have `do`-`end` blocks\n  2. local calls without parens where the name and arity of the local\n     call is also listed under `:locals_without_parens` (except for\n     calls with arity 0, where the compiler always require parens)\n\nThe choice of parens and no parens also affects indentation. When a\nfunction call with parens doesn't fit on the same line, the formatter\nintroduces a newline around parens and indents the arguments with two\nspaces:\n\n    some_call(\n      arg1,\n      arg2,\n      arg3\n    )\n\nOn the other hand, function calls without parens are always indented\nby the function call length itself, like this:\n\n    some_call arg1,\n              arg2,\n              arg3\n\nIf the last argument is a data structure, such as maps and lists, and\nthe beginning of the data structure fits on the same line as the function\ncall, then no indentation happens, this allows code like this:\n\n    Enum.reduce(some_collection, initial_value, fn element, acc ->\n      # code\n    end)\n\n    some_function_without_parens %{\n      foo: :bar,\n      baz: :bat\n    }\n\n## Code comments\n\nThe formatter also handles code comments in a way to guarantee a space\nis always added between the beginning of the comment (#) and the next\ncharacter.\n\nThe formatter also extracts all trailing comments to their previous line.\nFor example, the code below\n\n    hello #world\n\nwill be rewritten to\n\n    # world\n    hello\n\nBecause code comments are handled apart from the code representation (AST),\nthere are some situations where code comments are seen as ambiguous by the\ncode formatter. For example, the comment in the anonymous function below\n\n    fn\n      arg1 ->\n        body1\n        # comment\n\n      arg2 ->\n        body2\n    end\n\nand in this one\n\n    fn\n      arg1 ->\n        body1\n\n      # comment\n      arg2 ->\n        body2\n    end\n\nare considered equivalent (the nesting is discarded alongside most of\nuser formatting). In such cases, the code formatter will always format to\nthe latter.\n\n## Newlines\n\nThe formatter converts all newlines in code from `\\r\\n` to `\\n`.\n"}
{"completion":"","prompt":"Elixir.Code.get_compiler_option(key): Returns the value of a given compiler option.\n\nFor a description of all options, see `put_compiler_option/2`.\n\n## Examples\n\n    Code.get_compiler_option(:debug_info)\n    #=> true\n\n"}
{"completion":"","prompt":"Elixir.Code.prepend_path(path): Prepends a path to the beginning of the Erlang VM code path list.\n\nThis is the list of directories the Erlang VM uses for finding\nmodule code. The list of files is managed per Erlang VM node.\n\nThe path is expanded with `Path.expand/1` before being prepended.\nIf this path does not exist, an error is returned.\n\n## Examples\n\n    Code.prepend_path(\".\")\n    #=> true\n\n    Code.prepend_path(\"/does_not_exist\")\n    #=> {:error, :bad_directory}\n\n"}
{"completion":"","prompt":"Elixir.Code.purge_compiler_modules(): Purge compiler modules.\n\nThe compiler utilizes temporary modules to compile code. For example,\n`elixir_compiler_1`, `elixir_compiler_2`, and so on. In case the compiled code\nstores references to anonymous functions or similar, the Elixir compiler\nmay be unable to reclaim those modules, keeping an unnecessary amount of\ncode in memory and eventually leading to modules such as `elixir_compiler_12345`.\n\nThis function purges all modules currently kept by the compiler, allowing\nold compiler module names to be reused. If there are any processes running\nany code from such modules, they will be terminated too.\n\nThis function is only meant to be called if you have a long running node\nthat is constantly evaluating code.\n\nIt returns `{:ok, number_of_modules_purged}`.\n"}
{"completion":"","prompt":"Elixir.Code.put_compiler_option(key, value): Stores a compilation option.\n\nChanging the compilation options affect all processes running in a\ngiven Erlang VM node.\n\nAvailable options are:\n\n  * `:docs` - when `true`, retains documentation in the compiled module.\n    Defaults to `true`.\n\n  * `:debug_info` - when `true`, retains debug information in the compiled\n    module. This enables static analysis tools as it allows developers to\n    partially reconstruct the original source code. Therefore, disabling\n    `:debug_info` is not recommended as it removes the ability of the\n    Elixir compiler and other tools to provide feedback. If you want to\n    remove the `:debug_info` while deploying, tools like `mix release`\n    already do such by default.\n\n  * `:ignore_already_consolidated` - when `true`, does not warn when a protocol\n    has already been consolidated and a new implementation is added. Defaults\n    to `false`.\n\n  * `:ignore_module_conflict` - when `true`, does not warn when a module has\n    already been defined. Defaults to `false`.\n\n  * `:relative_paths` - when `true`, uses relative paths in quoted nodes,\n    warnings, and errors generated by the compiler. Note disabling this option\n    won't affect runtime warnings and errors. Defaults to `true`.\n\n  * `:warnings_as_errors` - causes compilation to fail when warnings are\n    generated. Defaults to `false`.\n\n  * `:no_warn_undefined` (since v1.10.0) - list of modules and `{Mod, fun, arity}`\n    tuples that will not emit warnings that the module or function does not exist\n    at compilation time. Pass atom `:all` to skip warning for all undefined\n    functions. This can be useful when doing dynamic compilation. Defaults to `[]`.\n\n  * `:tracers` (since v1.10.0) - a list of tracers (modules) to be used during\n    compilation. See the module docs for more information. Defaults to `[]`.\n\n  * `:parser_options` (since v1.10.0) - a keyword list of options to be given\n    to the parser when compiling files. It accepts the same options as\n    `string_to_quoted/2` (except by the options that change the AST itself).\n    This can be used in combination with the tracer to retrieve localized\n    information about events happening during compilation. Defaults to `[]`.\n\nIt always returns `:ok`. Raises an error for invalid options.\n\n## Examples\n\n    Code.put_compiler_option(:debug_info, true)\n    #=> :ok\n\n"}
{"completion":"","prompt":"Elixir.Code.quoted_to_algebra(quoted, opts \\\\ []): Converts a quoted expression to an algebra document using Elixir's formatter rules.\n\nThe algebra document can be converted into a string by calling:\n\n    doc\n    |> Inspect.Algebra.format(:infinity)\n    |> IO.iodata_to_binary()\n\nFor a high-level function that does the same, see `Macro.to_string/1`.\n\n## Formatting considerations\n\nThe Elixir AST does not contain metadata for literals like strings, lists, or\ntuples with two elements, which means that the produced algebra document will\nnot respect all of the user preferences and comments may be misplaced.\nTo get better results, you can use the `:token_metadata`, `:unescape` and\n`:literal_encoder` options to `string_to_quoted/2` to provide additional\ninformation to the formatter:\n\n    [\n      literal_encoder: &{:ok, {:__block__, &2, [&1]}},\n      token_metadata: true,\n      unescape: false\n    ]\n\nThis will produce an AST that contains information such as `do` blocks start\nand end lines or sigil delimiters, and by wrapping literals in blocks they can\nnow hold metadata like line number, string delimiter and escaped sequences, or\ninteger formatting (such as `0x2a` instead of `47`). However, **note this AST is\nnot valid**. If you evaluate it, it won't have the same semantics as the regular\nElixir AST due to the `:unescape` and `:literal_encoder` options. However,\nthose options are useful if you're doing source code manipulation, where it's\nimportant to preserve user choices and comments placing.\n\n## Options\n\n  * `:comments` - the list of comments associated with the quoted expression.\n    Defaults to `[]`. It is recommended that both `:token_metadata` and\n    `:literal_encoder` options are given to `string_to_quoted_with_comments/2`\n    in order to get proper placement for comments\n\n  * `:escape` - when `true`, escaped sequences like `\\n` will be escaped into\n    `\\\\n`. If the `:unescape` option was set to `false` when using\n    `string_to_quoted/2`, setting this option to `false` will prevent it from\n    escaping the sequences twice. Defaults to `true`.\n\n  * `:locals_without_parens` - a keyword list of name and arity\n    pairs that should be kept without parens whenever possible.\n    The arity may be the atom `:*`, which implies all arities of\n    that name. The formatter already includes a list of functions\n    and this option augments this list.\n"}
{"completion":"","prompt":"Elixir.Code.require_file(file, relative_to \\\\ nil): Requires the given `file`.\n\nAccepts `relative_to` as an argument to tell where the file is located.\nIf the file was already required, `require_file/2` doesn't do anything and\nreturns `nil`.\n\nNote that if `require_file/2` is invoked by different processes concurrently,\nthe first process to invoke `require_file/2` acquires a lock and the remaining\nones will block until the file is available. This means that if `require_file/2`\nis called more than once with a given file, that file will be compiled only once.\nThe first process to call `require_file/2` will get the list of loaded modules,\nothers will get `nil`. The list of required files is managed per Erlang VM node.\n\nSee `compile_file/2` if you would like to compile a file without tracking its\nfilenames. Finally, if you would like to get the result of evaluating a file rather\nthan the modules defined in it, see `eval_file/2`.\n\n## Examples\n\nIf the file has not been required, it returns the list of modules:\n\n    modules = Code.require_file(\"eex_test.exs\", \"../eex/test\")\n    List.first(modules)\n    #=> {EExTest.Compiled, <<70, 79, 82, 49, ...>>}\n\nIf the file has been required, it returns `nil`:\n\n    Code.require_file(\"eex_test.exs\", \"../eex/test\")\n    #=> nil\n\n"}
{"completion":"","prompt":"Elixir.Code.required_files(): Lists all required files.\n\n## Examples\n\n    Code.require_file(\"../eex/test/eex_test.exs\")\n    List.first(Code.required_files()) =~ \"eex_test.exs\"\n    #=> true\n\n"}
{"completion":"","prompt":"Elixir.Code.string_to_quoted(string, opts \\\\ []): Converts the given string to its quoted form.\n\nReturns `{:ok, quoted_form}` if it succeeds,\n`{:error, {meta, message_info, token}}` otherwise.\n\n## Options\n\n  * `:file` - the filename to be reported in case of parsing errors.\n    Defaults to `\"nofile\"`.\n\n  * `:line` - the starting line of the string being parsed.\n    Defaults to 1.\n\n  * `:column` - (since v1.11.0) the starting column of the string being parsed.\n    Defaults to 1.\n\n  * `:columns` - when `true`, attach a `:column` key to the quoted\n    metadata. Defaults to `false`.\n\n  * `:unescape` (since v1.10.0) - when `false`, preserves escaped sequences.\n    For example, `\"null byte\\\\t\\\\x00\"` will be kept as is instead of being\n    converted to a bitstring literal. Note if you set this option to false, the\n    resulting AST is no longer valid, but it can be useful to analyze/transform\n    source code, typically in in combination with `quoted_to_algebra/2`.\n    Defaults to `true`.\n\n  * `:existing_atoms_only` - when `true`, raises an error\n    when non-existing atoms are found by the tokenizer.\n    Defaults to `false`.\n\n  * `:token_metadata` (since v1.10.0) - when `true`, includes token-related\n    metadata in the expression AST, such as metadata for `do` and `end`\n    tokens, for closing tokens, end of expressions, as well as delimiters\n    for sigils. See `t:Macro.metadata/0`. Defaults to `false`.\n\n  * `:literal_encoder` (since v1.10.0) - how to encode literals in the AST.\n    It must be a function that receives two arguments, the literal and its\n    metadata, and it must return `{:ok, ast :: Macro.t}` or\n    `{:error, reason :: binary}`. If you return anything than the literal\n    itself as the `term`, then the AST is no longer valid. This option\n    may still useful for textual analysis of the source code.\n\n  * `:static_atoms_encoder` - the static atom encoder function, see\n    \"The `:static_atoms_encoder` function\" section below. Note this\n    option overrides the `:existing_atoms_only` behaviour for static\n    atoms but `:existing_atoms_only` is still used for dynamic atoms,\n    such as atoms with interpolations.\n\n  * `:warn_on_unnecessary_quotes` - when `false`, does not warn\n    when atoms, keywords or calls have unnecessary quotes on\n    them. Defaults to `true`.\n\n## `Macro.to_string/2`\n\nThe opposite of converting a string to its quoted form is\n`Macro.to_string/2`, which converts a quoted form to a string/binary\nrepresentation.\n\n## The `:static_atoms_encoder` function\n\nWhen `static_atoms_encoder: &my_encoder/2` is passed as an argument,\n`my_encoder/2` is called every time the tokenizer needs to create a\n\"static\" atom. Static atoms are atoms in the AST that function as\naliases, remote calls, local calls, variable names, regular atoms\nand keyword lists.\n\nThe encoder function will receive the atom name (as a binary) and a\nkeyword list with the current file, line and column. It must return\n`{:ok, token :: term} | {:error, reason :: binary}`.\n\nThe encoder function is supposed to create an atom from the given\nstring. To produce a valid AST, it is required to return `{:ok, term}`,\nwhere `term` is an atom. It is possible to return something other than an atom,\nhowever, in that case the AST is no longer \"valid\" in that it cannot\nbe used to compile or evaluate Elixir code. A use case for this is\nif you want to use the Elixir parser in a user-facing situation, but\nyou don't want to exhaust the atom table.\n\nThe atom encoder is not called for *all* atoms that are present in\nthe AST. It won't be invoked for the following atoms:\n\n  * operators (`:+`, `:-`, and so on)\n\n  * syntax keywords (`fn`, `do`, `else`, and so on)\n\n  * atoms containing interpolation (`:\"#{1 + 1} is two\"`), as these\n    atoms are constructed at runtime.\n\n"}
{"completion":"","prompt":"Elixir.Code.string_to_quoted!(string, opts \\\\ []): Converts the given string to its quoted form.\n\nIt returns the AST if it succeeds,\nraises an exception otherwise. The exception is a `TokenMissingError`\nin case a token is missing (usually because the expression is incomplete),\n`SyntaxError` otherwise.\n\nCheck `string_to_quoted/2` for options information.\n"}
{"completion":"","prompt":"Elixir.Code.string_to_quoted_with_comments(string, opts \\\\ []): Converts the given string to its quoted form and a list of comments.\n\nThis function is useful when performing textual changes to the source code,\nwhile preserving information like comments and literals position.\n\nReturns `{:ok, quoted_form, comments}` if it succeeds,\n`{:error, {line, error, token}}` otherwise.\n\nComments are maps with the following fields:\n\n  * `:line` - The line number the source code\n\n  * `:text` - The full text of the comment, including the leading `#`\n\n  * `:previous_eol_count` - How many end of lines there are between the comment and the previous AST node or comment\n\n  * `:next_eol_count` - How many end of lines there are between the comment and the next AST node or comment\n\nCheck `string_to_quoted/2` for options information.\n\n## Examples\n\n    iex> Code.string_to_quoted_with_comments(\"\"\"\n    ...> :foo\n    ...>\n    ...> # Hello, world!\n    ...>\n    ...>\n    ...> # Some more comments!\n    ...> \"\"\")\n    {:ok, :foo, [\n      %{line: 3, column: 1, previous_eol_count: 2, next_eol_count: 3, text: \"# Hello, world!\"},\n      %{line: 6, column: 1, previous_eol_count: 3, next_eol_count: 1, text: \"# Some more comments!\"},\n    ]}\n\n    iex> Code.string_to_quoted_with_comments(\":foo # :bar\")\n    {:ok, :foo, [\n      %{line: 1, column: 6, previous_eol_count: 0, next_eol_count: 0, text: \"# :bar\"}\n    ]}\n\n"}
{"completion":"","prompt":"Elixir.Code.string_to_quoted_with_comments!(string, opts \\\\ []): Converts the given string to its quoted form and a list of comments.\n\nReturns the AST and a list of comments if it succeeds, raises an exception\notherwise. The exception is a `TokenMissingError` in case a token is missing\n(usually because the expression is incomplete), `SyntaxError` otherwise.\n\nCheck `string_to_quoted/2` for options information.\n"}
{"completion":"","prompt":"Elixir.Code.unrequire_files(files): Removes files from the required files list.\n\nThe modules defined in the file are not removed;\ncalling this function only removes them from the list,\nallowing them to be required again.\n\nThe list of files is managed per Erlang VM node.\n\n## Examples\n\n    # Require EEx test code\n    Code.require_file(\"../eex/test/eex_test.exs\")\n\n    # Now unrequire all files\n    Code.unrequire_files(Code.required_files())\n\n    # Note that modules are still available\n    function_exported?(EExTest.Compiled, :before_compile, 0)\n    #=> true\n\n"}
{"completion":"","prompt":"Elixir.Collectable.into(collectable): Returns an initial accumulator and a \"collector\" function.\n\nReceives a `collectable` which can be used as the initial accumulator that will\nbe passed to the function.\n\nThe collector function receives a term and a command and injects the term into\nthe collectable accumulator on every `{:cont, term}` command.\n\n`:done` is passed as a command when no further values will be injected. This\nis useful when there's a need to close resources or normalizing values. A\ncollectable must be returned when the command is `:done`.\n\nIf injection is suddenly interrupted, `:halt` is passed and the function\ncan return any value as it won't be used.\n\nFor examples on how to use the `Collectable` protocol and `into/1` see the\nmodule documentation.\n"}
{"completion":"","prompt":"Elixir.Config.Provider.resolve_config_path!(path): Resolves a `t:config_path/0` to an actual path.\n"}
{"completion":"","prompt":"Elixir.Config.Provider.validate_config_path!(path): Validates a `t:config_path/0`.\n"}
{"completion":"","prompt":"Elixir.Config.Reader.eval!(file, contents, opts \\\\ []): Evaluates the configuration `contents` for the given `file`.\n\nAccepts the same options as `read!/2`.\n"}
{"completion":"","prompt":"Elixir.Config.Reader.merge(config1, config2): Merges two configurations.\n\nThe configurations are merged together with the values in\nthe second one having higher preference than the first in\ncase of conflicts. In case both values are set to keyword\nlists, it deep merges them.\n\n## Examples\n\n    iex> Config.Reader.merge([app: [k: :v1]], [app: [k: :v2]])\n    [app: [k: :v2]]\n\n    iex> Config.Reader.merge([app: [k: [v1: 1, v2: 2]]], [app: [k: [v2: :a, v3: :b]]])\n    [app: [k: [v1: 1, v2: :a, v3: :b]]]\n\n    iex> Config.Reader.merge([app1: []], [app2: []])\n    [app1: [], app2: []]\n\n"}
{"completion":"","prompt":"Elixir.Config.Reader.read!(file, opts \\\\ []): Reads the configuration file.\n\n## Options\n\n  * `:imports` - a list of already imported paths or `:disabled`\n    to disable imports\n\n  * `:env` - the environment the configuration file runs on.\n    See `Config.config_env/0` for sample usage\n\n  * `:target` - the target the configuration file runs on.\n    See `Config.config_target/0` for sample usage\n\n"}
{"completion":"","prompt":"Elixir.Config.Reader.read_imports!(file, opts \\\\ []): Reads the given configuration file and returns the configuration\nwith its imports.\n\nAccepts the same options as `read!/2`. Although note the `:imports`\noption cannot be disabled in `read_imports!/2`.\n"}
{"completion":"","prompt":"Elixir.Config.config(root_key, opts): Configures the given `root_key`.\n\nKeyword lists are always deep-merged.\n\n## Examples\n\nThe given `opts` are merged into the existing configuration\nfor the given `root_key`. Conflicting keys are overridden by the\nones specified in `opts`, unless they are keywords, which are\ndeep merged recursively. For example, the application configuration\nbelow\n\n    config :logger,\n      level: :warn,\n      backends: [:console]\n\n    config :logger,\n      level: :info,\n      truncate: 1024\n\nwill have a final configuration for `:logger` of:\n\n    [level: :info, backends: [:console], truncate: 1024]\n\n"}
{"completion":"","prompt":"Elixir.Config.config(root_key, key, opts): Configures the given `key` for the given `root_key`.\n\nKeyword lists are always deep merged.\n\n## Examples\n\nThe given `opts` are merged into the existing values for `key`\nin the given `root_key`. Conflicting keys are overridden by the\nones specified in `opts`, unless they are keywords, which are\ndeep merged recursively. For example, the application configuration\nbelow\n\n    config :ecto, Repo,\n      log_level: :warn,\n      adapter: Ecto.Adapters.Postgres,\n      metadata: [read_only: true]\n\n    config :ecto, Repo,\n      log_level: :info,\n      pool_size: 10,\n      metadata: [replica: true]\n\nwill have a final value of the configuration for the `Repo`\nkey in the `:ecto` application of:\n\n    Application.get_env(:ecto, Repo)\n    #=> [\n    #=>   log_level: :info,\n    #=>   pool_size: 10,\n    #=>   adapter: Ecto.Adapters.Postgres,\n    #=>   metadata: [read_only: true, replica: true]\n    #=> ]\n\n"}
{"completion":"","prompt":"Elixir.Date.add(date, days): Adds the number of days to the given `date`.\n\nThe days are counted as Gregorian days. The date is returned in the same\ncalendar as it was given in.\n\n## Examples\n\n    iex> Date.add(~D[2000-01-03], -2)\n    ~D[2000-01-01]\n    iex> Date.add(~D[2000-01-01], 2)\n    ~D[2000-01-03]\n    iex> Date.add(~N[2000-01-01 09:00:00], 2)\n    ~D[2000-01-03]\n    iex> Date.add(~D[-0010-01-01], -2)\n    ~D[-0011-12-30]\n\n"}
{"completion":"","prompt":"Elixir.Date.beginning_of_month(date): Calculates a date that is the first day of the month for the given `date`.\n\n## Examples\n\n    iex> Date.beginning_of_month(~D[2000-01-31])\n    ~D[2000-01-01]\n    iex> Date.beginning_of_month(~D[2000-01-01])\n    ~D[2000-01-01]\n    iex> Date.beginning_of_month(~N[2000-01-31 01:23:45])\n    ~D[2000-01-01]\n\n"}
{"completion":"","prompt":"Elixir.Date.beginning_of_week(date, starting_on \\\\ :default): Calculates a date that is the first day of the week for the given `date`.\n\nIf the day is already the first day of the week, it returns the\nday itself. For the built-in ISO calendar, the week starts on Monday.\nA weekday rather than `:default` can be given as `starting_on`.\n\n## Examples\n\n    iex> Date.beginning_of_week(~D[2020-07-11])\n    ~D[2020-07-06]\n    iex> Date.beginning_of_week(~D[2020-07-06])\n    ~D[2020-07-06]\n    iex> Date.beginning_of_week(~D[2020-07-11], :sunday)\n    ~D[2020-07-05]\n    iex> Date.beginning_of_week(~D[2020-07-11], :saturday)\n    ~D[2020-07-11]\n    iex> Date.beginning_of_week(~N[2020-07-11 01:23:45])\n    ~D[2020-07-06]\n\n"}
{"completion":"","prompt":"Elixir.Date.compare(date1, date2): Compares two date structs.\n\nReturns `:gt` if first date is later than the second\nand `:lt` for vice versa. If the two dates are equal\n`:eq` is returned.\n\n## Examples\n\n    iex> Date.compare(~D[2016-04-16], ~D[2016-04-28])\n    :lt\n\nThis function can also be used to compare across more\ncomplex calendar types by considering only the date fields:\n\n    iex> Date.compare(~D[2016-04-16], ~N[2016-04-28 01:23:45])\n    :lt\n    iex> Date.compare(~D[2016-04-16], ~N[2016-04-16 01:23:45])\n    :eq\n    iex> Date.compare(~N[2016-04-16 12:34:56], ~N[2016-04-16 01:23:45])\n    :eq\n\n"}
{"completion":"","prompt":"Elixir.Date.convert(date, calendar): Converts the given `date` from its calendar to the given `calendar`.\n\nReturns `{:ok, date}` if the calendars are compatible,\nor `{:error, :incompatible_calendars}` if they are not.\n\nSee also `Calendar.compatible_calendars?/2`.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> Date.convert(~D[2000-01-01], Calendar.Holocene)\n    {:ok, %Date{calendar: Calendar.Holocene, year: 12000, month: 1, day: 1}}\n\n"}
{"completion":"","prompt":"Elixir.Date.convert!(date, calendar): Similar to `Date.convert/2`, but raises an `ArgumentError`\nif the conversion between the two calendars is not possible.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> Date.convert!(~D[2000-01-01], Calendar.Holocene)\n    %Date{calendar: Calendar.Holocene, year: 12000, month: 1, day: 1}\n\n"}
{"completion":"","prompt":"Elixir.Date.day_of_era(date): Calculates the day-of-era and era for a given\ncalendar `date`.\n\nReturns a tuple `{day, era}` representing the\nday within the era and the era number.\n\n## Examples\n\n    iex> Date.day_of_era(~D[0001-01-01])\n    {1, 1}\n\n    iex> Date.day_of_era(~D[0000-12-31])\n    {1, 0}\n\n"}
{"completion":"","prompt":"Elixir.Date.day_of_week(date, starting_on \\\\ :default): Calculates the day of the week of a given `date`.\n\nReturns the day of the week as an integer. For the ISO 8601\ncalendar (the default), it is an integer from 1 to 7, where\n1 is Monday and 7 is Sunday.\n\nAn optional `starting_on` value may be supplied, which\nconfigures the weekday the week starts on. The default value\nfor it is `:default`, which translates to `:monday` for the\nbuilt-in ISO calendar. Any other weekday may be given to.\n\n## Examples\n\n    iex> Date.day_of_week(~D[2016-10-31])\n    1\n    iex> Date.day_of_week(~D[2016-11-01])\n    2\n    iex> Date.day_of_week(~N[2016-11-01 01:23:45])\n    2\n    iex> Date.day_of_week(~D[-0015-10-30])\n    3\n\n    iex> Date.day_of_week(~D[2016-10-31], :sunday)\n    2\n    iex> Date.day_of_week(~D[2016-11-01], :sunday)\n    3\n    iex> Date.day_of_week(~N[2016-11-01 01:23:45], :sunday)\n    3\n    iex> Date.day_of_week(~D[-0015-10-30], :sunday)\n    4\n\n"}
{"completion":"","prompt":"Elixir.Date.day_of_year(date): Calculates the day of the year of a given `date`.\n\nReturns the day of the year as an integer. For the ISO 8601\ncalendar (the default), it is an integer from 1 to 366.\n\n## Examples\n\n    iex> Date.day_of_year(~D[2016-01-01])\n    1\n    iex> Date.day_of_year(~D[2016-11-01])\n    306\n    iex> Date.day_of_year(~D[-0015-10-30])\n    303\n    iex> Date.day_of_year(~D[2004-12-31])\n    366\n\n"}
{"completion":"","prompt":"Elixir.Date.days_in_month(date): Returns the number of days in the given `date` month.\n\n## Examples\n\n    iex> Date.days_in_month(~D[1900-01-13])\n    31\n    iex> Date.days_in_month(~D[1900-02-09])\n    28\n    iex> Date.days_in_month(~N[2000-02-20 01:23:45])\n    29\n\n"}
{"completion":"","prompt":"Elixir.Date.diff(date1, date2): Calculates the difference between two dates, in a full number of days.\n\nIt returns the number of Gregorian days between the dates. Only `Date`\nstructs that follow the same or compatible calendars can be compared\nthis way. If two calendars are not compatible, it will raise.\n\n## Examples\n\n    iex> Date.diff(~D[2000-01-03], ~D[2000-01-01])\n    2\n    iex> Date.diff(~D[2000-01-01], ~D[2000-01-03])\n    -2\n    iex> Date.diff(~D[0000-01-02], ~D[-0001-12-30])\n    3\n    iex> Date.diff(~D[2000-01-01], ~N[2000-01-03 09:00:00])\n    -2\n\n"}
{"completion":"","prompt":"Elixir.Date.end_of_month(date): Calculates a date that is the last day of the month for the given `date`.\n\n## Examples\n\n    iex> Date.end_of_month(~D[2000-01-01])\n    ~D[2000-01-31]\n    iex> Date.end_of_month(~D[2000-01-31])\n    ~D[2000-01-31]\n    iex> Date.end_of_month(~N[2000-01-01 01:23:45])\n    ~D[2000-01-31]\n\n"}
{"completion":"","prompt":"Elixir.Date.end_of_week(date, starting_on \\\\ :default): Calculates a date that is the last day of the week for the given `date`.\n\nIf the day is already the last day of the week, it returns the\nday itself. For the built-in ISO calendar, the week ends on Sunday.\nA weekday rather than `:default` can be given as `starting_on`.\n\n## Examples\n\n    iex> Date.end_of_week(~D[2020-07-11])\n    ~D[2020-07-12]\n    iex> Date.end_of_week(~D[2020-07-05])\n    ~D[2020-07-05]\n    iex> Date.end_of_week(~D[2020-07-06], :sunday)\n    ~D[2020-07-11]\n    iex> Date.end_of_week(~D[2020-07-06], :saturday)\n    ~D[2020-07-10]\n    iex> Date.end_of_week(~N[2020-07-11 01:23:45])\n    ~D[2020-07-12]\n\n"}
{"completion":"","prompt":"Elixir.Date.from_erl(tuple, calendar \\\\ Calendar.ISO): Converts an Erlang date tuple to a `Date` struct.\n\nOnly supports converting dates which are in the ISO calendar,\nor other calendars in which the days also start at midnight.\nAttempting to convert dates from other calendars will return an error tuple.\n\n## Examples\n\n    iex> Date.from_erl({2000, 1, 1})\n    {:ok, ~D[2000-01-01]}\n    iex> Date.from_erl({2000, 13, 1})\n    {:error, :invalid_date}\n\n"}
{"completion":"","prompt":"Elixir.Date.from_erl!(tuple, calendar \\\\ Calendar.ISO): Converts an Erlang date tuple but raises for invalid dates.\n\n## Examples\n\n    iex> Date.from_erl!({2000, 1, 1})\n    ~D[2000-01-01]\n    iex> Date.from_erl!({2000, 13, 1})\n    ** (ArgumentError) cannot convert {2000, 13, 1} to date, reason: :invalid_date\n\n"}
{"completion":"","prompt":"Elixir.Date.from_gregorian_days(days, calendar \\\\ Calendar.ISO): Converts a number of gregorian days to a `Date` struct.\n\n## Examples\n\n    iex> Date.from_gregorian_days(1)\n    ~D[0000-01-02]\n    iex> Date.from_gregorian_days(730_485)\n    ~D[2000-01-01]\n    iex> Date.from_gregorian_days(-1)\n    ~D[-0001-12-31]\n\n"}
{"completion":"","prompt":"Elixir.Date.from_iso8601(string, calendar \\\\ Calendar.ISO): Parses the extended \"Dates\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nThe year parsed by this function is limited to four digits.\n\n## Examples\n\n    iex> Date.from_iso8601(\"2015-01-23\")\n    {:ok, ~D[2015-01-23]}\n\n    iex> Date.from_iso8601(\"2015:01:23\")\n    {:error, :invalid_format}\n\n    iex> Date.from_iso8601(\"2015-01-32\")\n    {:error, :invalid_date}\n\n"}
{"completion":"","prompt":"Elixir.Date.from_iso8601!(string, calendar \\\\ Calendar.ISO): Parses the extended \"Dates\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nRaises if the format is invalid.\n\n## Examples\n\n    iex> Date.from_iso8601!(\"2015-01-23\")\n    ~D[2015-01-23]\n    iex> Date.from_iso8601!(\"2015:01:23\")\n    ** (ArgumentError) cannot parse \"2015:01:23\" as date, reason: :invalid_format\n\n"}
{"completion":"","prompt":"Elixir.Date.leap_year?(date): Returns `true` if the year in the given `date` is a leap year.\n\n## Examples\n\n    iex> Date.leap_year?(~D[2000-01-01])\n    true\n    iex> Date.leap_year?(~D[2001-01-01])\n    false\n    iex> Date.leap_year?(~D[2004-01-01])\n    true\n    iex> Date.leap_year?(~D[1900-01-01])\n    false\n    iex> Date.leap_year?(~N[2004-01-01 01:23:45])\n    true\n\n"}
{"completion":"","prompt":"Elixir.Date.months_in_year(date): Returns the number of months in the given `date` year.\n\n## Example\n\n    iex> Date.months_in_year(~D[1900-01-13])\n    12\n\n"}
{"completion":"","prompt":"Elixir.Date.new(year, month, day, calendar \\\\ Calendar.ISO): Builds a new ISO date.\n\nExpects all values to be integers. Returns `{:ok, date}` if each\nentry fits its appropriate range, returns `{:error, reason}` otherwise.\n\n## Examples\n\n    iex> Date.new(2000, 1, 1)\n    {:ok, ~D[2000-01-01]}\n    iex> Date.new(2000, 13, 1)\n    {:error, :invalid_date}\n    iex> Date.new(2000, 2, 29)\n    {:ok, ~D[2000-02-29]}\n\n    iex> Date.new(2000, 2, 30)\n    {:error, :invalid_date}\n    iex> Date.new(2001, 2, 29)\n    {:error, :invalid_date}\n\n"}
{"completion":"","prompt":"Elixir.Date.new!(year, month, day, calendar \\\\ Calendar.ISO): Builds a new ISO date.\n\nExpects all values to be integers. Returns `date` if each\nentry fits its appropriate range, raises if the date is invalid.\n\n## Examples\n\n    iex> Date.new!(2000, 1, 1)\n    ~D[2000-01-01]\n    iex> Date.new!(2000, 13, 1)\n    ** (ArgumentError) cannot build date, reason: :invalid_date\n    iex> Date.new!(2000, 2, 29)\n    ~D[2000-02-29]\n"}
{"completion":"","prompt":"Elixir.Date.quarter_of_year(date): Calculates the quarter of the year of a given `date`.\n\nReturns the day of the year as an integer. For the ISO 8601\ncalendar (the default), it is an integer from 1 to 4.\n\n## Examples\n\n    iex> Date.quarter_of_year(~D[2016-10-31])\n    4\n    iex> Date.quarter_of_year(~D[2016-01-01])\n    1\n    iex> Date.quarter_of_year(~N[2016-04-01 01:23:45])\n    2\n    iex> Date.quarter_of_year(~D[-0015-09-30])\n    3\n\n"}
{"completion":"","prompt":"Elixir.Date.range(first, last): Returns a range of dates.\n\nA range of dates represents a discrete number of dates where\nthe first and last values are dates with matching calendars.\n\nRanges of dates can be either increasing (`first <= last`) or\ndecreasing (`first > last`). They are also always inclusive.\n\n## Examples\n\n    iex> Date.range(~D[1999-01-01], ~D[2000-01-01])\n    Date.range(~D[1999-01-01], ~D[2000-01-01])\n\nA range of dates implements the `Enumerable` protocol, which means\nfunctions in the `Enum` module can be used to work with\nranges:\n\n    iex> range = Date.range(~D[2001-01-01], ~D[2002-01-01])\n    iex> range\n    Date.range(~D[2001-01-01], ~D[2002-01-01])\n    iex> Enum.count(range)\n    366\n    iex> ~D[2001-02-01] in range\n    true\n    iex> Enum.take(range, 3)\n    [~D[2001-01-01], ~D[2001-01-02], ~D[2001-01-03]]\n\n"}
{"completion":"","prompt":"Elixir.Date.range(first, last, step): Returns a range of dates with a step.\n\n## Examples\n\n    iex> range = Date.range(~D[2001-01-01], ~D[2002-01-01], 2)\n    iex> range\n    Date.range(~D[2001-01-01], ~D[2002-01-01], 2)\n    iex> Enum.count(range)\n    183\n    iex> ~D[2001-01-03] in range\n    true\n    iex> Enum.take(range, 3)\n    [~D[2001-01-01], ~D[2001-01-03], ~D[2001-01-05]]\n\n"}
{"completion":"","prompt":"Elixir.Date.to_erl(date): Converts the given `date` to an Erlang date tuple.\n\nOnly supports converting dates which are in the ISO calendar,\nor other calendars in which the days also start at midnight.\nAttempting to convert dates from other calendars will raise.\n\n## Examples\n\n    iex> Date.to_erl(~D[2000-01-01])\n    {2000, 1, 1}\n\n    iex> Date.to_erl(~N[2000-01-01 00:00:00])\n    {2000, 1, 1}\n\n"}
{"completion":"","prompt":"Elixir.Date.to_gregorian_days(date): Converts a `date` struct to a number of gregorian days.\n\n## Examples\n\n    iex> Date.to_gregorian_days(~D[0000-01-02])\n    1\n    iex> Date.to_gregorian_days(~D[2000-01-01])\n    730_485\n    iex> Date.to_gregorian_days(~N[2000-01-01 00:00:00])\n    730_485\n\n"}
{"completion":"","prompt":"Elixir.Date.to_iso8601(date, format \\\\ :extended): Converts the given `date` to\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nBy default, `Date.to_iso8601/2` returns dates formatted in the \"extended\"\nformat, for human readability. It also supports the \"basic\" format through passing the `:basic` option.\n\nOnly supports converting dates which are in the ISO calendar,\nor other calendars in which the days also start at midnight.\nAttempting to convert dates from other calendars will raise an `ArgumentError`.\n\n### Examples\n\n    iex> Date.to_iso8601(~D[2000-02-28])\n    \"2000-02-28\"\n\n    iex> Date.to_iso8601(~D[2000-02-28], :basic)\n    \"20000228\"\n\n    iex> Date.to_iso8601(~N[2000-02-28 00:00:00])\n    \"2000-02-28\"\n\n"}
{"completion":"","prompt":"Elixir.Date.to_string(date): Converts the given date to a string according to its calendar.\n\n### Examples\n\n    iex> Date.to_string(~D[2000-02-28])\n    \"2000-02-28\"\n    iex> Date.to_string(~N[2000-02-28 01:23:45])\n    \"2000-02-28\"\n    iex> Date.to_string(~D[-0100-12-15])\n    \"-0100-12-15\"\n\n"}
{"completion":"","prompt":"Elixir.Date.utc_today(calendar \\\\ Calendar.ISO): Returns the current date in UTC.\n\n## Examples\n\n    iex> date = Date.utc_today()\n    iex> date.year >= 2016\n    true\n\n"}
{"completion":"","prompt":"Elixir.Date.year_of_era(date): Calculates the year-of-era and era for a given\ncalendar year.\n\nReturns a tuple `{year, era}` representing the\nyear within the era and the era number.\n\n## Examples\n\n    iex> Date.year_of_era(~D[0001-01-01])\n    {1, 1}\n    iex> Date.year_of_era(~D[0000-12-31])\n    {1, 0}\n    iex> Date.year_of_era(~D[-0001-01-01])\n    {2, 0}\n\n"}
{"completion":"","prompt":"Elixir.DateTime.add(datetime, amount_to_add, unit \\\\ :second, time_zone_database \\\\ Calendar.get_time_zone_database()): Adds a specified amount of time to a `DateTime`.\n\nAccepts an `amount_to_add` in any `unit`. `unit` can be `:day`,\n`:hour`, `:minute`, `:second` or any subsecond precision from\n`t:System.time_unit/0`. It defaults to `:second`. Negative values\nwill move backwards in time.\n\nThis function always consider the unit to be computed according\nto the `Calendar.ISO`.\n\nThis function uses relies on a contiguous representation of time,\nignoring the wall time and timezone changes. For example, if you add\none day when there are summer time/daylight saving time changes,\nit will also change the time forward or backward by one hour,\nso the ellapsed time is precisely 24 hours. Similarly, adding just\na few seconds to a datetime just before \"spring forward\" can cause\nwall time to increase by more than an hour.\n\nWhile this means this function is precise in terms of ellapsed time,\nits result may be misleading in certain use cases. For example, if a\nuser requests a meeting to happen every day at 15:00 and you use this\nfunction to compute all future meetings by adding day after day, this\nfunction may change the meeting time to 14:00 or 16:00 if there are\nchanges to the current timezone. Computing of recurring datetimes is\nnot currently supported in Elixir's standard library but it is available\nby third-party libraries.\n\n### Examples\n\n    iex> dt = DateTime.from_naive!(~N[2018-11-15 10:00:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> dt |> DateTime.add(3600, :second, FakeTimeZoneDatabase)\n    #DateTime<2018-11-15 11:00:00+01:00 CET Europe/Copenhagen>\n\n    iex> DateTime.add(~U[2018-11-15 10:00:00Z], 3600, :second)\n    ~U[2018-11-15 11:00:00Z]\n\nWhen adding 3 seconds just before \"spring forward\" we go from 1:59:59 to 3:00:02:\n\n    iex> dt = DateTime.from_naive!(~N[2019-03-31 01:59:59.123], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> dt |> DateTime.add(3, :second, FakeTimeZoneDatabase)\n    #DateTime<2019-03-31 03:00:02.123+02:00 CEST Europe/Copenhagen>\n\nWhen adding 1 day during \"spring forward\", the hour also changes:\n\n    iex> dt = DateTime.from_naive!(~N[2019-03-31 01:00:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> dt |> DateTime.add(1, :day, FakeTimeZoneDatabase)\n    #DateTime<2019-04-01 02:00:00+02:00 CEST Europe/Copenhagen>\n\nThis operation merges the precision of the naive date time with the given unit:\n\n    iex> result = DateTime.add(~U[2014-10-02 00:29:10Z], 21, :millisecond)\n    ~U[2014-10-02 00:29:10.021Z]\n    iex> result.microsecond\n    {21000, 3}\n\n"}
{"completion":"","prompt":"Elixir.DateTime.compare(datetime1, datetime2): Compares two datetime structs.\n\nReturns `:gt` if the first datetime is later than the second\nand `:lt` for vice versa. If the two datetimes are equal\n`:eq` is returned.\n\nNote that both UTC and Standard offsets will be taken into\naccount when comparison is done.\n\n## Examples\n\n    iex> dt1 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                 utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> dt2 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                 utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.compare(dt1, dt2)\n    :gt\n\n"}
{"completion":"","prompt":"Elixir.DateTime.convert(datetime, calendar): Converts a given `datetime` from one calendar to another.\n\nIf it is not possible to convert unambiguously between the calendars\n(see `Calendar.compatible_calendars?/2`), an `{:error, :incompatible_calendars}` tuple\nis returned.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> dt1 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                 utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> DateTime.convert(dt1, Calendar.Holocene)\n    {:ok, %DateTime{calendar: Calendar.Holocene, day: 29, hour: 23,\n                    microsecond: {0, 0}, minute: 0, month: 2, second: 7, std_offset: 0,\n                    time_zone: \"America/Manaus\", utc_offset: -14400, year: 12000,\n                    zone_abbr: \"AMT\"}}\n\n"}
{"completion":"","prompt":"Elixir.DateTime.convert!(datetime, calendar): Converts a given `datetime` from one calendar to another.\n\nIf it is not possible to convert unambiguously between the calendars\n(see `Calendar.compatible_calendars?/2`), an ArgumentError is raised.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> dt1 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                 utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> DateTime.convert!(dt1, Calendar.Holocene)\n    %DateTime{calendar: Calendar.Holocene, day: 29, hour: 23,\n              microsecond: {0, 0}, minute: 0, month: 2, second: 7, std_offset: 0,\n              time_zone: \"America/Manaus\", utc_offset: -14400, year: 12000,\n              zone_abbr: \"AMT\"}\n\n"}
{"completion":"","prompt":"Elixir.DateTime.diff(datetime1, datetime2, unit \\\\ :second): Subtracts `datetime2` from `datetime1`.\n\nThe answer can be returned in any `:day`, `:hour`, `:minute`, or any `unit`\navailable from `t:System.time_unit/0`. The unit is measured according to\n`Calendar.ISO` and defaults to `:second`.\n\nFractional results are not supported and are truncated.\n\n## Examples\n\n    iex> dt1 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                 utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> dt2 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                 utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.diff(dt1, dt2)\n    18000\n    iex> DateTime.diff(dt2, dt1)\n    -18000\n    iex> DateTime.diff(dt1, dt2, :hour)\n    5\n    iex> DateTime.diff(dt2, dt1, :hour)\n    -5\n\n"}
{"completion":"","prompt":"Elixir.DateTime.from_gregorian_seconds(seconds, arg \\\\ {0, 0}, calendar \\\\ Calendar.ISO): Converts a number of gregorian seconds to a `DateTime` struct.\n\nThe returned `DateTime` will have `UTC` timezone, if you want other timezone, please use\n`DateTime.shift_zone/3`.\n\n## Examples\n\n    iex> DateTime.from_gregorian_seconds(1)\n    ~U[0000-01-01 00:00:01Z]\n    iex> DateTime.from_gregorian_seconds(63_755_511_991, {5000, 3})\n    ~U[2020-05-01 00:26:31.005Z]\n    iex> DateTime.from_gregorian_seconds(-1)\n    ~U[-0001-12-31 23:59:59Z]\n\n"}
{"completion":"","prompt":"Elixir.DateTime.from_iso8601(string, format_or_calendar \\\\ Calendar.ISO): Parses the extended \"Date and time of day\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nSince ISO 8601 does not include the proper time zone, the given\nstring will be converted to UTC and its offset in seconds will be\nreturned as part of this function. Therefore offset information\nmust be present in the string.\n\nAs specified in the standard, the separator \"T\" may be omitted if\ndesired as there is no ambiguity within this function.\n\nNote leap seconds are not supported by the built-in Calendar.ISO.\n\n## Examples\n\n    iex> {:ok, datetime, 0} = DateTime.from_iso8601(\"2015-01-23T23:50:07Z\")\n    iex> datetime\n    ~U[2015-01-23 23:50:07Z]\n\n    iex> {:ok, datetime, 9000} = DateTime.from_iso8601(\"2015-01-23T23:50:07.123+02:30\")\n    iex> datetime\n    ~U[2015-01-23 21:20:07.123Z]\n\n    iex> {:ok, datetime, 9000} = DateTime.from_iso8601(\"2015-01-23T23:50:07,123+02:30\")\n    iex> datetime\n    ~U[2015-01-23 21:20:07.123Z]\n\n    iex> {:ok, datetime, 0} = DateTime.from_iso8601(\"-2015-01-23T23:50:07Z\")\n    iex> datetime\n    ~U[-2015-01-23 23:50:07Z]\n\n    iex> {:ok, datetime, 9000} = DateTime.from_iso8601(\"-2015-01-23T23:50:07,123+02:30\")\n    iex> datetime\n    ~U[-2015-01-23 21:20:07.123Z]\n\n    iex> {:ok, datetime, 9000} = DateTime.from_iso8601(\"20150123T235007.123+0230\", :basic)\n    iex> datetime\n    ~U[2015-01-23 21:20:07.123Z]\n\n    iex> DateTime.from_iso8601(\"2015-01-23P23:50:07\")\n    {:error, :invalid_format}\n    iex> DateTime.from_iso8601(\"2015-01-23T23:50:07\")\n    {:error, :missing_offset}\n    iex> DateTime.from_iso8601(\"2015-01-23 23:50:61\")\n    {:error, :invalid_time}\n    iex> DateTime.from_iso8601(\"2015-01-32 23:50:07\")\n    {:error, :invalid_date}\n    iex> DateTime.from_iso8601(\"2015-01-23T23:50:07.123-00:00\")\n    {:error, :invalid_format}\n\n"}
{"completion":"","prompt":"Elixir.DateTime.from_iso8601(string, calendar, format): Converts to ISO8601 specifying both a calendar and a mode.\n\nSee `from_iso8601/2` for more information.\n\n## Examples\n\n    iex> {:ok, datetime, 9000} = DateTime.from_iso8601(\"2015-01-23T23:50:07,123+02:30\", Calendar.ISO, :extended)\n    iex> datetime\n    ~U[2015-01-23 21:20:07.123Z]\n\n    iex> {:ok, datetime, 9000} = DateTime.from_iso8601(\"20150123T235007.123+0230\", Calendar.ISO, :basic)\n    iex> datetime\n    ~U[2015-01-23 21:20:07.123Z]\n"}
{"completion":"","prompt":"Elixir.DateTime.from_naive(naive_datetime, time_zone, time_zone_database \\\\ Calendar.get_time_zone_database()): Converts the given `NaiveDateTime` to `DateTime`.\n\nIt expects a time zone to put the `NaiveDateTime` in.\nIf the time zone is \"Etc/UTC\", it always succeeds. Otherwise,\nthe NaiveDateTime is checked against the time zone database\ngiven as `time_zone_database`. See the \"Time zone database\"\nsection in the module documentation.\n\n## Examples\n\n    iex> DateTime.from_naive(~N[2016-05-24 13:26:08.003], \"Etc/UTC\")\n    {:ok, ~U[2016-05-24 13:26:08.003Z]}\n\nWhen the datetime is ambiguous - for instance during changing from summer\nto winter time - the two possible valid datetimes are returned in a tuple.\nThe first datetime is also the one which comes first chronologically, while\nthe second one comes last.\n\n    iex> {:ambiguous, first_dt, second_dt} = DateTime.from_naive(~N[2018-10-28 02:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> first_dt\n    #DateTime<2018-10-28 02:30:00+02:00 CEST Europe/Copenhagen>\n    iex> second_dt\n    #DateTime<2018-10-28 02:30:00+01:00 CET Europe/Copenhagen>\n\nWhen there is a gap in wall time - for instance in spring when the clocks are\nturned forward - the latest valid datetime just before the gap and the first\nvalid datetime just after the gap.\n\n    iex> {:gap, just_before, just_after} = DateTime.from_naive(~N[2019-03-31 02:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> just_before\n    #DateTime<2019-03-31 01:59:59.999999+01:00 CET Europe/Copenhagen>\n    iex> just_after\n    #DateTime<2019-03-31 03:00:00+02:00 CEST Europe/Copenhagen>\n\nMost of the time there is one, and just one, valid datetime for a certain\ndate and time in a certain time zone.\n\n    iex> {:ok, datetime} = DateTime.from_naive(~N[2018-07-28 12:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> datetime\n    #DateTime<2018-07-28 12:30:00+02:00 CEST Europe/Copenhagen>\n\nThis function accepts any map or struct that contains at least the same fields as a `NaiveDateTime`\nstruct. The most common example of that is a `DateTime`. In this case the information about the time\nzone of that `DateTime` is completely ignored. This is the same principle as passing a `DateTime` to\n`Date.to_iso8601/2`. `Date.to_iso8601/2` extracts only the date-specific fields (calendar, year,\nmonth and day) of the given structure and ignores all others.\n\nThis way if you have a `DateTime` in one time zone, you can get the same wall time in another time zone.\nFor instance if you have 2018-08-24 10:00:00 in Copenhagen and want a `DateTime` for 2018-08-24 10:00:00\nin UTC you can do:\n\n    iex> cph_datetime = DateTime.from_naive!(~N[2018-08-24 10:00:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> {:ok, utc_datetime} = DateTime.from_naive(cph_datetime, \"Etc/UTC\", FakeTimeZoneDatabase)\n    iex> utc_datetime\n    ~U[2018-08-24 10:00:00Z]\n\nIf instead you want a `DateTime` for the same point time in a different time zone see the\n`DateTime.shift_zone/3` function which would convert 2018-08-24 10:00:00 in Copenhagen\nto 2018-08-24 08:00:00 in UTC.\n"}
{"completion":"","prompt":"Elixir.DateTime.from_naive!(naive_datetime, time_zone, time_zone_database \\\\ Calendar.get_time_zone_database()): Converts the given `NaiveDateTime` to `DateTime`.\n\nIt expects a time zone to put the NaiveDateTime in.\nIf the time zone is \"Etc/UTC\", it always succeeds. Otherwise,\nthe NaiveDateTime is checked against the time zone database\ngiven as `time_zone_database`. See the \"Time zone database\"\nsection in the module documentation.\n\n## Examples\n\n    iex> DateTime.from_naive!(~N[2016-05-24 13:26:08.003], \"Etc/UTC\")\n    ~U[2016-05-24 13:26:08.003Z]\n\n    iex> DateTime.from_naive!(~N[2018-05-24 13:26:08.003], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    #DateTime<2018-05-24 13:26:08.003+02:00 CEST Europe/Copenhagen>\n\n"}
{"completion":"","prompt":"Elixir.DateTime.from_unix(integer, unit \\\\ :second, calendar \\\\ Calendar.ISO): Converts the given Unix time to `DateTime`.\n\nThe integer can be given in different unit\naccording to `System.convert_time_unit/3` and it will\nbe converted to microseconds internally. Up to\n253402300799 seconds is supported.\n\nUnix times are always in UTC and therefore the DateTime\nwill be returned in UTC.\n\n## Examples\n\n    iex> {:ok, datetime} = DateTime.from_unix(1_464_096_368)\n    iex> datetime\n    ~U[2016-05-24 13:26:08Z]\n\n    iex> {:ok, datetime} = DateTime.from_unix(1_432_560_368_868_569, :microsecond)\n    iex> datetime\n    ~U[2015-05-25 13:26:08.868569Z]\n\n    iex> {:ok, datetime} = DateTime.from_unix(253_402_300_799)\n    iex> datetime\n    ~U[9999-12-31 23:59:59Z]\n\n    iex> {:error, :invalid_unix_time} = DateTime.from_unix(253_402_300_800)\n\nThe unit can also be an integer as in `t:System.time_unit/0`:\n\n    iex> {:ok, datetime} = DateTime.from_unix(143_256_036_886_856, 1024)\n    iex> datetime\n    ~U[6403-03-17 07:05:22.320312Z]\n\nNegative Unix times are supported up to -377705116800 seconds:\n\n    iex> {:ok, datetime} = DateTime.from_unix(-377_705_116_800)\n    iex> datetime\n    ~U[-9999-01-01 00:00:00Z]\n\n    iex> {:error, :invalid_unix_time} = DateTime.from_unix(-377_705_116_801)\n\n"}
{"completion":"","prompt":"Elixir.DateTime.from_unix!(integer, unit \\\\ :second, calendar \\\\ Calendar.ISO): Converts the given Unix time to `DateTime`.\n\nThe integer can be given in different unit\naccording to `System.convert_time_unit/3` and it will\nbe converted to microseconds internally.\n\nUnix times are always in UTC and therefore the DateTime\nwill be returned in UTC.\n\n## Examples\n\n    # An easy way to get the Unix epoch is passing 0 to this function\n    iex> DateTime.from_unix!(0)\n    ~U[1970-01-01 00:00:00Z]\n\n    iex> DateTime.from_unix!(1_464_096_368)\n    ~U[2016-05-24 13:26:08Z]\n\n    iex> DateTime.from_unix!(1_432_560_368_868_569, :microsecond)\n    ~U[2015-05-25 13:26:08.868569Z]\n\n    iex> DateTime.from_unix!(143_256_036_886_856, 1024)\n    ~U[6403-03-17 07:05:22.320312Z]\n\n"}
{"completion":"","prompt":"Elixir.DateTime.new(date, time, time_zone \\\\ \"Etc/UTC\", time_zone_database \\\\ Calendar.get_time_zone_database()): Builds a datetime from date and time structs.\n\nIt expects a time zone to put the `DateTime` in.\nIf the time zone is not passed it will default to `\"Etc/UTC\"`,\nwhich always succeeds. Otherwise, the `DateTime` is checked against the time zone database\ngiven as `time_zone_database`. See the \"Time zone database\"\nsection in the module documentation.\n\n## Examples\n\n    iex> DateTime.new(~D[2016-05-24], ~T[13:26:08.003], \"Etc/UTC\")\n    {:ok, ~U[2016-05-24 13:26:08.003Z]}\n\nWhen the datetime is ambiguous - for instance during changing from summer\nto winter time - the two possible valid datetimes are returned in a tuple.\nThe first datetime is also the one which comes first chronologically, while\nthe second one comes last.\n\n    iex> {:ambiguous, first_dt, second_dt} = DateTime.new(~D[2018-10-28], ~T[02:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> first_dt\n    #DateTime<2018-10-28 02:30:00+02:00 CEST Europe/Copenhagen>\n    iex> second_dt\n    #DateTime<2018-10-28 02:30:00+01:00 CET Europe/Copenhagen>\n\nWhen there is a gap in wall time - for instance in spring when the clocks are\nturned forward - the latest valid datetime just before the gap and the first\nvalid datetime just after the gap.\n\n    iex> {:gap, just_before, just_after} = DateTime.new(~D[2019-03-31], ~T[02:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> just_before\n    #DateTime<2019-03-31 01:59:59.999999+01:00 CET Europe/Copenhagen>\n    iex> just_after\n    #DateTime<2019-03-31 03:00:00+02:00 CEST Europe/Copenhagen>\n\nMost of the time there is one, and just one, valid datetime for a certain\ndate and time in a certain time zone.\n\n    iex> {:ok, datetime} = DateTime.new(~D[2018-07-28], ~T[12:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> datetime\n    #DateTime<2018-07-28 12:30:00+02:00 CEST Europe/Copenhagen>\n\n"}
{"completion":"","prompt":"Elixir.DateTime.new!(date, time, time_zone \\\\ \"Etc/UTC\", time_zone_database \\\\ Calendar.get_time_zone_database()): Builds a datetime from date and time structs, raising on errors.\n\nIt expects a time zone to put the `DateTime` in.\nIf the time zone is not passed it will default to `\"Etc/UTC\"`,\nwhich always succeeds. Otherwise, the DateTime is checked against the time zone database\ngiven as `time_zone_database`. See the \"Time zone database\"\nsection in the module documentation.\n\n## Examples\n\n    iex> DateTime.new!(~D[2016-05-24], ~T[13:26:08.003], \"Etc/UTC\")\n    ~U[2016-05-24 13:26:08.003Z]\n\nWhen the datetime is ambiguous - for instance during changing from summer\nto winter time - an error will be raised.\n\n    iex> DateTime.new!(~D[2018-10-28], ~T[02:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    ** (ArgumentError) cannot build datetime with ~D[2018-10-28] and ~T[02:30:00] because such instant is ambiguous in time zone Europe/Copenhagen as there is an overlap between #DateTime<2018-10-28 02:30:00+02:00 CEST Europe/Copenhagen> and #DateTime<2018-10-28 02:30:00+01:00 CET Europe/Copenhagen>\n\nWhen there is a gap in wall time - for instance in spring when the clocks are\nturned forward - an error will be raised.\n\n    iex> DateTime.new!(~D[2019-03-31], ~T[02:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    ** (ArgumentError) cannot build datetime with ~D[2019-03-31] and ~T[02:30:00] because such instant does not exist in time zone Europe/Copenhagen as there is a gap between #DateTime<2019-03-31 01:59:59.999999+01:00 CET Europe/Copenhagen> and #DateTime<2019-03-31 03:00:00+02:00 CEST Europe/Copenhagen>\n\nMost of the time there is one, and just one, valid datetime for a certain\ndate and time in a certain time zone.\n\n    iex> datetime = DateTime.new!(~D[2018-07-28], ~T[12:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> datetime\n    #DateTime<2018-07-28 12:30:00+02:00 CEST Europe/Copenhagen>\n\n"}
{"completion":"","prompt":"Elixir.DateTime.now(time_zone, time_zone_database \\\\ Calendar.get_time_zone_database()): Returns the current datetime in the provided time zone.\n\nBy default, it uses the default time_zone returned by\n`Calendar.get_time_zone_database/0`, which defaults to\n`Calendar.UTCOnlyTimeZoneDatabase` which only handles \"Etc/UTC\" datetimes.\nOther time zone databases can be passed as argument or set globally.\nSee the \"Time zone database\" section in the module docs.\n\n## Examples\n\n    iex> {:ok, datetime} = DateTime.now(\"Etc/UTC\")\n    iex> datetime.time_zone\n    \"Etc/UTC\"\n\n    iex> DateTime.now(\"Europe/Copenhagen\")\n    {:error, :utc_only_time_zone_database}\n\n    iex> DateTime.now(\"bad timezone\", FakeTimeZoneDatabase)\n    {:error, :time_zone_not_found}\n\n"}
{"completion":"","prompt":"Elixir.DateTime.now!(time_zone, time_zone_database \\\\ Calendar.get_time_zone_database()): Returns the current datetime in the provided time zone or raises on errors\n\nSee `now/2` for more information.\n\n## Examples\n\n    iex> datetime = DateTime.now!(\"Etc/UTC\")\n    iex> datetime.time_zone\n    \"Etc/UTC\"\n\n    iex> DateTime.now!(\"Europe/Copenhagen\")\n    ** (ArgumentError) cannot get current datetime in \"Europe/Copenhagen\" time zone, reason: :utc_only_time_zone_database\n\n    iex> DateTime.now!(\"bad timezone\", FakeTimeZoneDatabase)\n    ** (ArgumentError) cannot get current datetime in \"bad timezone\" time zone, reason: :time_zone_not_found\n\n"}
{"completion":"","prompt":"Elixir.DateTime.shift_zone(datetime, time_zone, time_zone_database \\\\ Calendar.get_time_zone_database()): Changes the time zone of a `DateTime`.\n\nReturns a `DateTime` for the same point in time, but instead at\nthe time zone provided. It assumes that `DateTime` is valid and\nexists in the given time zone and calendar.\n\nBy default, it uses the default time zone database returned by\n`Calendar.get_time_zone_database/0`, which defaults to\n`Calendar.UTCOnlyTimeZoneDatabase` which only handles \"Etc/UTC\" datetimes.\nOther time zone databases can be passed as argument or set globally.\nSee the \"Time zone database\" section in the module docs.\n\n## Examples\n\n    iex> {:ok, pacific_datetime} = DateTime.shift_zone(~U[2018-07-16 10:00:00Z], \"America/Los_Angeles\", FakeTimeZoneDatabase)\n    iex> pacific_datetime\n    #DateTime<2018-07-16 03:00:00-07:00 PDT America/Los_Angeles>\n\n    iex> DateTime.shift_zone(~U[2018-07-16 10:00:00Z], \"bad timezone\", FakeTimeZoneDatabase)\n    {:error, :time_zone_not_found}\n\n"}
{"completion":"","prompt":"Elixir.DateTime.shift_zone!(datetime, time_zone, time_zone_database \\\\ Calendar.get_time_zone_database()): Changes the time zone of a `DateTime` or raises on errors.\n\nSee `shift_zone/3` for more information.\n\n## Examples\n\n    iex> DateTime.shift_zone!(~U[2018-07-16 10:00:00Z], \"America/Los_Angeles\", FakeTimeZoneDatabase)\n    #DateTime<2018-07-16 03:00:00-07:00 PDT America/Los_Angeles>\n\n    iex> DateTime.shift_zone!(~U[2018-07-16 10:00:00Z], \"bad timezone\", FakeTimeZoneDatabase)\n    ** (ArgumentError) cannot shift ~U[2018-07-16 10:00:00Z] to \"bad timezone\" time zone, reason: :time_zone_not_found\n\n"}
{"completion":"","prompt":"Elixir.DateTime.to_date(datetime): Converts a `DateTime` into a `Date`.\n\nBecause `Date` does not hold time nor time zone information,\ndata will be lost during the conversion.\n\n## Examples\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.to_date(dt)\n    ~D[2000-02-29]\n\n"}
{"completion":"","prompt":"Elixir.DateTime.to_gregorian_seconds(datetime): Converts a `DateTime` struct to a number of gregorian seconds and microseconds.\n\n## Examples\n\n    iex> dt = %DateTime{year: 0000, month: 1, day: 1, zone_abbr: \"UTC\",\n    ...>                hour: 0, minute: 0, second: 1, microsecond: {0, 0},\n    ...>                utc_offset: 0, std_offset: 0, time_zone: \"Etc/UTC\"}\n    iex> DateTime.to_gregorian_seconds(dt)\n    {1, 0}\n\n    iex> dt = %DateTime{year: 2020, month: 5, day: 1, zone_abbr: \"UTC\",\n    ...>                hour: 0, minute: 26, second: 31, microsecond: {5000, 0},\n    ...>                utc_offset: 0, std_offset: 0, time_zone: \"Etc/UTC\"}\n    iex> DateTime.to_gregorian_seconds(dt)\n    {63_755_511_991, 5000}\n\n    iex> dt = %DateTime{year: 2020, month: 5, day: 1, zone_abbr: \"CET\",\n    ...>                hour: 1, minute: 26, second: 31, microsecond: {5000, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.to_gregorian_seconds(dt)\n    {63_755_511_991, 5000}\n\n"}
{"completion":"","prompt":"Elixir.DateTime.to_iso8601(datetime, format \\\\ :extended, offset \\\\ nil): Converts the given datetime to\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601) format.\n\nBy default, `DateTime.to_iso8601/2` returns datetimes formatted in the \"extended\"\nformat, for human readability. It also supports the \"basic\" format through passing the `:basic` option.\n\nOnly supports converting datetimes which are in the ISO calendar,\nattempting to convert datetimes from other calendars will raise.\nYou can also optionally specify an offset for the formatted string.\n\nWARNING: the ISO 8601 datetime format does not contain the time zone nor\nits abbreviation, which means information is lost when converting to such\nformat.\n\n### Examples\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.to_iso8601(dt)\n    \"2000-02-29T23:00:07+01:00\"\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"UTC\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 0, std_offset: 0, time_zone: \"Etc/UTC\"}\n    iex> DateTime.to_iso8601(dt)\n    \"2000-02-29T23:00:07Z\"\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> DateTime.to_iso8601(dt, :extended)\n    \"2000-02-29T23:00:07-04:00\"\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> DateTime.to_iso8601(dt, :basic)\n    \"20000229T230007-0400\"\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> DateTime.to_iso8601(dt, :extended, 3600)\n    \"2000-03-01T04:00:07+01:00\"\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> DateTime.to_iso8601(dt, :extended, 0)\n    \"2000-03-01T03:00:07+00:00\"\n\n    iex> dt = %DateTime{year: 2000, month: 3, day: 01, zone_abbr: \"UTC\",\n    ...>                hour: 03, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 0, std_offset: 0, time_zone: \"Etc/UTC\"}\n    iex> DateTime.to_iso8601(dt, :extended, 0)\n    \"2000-03-01T03:00:07Z\"\n\n    iex> {:ok, dt, offset} = DateTime.from_iso8601(\"2000-03-01T03:00:07Z\")\n    iex> \"2000-03-01T03:00:07Z\" = DateTime.to_iso8601(dt, :extended, offset)\n"}
{"completion":"","prompt":"Elixir.DateTime.to_naive(datetime): Converts the given `datetime` into a `NaiveDateTime`.\n\nBecause `NaiveDateTime` does not hold time zone information,\nany time zone related data will be lost during the conversion.\n\n## Examples\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 1},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.to_naive(dt)\n    ~N[2000-02-29 23:00:07.0]\n\n"}
{"completion":"","prompt":"Elixir.DateTime.to_string(datetime): Converts the given `datetime` to a string according to its calendar.\n\n### Examples\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.to_string(dt)\n    \"2000-02-29 23:00:07+01:00 CET Europe/Warsaw\"\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"UTC\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 0, std_offset: 0, time_zone: \"Etc/UTC\"}\n    iex> DateTime.to_string(dt)\n    \"2000-02-29 23:00:07Z\"\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> DateTime.to_string(dt)\n    \"2000-02-29 23:00:07-04:00 AMT America/Manaus\"\n\n    iex> dt = %DateTime{year: -100, month: 12, day: 19, zone_abbr: \"CET\",\n    ...>                hour: 3, minute: 20, second: 31, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Stockholm\"}\n    iex> DateTime.to_string(dt)\n    \"-0100-12-19 03:20:31+01:00 CET Europe/Stockholm\"\n\n"}
{"completion":"","prompt":"Elixir.DateTime.to_time(datetime): Converts a `DateTime` into `Time`.\n\nBecause `Time` does not hold date nor time zone information,\ndata will be lost during the conversion.\n\n## Examples\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 1},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.to_time(dt)\n    ~T[23:00:07.0]\n\n"}
{"completion":"","prompt":"Elixir.DateTime.to_unix(datetime, unit \\\\ :second): Converts the given `datetime` to Unix time.\n\nThe `datetime` is expected to be using the ISO calendar\nwith a year greater than or equal to 0.\n\nIt will return the integer with the given unit,\naccording to `System.convert_time_unit/3`.\n\n## Examples\n\n    iex> 1_464_096_368 |> DateTime.from_unix!() |> DateTime.to_unix()\n    1464096368\n\n    iex> dt = %DateTime{calendar: Calendar.ISO, day: 20, hour: 18, microsecond: {273806, 6},\n    ...>                minute: 58, month: 11, second: 19, time_zone: \"America/Montevideo\",\n    ...>                utc_offset: -10800, std_offset: 3600, year: 2014, zone_abbr: \"UYST\"}\n    iex> DateTime.to_unix(dt)\n    1416517099\n\n    iex> flamel = %DateTime{calendar: Calendar.ISO, day: 22, hour: 8, microsecond: {527771, 6},\n    ...>                minute: 2, month: 3, second: 25, std_offset: 0, time_zone: \"Etc/UTC\",\n    ...>                utc_offset: 0, year: 1418, zone_abbr: \"UTC\"}\n    iex> DateTime.to_unix(flamel)\n    -17412508655\n\n"}
{"completion":"","prompt":"Elixir.DateTime.truncate(datetime, precision): Returns the given datetime with the microsecond field truncated to the given\nprecision (`:microsecond`, `:millisecond` or `:second`).\n\nThe given datetime is returned unchanged if it already has lower precision than\nthe given precision.\n\n## Examples\n\n    iex> dt1 = %DateTime{year: 2017, month: 11, day: 7, zone_abbr: \"CET\",\n    ...>                 hour: 11, minute: 45, second: 18, microsecond: {123456, 6},\n    ...>                 utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Paris\"}\n    iex> DateTime.truncate(dt1, :microsecond)\n    #DateTime<2017-11-07 11:45:18.123456+01:00 CET Europe/Paris>\n\n    iex> dt2 = %DateTime{year: 2017, month: 11, day: 7, zone_abbr: \"CET\",\n    ...>                 hour: 11, minute: 45, second: 18, microsecond: {123456, 6},\n    ...>                 utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Paris\"}\n    iex> DateTime.truncate(dt2, :millisecond)\n    #DateTime<2017-11-07 11:45:18.123+01:00 CET Europe/Paris>\n\n    iex> dt3 = %DateTime{year: 2017, month: 11, day: 7, zone_abbr: \"CET\",\n    ...>                 hour: 11, minute: 45, second: 18, microsecond: {123456, 6},\n    ...>                 utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Paris\"}\n    iex> DateTime.truncate(dt3, :second)\n    #DateTime<2017-11-07 11:45:18+01:00 CET Europe/Paris>\n\n"}
{"completion":"","prompt":"Elixir.DateTime.utc_now(calendar \\\\ Calendar.ISO): Returns the current datetime in UTC.\n\nIf you want the current time in Unix seconds,\nuse `System.os_time/1` instead.\n\n## Examples\n\n    iex> datetime = DateTime.utc_now()\n    iex> datetime.time_zone\n    \"Etc/UTC\"\n\n"}
{"completion":"","prompt":"Elixir.DynamicSupervisor.child_spec(opts): Returns a specification to start a dynamic supervisor under a supervisor.\n\nSee `Supervisor`.\n"}
{"completion":"","prompt":"Elixir.DynamicSupervisor.count_children(supervisor): Returns a map containing count values for the supervisor.\n\nThe map contains the following keys:\n\n  * `:specs` - the number of children processes\n\n  * `:active` - the count of all actively running child processes managed by\n    this supervisor\n\n  * `:supervisors` - the count of all supervisors whether or not the child\n    process is still alive\n\n  * `:workers` - the count of all workers, whether or not the child process\n    is still alive\n\n"}
{"completion":"","prompt":"Elixir.DynamicSupervisor.init(options): Receives a set of `options` that initializes a dynamic supervisor.\n\nThis is typically invoked at the end of the `c:init/1` callback of\nmodule-based supervisors. See the \"Module-based supervisors\" section\nin the module documentation for more information.\n\nIt accepts the same `options` as `start_link/1` (except for `:name`)\nand it returns a tuple containing the supervisor options.\n\n## Examples\n\n    def init(_arg) do\n      DynamicSupervisor.init(max_children: 1000)\n    end\n\n"}
{"completion":"","prompt":"Elixir.DynamicSupervisor.start_child(supervisor, child_spec): Dynamically adds a child specification to `supervisor` and starts that child.\n\n`child_spec` should be a valid child specification as detailed in the\n\"Child specification\" section of the documentation for `Supervisor`. The child\nprocess will be started as defined in the child specification. Note that while\nthe `:id` field is still required in the spec, the value is ignored and\ntherefore does not need to be unique.\n\nIf the child process start function returns `{:ok, child}` or `{:ok, child,\ninfo}`, then child specification and PID are added to the supervisor and\nthis function returns the same value.\n\nIf the child process start function returns `:ignore`, then no child is added\nto the supervision tree and this function returns `:ignore` too.\n\nIf the child process start function returns an error tuple or an erroneous\nvalue, or if it fails, the child specification is discarded and this function\nreturns `{:error, error}` where `error` is the error or erroneous value\nreturned from child process start function, or failure reason if it fails.\n\nIf the supervisor already has N children in a way that N exceeds the amount\nof `:max_children` set on the supervisor initialization (see `init/1`), then\nthis function returns `{:error, :max_children}`.\n"}
{"completion":"","prompt":"Elixir.DynamicSupervisor.start_link(options): Starts a supervisor with the given options.\n\nThis function is typically not invoked directly, instead it is invoked\nwhen using a `DynamicSupervisor` as a child of another supervisor:\n\n    children = [\n      {DynamicSupervisor, name: MySupervisor}\n    ]\n\nIf the supervisor is successfully spawned, this function returns\n`{:ok, pid}`, where `pid` is the PID of the supervisor. If the supervisor\nis given a name and a process with the specified name already exists,\nthe function returns `{:error, {:already_started, pid}}`, where `pid`\nis the PID of that process.\n\nNote that a supervisor started with this function is linked to the parent\nprocess and exits not only on crashes but also if the parent process exits\nwith `:normal` reason.\n\n## Options\n\n  * `:name` - registers the supervisor under the given name.\n    The supported values are described under the \"Name registration\"\n    section in the `GenServer` module docs.\n\n  * `:strategy` - the restart strategy option. The only supported\n    value is `:one_for_one` which means that no other child is\n    terminated if a child process terminates. You can learn more\n    about strategies in the `Supervisor` module docs.\n\n  * `:max_restarts` - the maximum number of restarts allowed in\n    a time frame. Defaults to `3`.\n\n  * `:max_seconds` - the time frame in which `:max_restarts` applies.\n    Defaults to `5`.\n\n  * `:max_children` - the maximum amount of children to be running\n    under this supervisor at the same time. When `:max_children` is\n    exceeded, `start_child/2` returns `{:error, :max_children}`. Defaults\n    to `:infinity`.\n\n  * `:extra_arguments` - arguments that are prepended to the arguments\n    specified in the child spec given to `start_child/2`. Defaults to\n    an empty list.\n\n"}
{"completion":"","prompt":"Elixir.DynamicSupervisor.start_link(module, init_arg, opts \\\\ []): Starts a module-based supervisor process with the given `module` and `init_arg`.\n\nTo start the supervisor, the `c:init/1` callback will be invoked in the given\n`module`, with `init_arg` as its argument. The `c:init/1` callback must return a\nsupervisor specification which can be created with the help of the `init/1`\nfunction.\n\nIf the `c:init/1` callback returns `:ignore`, this function returns\n`:ignore` as well and the supervisor terminates with reason `:normal`.\nIf it fails or returns an incorrect value, this function returns\n`{:error, term}` where `term` is a term with information about the\nerror, and the supervisor terminates with reason `term`.\n\nThe `:name` option can also be given in order to register a supervisor\nname, the supported values are described in the \"Name registration\"\nsection in the `GenServer` module docs.\n\nIf the supervisor is successfully spawned, this function returns\n`{:ok, pid}`, where `pid` is the PID of the supervisor. If the supervisor\nis given a name and a process with the specified name already exists,\nthe function returns `{:error, {:already_started, pid}}`, where `pid`\nis the PID of that process.\n\nNote that a supervisor started with this function is linked to the parent\nprocess and exits not only on crashes but also if the parent process exits\nwith `:normal` reason.\n"}
{"completion":"","prompt":"Elixir.DynamicSupervisor.stop(supervisor, reason \\\\ :normal, timeout \\\\ :infinity): Synchronously stops the given supervisor with the given `reason`.\n\nIt returns `:ok` if the supervisor terminates with the given\nreason. If it terminates with another reason, the call exits.\n\nThis function keeps OTP semantics regarding error reporting.\nIf the reason is any other than `:normal`, `:shutdown` or\n`{:shutdown, _}`, an error report is logged.\n"}
{"completion":"","prompt":"Elixir.DynamicSupervisor.terminate_child(supervisor, pid): Terminates the given child identified by `pid`.\n\nIf successful, this function returns `:ok`. If there is no process with\nthe given PID, this function returns `{:error, :not_found}`.\n"}
{"completion":"","prompt":"Elixir.DynamicSupervisor.which_children(supervisor): Returns a list with information about all children.\n\nNote that calling this function when supervising a large number\nof children under low memory conditions can cause an out of memory\nexception.\n\nThis function returns a list of tuples containing:\n\n  * `id` - it is always `:undefined` for dynamic supervisors\n\n  * `child` - the PID of the corresponding child process or the\n    atom `:restarting` if the process is about to be restarted\n\n  * `type` - `:worker` or `:supervisor` as defined in the child\n    specification\n\n  * `modules` - as defined in the child specification\n\n"}
{"completion":"","prompt":"Elixir.Enum.all?(enumerable): Returns `true` if all elements in `enumerable` are truthy.\n\nWhen an element has a falsy value (`false` or `nil`) iteration stops immediately\nand `false` is returned. In all other cases `true` is returned.\n\n## Examples\n\n    iex> Enum.all?([1, 2, 3])\n    true\n\n    iex> Enum.all?([1, nil, 3])\n    false\n\n    iex> Enum.all?([])\n    true\n\n"}
{"completion":"","prompt":"Elixir.Enum.all?(enumerable, fun): Returns `true` if `fun.(element)` is truthy for all elements in `enumerable`.\n\nIterates over `enumerable` and invokes `fun` on each element. If `fun` ever\nreturns a falsy value (`false` or `nil`), iteration stops immediately and\n`false` is returned. Otherwise, `true` is returned.\n\n## Examples\n\n    iex> Enum.all?([2, 4, 6], fn x -> rem(x, 2) == 0 end)\n    true\n\n    iex> Enum.all?([2, 3, 4], fn x -> rem(x, 2) == 0 end)\n    false\n\n    iex> Enum.all?([], fn _ -> nil end)\n    true\n\nAs the last example shows, `Enum.all?/2` returns `true` if `enumerable` is\nempty, regardless of `fun`. In an empty enumerable there is no element for\nwhich `fun` returns a falsy value, so the result must be `true`. This is a\nwell-defined logical argument for empty collections.\n\n"}
{"completion":"","prompt":"Elixir.Enum.any?(enumerable): Returns `true` if at least one element in `enumerable` is truthy.\n\nWhen an element has a truthy value (neither `false` nor `nil`) iteration stops\nimmediately and `true` is returned. In all other cases `false` is returned.\n\n## Examples\n\n    iex> Enum.any?([false, false, false])\n    false\n\n    iex> Enum.any?([false, true, false])\n    true\n\n    iex> Enum.any?([])\n    false\n\n"}
{"completion":"","prompt":"Elixir.Enum.any?(enumerable, fun): Returns `true` if `fun.(element)` is truthy for at least one element in `enumerable`.\n\nIterates over the `enumerable` and invokes `fun` on each element. When an invocation\nof `fun` returns a truthy value (neither `false` nor `nil`) iteration stops\nimmediately and `true` is returned. In all other cases `false` is returned.\n\n## Examples\n\n    iex> Enum.any?([2, 4, 6], fn x -> rem(x, 2) == 1 end)\n    false\n\n    iex> Enum.any?([2, 3, 4], fn x -> rem(x, 2) == 1 end)\n    true\n\n    iex> Enum.any?([], fn x -> x > 0 end)\n    false\n\n"}
{"completion":"","prompt":"Elixir.Enum.at(enumerable, index, default \\\\ nil): Finds the element at the given `index` (zero-based).\n\nReturns `default` if `index` is out of bounds.\n\nA negative `index` can be passed, which means the `enumerable` is\nenumerated once and the `index` is counted from the end (for example,\n`-1` finds the last element).\n\n## Examples\n\n    iex> Enum.at([2, 4, 6], 0)\n    2\n\n    iex> Enum.at([2, 4, 6], 2)\n    6\n\n    iex> Enum.at([2, 4, 6], 4)\n    nil\n\n    iex> Enum.at([2, 4, 6], 4, :none)\n    :none\n\n"}
{"completion":"","prompt":"Elixir.Enum.chunk_by(enumerable, fun): Splits enumerable on every element for which `fun` returns a new\nvalue.\n\nReturns a list of lists.\n\n## Examples\n\n    iex> Enum.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) == 1))\n    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n\n"}
{"completion":"","prompt":"Elixir.Enum.chunk_every(enumerable, count): Shortcut to `chunk_every(enumerable, count, count)`.\n"}
{"completion":"","prompt":"Elixir.Enum.chunk_every(enumerable, count, step, leftover \\\\ []): Returns list of lists containing `count` elements each, where\neach new chunk starts `step` elements into the `enumerable`.\n\n`step` is optional and, if not passed, defaults to `count`, i.e.\nchunks do not overlap.\n\nIf the last chunk does not have `count` elements to fill the chunk,\nelements are taken from `leftover` to fill in the chunk. If `leftover`\ndoes not have enough elements to fill the chunk, then a partial chunk\nis returned with less than `count` elements.\n\nIf `:discard` is given in `leftover`, the last chunk is discarded\nunless it has exactly `count` elements.\n\n## Examples\n\n    iex> Enum.chunk_every([1, 2, 3, 4, 5, 6], 2)\n    [[1, 2], [3, 4], [5, 6]]\n\n    iex> Enum.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, :discard)\n    [[1, 2, 3], [3, 4, 5]]\n\n    iex> Enum.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, [7])\n    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n\n    iex> Enum.chunk_every([1, 2, 3, 4], 3, 3, [])\n    [[1, 2, 3], [4]]\n\n    iex> Enum.chunk_every([1, 2, 3, 4], 10)\n    [[1, 2, 3, 4]]\n\n    iex> Enum.chunk_every([1, 2, 3, 4, 5], 2, 3, [])\n    [[1, 2], [4, 5]]\n\n    iex> Enum.chunk_every([1, 2, 3, 4], 3, 3, Stream.cycle([0]))\n    [[1, 2, 3], [4, 0, 0]]\n\n"}
{"completion":"","prompt":"Elixir.Enum.chunk_while(enumerable, acc, chunk_fun, after_fun): Chunks the `enumerable` with fine grained control when every chunk is emitted.\n\n`chunk_fun` receives the current element and the accumulator and must return:\n\n  * `{:cont, chunk, acc}` to emit a chunk and continue with the accumulator\n  * `{:cont, acc}` to not emit any chunk and continue with the accumulator\n  * `{:halt, acc}` to halt chunking over the `enumerable`.\n\n`after_fun` is invoked with the final accumulator when iteration is\nfinished (or `halt`ed) to handle any trailing elements that were returned\nas part of an accumulator, but were not emitted as a chunk by `chunk_fun`.\nIt must return:\n\n  * `{:cont, chunk, acc}` to emit a chunk. The chunk will be appended to the\n    list of already emitted chunks.\n  * `{:cont, acc}` to not emit a chunk\n\nThe `acc` in `after_fun` is required in order to mirror the tuple format\nfrom `chunk_fun` but it will be discarded since the traversal is complete.\n\nReturns a list of emitted chunks.\n\n## Examples\n\n    iex> chunk_fun = fn element, acc ->\n    ...>   if rem(element, 2) == 0 do\n    ...>     {:cont, Enum.reverse([element | acc]), []}\n    ...>   else\n    ...>     {:cont, [element | acc]}\n    ...>   end\n    ...> end\n    iex> after_fun = fn\n    ...>   [] -> {:cont, []}\n    ...>   acc -> {:cont, Enum.reverse(acc), []}\n    ...> end\n    iex> Enum.chunk_while(1..10, [], chunk_fun, after_fun)\n    [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]\n    iex> Enum.chunk_while([1, 2, 3, 5, 7], [], chunk_fun, after_fun)\n    [[1, 2], [3, 5, 7]]\n\n"}
{"completion":"","prompt":"Elixir.Enum.concat(enumerables): Given an enumerable of enumerables, concatenates the `enumerables` into\na single list.\n\n## Examples\n\n    iex> Enum.concat([1..3, 4..6, 7..9])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    iex> Enum.concat([[1, [2], 3], [4], [5, 6]])\n    [1, [2], 3, 4, 5, 6]\n\n"}
{"completion":"","prompt":"Elixir.Enum.concat(left, right): Concatenates the enumerable on the `right` with the enumerable on the\n`left`.\n\nThis function produces the same result as the `++/2` operator\nfor lists.\n\n## Examples\n\n    iex> Enum.concat(1..3, 4..6)\n    [1, 2, 3, 4, 5, 6]\n\n    iex> Enum.concat([1, 2, 3], [4, 5, 6])\n    [1, 2, 3, 4, 5, 6]\n\n"}
{"completion":"","prompt":"Elixir.Enum.count(enumerable): Returns the size of the `enumerable`.\n\n## Examples\n\n    iex> Enum.count([1, 2, 3])\n    3\n\n"}
{"completion":"","prompt":"Elixir.Enum.count(enumerable, fun): Returns the count of elements in the `enumerable` for which `fun` returns\na truthy value.\n\n## Examples\n\n    iex> Enum.count([1, 2, 3, 4, 5], fn x -> rem(x, 2) == 0 end)\n    2\n\n"}
{"completion":"","prompt":"Elixir.Enum.count_until(enumerable, limit): Counts the enumerable stopping at `limit`.\n\nThis is useful for checking certain properties of the count of an enumerable\nwithout having to actually count the entire enumerable. For example, if you\nwanted to check that the count was exactly, at least, or more than a value.\n\nIf the enumerable implements `c:Enumerable.count/1`, the enumerable is\nnot traversed and we return the lower of the two numbers. To force\nenumeration, use `count_until/3` with `fn _ -> true end` as the second\nargument.\n\n## Examples\n\n    iex> Enum.count_until(1..20, 5)\n    5\n    iex> Enum.count_until(1..20, 50)\n    20\n    iex> Enum.count_until(1..10, 10) == 10 # At least 10\n    true\n    iex> Enum.count_until(1..11, 10 + 1) > 10 # More than 10\n    true\n    iex> Enum.count_until(1..5, 10) < 10 # Less than 10\n    true\n    iex> Enum.count_until(1..10, 10 + 1) == 10 # Exactly ten\n    true\n\n"}
{"completion":"","prompt":"Elixir.Enum.count_until(enumerable, fun, limit): Counts the elements in the enumerable for which `fun` returns a truthy value, stopping at `limit`.\n\nSee `count/2` and `count_until/3` for more information.\n\n## Examples\n\n    iex> Enum.count_until(1..20, fn x -> rem(x, 2) == 0 end, 7)\n    7\n    iex> Enum.count_until(1..20, fn x -> rem(x, 2) == 0 end, 11)\n    10\n"}
{"completion":"","prompt":"Elixir.Enum.dedup(enumerable): Enumerates the `enumerable`, returning a list where all consecutive\nduplicated elements are collapsed to a single element.\n\nElements are compared using `===/2`.\n\nIf you want to remove all duplicated elements, regardless of order,\nsee `uniq/1`.\n\n## Examples\n\n    iex> Enum.dedup([1, 2, 3, 3, 2, 1])\n    [1, 2, 3, 2, 1]\n\n    iex> Enum.dedup([1, 1, 2, 2.0, :three, :three])\n    [1, 2, 2.0, :three]\n\n"}
{"completion":"","prompt":"Elixir.Enum.dedup_by(enumerable, fun): Enumerates the `enumerable`, returning a list where all consecutive\nduplicated elements are collapsed to a single element.\n\nThe function `fun` maps every element to a term which is used to\ndetermine if two elements are duplicates.\n\n## Examples\n\n    iex> Enum.dedup_by([{1, :a}, {2, :b}, {2, :c}, {1, :a}], fn {x, _} -> x end)\n    [{1, :a}, {2, :b}, {1, :a}]\n\n    iex> Enum.dedup_by([5, 1, 2, 3, 2, 1], fn x -> x > 2 end)\n    [5, 1, 3, 2]\n\n"}
{"completion":"","prompt":"Elixir.Enum.drop(enumerable, amount): Drops the `amount` of elements from the `enumerable`.\n\nIf a negative `amount` is given, the `amount` of last values will be dropped.\nThe `enumerable` will be enumerated once to retrieve the proper index and\nthe remaining calculation is performed from the end.\n\n## Examples\n\n    iex> Enum.drop([1, 2, 3], 2)\n    [3]\n\n    iex> Enum.drop([1, 2, 3], 10)\n    []\n\n    iex> Enum.drop([1, 2, 3], 0)\n    [1, 2, 3]\n\n    iex> Enum.drop([1, 2, 3], -1)\n    [1, 2]\n\n"}
{"completion":"","prompt":"Elixir.Enum.drop_every(enumerable, nth): Returns a list of every `nth` element in the `enumerable` dropped,\nstarting with the first element.\n\nThe first element is always dropped, unless `nth` is 0.\n\nThe second argument specifying every `nth` element must be a non-negative\ninteger.\n\n## Examples\n\n    iex> Enum.drop_every(1..10, 2)\n    [2, 4, 6, 8, 10]\n\n    iex> Enum.drop_every(1..10, 0)\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    iex> Enum.drop_every([1, 2, 3], 1)\n    []\n\n"}
{"completion":"","prompt":"Elixir.Enum.drop_while(enumerable, fun): Drops elements at the beginning of the `enumerable` while `fun` returns a\ntruthy value.\n\n## Examples\n\n    iex> Enum.drop_while([1, 2, 3, 2, 1], fn x -> x < 3 end)\n    [3, 2, 1]\n\n"}
{"completion":"","prompt":"Elixir.Enum.each(enumerable, fun): Invokes the given `fun` for each element in the `enumerable`.\n\nReturns `:ok`.\n\n## Examples\n\n    Enum.each([\"some\", \"example\"], fn x -> IO.puts(x) end)\n    \"some\"\n    \"example\"\n    #=> :ok\n\n"}
{"completion":"","prompt":"Elixir.Enum.empty?(enumerable): Determines if the `enumerable` is empty.\n\nReturns `true` if `enumerable` is empty, otherwise `false`.\n\n## Examples\n\n    iex> Enum.empty?([])\n    true\n\n    iex> Enum.empty?([1, 2, 3])\n    false\n\n"}
{"completion":"","prompt":"Elixir.Enum.fetch(enumerable, index): Finds the element at the given `index` (zero-based).\n\nReturns `{:ok, element}` if found, otherwise `:error`.\n\nA negative `index` can be passed, which means the `enumerable` is\nenumerated once and the `index` is counted from the end (for example,\n`-1` fetches the last element).\n\n## Examples\n\n    iex> Enum.fetch([2, 4, 6], 0)\n    {:ok, 2}\n\n    iex> Enum.fetch([2, 4, 6], -3)\n    {:ok, 2}\n\n    iex> Enum.fetch([2, 4, 6], 2)\n    {:ok, 6}\n\n    iex> Enum.fetch([2, 4, 6], 4)\n    :error\n\n"}
{"completion":"","prompt":"Elixir.Enum.fetch!(enumerable, index): Finds the element at the given `index` (zero-based).\n\nRaises `OutOfBoundsError` if the given `index` is outside the range of\nthe `enumerable`.\n\n## Examples\n\n    iex> Enum.fetch!([2, 4, 6], 0)\n    2\n\n    iex> Enum.fetch!([2, 4, 6], 2)\n    6\n\n    iex> Enum.fetch!([2, 4, 6], 4)\n    ** (Enum.OutOfBoundsError) out of bounds error\n\n"}
{"completion":"","prompt":"Elixir.Enum.filter(enumerable, fun): Filters the `enumerable`, i.e. returns only those elements\nfor which `fun` returns a truthy value.\n\nSee also `reject/2` which discards all elements where the\nfunction returns a truthy value.\n\n## Examples\n\n    iex> Enum.filter([1, 2, 3], fn x -> rem(x, 2) == 0 end)\n    [2]\n\nKeep in mind that `filter` is not capable of filtering and\ntransforming an element at the same time. If you would like\nto do so, consider using `flat_map/2`. For example, if you\nwant to convert all strings that represent an integer and\ndiscard the invalid one in one pass:\n\n    strings = [\"1234\", \"abc\", \"12ab\"]\n\n    Enum.flat_map(strings, fn string ->\n      case Integer.parse(string) do\n        # transform to integer\n        {int, _rest} -> [int]\n        # skip the value\n        :error -> []\n      end\n    end)\n\n"}
{"completion":"","prompt":"Elixir.Enum.find(enumerable, default \\\\ nil, fun): Returns the first element for which `fun` returns a truthy value.\nIf no such element is found, returns `default`.\n\n## Examples\n\n    iex> Enum.find([2, 3, 4], fn x -> rem(x, 2) == 1 end)\n    3\n\n    iex> Enum.find([2, 4, 6], fn x -> rem(x, 2) == 1 end)\n    nil\n    iex> Enum.find([2, 4, 6], 0, fn x -> rem(x, 2) == 1 end)\n    0\n\n"}
{"completion":"","prompt":"Elixir.Enum.find_index(enumerable, fun): Similar to `find/3`, but returns the index (zero-based)\nof the element instead of the element itself.\n\n## Examples\n\n    iex> Enum.find_index([2, 4, 6], fn x -> rem(x, 2) == 1 end)\n    nil\n\n    iex> Enum.find_index([2, 3, 4], fn x -> rem(x, 2) == 1 end)\n    1\n\n"}
{"completion":"","prompt":"Elixir.Enum.find_value(enumerable, default \\\\ nil, fun): Similar to `find/3`, but returns the value of the function\ninvocation instead of the element itself.\n\nThe return value is considered to be found when the result is truthy\n(neither `nil` nor `false`).\n\n## Examples\n\n    iex> Enum.find_value([2, 3, 4], fn x ->\n    ...>   if x > 2, do: x * x\n    ...> end)\n    9\n\n    iex> Enum.find_value([2, 4, 6], fn x -> rem(x, 2) == 1 end)\n    nil\n\n    iex> Enum.find_value([2, 3, 4], fn x -> rem(x, 2) == 1 end)\n    true\n\n    iex> Enum.find_value([1, 2, 3], \"no bools!\", &is_boolean/1)\n    \"no bools!\"\n\n"}
{"completion":"","prompt":"Elixir.Enum.flat_map(enumerable, fun): Maps the given `fun` over `enumerable` and flattens the result.\n\nThis function returns a new enumerable built by appending the result of invoking `fun`\non each element of `enumerable` together; conceptually, this is similar to a\ncombination of `map/2` and `concat/1`.\n\n## Examples\n\n    iex> Enum.flat_map([:a, :b, :c], fn x -> [x, x] end)\n    [:a, :a, :b, :b, :c, :c]\n\n    iex> Enum.flat_map([{1, 3}, {4, 6}], fn {x, y} -> x..y end)\n    [1, 2, 3, 4, 5, 6]\n\n    iex> Enum.flat_map([:a, :b, :c], fn x -> [[x]] end)\n    [[:a], [:b], [:c]]\n\n"}
{"completion":"","prompt":"Elixir.Enum.flat_map_reduce(enumerable, acc, fun): Maps and reduces an `enumerable`, flattening the given results (only one level deep).\n\nIt expects an accumulator and a function that receives each enumerable\nelement, and must return a tuple containing a new enumerable (often a list)\nwith the new accumulator or a tuple with `:halt` as first element and\nthe accumulator as second.\n\n## Examples\n\n    iex> enumerable = 1..100\n    iex> n = 3\n    iex> Enum.flat_map_reduce(enumerable, 0, fn x, acc ->\n    ...>   if acc < n, do: {[x], acc + 1}, else: {:halt, acc}\n    ...> end)\n    {[1, 2, 3], 3}\n\n    iex> Enum.flat_map_reduce(1..5, 0, fn x, acc -> {[[x]], acc + x} end)\n    {[[1], [2], [3], [4], [5]], 15}\n\n"}
{"completion":"","prompt":"Elixir.Enum.frequencies(enumerable): Returns a map with keys as unique elements of `enumerable` and values\nas the count of every element.\n\n## Examples\n\n    iex> Enum.frequencies(~w{ant buffalo ant ant buffalo dingo})\n    %{\"ant\" => 3, \"buffalo\" => 2, \"dingo\" => 1}\n\n"}
{"completion":"","prompt":"Elixir.Enum.frequencies_by(enumerable, key_fun): Returns a map with keys as unique elements given by `key_fun` and values\nas the count of every element.\n\n## Examples\n\n    iex> Enum.frequencies_by(~w{aa aA bb cc}, &String.downcase/1)\n    %{\"aa\" => 2, \"bb\" => 1, \"cc\" => 1}\n\n    iex> Enum.frequencies_by(~w{aaa aA bbb cc c}, &String.length/1)\n    %{3 => 2, 2 => 2, 1 => 1}\n\n"}
{"completion":"","prompt":"Elixir.Enum.group_by(enumerable, key_fun, value_fun \\\\ fn x -> x end): Splits the `enumerable` into groups based on `key_fun`.\n\nThe result is a map where each key is given by `key_fun`\nand each value is a list of elements given by `value_fun`.\nThe order of elements within each list is preserved from the `enumerable`.\nHowever, like all maps, the resulting map is unordered.\n\n## Examples\n\n    iex> Enum.group_by(~w{ant buffalo cat dingo}, &String.length/1)\n    %{3 => [\"ant\", \"cat\"], 5 => [\"dingo\"], 7 => [\"buffalo\"]}\n\n    iex> Enum.group_by(~w{ant buffalo cat dingo}, &String.length/1, &String.first/1)\n    %{3 => [\"a\", \"c\"], 5 => [\"d\"], 7 => [\"b\"]}\n\n"}
{"completion":"","prompt":"Elixir.Enum.intersperse(enumerable, separator): Intersperses `separator` between each element of the enumeration.\n\n## Examples\n\n    iex> Enum.intersperse([1, 2, 3], 0)\n    [1, 0, 2, 0, 3]\n\n    iex> Enum.intersperse([1], 0)\n    [1]\n\n    iex> Enum.intersperse([], 0)\n    []\n\n"}
{"completion":"","prompt":"Elixir.Enum.into(enumerable, collectable): Inserts the given `enumerable` into a `collectable`.\n\nNote that passing a non-empty list as the `collectable` is deprecated.\nIf you're collecting into a non-empty keyword list, consider using\n`Keyword.merge(collectable, Enum.to_list(enumerable))`. If you're collecting\ninto a non-empty list, consider something like `Enum.to_list(enumerable) ++ collectable`.\n\n## Examples\n\n    iex> Enum.into([1, 2], [])\n    [1, 2]\n\n    iex> Enum.into([a: 1, b: 2], %{})\n    %{a: 1, b: 2}\n\n    iex> Enum.into(%{a: 1}, %{b: 2})\n    %{a: 1, b: 2}\n\n    iex> Enum.into([a: 1, a: 2], %{})\n    %{a: 2}\n\n"}
{"completion":"","prompt":"Elixir.Enum.into(enumerable, collectable, transform): Inserts the given `enumerable` into a `collectable` according to the\ntransformation function.\n\n## Examples\n\n    iex> Enum.into([1, 2, 3], [], fn x -> x * 3 end)\n    [3, 6, 9]\n\n    iex> Enum.into(%{a: 1, b: 2}, %{c: 3}, fn {k, v} -> {k, v * 2} end)\n    %{a: 2, b: 4, c: 3}\n\n"}
{"completion":"","prompt":"Elixir.Enum.join(enumerable, joiner \\\\ \"\"): Joins the given `enumerable` into a string using `joiner` as a\nseparator.\n\nIf `joiner` is not passed at all, it defaults to an empty string.\n\nAll elements in the `enumerable` must be convertible to a string,\notherwise an error is raised.\n\n## Examples\n\n    iex> Enum.join([1, 2, 3])\n    \"123\"\n\n    iex> Enum.join([1, 2, 3], \" = \")\n    \"1 = 2 = 3\"\n\n    iex> Enum.join([[\"a\", \"b\"], [\"c\", \"d\", \"e\", [\"f\", \"g\"]], \"h\", \"i\"], \" \")\n    \"ab cdefg h i\"\n\n"}
{"completion":"","prompt":"Elixir.Enum.map(enumerable, fun): Returns a list where each element is the result of invoking\n`fun` on each corresponding element of `enumerable`.\n\nFor maps, the function expects a key-value tuple.\n\n## Examples\n\n    iex> Enum.map([1, 2, 3], fn x -> x * 2 end)\n    [2, 4, 6]\n\n    iex> Enum.map([a: 1, b: 2], fn {k, v} -> {k, -v} end)\n    [a: -1, b: -2]\n\n"}
{"completion":"","prompt":"Elixir.Enum.map_every(enumerable, nth, fun): Returns a list of results of invoking `fun` on every `nth`\nelement of `enumerable`, starting with the first element.\n\nThe first element is always passed to the given function, unless `nth` is `0`.\n\nThe second argument specifying every `nth` element must be a non-negative\ninteger.\n\nIf `nth` is `0`, then `enumerable` is directly converted to a list,\nwithout `fun` being ever applied.\n\n## Examples\n\n    iex> Enum.map_every(1..10, 2, fn x -> x + 1000 end)\n    [1001, 2, 1003, 4, 1005, 6, 1007, 8, 1009, 10]\n\n    iex> Enum.map_every(1..10, 3, fn x -> x + 1000 end)\n    [1001, 2, 3, 1004, 5, 6, 1007, 8, 9, 1010]\n\n    iex> Enum.map_every(1..5, 0, fn x -> x + 1000 end)\n    [1, 2, 3, 4, 5]\n\n    iex> Enum.map_every([1, 2, 3], 1, fn x -> x + 1000 end)\n    [1001, 1002, 1003]\n\n"}
{"completion":"","prompt":"Elixir.Enum.map_intersperse(enumerable, separator, mapper): Maps and intersperses the given enumerable in one pass.\n\n## Examples\n\n    iex> Enum.map_intersperse([1, 2, 3], :a, &(&1 * 2))\n    [2, :a, 4, :a, 6]\n"}
{"completion":"","prompt":"Elixir.Enum.map_join(enumerable, joiner \\\\ \"\", mapper): Maps and joins the given `enumerable` in one pass.\n\nIf `joiner` is not passed at all, it defaults to an empty string.\n\nAll elements returned from invoking the `mapper` must be convertible to\na string, otherwise an error is raised.\n\n## Examples\n\n    iex> Enum.map_join([1, 2, 3], &(&1 * 2))\n    \"246\"\n\n    iex> Enum.map_join([1, 2, 3], \" = \", &(&1 * 2))\n    \"2 = 4 = 6\"\n\n"}
{"completion":"","prompt":"Elixir.Enum.map_reduce(enumerable, acc, fun): Invokes the given function to each element in the `enumerable` to reduce\nit to a single element, while keeping an accumulator.\n\nReturns a tuple where the first element is the mapped enumerable and\nthe second one is the final accumulator.\n\nThe function, `fun`, receives two arguments: the first one is the\nelement, and the second one is the accumulator. `fun` must return\na tuple with two elements in the form of `{result, accumulator}`.\n\nFor maps, the first tuple element must be a `{key, value}` tuple.\n\n## Examples\n\n    iex> Enum.map_reduce([1, 2, 3], 0, fn x, acc -> {x * 2, x + acc} end)\n    {[2, 4, 6], 6}\n\n"}
{"completion":"","prompt":"Elixir.Enum.max(enumerable, sorter \\\\ &>=/2, empty_fallback \\\\ fn -> raise Enum.EmptyError end): Returns the maximal element in the `enumerable` according\nto Erlang's term ordering.\n\nBy default, the comparison is done with the `>=` sorter function.\nIf multiple elements are considered maximal, the first one that\nwas found is returned. If you want the last element considered\nmaximal to be returned, the sorter function should not return true\nfor equal elements.\n\nIf the enumerable is empty, the provided `empty_fallback` is called.\nThe default `empty_fallback` raises `Enum.EmptyError`.\n\n## Examples\n\n    iex> Enum.max([1, 2, 3])\n    3\n\nThe fact this function uses Erlang's term ordering means that the comparison\nis structural and not semantic. For example:\n\n    iex> Enum.max([~D[2017-03-31], ~D[2017-04-01]])\n    ~D[2017-03-31]\n\nIn the example above, `max/2` returned March 31st instead of April 1st\nbecause the structural comparison compares the day before the year.\nFor this reason, most structs provide a \"compare\" function, such as\n`Date.compare/2`, which receives two structs and returns `:lt` (less-than),\n`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the\nsorting function, Elixir will automatically use the `compare/2` function\nof said module:\n\n    iex> Enum.max([~D[2017-03-31], ~D[2017-04-01]], Date)\n    ~D[2017-04-01]\n\nFinally, if you don't want to raise on empty enumerables, you can pass\nthe empty fallback:\n\n    iex> Enum.max([], &>=/2, fn -> 0 end)\n    0\n\n"}
{"completion":"","prompt":"Elixir.Enum.max_by(enumerable, fun, sorter \\\\ &>=/2, empty_fallback \\\\ fn -> raise Enum.EmptyError end): Returns the maximal element in the `enumerable` as calculated\nby the given `fun`.\n\nBy default, the comparison is done with the `>=` sorter function.\nIf multiple elements are considered maximal, the first one that\nwas found is returned. If you want the last element considered\nmaximal to be returned, the sorter function should not return true\nfor equal elements.\n\nCalls the provided `empty_fallback` function and returns its value if\n`enumerable` is empty. The default `empty_fallback` raises `Enum.EmptyError`.\n\n## Examples\n\n    iex> Enum.max_by([\"a\", \"aa\", \"aaa\"], fn x -> String.length(x) end)\n    \"aaa\"\n\n    iex> Enum.max_by([\"a\", \"aa\", \"aaa\", \"b\", \"bbb\"], &String.length/1)\n    \"aaa\"\n\nThe fact this function uses Erlang's term ordering means that the\ncomparison is structural and not semantic. Therefore, if you want\nto compare structs, most structs provide a \"compare\" function, such as\n`Date.compare/2`, which receives two structs and returns `:lt` (less-than),\n`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the\nsorting function, Elixir will automatically use the `compare/2` function\nof said module:\n\n    iex> users = [\n    ...>   %{name: \"Ellis\", birthday: ~D[1943-05-11]},\n    ...>   %{name: \"Lovelace\", birthday: ~D[1815-12-10]},\n    ...>   %{name: \"Turing\", birthday: ~D[1912-06-23]}\n    ...> ]\n    iex> Enum.max_by(users, &(&1.birthday), Date)\n    %{name: \"Ellis\", birthday: ~D[1943-05-11]}\n\nFinally, if you don't want to raise on empty enumerables, you can pass\nthe empty fallback:\n\n    iex> Enum.max_by([], &String.length/1, fn -> nil end)\n    nil\n\n"}
{"completion":"","prompt":"Elixir.Enum.member?(enumerable, element): Checks if `element` exists within the `enumerable`.\n\nMembership is tested with the match (`===/2`) operator.\n\n## Examples\n\n    iex> Enum.member?(1..10, 5)\n    true\n    iex> Enum.member?(1..10, 5.0)\n    false\n\n    iex> Enum.member?([1.0, 2.0, 3.0], 2)\n    false\n    iex> Enum.member?([1.0, 2.0, 3.0], 2.000)\n    true\n\n    iex> Enum.member?([:a, :b, :c], :d)\n    false\n\n\nWhen called outside guards, the [`in`](`in/2`) and [`not in`](`in/2`)\noperators work by using this function.\n"}
{"completion":"","prompt":"Elixir.Enum.min(enumerable, sorter \\\\ &<=/2, empty_fallback \\\\ fn -> raise Enum.EmptyError end): Returns the minimal element in the `enumerable` according\nto Erlang's term ordering.\n\nBy default, the comparison is done with the `<=` sorter function.\nIf multiple elements are considered minimal, the first one that\nwas found is returned. If you want the last element considered\nminimal to be returned, the sorter function should not return true\nfor equal elements.\n\nIf the enumerable is empty, the provided `empty_fallback` is called.\nThe default `empty_fallback` raises `Enum.EmptyError`.\n\n## Examples\n\n    iex> Enum.min([1, 2, 3])\n    1\n\nThe fact this function uses Erlang's term ordering means that the comparison\nis structural and not semantic. For example:\n\n    iex> Enum.min([~D[2017-03-31], ~D[2017-04-01]])\n    ~D[2017-04-01]\n\nIn the example above, `min/2` returned April 1st instead of March 31st\nbecause the structural comparison compares the day before the year.\nFor this reason, most structs provide a \"compare\" function, such as\n`Date.compare/2`, which receives two structs and returns `:lt` (less-than),\n`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the\nsorting function, Elixir will automatically use the `compare/2` function\nof said module:\n\n    iex> Enum.min([~D[2017-03-31], ~D[2017-04-01]], Date)\n    ~D[2017-03-31]\n\nFinally, if you don't want to raise on empty enumerables, you can pass\nthe empty fallback:\n\n    iex> Enum.min([], fn -> 0 end)\n    0\n\n"}
{"completion":"","prompt":"Elixir.Enum.min_by(enumerable, fun, sorter \\\\ &<=/2, empty_fallback \\\\ fn -> raise Enum.EmptyError end): Returns the minimal element in the `enumerable` as calculated\nby the given `fun`.\n\nBy default, the comparison is done with the `<=` sorter function.\nIf multiple elements are considered minimal, the first one that\nwas found is returned. If you want the last element considered\nminimal to be returned, the sorter function should not return true\nfor equal elements.\n\nCalls the provided `empty_fallback` function and returns its value if\n`enumerable` is empty. The default `empty_fallback` raises `Enum.EmptyError`.\n\n## Examples\n\n    iex> Enum.min_by([\"a\", \"aa\", \"aaa\"], fn x -> String.length(x) end)\n    \"a\"\n\n    iex> Enum.min_by([\"a\", \"aa\", \"aaa\", \"b\", \"bbb\"], &String.length/1)\n    \"a\"\n\nThe fact this function uses Erlang's term ordering means that the\ncomparison is structural and not semantic. Therefore, if you want\nto compare structs, most structs provide a \"compare\" function, such as\n`Date.compare/2`, which receives two structs and returns `:lt` (less-than),\n`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the\nsorting function, Elixir will automatically use the `compare/2` function\nof said module:\n\n    iex> users = [\n    ...>   %{name: \"Ellis\", birthday: ~D[1943-05-11]},\n    ...>   %{name: \"Lovelace\", birthday: ~D[1815-12-10]},\n    ...>   %{name: \"Turing\", birthday: ~D[1912-06-23]}\n    ...> ]\n    iex> Enum.min_by(users, &(&1.birthday), Date)\n    %{name: \"Lovelace\", birthday: ~D[1815-12-10]}\n\nFinally, if you don't want to raise on empty enumerables, you can pass\nthe empty fallback:\n\n    iex> Enum.min_by([], &String.length/1, fn -> nil end)\n    nil\n\n"}
{"completion":"","prompt":"Elixir.Enum.min_max(enumerable, empty_fallback \\\\ fn -> raise Enum.EmptyError end): Returns a tuple with the minimal and the maximal elements in the\nenumerable according to Erlang's term ordering.\n\nIf multiple elements are considered maximal or minimal, the first one\nthat was found is returned.\n\nCalls the provided `empty_fallback` function and returns its value if\n`enumerable` is empty. The default `empty_fallback` raises `Enum.EmptyError`.\n\n## Examples\n\n    iex> Enum.min_max([2, 3, 1])\n    {1, 3}\n\n    iex> Enum.min_max([], fn -> {nil, nil} end)\n    {nil, nil}\n\n"}
{"completion":"","prompt":"Elixir.Enum.min_max_by(enumerable, fun, sorter_or_empty_fallback \\\\ &</2, empty_fallback \\\\ fn -> raise Enum.EmptyError end): Returns a tuple with the minimal and the maximal elements in the\nenumerable as calculated by the given function.\n\nIf multiple elements are considered maximal or minimal, the first one\nthat was found is returned.\n\n## Examples\n\n    iex> Enum.min_max_by([\"aaa\", \"bb\", \"c\"], fn x -> String.length(x) end)\n    {\"c\", \"aaa\"}\n\n    iex> Enum.min_max_by([\"aaa\", \"a\", \"bb\", \"c\", \"ccc\"], &String.length/1)\n    {\"a\", \"aaa\"}\n\n    iex> Enum.min_max_by([], &String.length/1, fn -> {nil, nil} end)\n    {nil, nil}\n\nThe fact this function uses Erlang's term ordering means that the\ncomparison is structural and not semantic. Therefore, if you want\nto compare structs, most structs provide a \"compare\" function, such as\n`Date.compare/2`, which receives two structs and returns `:lt` (less-than),\n`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the\nsorting function, Elixir will automatically use the `compare/2` function\nof said module:\n\n    iex> users = [\n    ...>   %{name: \"Ellis\", birthday: ~D[1943-05-11]},\n    ...>   %{name: \"Lovelace\", birthday: ~D[1815-12-10]},\n    ...>   %{name: \"Turing\", birthday: ~D[1912-06-23]}\n    ...> ]\n    iex> Enum.min_max_by(users, &(&1.birthday), Date)\n    {\n      %{name: \"Lovelace\", birthday: ~D[1815-12-10]},\n      %{name: \"Ellis\", birthday: ~D[1943-05-11]}\n    }\n\nFinally, if you don't want to raise on empty enumerables, you can pass\nthe empty fallback:\n\n    iex> Enum.min_max_by([], &String.length/1, fn -> nil end)\n    nil\n\n"}
{"completion":"","prompt":"Elixir.Enum.product(enumerable): Returns the product of all elements.\n\nRaises `ArithmeticError` if `enumerable` contains a non-numeric value.\n\n## Examples\n\n    iex> Enum.product([])\n    1\n    iex> Enum.product([2, 3, 4])\n    24\n    iex> Enum.product([2.0, 3.0, 4.0])\n    24.0\n\n"}
{"completion":"","prompt":"Elixir.Enum.random(enumerable): Returns a random element of an `enumerable`.\n\nRaises `Enum.EmptyError` if `enumerable` is empty.\n\nThis function uses Erlang's [`:rand` module](`:rand`) to calculate\nthe random value. Check its documentation for setting a\ndifferent random algorithm or a different seed.\n\nThe implementation is based on the\n[reservoir sampling](https://en.wikipedia.org/wiki/Reservoir_sampling#Relation_to_Fisher-Yates_shuffle)\nalgorithm.\nIt assumes that the sample being returned can fit into memory;\nthe input `enumerable` doesn't have to, as it is traversed just once.\n\nIf a range is passed into the function, this function will pick a\nrandom value between the range limits, without traversing the whole\nrange (thus executing in constant time and constant memory).\n\n## Examples\n\nThe examples below use the `:exsss` pseudorandom algorithm since it's\nthe default from Erlang/OTP 22:\n\n    # Although not necessary, let's seed the random algorithm\n    iex> :rand.seed(:exsss, {100, 101, 102})\n    iex> Enum.random([1, 2, 3])\n    2\n    iex> Enum.random([1, 2, 3])\n    1\n    iex> Enum.random(1..1_000)\n    309\n\n"}
{"completion":"","prompt":"Elixir.Enum.reduce(enumerable, fun): Invokes `fun` for each element in the `enumerable` with the\naccumulator.\n\nRaises `Enum.EmptyError` if `enumerable` is empty.\n\nThe first element of the `enumerable` is used as the initial value\nof the accumulator. Then, the function is invoked with the next\nelement and the accumulator. The result returned by the function\nis used as the accumulator for the next iteration, recursively.\nWhen the `enumerable` is done, the last accumulator is returned.\n\nSince the first element of the enumerable is used as the initial\nvalue of the accumulator, `fun` will only be executed `n - 1` times\nwhere `n` is the length of the enumerable. This function won't call\nthe specified function for enumerables that are one-element long.\n\nIf you wish to use another value for the accumulator, use\n`Enum.reduce/3`.\n\n## Examples\n\n    iex> Enum.reduce([1, 2, 3, 4], fn x, acc -> x * acc end)\n    24\n\n"}
{"completion":"","prompt":"Elixir.Enum.reduce(enumerable, acc, fun): Invokes `fun` for each element in the `enumerable` with the accumulator.\n\nThe initial value of the accumulator is `acc`. The function is invoked for\neach element in the enumerable with the accumulator. The result returned\nby the function is used as the accumulator for the next iteration.\nThe function returns the last accumulator.\n\n## Examples\n\n    iex> Enum.reduce([1, 2, 3], 0, fn x, acc -> x + acc end)\n    6\n\n## Reduce as a building block\n\nReduce (sometimes called `fold`) is a basic building block in functional\nprogramming. Almost all of the functions in the `Enum` module can be\nimplemented on top of reduce. Those functions often rely on other operations,\nsuch as `Enum.reverse/1`, which are optimized by the runtime.\n\nFor example, we could implement `map/2` in terms of `reduce/3` as follows:\n\n    def my_map(enumerable, fun) do\n      enumerable\n      |> Enum.reduce([], fn x, acc -> [fun.(x) | acc] end)\n      |> Enum.reverse()\n    end\n\nIn the example above, `Enum.reduce/3` accumulates the result of each call\nto `fun` into a list in reverse order, which is correctly ordered at the\nend by calling `Enum.reverse/1`.\n\nImplementing functions like `map/2`, `filter/2` and others are a good\nexercise for understanding the power behind `Enum.reduce/3`. When an\noperation cannot be expressed by any of the functions in the `Enum`\nmodule, developers will most likely resort to `reduce/3`.\n"}
{"completion":"","prompt":"Elixir.Enum.reduce_while(enumerable, acc, fun): Reduces `enumerable` until `fun` returns `{:halt, term}`.\n\nThe return value for `fun` is expected to be\n\n  * `{:cont, acc}` to continue the reduction with `acc` as the new\n    accumulator or\n  * `{:halt, acc}` to halt the reduction\n\nIf `fun` returns `{:halt, acc}` the reduction is halted and the function\nreturns `acc`. Otherwise, if the enumerable is exhausted, the function returns\nthe accumulator of the last `{:cont, acc}`.\n\n## Examples\n\n    iex> Enum.reduce_while(1..100, 0, fn x, acc ->\n    ...>   if x < 5, do: {:cont, acc + x}, else: {:halt, acc}\n    ...> end)\n    10\n    iex> Enum.reduce_while(1..100, 0, fn x, acc ->\n    ...>   if x > 0, do: {:cont, acc + x}, else: {:halt, acc}\n    ...> end)\n    5050\n\n"}
{"completion":"","prompt":"Elixir.Enum.reject(enumerable, fun): Returns a list of elements in `enumerable` excluding those for which the function `fun` returns\na truthy value.\n\nSee also `filter/2`.\n\n## Examples\n\n    iex> Enum.reject([1, 2, 3], fn x -> rem(x, 2) == 0 end)\n    [1, 3]\n\n"}
{"completion":"","prompt":"Elixir.Enum.reverse(enumerable): Returns a list of elements in `enumerable` in reverse order.\n\n## Examples\n\n    iex> Enum.reverse([1, 2, 3])\n    [3, 2, 1]\n\n"}
{"completion":"","prompt":"Elixir.Enum.reverse(enumerable, tail): Reverses the elements in `enumerable`, appends the `tail`, and returns\nit as a list.\n\nThis is an optimization for\n`enumerable |> Enum.reverse() |> Enum.concat(tail)`.\n\n## Examples\n\n    iex> Enum.reverse([1, 2, 3], [4, 5, 6])\n    [3, 2, 1, 4, 5, 6]\n\n"}
{"completion":"","prompt":"Elixir.Enum.reverse_slice(enumerable, start_index, count): Reverses the `enumerable` in the range from initial `start_index`\nthrough `count` elements.\n\nIf `count` is greater than the size of the rest of the `enumerable`,\nthen this function will reverse the rest of the enumerable.\n\n## Examples\n\n    iex> Enum.reverse_slice([1, 2, 3, 4, 5, 6], 2, 4)\n    [1, 2, 6, 5, 4, 3]\n\n"}
{"completion":"","prompt":"Elixir.Enum.scan(enumerable, fun): Applies the given function to each element in the `enumerable`,\nstoring the result in a list and passing it as the accumulator\nfor the next computation. Uses the first element in the `enumerable`\nas the starting value.\n\n## Examples\n\n    iex> Enum.scan(1..5, &(&1 + &2))\n    [1, 3, 6, 10, 15]\n\n"}
{"completion":"","prompt":"Elixir.Enum.scan(enumerable, acc, fun): Applies the given function to each element in the `enumerable`,\nstoring the result in a list and passing it as the accumulator\nfor the next computation. Uses the given `acc` as the starting value.\n\n## Examples\n\n    iex> Enum.scan(1..5, 0, &(&1 + &2))\n    [1, 3, 6, 10, 15]\n\n"}
{"completion":"","prompt":"Elixir.Enum.shuffle(enumerable): Returns a list with the elements of `enumerable` shuffled.\n\nThis function uses Erlang's [`:rand` module](`:rand`) to calculate\nthe random value. Check its documentation for setting a\ndifferent random algorithm or a different seed.\n\n## Examples\n\nThe examples below use the `:exsss` pseudorandom algorithm since it's\nthe default from Erlang/OTP 22:\n\n    # Although not necessary, let's seed the random algorithm\n    iex> :rand.seed(:exsss, {1, 2, 3})\n    iex> Enum.shuffle([1, 2, 3])\n    [3, 2, 1]\n    iex> Enum.shuffle([1, 2, 3])\n    [2, 1, 3]\n\n"}
{"completion":"","prompt":"Elixir.Enum.slice(enumerable, index_range): Returns a subset list of the given `enumerable` by `index_range`.\n\n`index_range` must be a `Range`. Given an `enumerable`, it drops\nelements before `index_range.first` (zero-base), then it takes elements\nuntil element `index_range.last` (inclusively).\n\nIndexes are normalized, meaning that negative indexes will be counted\nfrom the end (for example, `-1` means the last element of the `enumerable`).\n\nIf `index_range.last` is out of bounds, then it is assigned as the index\nof the last element.\n\nIf the normalized `index_range.first` is out of bounds of the given\n`enumerable`, or this one is greater than the normalized `index_range.last`,\nthen `[]` is returned.\n\nIf a step `n` (other than `1`) is used in `index_range`, then it takes\nevery `n`th element from `index_range.first` to `index_range.last`\n(according to the same rules described above).\n\n## Examples\n\n    iex> Enum.slice([1, 2, 3, 4, 5], 1..3)\n    [2, 3, 4]\n\n    iex> Enum.slice([1, 2, 3, 4, 5], 3..10)\n    [4, 5]\n\n    # Last three elements (negative indexes)\n    iex> Enum.slice([1, 2, 3, 4, 5], -3..-1)\n    [3, 4, 5]\n\nFor ranges where `start > stop`, you need to explicit\nmark them as increasing:\n\n    iex> Enum.slice([1, 2, 3, 4, 5], 1..-2//1)\n    [2, 3, 4]\n\nThe step can be any positive number. For example, to\nget every 2 elements of the collection:\n\n    iex> Enum.slice([1, 2, 3, 4, 5], 0..-1//2)\n    [1, 3, 5]\n\nTo get every third element of the first ten elements:\n\n    iex> integers = Enum.to_list(1..20)\n    iex> Enum.slice(integers, 0..9//3)\n    [1, 4, 7, 10]\n\nIf the first position is after the end of the enumerable\nor after the last position of the range, it returns an\nempty list:\n\n    iex> Enum.slice([1, 2, 3, 4, 5], 6..10)\n    []\n\n    # first is greater than last\n    iex> Enum.slice([1, 2, 3, 4, 5], 6..5)\n    []\n\n"}
{"completion":"","prompt":"Elixir.Enum.slice(enumerable, start_index, amount): Returns a subset list of the given `enumerable`, from `start_index` (zero-based)\nwith `amount` number of elements if available.\n\nGiven an `enumerable`, it drops elements right before element `start_index`;\nthen, it takes `amount` of elements, returning as many elements as possible if\nthere are not enough elements.\n\nA negative `start_index` can be passed, which means the `enumerable` is\nenumerated once and the index is counted from the end (for example,\n`-1` starts slicing from the last element).\n\nIt returns `[]` if `amount` is `0` or if `start_index` is out of bounds.\n\n## Examples\n\n    iex> Enum.slice(1..100, 5, 10)\n    [6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n\n    # amount to take is greater than the number of elements\n    iex> Enum.slice(1..10, 5, 100)\n    [6, 7, 8, 9, 10]\n\n    iex> Enum.slice(1..10, 5, 0)\n    []\n\n    # using a negative start index\n    iex> Enum.slice(1..10, -6, 3)\n    [5, 6, 7]\n    iex> Enum.slice(1..10, -11, 5)\n    [1, 2, 3, 4, 5]\n\n    # out of bound start index\n    iex> Enum.slice(1..10, 10, 5)\n    []\n\n"}
{"completion":"","prompt":"Elixir.Enum.slide(enumerable, range_or_single_index, insertion_index): Slides a single or multiple elements given by `range_or_single_index` from `enumerable`\nto `insertion_index`.\n\nThe semantics of the range to be moved match the semantics of `Enum.slice/2`.\nSpecifically, that means:\n\n * Indices are normalized, meaning that negative indexes will be counted from the end\n    (for example, -1 means the last element of the enumerable). This will result in *two*\n    traversals of your enumerable on types like lists that don't provide a constant-time count.\n\n  * If the normalized index range's `last` is out of bounds, the range is truncated to the last element.\n\n  * If the normalized index range's `first` is out of bounds, the selected range for sliding\n    will be empty, so you'll get back your input list.\n\n  * Decreasing ranges (such as `5..0//1`) also select an empty range to be moved,\n    so you'll get back your input list.\n\n  * Ranges with any step but 1 will raise an error.\n\n## Examples\n\n    # Slide a single element\n    iex> Enum.slide([:a, :b, :c, :d, :e, :f, :g], 5, 1)\n    [:a, :f, :b, :c, :d, :e, :g]\n\n    # Slide a range of elements backward\n    iex> Enum.slide([:a, :b, :c, :d, :e, :f, :g], 3..5, 1)\n    [:a, :d, :e, :f, :b, :c, :g]\n\n    # Slide a range of elements forward\n    iex> Enum.slide([:a, :b, :c, :d, :e, :f, :g], 1..3, 5)\n    [:a, :e, :f, :b, :c, :d, :g]\n\n    # Slide with negative indices (counting from the end)\n    iex> Enum.slide([:a, :b, :c, :d, :e, :f, :g], 3..-1//1, 2)\n    [:a, :b, :d, :e, :f, :g, :c]\n    iex> Enum.slide([:a, :b, :c, :d, :e, :f, :g], -4..-2, 1)\n    [:a, :d, :e, :f, :b, :c, :g]\n\n    # Insert at negative indices (counting from the end)\n    iex> Enum.slide([:a, :b, :c, :d, :e, :f, :g], 3, -1)\n    [:a, :b, :c, :e, :f, :g, :d]\n\n"}
{"completion":"","prompt":"Elixir.Enum.sort(enumerable): Sorts the `enumerable` according to Erlang's term ordering.\n\nThis function uses the merge sort algorithm. Do not use this\nfunction to sort structs, see `sort/2` for more information.\n\n## Examples\n\n    iex> Enum.sort([3, 2, 1])\n    [1, 2, 3]\n\n"}
{"completion":"","prompt":"Elixir.Enum.sort(enumerable, sorter): Sorts the `enumerable` by the given function.\n\nThis function uses the merge sort algorithm. The given function should compare\ntwo arguments, and return `true` if the first argument precedes or is in the\nsame place as the second one.\n\n## Examples\n\n    iex> Enum.sort([1, 2, 3], &(&1 >= &2))\n    [3, 2, 1]\n\nThe sorting algorithm will be stable as long as the given function\nreturns `true` for values considered equal:\n\n    iex> Enum.sort([\"some\", \"kind\", \"of\", \"monster\"], &(byte_size(&1) <= byte_size(&2)))\n    [\"of\", \"some\", \"kind\", \"monster\"]\n\nIf the function does not return `true` for equal values, the sorting\nis not stable and the order of equal terms may be shuffled.\nFor example:\n\n    iex> Enum.sort([\"some\", \"kind\", \"of\", \"monster\"], &(byte_size(&1) < byte_size(&2)))\n    [\"of\", \"kind\", \"some\", \"monster\"]\n\n## Ascending and descending (since v1.10.0)\n\n`sort/2` allows a developer to pass `:asc` or `:desc` as the sorter, which is a convenience for\n[`&<=/2`](`<=/2`) and [`&>=/2`](`>=/2`) respectively.\n\n    iex> Enum.sort([2, 3, 1], :asc)\n    [1, 2, 3]\n    iex> Enum.sort([2, 3, 1], :desc)\n    [3, 2, 1]\n\n## Sorting structs\n\nDo not use `</2`, `<=/2`, `>/2`, `>=/2` and friends when sorting structs.\nThat's because the built-in operators above perform structural comparison\nand not a semantic one. Imagine we sort the following list of dates:\n\n    iex> dates = [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]\n    iex> Enum.sort(dates)\n    [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]\n\nNote that the returned result is incorrect, because `sort/1` by default uses\n`<=/2`, which will compare their structure. When comparing structures, the\nfields are compared in alphabetical order, which means the dates above will\nbe compared by `day`, `month` and then `year`, which is the opposite of what\nwe want.\n\nFor this reason, most structs provide a \"compare\" function, such as\n`Date.compare/2`, which receives two structs and returns `:lt` (less-than),\n`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the\nsorting function, Elixir will automatically use the `compare/2` function\nof said module:\n\n    iex> dates = [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]\n    iex> Enum.sort(dates, Date)\n    [~D[2019-01-01], ~D[2019-06-06], ~D[2020-03-02]]\n\nTo retrieve all dates in descending order, you can wrap the module in\na tuple with `:asc` or `:desc` as first element:\n\n    iex> dates = [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]\n    iex> Enum.sort(dates, {:asc, Date})\n    [~D[2019-01-01], ~D[2019-06-06], ~D[2020-03-02]]\n    iex> dates = [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]\n    iex> Enum.sort(dates, {:desc, Date})\n    [~D[2020-03-02], ~D[2019-06-06], ~D[2019-01-01]]\n\n"}
{"completion":"","prompt":"Elixir.Enum.sort_by(enumerable, mapper, sorter \\\\ :asc): Sorts the mapped results of the `enumerable` according to the provided `sorter`\nfunction.\n\nThis function maps each element of the `enumerable` using the\nprovided `mapper` function. The enumerable is then sorted by\nthe mapped elements using the `sorter`, which defaults to `:asc`\nand sorts the elements ascendingly.\n\n`sort_by/3` differs from `sort/2` in that it only calculates the\ncomparison value for each element in the enumerable once instead of\nonce for each element in each comparison. If the same function is\nbeing called on both elements, it's more efficient to use `sort_by/3`.\n\n## Ascending and descending (since v1.10.0)\n\n`sort_by/3` allows a developer to pass `:asc` or `:desc` as the sorter,\nwhich is a convenience for [`&<=/2`](`<=/2`) and [`&>=/2`](`>=/2`) respectively:\n    iex> Enum.sort_by([2, 3, 1], &(&1), :asc)\n    [1, 2, 3]\n\n    iex> Enum.sort_by([2, 3, 1], &(&1), :desc)\n    [3, 2, 1]\n\n## Examples\n\nUsing the default `sorter` of `:asc` :\n\n    iex> Enum.sort_by([\"some\", \"kind\", \"of\", \"monster\"], &byte_size/1)\n    [\"of\", \"some\", \"kind\", \"monster\"]\n\nSorting by multiple properties - first by size, then by first letter\n(this takes advantage of the fact that tuples are compared element-by-element):\n\n    iex> Enum.sort_by([\"some\", \"kind\", \"of\", \"monster\"], &{byte_size(&1), String.first(&1)})\n    [\"of\", \"kind\", \"some\", \"monster\"]\n\nSimilar to `sort/2`, you can pass a custom sorter:\n\n    iex> Enum.sort_by([\"some\", \"kind\", \"of\", \"monster\"], &byte_size/1, :desc)\n    [\"monster\", \"some\", \"kind\", \"of\"]\n\nAs in `sort/2`, avoid using the default sorting function to sort\nstructs, as by default it performs structural comparison instead of\na semantic one. In such cases, you shall pass a sorting function as\nthird element or any module that implements a `compare/2` function.\nFor example, to sort users by their birthday in both ascending and\ndescending order respectively:\n\n    iex> users = [\n    ...>   %{name: \"Ellis\", birthday: ~D[1943-05-11]},\n    ...>   %{name: \"Lovelace\", birthday: ~D[1815-12-10]},\n    ...>   %{name: \"Turing\", birthday: ~D[1912-06-23]}\n    ...> ]\n    iex> Enum.sort_by(users, &(&1.birthday), Date)\n    [\n      %{name: \"Lovelace\", birthday: ~D[1815-12-10]},\n      %{name: \"Turing\", birthday: ~D[1912-06-23]},\n      %{name: \"Ellis\", birthday: ~D[1943-05-11]}\n    ]\n    iex> Enum.sort_by(users, &(&1.birthday), {:desc, Date})\n    [\n      %{name: \"Ellis\", birthday: ~D[1943-05-11]},\n      %{name: \"Turing\", birthday: ~D[1912-06-23]},\n      %{name: \"Lovelace\", birthday: ~D[1815-12-10]}\n    ]\n\n## Performance characteristics\n\nAs detailed in the initial section, `sort_by/3` calculates the comparison\nvalue for each element in the enumerable once instead of once for each\nelement in each comparison. This implies `sort_by/3` must do an initial\npass on the data to compute those values.\n\nHowever, if those values are cheap to compute, for example, you have\nalready extracted the field you want to sort by into a tuple, then those\nextra passes become overhead. In such cases, consider using `List.keysort/3`\ninstead.\n\nLet's see an example. Imagine you have a list of products and you have a\nlist of IDs. You want to keep all products that are in the given IDs and\nreturn their names sorted by their price. You could write it like this:\n\n    for(\n      product <- products,\n      product.id in ids,\n      do: product\n    )\n    |> Enum.sort_by(& &1.price)\n    |> Enum.map(& &1.name)\n\nHowever, you could also write it like this:\n\n    for(\n      product <- products,\n      product.id in ids,\n      do: {product.name, product.price}\n    )\n    |> List.keysort(1)\n    |> Enum.map(&elem(&1, 0))\n\nUsing `List.keysort/3` will be a better choice for performance sensitive\ncode as it avoids additional traversals.\n"}
{"completion":"","prompt":"Elixir.Enum.split(enumerable, count): Splits the `enumerable` into two enumerables, leaving `count`\nelements in the first one.\n\nIf `count` is a negative number, it starts counting from the\nback to the beginning of the `enumerable`.\n\nBe aware that a negative `count` implies the `enumerable`\nwill be enumerated twice: once to calculate the position, and\na second time to do the actual splitting.\n\n## Examples\n\n    iex> Enum.split([1, 2, 3], 2)\n    {[1, 2], [3]}\n\n    iex> Enum.split([1, 2, 3], 10)\n    {[1, 2, 3], []}\n\n    iex> Enum.split([1, 2, 3], 0)\n    {[], [1, 2, 3]}\n\n    iex> Enum.split([1, 2, 3], -1)\n    {[1, 2], [3]}\n\n    iex> Enum.split([1, 2, 3], -5)\n    {[], [1, 2, 3]}\n\n"}
{"completion":"","prompt":"Elixir.Enum.split_while(enumerable, fun): Splits enumerable in two at the position of the element for which\n`fun` returns a falsy value (`false` or `nil`) for the first time.\n\nIt returns a two-element tuple with two lists of elements.\nThe element that triggered the split is part of the second list.\n\n## Examples\n\n    iex> Enum.split_while([1, 2, 3, 4], fn x -> x < 3 end)\n    {[1, 2], [3, 4]}\n\n    iex> Enum.split_while([1, 2, 3, 4], fn x -> x < 0 end)\n    {[], [1, 2, 3, 4]}\n\n    iex> Enum.split_while([1, 2, 3, 4], fn x -> x > 0 end)\n    {[1, 2, 3, 4], []}\n\n"}
{"completion":"","prompt":"Elixir.Enum.split_with(enumerable, fun): Splits the `enumerable` in two lists according to the given function `fun`.\n\nSplits the given `enumerable` in two lists by calling `fun` with each element\nin the `enumerable` as its only argument. Returns a tuple with the first list\ncontaining all the elements in `enumerable` for which applying `fun` returned\na truthy value, and a second list with all the elements for which applying\n`fun` returned a falsy value (`false` or `nil`).\n\nThe elements in both the returned lists are in the same relative order as they\nwere in the original enumerable (if such enumerable was ordered, like a\nlist). See the examples below.\n\n## Examples\n\n    iex> Enum.split_with([5, 4, 3, 2, 1, 0], fn x -> rem(x, 2) == 0 end)\n    {[4, 2, 0], [5, 3, 1]}\n\n    iex> Enum.split_with(%{a: 1, b: -2, c: 1, d: -3}, fn {_k, v} -> v < 0 end)\n    {[b: -2, d: -3], [a: 1, c: 1]}\n\n    iex> Enum.split_with(%{a: 1, b: -2, c: 1, d: -3}, fn {_k, v} -> v > 50 end)\n    {[], [a: 1, b: -2, c: 1, d: -3]}\n\n    iex> Enum.split_with(%{}, fn {_k, v} -> v > 50 end)\n    {[], []}\n\n"}
{"completion":"","prompt":"Elixir.Enum.sum(enumerable): Returns the sum of all elements.\n\nRaises `ArithmeticError` if `enumerable` contains a non-numeric value.\n\n## Examples\n\n    iex> Enum.sum([1, 2, 3])\n    6\n\n    iex> Enum.sum(1..10)\n    55\n\n    iex> Enum.sum(1..10//2)\n    25\n\n"}
{"completion":"","prompt":"Elixir.Enum.take(enumerable, amount): Takes an `amount` of elements from the beginning or the end of the `enumerable`.\n\nIf a positive `amount` is given, it takes the `amount` elements from the\nbeginning of the `enumerable`.\n\nIf a negative `amount` is given, the `amount` of elements will be taken from the end.\nThe `enumerable` will be enumerated once to retrieve the proper index and\nthe remaining calculation is performed from the end.\n\nIf amount is `0`, it returns `[]`.\n\n## Examples\n\n    iex> Enum.take([1, 2, 3], 2)\n    [1, 2]\n\n    iex> Enum.take([1, 2, 3], 10)\n    [1, 2, 3]\n\n    iex> Enum.take([1, 2, 3], 0)\n    []\n\n    iex> Enum.take([1, 2, 3], -1)\n    [3]\n\n"}
{"completion":"","prompt":"Elixir.Enum.take_every(enumerable, nth): Returns a list of every `nth` element in the `enumerable`,\nstarting with the first element.\n\nThe first element is always included, unless `nth` is 0.\n\nThe second argument specifying every `nth` element must be a non-negative\ninteger.\n\n## Examples\n\n    iex> Enum.take_every(1..10, 2)\n    [1, 3, 5, 7, 9]\n\n    iex> Enum.take_every(1..10, 0)\n    []\n\n    iex> Enum.take_every([1, 2, 3], 1)\n    [1, 2, 3]\n\n"}
{"completion":"","prompt":"Elixir.Enum.take_random(enumerable, count): Takes `count` random elements from `enumerable`.\n\nNote that this function will traverse the whole `enumerable` to\nget the random sublist.\n\nSee `random/1` for notes on implementation and random seed.\n\n## Examples\n\n    # Although not necessary, let's seed the random algorithm\n    iex> :rand.seed(:exsss, {1, 2, 3})\n    iex> Enum.take_random(1..10, 2)\n    [3, 1]\n    iex> Enum.take_random(?a..?z, 5)\n    'mikel'\n\n"}
{"completion":"","prompt":"Elixir.Enum.take_while(enumerable, fun): Takes the elements from the beginning of the `enumerable` while `fun` returns\na truthy value.\n\n## Examples\n\n    iex> Enum.take_while([1, 2, 3], fn x -> x < 3 end)\n    [1, 2]\n\n"}
{"completion":"","prompt":"Elixir.Enum.to_list(enumerable): Converts `enumerable` to a list.\n\n## Examples\n\n    iex> Enum.to_list(1..3)\n    [1, 2, 3]\n\n"}
{"completion":"","prompt":"Elixir.Enum.uniq(enumerable): Enumerates the `enumerable`, removing all duplicated elements.\n\n## Examples\n\n    iex> Enum.uniq([1, 2, 3, 3, 2, 1])\n    [1, 2, 3]\n\n"}
{"completion":"","prompt":"Elixir.Enum.uniq_by(enumerable, fun): Enumerates the `enumerable`, by removing the elements for which\nfunction `fun` returned duplicate elements.\n\nThe function `fun` maps every element to a term. Two elements are\nconsidered duplicates if the return value of `fun` is equal for\nboth of them.\n\nThe first occurrence of each element is kept.\n\n## Example\n\n    iex> Enum.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end)\n    [{1, :x}, {2, :y}]\n\n    iex> Enum.uniq_by([a: {:tea, 2}, b: {:tea, 2}, c: {:coffee, 1}], fn {_, y} -> y end)\n    [a: {:tea, 2}, c: {:coffee, 1}]\n\n"}
{"completion":"","prompt":"Elixir.Enum.unzip(list): Opposite of `zip/2`. Extracts two-element tuples from the\ngiven `enumerable` and groups them together.\n\nIt takes an `enumerable` with elements being two-element tuples and returns\na tuple with two lists, each of which is formed by the first and\nsecond element of each tuple, respectively.\n\nThis function fails unless `enumerable` is or can be converted into a\nlist of tuples with *exactly* two elements in each tuple.\n\n## Examples\n\n    iex> Enum.unzip([{:a, 1}, {:b, 2}, {:c, 3}])\n    {[:a, :b, :c], [1, 2, 3]}\n\n    iex> Enum.unzip(%{a: 1, b: 2})\n    {[:a, :b], [1, 2]}\n\n"}
{"completion":"","prompt":"Elixir.Enum.with_index(enumerable, fun_or_offset \\\\ 0): Returns the `enumerable` with each element wrapped in a tuple\nalongside its index.\n\nMay receive a function or an integer offset.\n\nIf an `offset` is given, it will index from the given offset instead of from\nzero.\n\nIf a `function` is given, it will index by invoking the function for each\nelement and index (zero-based) of the enumerable.\n\n## Examples\n\n    iex> Enum.with_index([:a, :b, :c])\n    [a: 0, b: 1, c: 2]\n\n    iex> Enum.with_index([:a, :b, :c], 3)\n    [a: 3, b: 4, c: 5]\n\n    iex> Enum.with_index([:a, :b, :c], fn element, index -> {index, element} end)\n    [{0, :a}, {1, :b}, {2, :c}]\n\n"}
{"completion":"","prompt":"Elixir.Enum.zip(enumerables): Zips corresponding elements from a finite collection of enumerables\ninto a list of tuples.\n\nThe zipping finishes as soon as any enumerable in the given collection completes.\n\n## Examples\n\n    iex> Enum.zip([[1, 2, 3], [:a, :b, :c], [\"foo\", \"bar\", \"baz\"]])\n    [{1, :a, \"foo\"}, {2, :b, \"bar\"}, {3, :c, \"baz\"}]\n\n    iex> Enum.zip([[1, 2, 3, 4, 5], [:a, :b, :c]])\n    [{1, :a}, {2, :b}, {3, :c}]\n\n"}
{"completion":"","prompt":"Elixir.Enum.zip(enumerable1, enumerable2): Zips corresponding elements from two enumerables into a list\nof tuples.\n\nThe zipping finishes as soon as either enumerable completes.\n\n## Examples\n\n    iex> Enum.zip([1, 2, 3], [:a, :b, :c])\n    [{1, :a}, {2, :b}, {3, :c}]\n\n    iex> Enum.zip([1, 2, 3, 4, 5], [:a, :b, :c])\n    [{1, :a}, {2, :b}, {3, :c}]\n\n"}
{"completion":"","prompt":"Elixir.Enum.zip_reduce(enums, acc, reducer): Reduces over all of the given enumerables, halting as soon as any enumerable is\nempty.\n\nThe reducer will receive 2 args: a list of elements (one from each enum) and the\naccumulator.\n\nIn practice, the behaviour provided by this function can be achieved with:\n\n    Enum.reduce(Stream.zip(enums), acc, reducer)\n\nBut `zip_reduce/3` exists for convenience purposes.\n\n## Examples\n\n    iex> enums = [[1, 1], [2, 2], [3, 3]]\n    ...>  Enum.zip_reduce(enums, [], fn elements, acc ->\n    ...>    [List.to_tuple(elements) | acc]\n    ...> end)\n    [{1, 2, 3}, {1, 2, 3}]\n\n    iex> enums = [[1, 2], %{a: 3, b: 4}, [5, 6]]\n    ...> Enum.zip_reduce(enums, [], fn elements, acc ->\n    ...>   [List.to_tuple(elements) | acc]\n    ...> end)\n    [{2, {:b, 4}, 6}, {1, {:a, 3}, 5}]\n"}
{"completion":"","prompt":"Elixir.Enum.zip_reduce(left, right, acc, reducer): Reduces over two enumerables halting as soon as either enumerable is empty.\n\nIn practice, the behaviour provided by this function can be achieved with:\n\n    Enum.reduce(Stream.zip(left, right), acc, reducer)\n\nBut `zip_reduce/4` exists for convenience purposes.\n\n## Examples\n\n    iex> Enum.zip_reduce([1, 2], [3, 4], 0, fn x, y, acc -> x + y + acc end)\n    10\n\n    iex> Enum.zip_reduce([1, 2], [3, 4], [], fn x, y, acc -> [x + y | acc] end)\n    [6, 4]\n"}
{"completion":"","prompt":"Elixir.Enum.zip_with(enumerables, zip_fun): Zips corresponding elements from a finite collection of enumerables\ninto list, transforming them with the `zip_fun` function as it goes.\n\nThe first element from each of the enums in `enumerables` will be put\ninto a list which is then passed to the one-arity `zip_fun` function.\nThen, the second elements from each of the enums are put into a list\nand passed to `zip_fun`, and so on until any one of the enums in\n`enumerables` runs out of elements.\n\nReturns a list with all the results of calling `zip_fun`.\n\n## Examples\n\n    iex> Enum.zip_with([[1, 2], [3, 4], [5, 6]], fn [x, y, z] -> x + y + z end)\n    [9, 12]\n\n    iex> Enum.zip_with([[1, 2], [3, 4]], fn [x, y] -> x + y end)\n    [4, 6]\n\n"}
{"completion":"","prompt":"Elixir.Enum.zip_with(enumerable1, enumerable2, zip_fun): Zips corresponding elements from two enumerables into a list, transforming them with\nthe `zip_fun` function as it goes.\n\nThe corresponding elements from each collection are passed to the provided two-arity `zip_fun`\nfunction in turn. Returns a list that contains the result of calling `zip_fun` for each pair of\nelements.\n\nThe zipping finishes as soon as either enumerable runs out of elements.\n\n## Zipping Maps\n\nIt's important to remember that zipping inherently relies on order.\nIf you zip two lists you get the element at the index from each list in turn.\nIf we zip two maps together it's tempting to think that you will get the given\nkey in the left map and the matching key in the right map, but there is no such\nguarantee because map keys are not ordered! Consider the following:\n\n    left =  %{:a => 1, 1 => 3}\n    right = %{:a => 1, :b => :c}\n    Enum.zip(left, right)\n    # [{{1, 3}, {:a, 1}}, {{:a, 1}, {:b, :c}}]\n\nAs you can see `:a` does not get paired with `:a`. If this is what you want,\nyou should use `Map.merge/3`.\n\n## Examples\n\n    iex> Enum.zip_with([1, 2], [3, 4], fn x, y -> x + y end)\n    [4, 6]\n\n    iex> Enum.zip_with([1, 2], [3, 4, 5, 6], fn x, y -> x + y end)\n    [4, 6]\n\n    iex> Enum.zip_with([1, 2, 5, 6], [3, 4], fn x, y -> x + y end)\n    [4, 6]\n\n"}
{"completion":"","prompt":"Elixir.Enumerable.count(enumerable): Retrieves the number of elements in the `enumerable`.\n\nIt should return `{:ok, count}` if you can count the number of elements\nin `enumerable` in a faster way than fully traversing it.\n\nOtherwise it should return `{:error, __MODULE__}` and a default algorithm\nbuilt on top of `reduce/3` that runs in linear time will be used.\n"}
{"completion":"","prompt":"Elixir.Enumerable.member?(enumerable, element): Checks if an `element` exists within the `enumerable`.\n\nIt should return `{:ok, boolean}` if you can check the membership of a\ngiven element in `enumerable` with `===/2` without traversing the whole\nof it.\n\nOtherwise it should return `{:error, __MODULE__}` and a default algorithm\nbuilt on top of `reduce/3` that runs in linear time will be used.\n\nWhen called outside guards, the [`in`](`in/2`) and [`not in`](`in/2`)\noperators work by using this function.\n"}
{"completion":"","prompt":"Elixir.Enumerable.reduce(enumerable, acc, fun): Reduces the `enumerable` into an element.\n\nMost of the operations in `Enum` are implemented in terms of reduce.\nThis function should apply the given `t:reducer/0` function to each\nelement in the `enumerable` and proceed as expected by the returned\naccumulator.\n\nSee the documentation of the types `t:result/0` and `t:acc/0` for\nmore information.\n\n## Examples\n\nAs an example, here is the implementation of `reduce` for lists:\n\n    def reduce(_list, {:halt, acc}, _fun), do: {:halted, acc}\n    def reduce(list, {:suspend, acc}, fun), do: {:suspended, acc, &reduce(list, &1, fun)}\n    def reduce([], {:cont, acc}, _fun), do: {:done, acc}\n    def reduce([head | tail], {:cont, acc}, fun), do: reduce(tail, fun.(head, acc), fun)\n\n"}
{"completion":"","prompt":"Elixir.Enumerable.slice(enumerable): Returns a function that slices the data structure contiguously.\n\nIt should return either:\n\n  * `{:ok, size, slicing_fun}` - if the `enumerable` has a known\n    bound and can access a position in the `enumerable` without\n    traversing all previous elements. The `slicing_fun` will receive\n    a `start` position, the `amount` of elements to fetch, and a\n    `step`.\n\n  * `{:ok, size, to_list_fun}` - if the `enumerable` has a known bound\n    and can access a position in the `enumerable` by first converting\n    it to a list via `to_list_fun`.\n\n  * `{:error, __MODULE__}` - the enumerable cannot be sliced efficiently\n    and a default algorithm built on top of `reduce/3` that runs in\n    linear time will be used.\n\n## Differences to `count/1`\n\nThe `size` value returned by this function is used for boundary checks,\ntherefore it is extremely important that this function only returns `:ok`\nif retrieving the `size` of the `enumerable` is cheap, fast, and takes\nconstant time. Otherwise the simplest of operations, such as\n`Enum.at(enumerable, 0)`, will become too expensive.\n\nOn the other hand, the `count/1` function in this protocol should be\nimplemented whenever you can count the number of elements in the collection\nwithout traversing it.\n"}
{"completion":"","prompt":"Elixir.Exception.blame(kind, error, stacktrace): Attaches information to exceptions for extra debugging.\n\nThis operation is potentially expensive, as it reads data\nfrom the file system, parses beam files, evaluates code and\nso on.\n\nIf the exception module implements the optional `c:blame/2`\ncallback, it will be invoked to perform the computation.\n"}
{"completion":"","prompt":"Elixir.Exception.blame_mfa(module, function, args): Blames the invocation of the given module, function and arguments.\n\nThis function will retrieve the available clauses from bytecode\nand evaluate them against the given arguments. The clauses are\nreturned as a list of `{args, guards}` pairs where each argument\nand each top-level condition in a guard separated by `and`/`or`\nis wrapped in a tuple with blame metadata.\n\nThis function returns either `{:ok, definition, clauses}` or `:error`.\nWhere `definition` is `:def`, `:defp`, `:defmacro` or `:defmacrop`.\n"}
{"completion":"","prompt":"Elixir.Exception.exception?(term): Returns `true` if the given `term` is an exception.\n"}
{"completion":"","prompt":"Elixir.Exception.format(kind, payload, stacktrace \\\\ []): Normalizes and formats throw/errors/exits and stacktraces.\n\nIt relies on `format_banner/3` and `format_stacktrace/1`\nto generate the final format.\n\nIf `kind` is `{:EXIT, pid}`, it does not generate a stacktrace,\nas such exits are retrieved as messages without stacktraces.\n"}
{"completion":"","prompt":"Elixir.Exception.format_banner(kind, exception, stacktrace \\\\ []): Normalizes and formats any throw/error/exit.\n\nThe message is formatted and displayed in the same\nformat as used by Elixir's CLI.\n\nThe third argument is the stacktrace which is used to enrich\na normalized error with more information. It is only used when\nthe kind is an error.\n"}
{"completion":"","prompt":"Elixir.Exception.format_exit(reason): Formats an exit. It returns a string.\n\nOften there are errors/exceptions inside exits. Exits are often\nwrapped by the caller and provide stacktraces too. This function\nformats exits in a way to nicely show the exit reason, caller\nand stacktrace.\n"}
{"completion":"","prompt":"Elixir.Exception.format_fa(fun, arity): Receives an anonymous function and arity and formats it as\nshown in stacktraces. The arity may also be a list of arguments.\n\n## Examples\n\n    Exception.format_fa(fn -> nil end, 1)\n    #=> \"#Function<...>/1\"\n\n"}
{"completion":"","prompt":"Elixir.Exception.format_file_line(file, line, suffix \\\\ \"\"): Formats the given `file` and `line` as shown in stacktraces.\n\nIf any of the values are `nil`, they are omitted.\n\n## Examples\n\n    iex> Exception.format_file_line(\"foo\", 1)\n    \"foo:1:\"\n\n    iex> Exception.format_file_line(\"foo\", nil)\n    \"foo:\"\n\n    iex> Exception.format_file_line(nil, nil)\n    \"\"\n\n"}
{"completion":"","prompt":"Elixir.Exception.format_file_line_column(file, line, column, suffix \\\\ \"\"): Formats the given `file`, `line`, and `column` as shown in stacktraces.\n\nIf any of the values are `nil`, they are omitted.\n\n## Examples\n\n    iex> Exception.format_file_line_column(\"foo\", 1, 2)\n    \"foo:1:2:\"\n\n    iex> Exception.format_file_line_column(\"foo\", 1, nil)\n    \"foo:1:\"\n\n    iex> Exception.format_file_line_column(\"foo\", nil, nil)\n    \"foo:\"\n\n    iex> Exception.format_file_line_column(\"foo\", nil, 2)\n    \"foo:\"\n\n    iex> Exception.format_file_line_column(nil, nil, nil)\n    \"\"\n\n"}
{"completion":"","prompt":"Elixir.Exception.format_mfa(module, fun, arity): Receives a module, fun and arity and formats it\nas shown in stacktraces. The arity may also be a list\nof arguments.\n\n## Examples\n\n    iex> Exception.format_mfa(Foo, :bar, 1)\n    \"Foo.bar/1\"\n\n    iex> Exception.format_mfa(Foo, :bar, [])\n    \"Foo.bar()\"\n\n    iex> Exception.format_mfa(nil, :bar, [])\n    \"nil.bar()\"\n\nAnonymous functions are reported as -func/arity-anonfn-count-,\nwhere func is the name of the enclosing function. Convert to\n\"anonymous fn in func/arity\"\n"}
{"completion":"","prompt":"Elixir.Exception.format_stacktrace(trace \\\\ nil): Formats the stacktrace.\n\nA stacktrace must be given as an argument. If not, the stacktrace\nis retrieved from `Process.info/2`.\n"}
{"completion":"","prompt":"Elixir.Exception.format_stacktrace_entry(entry): Receives a stacktrace entry and formats it into a string.\n"}
{"completion":"","prompt":"Elixir.Exception.message(exception): Gets the message for an `exception`.\n"}
{"completion":"","prompt":"Elixir.Exception.normalize(kind, payload, stacktrace \\\\ []): Normalizes an exception, converting Erlang exceptions\nto Elixir exceptions.\n\nIt takes the `kind` spilled by `catch` as an argument and\nnormalizes only `:error`, returning the untouched payload\nfor others.\n\nThe third argument is the stacktrace which is used to enrich\na normalized error with more information. It is only used when\nthe kind is an error.\n"}
{"completion":"","prompt":"Elixir.File.Stat.from_record(file_info): Converts a `:file_info` record into a `File.Stat`.\n"}
{"completion":"","prompt":"Elixir.File.Stat.to_record(stat): Converts a `File.Stat` struct to a `:file_info` record.\n"}
{"completion":"","prompt":"Elixir.File.cd(path): Sets the current working directory.\n\nThe current working directory is set for the BEAM globally. This can lead to\nrace conditions if multiple processes are changing the current working\ndirectory concurrently. To run an external command in a given directory\nwithout changing the global current working directory, use the `:cd` option\nof `System.cmd/3` and `Port.open/2`.\n\nReturns `:ok` if successful, `{:error, reason}` otherwise.\n"}
{"completion":"","prompt":"Elixir.File.cd!(path): The same as `cd/1`, but raises a `File.Error` exception if it fails.\n"}
{"completion":"","prompt":"Elixir.File.cd!(path, function): Changes the current directory to the given `path`,\nexecutes the given function and then reverts back\nto the previous path regardless of whether there is an exception.\n\nThe current working directory is temporarily set for the BEAM globally. This\ncan lead to race conditions if multiple processes are changing the current\nworking directory concurrently. To run an external command in a given\ndirectory without changing the global current working directory, use the\n`:cd` option of `System.cmd/3` and `Port.open/2`.\n\nRaises an error if retrieving or changing the current\ndirectory fails.\n"}
{"completion":"","prompt":"Elixir.File.chgrp(path, gid): Changes the group given by the group ID `gid`\nfor a given `file`. Returns `:ok` on success, or\n`{:error, reason}` on failure.\n"}
{"completion":"","prompt":"Elixir.File.chgrp!(path, gid): Same as `chgrp/2`, but raises a `File.Error` exception in case of failure.\nOtherwise `:ok`.\n"}
{"completion":"","prompt":"Elixir.File.chmod(path, mode): Changes the `mode` for a given `file`.\n\nReturns `:ok` on success, or `{:error, reason}` on failure.\n\n## Permissions\n\nFile permissions are specified by adding together the following octal modes:\n\n  * `0o400` - read permission: owner\n  * `0o200` - write permission: owner\n  * `0o100` - execute permission: owner\n\n  * `0o040` - read permission: group\n  * `0o020` - write permission: group\n  * `0o010` - execute permission: group\n\n  * `0o004` - read permission: other\n  * `0o002` - write permission: other\n  * `0o001` - execute permission: other\n\nFor example, setting the mode `0o755` gives it\nwrite, read and execute permission to the owner\nand both read and execute permission to group\nand others.\n"}
{"completion":"","prompt":"Elixir.File.chmod!(path, mode): Same as `chmod/2`, but raises a `File.Error` exception in case of failure.\nOtherwise `:ok`.\n"}
{"completion":"","prompt":"Elixir.File.chown(path, uid): Changes the owner given by the user ID `uid`\nfor a given `file`. Returns `:ok` on success,\nor `{:error, reason}` on failure.\n"}
{"completion":"","prompt":"Elixir.File.chown!(path, uid): Same as `chown/2`, but raises a `File.Error` exception in case of failure.\nOtherwise `:ok`.\n"}
{"completion":"","prompt":"Elixir.File.close(io_device): Closes the file referenced by `io_device`. It mostly returns `:ok`, except\nfor some severe errors such as out of memory.\n\nNote that if the option `:delayed_write` was used when opening the file,\n`close/1` might return an old write error and not even try to close the file.\nSee `open/2` for more information.\n"}
{"completion":"","prompt":"Elixir.File.copy(source, destination, bytes_count \\\\ :infinity): Copies the contents of `source` to `destination`.\n\nBoth parameters can be a filename or an IO device opened\nwith `open/2`. `bytes_count` specifies the number of\nbytes to copy, the default being `:infinity`.\n\nIf file `destination` already exists, it is overwritten\nby the contents in `source`.\n\nReturns `{:ok, bytes_copied}` if successful,\n`{:error, reason}` otherwise.\n\nCompared to the `cp/3`, this function is more low-level,\nallowing a copy from device to device limited by a number of\nbytes. On the other hand, `cp/3` performs more extensive\nchecks on both source and destination and it also preserves\nthe file mode after copy.\n\nTypical error reasons are the same as in `open/2`,\n`read/1` and `write/3`.\n"}
{"completion":"","prompt":"Elixir.File.copy!(source, destination, bytes_count \\\\ :infinity): The same as `copy/3` but raises a `File.CopyError` exception if it fails.\nReturns the `bytes_copied` otherwise.\n"}
{"completion":"","prompt":"Elixir.File.cp(source_file, destination_file, options \\\\ []): Copies the contents of `source_file` to `destination_file` preserving its modes.\n\n`source_file` must be a file or a symbolic link to one. `destination_file` must\nbe a path to a non-existent file. If either is a directory, `{:error, :eisdir}`\nwill be returned.\n\nThe function returns `:ok` in case of success. Otherwise, it returns\n`{:error, reason}`.\n\nIf you want to copy contents from an IO device to another device\nor do a straight copy from a source to a destination without\npreserving modes, check `copy/3` instead.\n\nNote: The command `cp` in Unix-like systems behaves differently depending on\nwhether the destination is an existing directory or not. We have chosen to\nexplicitly disallow copying to a destination which is a directory,\nand an error will be returned if tried.\n\n## Options\n\n  * `:on_conflict` - (since v1.14.0) Invoked when a file already exists in the destination.\n    The function receives arguments for `source_file` and `destination_file`. It should\n    return `true` if the existing file should be overwritten, `false` if otherwise.\n    The default callback returns `true`. On earlier versions, this callback could be\n    given as third argument, but such behaviour is now deprecated.\n\n"}
{"completion":"","prompt":"Elixir.File.cp!(source_file, destination_file, options \\\\ []): The same as `cp/3`, but raises a `File.CopyError` exception if it fails.\nReturns `:ok` otherwise.\n"}
{"completion":"","prompt":"Elixir.File.cp_r(source, destination, options \\\\ []): Copies the contents in `source` to `destination` recursively, maintaining the\nsource directory structure and modes.\n\nIf `source` is a file or a symbolic link to it, `destination` must be a path\nto an existent file, a symbolic link to one, or a path to a non-existent file.\n\nIf `source` is a directory, or a symbolic link to it, then `destination` must\nbe an existent `directory` or a symbolic link to one, or a path to a non-existent directory.\n\nIf the source is a file, it copies `source` to `destination`. If the `source`\nis a directory, it copies the contents inside source into the `destination` directory.\n\nIf a file already exists in the destination, it invokes the optional `on_conflict`\ncallback given as an option. See \"Options\" for more information.\n\nThis function may fail while copying files, in such cases, it will leave the\ndestination directory in a dirty state, where file which have already been\ncopied won't be removed.\n\nThe function returns `{:ok, files_and_directories}` in case of\nsuccess, `files_and_directories` lists all files and directories copied in no\nspecific order. It returns `{:error, reason, file}` otherwise.\n\nNote: The command `cp` in Unix-like systems behaves differently depending on\nwhether `destination` is an existing directory or not. We have chosen to\nexplicitly disallow this behaviour. If `source` is a `file` and `destination`\nis a directory, `{:error, :eisdir}` will be returned.\n\n## Options\n\n  * `:on_conflict` - (since v1.14.0) Invoked when a file already exists in the destination.\n    The function receives arguments for `source` and `destination`. It should return\n    `true` if the existing file should be overwritten, `false` if otherwise. The default\n    callback returns `true`. On earlier versions, this callback could be given as third\n    argument, but such behaviour is now deprecated.\n\n  * `:dereference_symlinks` - (since v1.14.0) By default, this function will copy symlinks\n    by creating symlinks that point to the same location. This option forces symlinks to be\n    dereferenced and have their contents copied instead when set to `true`. If the dereferenced\n    files do not exist, than the operation fails. The default is `false`.\n\n## Examples\n\n    # Copies file \"a.txt\" to \"b.txt\"\n    File.cp_r(\"a.txt\", \"b.txt\")\n\n    # Copies all files in \"samples\" to \"tmp\"\n    File.cp_r(\"samples\", \"tmp\")\n\n    # Same as before, but asks the user how to proceed in case of conflicts\n    File.cp_r(\"samples\", \"tmp\", on_conflict: fn source, destination ->\n      IO.gets(\"Overwriting #{destination} by #{source}. Type y to confirm. \") == \"y\\n\"\n    end)\n\n"}
{"completion":"","prompt":"Elixir.File.cp_r!(source, destination, options \\\\ []): The same as `cp_r/3`, but raises a `File.CopyError` exception if it fails.\nReturns the list of copied files otherwise.\n"}
{"completion":"","prompt":"Elixir.File.cwd(): Gets the current working directory.\n\nIn rare circumstances, this function can fail on Unix-like systems. It may happen\nif read permissions do not exist for the parent directories of the\ncurrent directory. For this reason, returns `{:ok, cwd}` in case\nof success, `{:error, reason}` otherwise.\n"}
{"completion":"","prompt":"Elixir.File.cwd!(): The same as `cwd/0`, but raises a `File.Error` exception if it fails.\n"}
{"completion":"","prompt":"Elixir.File.dir?(path, opts \\\\ []): Returns `true` if the given path is a directory.\n\nThis function follows symbolic links, so if a symbolic link points to a\ndirectory, `true` is returned.\n\n## Options\n\nThe supported options are:\n\n  * `:raw` - a single atom to bypass the file server and only check\n    for the file locally\n\n## Examples\n\n    File.dir?(\"./test\")\n    #=> true\n\n    File.dir?(\"test\")\n    #=> true\n\n    File.dir?(\"/usr/bin\")\n    #=> true\n\n    File.dir?(\"~/Downloads\")\n    #=> false\n\n    \"~/Downloads\" |> Path.expand() |> File.dir?()\n    #=> true\n\n"}
{"completion":"","prompt":"Elixir.File.exists?(path, opts \\\\ []): Returns `true` if the given path exists.\n\nIt can be a regular file, directory, socket, symbolic link, named pipe, or device file.\nReturns `false` for symbolic links pointing to non-existing targets.\n\n## Options\n\nThe supported options are:\n\n  * `:raw` - a single atom to bypass the file server and only check\n    for the file locally\n\n## Examples\n\n    File.exists?(\"test/\")\n    #=> true\n\n    File.exists?(\"missing.txt\")\n    #=> false\n\n    File.exists?(\"/dev/null\")\n    #=> true\n\n"}
{"completion":"","prompt":"Elixir.File.ln(existing, new): Creates a hard link `new` to the file `existing`.\n\nReturns `:ok` if successful, `{:error, reason}` otherwise.\nIf the operating system does not support hard links, returns\n`{:error, :enotsup}`.\n"}
{"completion":"","prompt":"Elixir.File.ln!(existing, new): Same as `ln/2` but raises a `File.LinkError` exception if it fails.\nReturns `:ok` otherwise.\n"}
{"completion":"","prompt":"Elixir.File.ln_s(existing, new): Creates a symbolic link `new` to the file or directory `existing`.\n\nReturns `:ok` if successful, `{:error, reason}` otherwise.\nIf the operating system does not support symlinks, returns\n`{:error, :enotsup}`.\n"}
{"completion":"","prompt":"Elixir.File.ln_s!(existing, new): Same as `ln_s/2` but raises a `File.LinkError` exception if it fails.\nReturns `:ok` otherwise.\n"}
{"completion":"","prompt":"Elixir.File.ls(path \\\\ \".\"): Returns the list of files in the given directory.\n\nReturns `{:ok, files}` in case of success,\n`{:error, reason}` otherwise.\n"}
{"completion":"","prompt":"Elixir.File.ls!(path \\\\ \".\"): The same as `ls/1` but raises a `File.Error` exception in case of an error.\n"}
{"completion":"","prompt":"Elixir.File.lstat(path, opts \\\\ []): Returns information about the `path`. If the file is a symlink, sets\nthe `type` to `:symlink` and returns a `File.Stat` struct for the link. For any\nother file, returns exactly the same values as `stat/2`.\n\nFor more details, see `:file.read_link_info/2`.\n\n## Options\n\nThe accepted options are:\n\n  * `:time` - configures how the file timestamps are returned\n\nThe values for `:time` can be:\n\n  * `:universal` - returns a `{date, time}` tuple in UTC (default)\n  * `:local` - returns a `{date, time}` tuple using the machine time\n  * `:posix` - returns the time as integer seconds since epoch\n\nNote: Since file times are stored in POSIX time format on most operating systems,\nit is faster to retrieve file information with the `time: :posix` option.\n"}
{"completion":"","prompt":"Elixir.File.lstat!(path, opts \\\\ []): Same as `lstat/2` but returns the `File.Stat` struct directly,\nor raises a `File.Error` exception if an error is returned.\n"}
{"completion":"","prompt":"Elixir.File.mkdir(path): Tries to create the directory `path`.\n\nMissing parent directories are not created.\nReturns `:ok` if successful, or `{:error, reason}` if an error occurs.\n\nTypical error reasons are:\n\n  * `:eacces`  - missing search or write permissions for the parent\n    directories of `path`\n  * `:eexist`  - there is already a file or directory named `path`\n  * `:enoent`  - a component of `path` does not exist\n  * `:enospc`  - there is no space left on the device\n  * `:enotdir` - a component of `path` is not a directory;\n    on some platforms, `:enoent` is returned instead\n\n"}
{"completion":"","prompt":"Elixir.File.mkdir!(path): Same as `mkdir/1`, but raises a `File.Error` exception in case of failure.\nOtherwise `:ok`.\n"}
{"completion":"","prompt":"Elixir.File.mkdir_p(path): Tries to create the directory `path`.\n\nMissing parent directories are created. Returns `:ok` if successful, or\n`{:error, reason}` if an error occurs.\n\nTypical error reasons are:\n\n  * `:eacces`  - missing search or write permissions for the parent\n    directories of `path`\n  * `:enospc`  - there is no space left on the device\n  * `:enotdir` - a component of `path` is not a directory\n\n"}
{"completion":"","prompt":"Elixir.File.mkdir_p!(path): Same as `mkdir_p/1`, but raises a `File.Error` exception in case of failure.\nOtherwise `:ok`.\n"}
{"completion":"","prompt":"Elixir.File.open(path, modes_or_function \\\\ []): Opens the given `path`.\n\nIn order to write and read files, one must use the functions\nin the `IO` module. By default, a file is opened in `:binary` mode,\nwhich requires the functions `IO.binread/2` and `IO.binwrite/2`\nto interact with the file. A developer may pass `:utf8` as an\noption when opening the file and then all other functions from\n`IO` are available, since they work directly with Unicode data.\n\n`modes_or_function` can either be a list of modes or a function. If it's a\nlist, it's considered to be a list of modes (that are documented below). If\nit's a function, then it's equivalent to calling `open(path, [],\nmodes_or_function)`. See the documentation for `open/3` for more information\non this function.\n\nThe allowed modes:\n\n  * `:binary` - opens the file in binary mode, disabling special handling of Unicode sequences\n    (default mode).\n\n  * `:read` - the file, which must exist, is opened for reading.\n\n  * `:write` - the file is opened for writing. It is created if it does not\n    exist.\n\n    If the file does exists, and if write is not combined with read, the file\n    will be truncated.\n\n  * `:append` - the file will be opened for writing, and it will be created\n    if it does not exist. Every write operation to a file opened with append\n    will take place at the end of the file.\n\n  * `:exclusive` - the file, when opened for writing, is created if it does\n    not exist. If the file exists, open will return `{:error, :eexist}`.\n\n  * `:charlist` - when this term is given, read operations on the file will\n    return charlists rather than binaries.\n\n  * `:compressed` - makes it possible to read or write gzip compressed files.\n\n    The compressed option must be combined with either read or write, but not\n    both. Note that the file size obtained with `stat/1` will most probably\n    not match the number of bytes that can be read from a compressed file.\n\n  * `:utf8` - this option denotes how data is actually stored in the disk\n    file and makes the file perform automatic translation of characters to\n    and from UTF-8.\n\n    If data is sent to a file in a format that cannot be converted to the\n    UTF-8 or if data is read by a function that returns data in a format that\n    cannot cope with the character range of the data, an error occurs and the\n    file will be closed.\n\n  * `:delayed_write`, `:raw`, `:ram`, `:read_ahead`, `:sync`, `{:encoding, ...}`,\n    `{:read_ahead, pos_integer}`, `{:delayed_write, non_neg_integer, non_neg_integer}` -\n    for more information about these options see `:file.open/2`.\n\nThis function returns:\n\n  * `{:ok, io_device}` - the file has been opened in the requested mode.\n\n    `io_device` is actually the PID of the process which handles the file.\n    This process monitors the process that originally opened the file (the\n    owner process). If the owner process terminates, the file is closed and\n    the process itself terminates too. If any process to which the `io_device`\n    is linked terminates, the file will be closed and the process itself will\n    be terminated.\n\n    An `io_device` returned from this call can be used as an argument to the\n    `IO` module functions.\n\n  * `{:error, reason}` - the file could not be opened.\n\n## Examples\n\n    {:ok, file} = File.open(\"foo.tar.gz\", [:read, :compressed])\n    IO.read(file, :line)\n    File.close(file)\n\n"}
{"completion":"","prompt":"Elixir.File.open(path, modes, function): Similar to `open/2` but expects a function as its last argument.\n\nThe file is opened, given to the function as an argument and\nautomatically closed after the function returns, regardless\nif there was an error when executing the function.\n\nReturns `{:ok, function_result}` in case of success,\n`{:error, reason}` otherwise.\n\nThis function expects the file to be closed with success,\nwhich is usually the case unless the `:delayed_write` option\nis given. For this reason, we do not recommend passing\n`:delayed_write` to this function.\n\n## Examples\n\n    File.open(\"file.txt\", [:read, :write], fn file ->\n      IO.read(file, :line)\n    end)\n\nSee `open/2` for the list of available `modes`.\n"}
{"completion":"","prompt":"Elixir.File.open!(path, modes_or_function \\\\ []): Similar to `open/2` but raises a `File.Error` exception if the file\ncould not be opened. Returns the IO device otherwise.\n\nSee `open/2` for the list of available modes.\n"}
{"completion":"","prompt":"Elixir.File.open!(path, modes, function): Similar to `open/3` but raises a `File.Error` exception if the file\ncould not be opened.\n\nIf it succeeds opening the file, it returns the `function` result on the IO device.\n\nSee `open/2` for the list of available `modes`.\n"}
{"completion":"","prompt":"Elixir.File.read(path): Returns `{:ok, binary}`, where `binary` is a binary data object that contains the contents\nof `path`, or `{:error, reason}` if an error occurs.\n\nTypical error reasons:\n\n  * `:enoent`  - the file does not exist\n  * `:eacces`  - missing permission for reading the file,\n    or for searching one of the parent directories\n  * `:eisdir`  - the named file is a directory\n  * `:enotdir` - a component of the file name is not a directory;\n    on some platforms, `:enoent` is returned instead\n  * `:enomem`  - there is not enough memory for the contents of the file\n\nYou can use `:file.format_error/1` to get a descriptive string of the error.\n"}
{"completion":"","prompt":"Elixir.File.read!(path): Returns a binary with the contents of the given filename,\nor raises a `File.Error` exception if an error occurs.\n"}
{"completion":"","prompt":"Elixir.File.read_link(path): Reads the symbolic link at `path`.\n\nIf `path` exists and is a symlink, returns `{:ok, target}`, otherwise returns\n`{:error, reason}`.\n\nFor more details, see `:file.read_link/1`.\n\nTypical error reasons are:\n\n  * `:einval` - path is not a symbolic link\n  * `:enoent` - path does not exist\n  * `:enotsup` - symbolic links are not supported on the current platform\n\n"}
{"completion":"","prompt":"Elixir.File.read_link!(path): Same as `read_link/1` but returns the target directly,\nor raises a `File.Error` exception if an error is returned.\n"}
{"completion":"","prompt":"Elixir.File.regular?(path, opts \\\\ []): Returns `true` if the path is a regular file.\n\nThis function follows symbolic links, so if a symbolic link points to a\nregular file, `true` is returned.\n\n## Options\n\nThe supported options are:\n\n  * `:raw` - a single atom to bypass the file server and only check\n    for the file locally\n\n## Examples\n\n    File.regular?(__ENV__.file)\n    #=> true\n\n"}
{"completion":"","prompt":"Elixir.File.rename(source, destination): Renames the `source` file to `destination` file.  It can be used to move files\n(and directories) between directories.  If moving a file, you must fully\nspecify the `destination` filename, it is not sufficient to simply specify\nits directory.\n\nReturns `:ok` in case of success, `{:error, reason}` otherwise.\n\nNote: The command `mv` in Unix-like systems behaves differently depending on\nwhether `source` is a file and the `destination` is an existing directory.\nWe have chosen to explicitly disallow this behaviour.\n\n## Examples\n\n    # Rename file \"a.txt\" to \"b.txt\"\n    File.rename(\"a.txt\", \"b.txt\")\n\n    # Rename directory \"samples\" to \"tmp\"\n    File.rename(\"samples\", \"tmp\")\n\n"}
{"completion":"","prompt":"Elixir.File.rename!(source, destination): The same as `rename/2` but raises a `File.RenameError` exception if it fails.\nReturns `:ok` otherwise.\n"}
{"completion":"","prompt":"Elixir.File.rm(path): Tries to delete the file `path`.\n\nReturns `:ok` if successful, or `{:error, reason}` if an error occurs.\n\nNote the file is deleted even if in read-only mode.\n\nTypical error reasons are:\n\n  * `:enoent`  - the file does not exist\n  * `:eacces`  - missing permission for the file or one of its parents\n  * `:eperm`   - the file is a directory and user is not super-user\n  * `:enotdir` - a component of the file name is not a directory;\n    on some platforms, `:enoent` is returned instead\n  * `:einval`  - filename had an improper type, such as tuple\n\n## Examples\n\n    File.rm(\"file.txt\")\n    #=> :ok\n\n    File.rm(\"tmp_dir/\")\n    #=> {:error, :eperm}\n\n"}
{"completion":"","prompt":"Elixir.File.rm!(path): Same as `rm/1`, but raises a `File.Error` exception in case of failure.\nOtherwise `:ok`.\n"}
{"completion":"","prompt":"Elixir.File.rm_rf(path): Removes files and directories recursively at the given `path`.\nSymlinks are not followed but simply removed, non-existing\nfiles are simply ignored (i.e. doesn't make this function fail).\n\nReturns `{:ok, files_and_directories}` with all files and\ndirectories removed in no specific order, `{:error, reason, file}`\notherwise.\n\n## Examples\n\n    File.rm_rf(\"samples\")\n    #=> {:ok, [\"samples\", \"samples/1.txt\"]}\n\n    File.rm_rf(\"unknown\")\n    #=> {:ok, []}\n\n"}
{"completion":"","prompt":"Elixir.File.rm_rf!(path): Same as `rm_rf/1` but raises a `File.Error` exception in case of failures,\notherwise the list of files or directories removed.\n"}
{"completion":"","prompt":"Elixir.File.rmdir(path): Tries to delete the dir at `path`.\n\nReturns `:ok` if successful, or `{:error, reason}` if an error occurs.\nIt returns `{:error, :eexist}` if the directory is not empty.\n\n## Examples\n\n    File.rmdir(\"tmp_dir\")\n    #=> :ok\n\n    File.rmdir(\"non_empty_dir\")\n    #=> {:error, :eexist}\n\n    File.rmdir(\"file.txt\")\n    #=> {:error, :enotdir}\n\n"}
{"completion":"","prompt":"Elixir.File.rmdir!(path): Same as `rmdir/1`, but raises a `File.Error` exception in case of failure.\nOtherwise `:ok`.\n"}
{"completion":"","prompt":"Elixir.File.stat(path, opts \\\\ []): Returns information about the `path`. If it exists, it\nreturns a `{:ok, info}` tuple, where info is a\n`File.Stat` struct. Returns `{:error, reason}` with\nthe same reasons as `read/1` if a failure occurs.\n\n## Options\n\nThe accepted options are:\n\n  * `:time` - configures how the file timestamps are returned\n\nThe values for `:time` can be:\n\n  * `:universal` - returns a `{date, time}` tuple in UTC (default)\n  * `:local` - returns a `{date, time}` tuple using the same time zone as the\n    machine\n  * `:posix` - returns the time as integer seconds since epoch\n\nNote: Since file times are stored in POSIX time format on most operating systems,\nit is faster to retrieve file information with the `time: :posix` option.\n"}
{"completion":"","prompt":"Elixir.File.stat!(path, opts \\\\ []): Same as `stat/2` but returns the `File.Stat` directly,\nor raises a `File.Error` exception if an error is returned.\n"}
{"completion":"","prompt":"Elixir.File.stream!(path, modes \\\\ [], line_or_bytes \\\\ :line): Returns a `File.Stream` for the given `path` with the given `modes`.\n\nThe stream implements both `Enumerable` and `Collectable` protocols,\nwhich means it can be used both for read and write.\n\nThe `line_or_bytes` argument configures how the file is read when\nstreaming, by `:line` (default) or by a given number of bytes. When\nusing the `:line` option, CRLF line breaks (`\"\\r\\n\"`) are normalized\nto LF (`\"\\n\"`).\n\nOperating the stream can fail on open for the same reasons as\n`File.open!/2`. Note that the file is automatically opened each time streaming\nbegins. There is no need to pass `:read` and `:write` modes, as those are\nautomatically set by Elixir.\n\n## Raw files\n\nSince Elixir controls when the streamed file is opened, the underlying\ndevice cannot be shared and as such it is convenient to open the file\nin raw mode for performance reasons. Therefore, Elixir **will** open\nstreams in `:raw` mode with the `:read_ahead` option unless an encoding\nis specified. This means any data streamed into the file must be\nconverted to `t:iodata/0` type. If you pass, for example, `[encoding: :utf8]`\nor `[encoding: {:utf16, :little}]` in the modes parameter,\nthe underlying stream will use `IO.write/2` and the `String.Chars` protocol\nto convert the data. See `IO.binwrite/2` and `IO.write/2` .\n\nOne may also consider passing the `:delayed_write` option if the stream\nis meant to be written to under a tight loop.\n\n## Byte order marks\n\nIf you pass `:trim_bom` in the modes parameter, the stream will\ntrim UTF-8, UTF-16 and UTF-32 byte order marks when reading from file.\n\nNote that this function does not try to discover the file encoding basing\non BOM.\n\n## Examples\n\n    # Read in 2048 byte chunks rather than lines\n    File.stream!(\"./test/test.data\", [], 2048)\n    #=> %File.Stream{line_or_bytes: 2048, modes: [:raw, :read_ahead, :binary],\n    #=>   path: \"./test/test.data\", raw: true}\n\nSee `Stream.run/1` for an example of streaming into a file.\n"}
{"completion":"","prompt":"Elixir.File.touch(path, time \\\\ System.os_time(:second)): Updates modification time (mtime) and access time (atime) of\nthe given file.\n\nThe file is created if it doesn't exist. Requires datetime in UTC\n(as returned by `:erlang.universaltime()`) or an integer\nrepresenting the POSIX timestamp (as returned by `System.os_time(:second)`).\n\nIn Unix-like systems, changing the modification time may require\nyou to be either `root` or the owner of the file. Having write\naccess may not be enough. In those cases, touching the file the\nfirst time (to create it) will succeed, but touching an existing\nfile with fail with `{:error, :eperm}`.\n\n## Examples\n\n    File.touch(\"/tmp/a.txt\", {{2018, 1, 30}, {13, 59, 59}})\n    #=> :ok\n    File.touch(\"/fakedir/b.txt\", {{2018, 1, 30}, {13, 59, 59}})\n    {:error, :enoent}\n\n    File.touch(\"/tmp/a.txt\", 1544519753)\n    #=> :ok\n\n"}
{"completion":"","prompt":"Elixir.File.touch!(path, time \\\\ System.os_time(:second)): Same as `touch/2` but raises a `File.Error` exception if it fails.\nReturns `:ok` otherwise.\n\nThe file is created if it doesn't exist. Requires datetime in UTC\n(as returned by `:erlang.universaltime()`) or an integer\nrepresenting the POSIX timestamp (as returned by `System.os_time(:second)`).\n\n## Examples\n\n    File.touch!(\"/tmp/a.txt\", {{2018, 1, 30}, {13, 59, 59}})\n    #=> :ok\n    File.touch!(\"/fakedir/b.txt\", {{2018, 1, 30}, {13, 59, 59}})\n    ** (File.Error) could not touch \"/fakedir/b.txt\": no such file or directory\n\n    File.touch!(\"/tmp/a.txt\", 1544519753)\n\n"}
{"completion":"","prompt":"Elixir.File.write(path, content, modes \\\\ []): Writes `content` to the file `path`.\n\nThe file is created if it does not exist. If it exists, the previous\ncontents are overwritten. Returns `:ok` if successful, or `{:error, reason}`\nif an error occurs.\n\n`content` must be `iodata` (a list of bytes or a binary). Setting the\nencoding for this function has no effect.\n\n**Warning:** Every time this function is invoked, a file descriptor is opened\nand a new process is spawned to write to the file. For this reason, if you are\ndoing multiple writes in a loop, opening the file via `File.open/2` and using\nthe functions in `IO` to write to the file will yield much better performance\nthan calling this function multiple times.\n\nTypical error reasons are:\n\n  * `:enoent`  - a component of the file name does not exist\n  * `:enotdir` - a component of the file name is not a directory;\n    on some platforms, `:enoent` is returned instead\n  * `:enospc`  - there is no space left on the device\n  * `:eacces`  - missing permission for writing the file or searching one of\n    the parent directories\n  * `:eisdir`  - the named file is a directory\n\nCheck `File.open/2` for other available options.\n"}
{"completion":"","prompt":"Elixir.File.write!(path, content, modes \\\\ []): Same as `write/3` but raises a `File.Error` exception if it fails.\nReturns `:ok` otherwise.\n"}
{"completion":"","prompt":"Elixir.File.write_stat(path, stat, opts \\\\ []): Writes the given `File.Stat` back to the file system at the given\npath. Returns `:ok` or `{:error, reason}`.\n"}
{"completion":"","prompt":"Elixir.File.write_stat!(path, stat, opts \\\\ []): Same as `write_stat/3` but raises a `File.Error` exception if it fails.\nReturns `:ok` otherwise.\n"}
{"completion":"","prompt":"Elixir.Float.ceil(number, precision \\\\ 0): Rounds a float to the smallest integer greater than or equal to `num`.\n\n`ceil/2` also accepts a precision to round a floating-point value down\nto an arbitrary number of fractional digits (between 0 and 15).\n\nThe operation is performed on the binary floating point, without a\nconversion to decimal.\n\nThe behaviour of `ceil/2` for floats can be surprising. For example:\n\n    iex> Float.ceil(-12.52, 2)\n    -12.51\n\nOne may have expected it to ceil to -12.52. This is not a bug.\nMost decimal fractions cannot be represented as a binary floating point\nand therefore the number above is internally represented as -12.51999999,\nwhich explains the behaviour above.\n\nThis function always returns floats. `Kernel.trunc/1` may be used instead to\ntruncate the result to an integer afterwards.\n\n## Examples\n\n    iex> Float.ceil(34.25)\n    35.0\n    iex> Float.ceil(-56.5)\n    -56.0\n    iex> Float.ceil(34.251, 2)\n    34.26\n\n"}
{"completion":"","prompt":"Elixir.Float.floor(number, precision \\\\ 0): Rounds a float to the largest number less than or equal to `num`.\n\n`floor/2` also accepts a precision to round a floating-point value down\nto an arbitrary number of fractional digits (between 0 and 15).\nThe operation is performed on the binary floating point, without a\nconversion to decimal.\n\nThis function always returns a float. `Kernel.trunc/1` may be used instead to\ntruncate the result to an integer afterwards.\n\n## Known issues\n\nThe behaviour of `floor/2` for floats can be surprising. For example:\n\n    iex> Float.floor(12.52, 2)\n    12.51\n\nOne may have expected it to floor to 12.52. This is not a bug.\nMost decimal fractions cannot be represented as a binary floating point\nand therefore the number above is internally represented as 12.51999999,\nwhich explains the behaviour above.\n\n## Examples\n\n    iex> Float.floor(34.25)\n    34.0\n    iex> Float.floor(-56.5)\n    -57.0\n    iex> Float.floor(34.259, 2)\n    34.25\n\n"}
{"completion":"","prompt":"Elixir.Float.max_finite(): Returns the maximum finite value for a float.\n\n## Examples\n\n    iex> Float.max_finite()\n    1.7976931348623157e308\n\n"}
{"completion":"","prompt":"Elixir.Float.min_finite(): Returns the minimum finite value for a float.\n\n## Examples\n\n    iex> Float.min_finite()\n    -1.7976931348623157e308\n\n"}
{"completion":"","prompt":"Elixir.Float.parse(binary): Parses a binary into a float.\n\nIf successful, returns a tuple in the form of `{float, remainder_of_binary}`;\nwhen the binary cannot be coerced into a valid float, the atom `:error` is\nreturned.\n\nIf the size of float exceeds the maximum size of `1.7976931348623157e+308`,\n`:error` is returned even though the textual representation itself might be\nwell formed.\n\nIf you want to convert a string-formatted float directly to a float,\n`String.to_float/1` can be used instead.\n\n## Examples\n\n    iex> Float.parse(\"34\")\n    {34.0, \"\"}\n    iex> Float.parse(\"34.25\")\n    {34.25, \"\"}\n    iex> Float.parse(\"56.5xyz\")\n    {56.5, \"xyz\"}\n\n    iex> Float.parse(\"pi\")\n    :error\n    iex> Float.parse(\"1.7976931348623159e+308\")\n    :error\n\n"}
{"completion":"","prompt":"Elixir.Float.pow(base, exponent): Computes `base` raised to power of `exponent`.\n\n`base` must be a float and `exponent` can be any number.\nHowever, if a negative base and a fractional exponent\nare given, it raises `ArithmeticError`.\n\nIt always returns a float. See `Integer.pow/2` for\nexponentiation that returns integers.\n\n## Examples\n\n    iex> Float.pow(2.0, 0)\n    1.0\n    iex> Float.pow(2.0, 1)\n    2.0\n    iex> Float.pow(2.0, 10)\n    1024.0\n    iex> Float.pow(2.0, -1)\n    0.5\n    iex> Float.pow(2.0, -3)\n    0.125\n\n    iex> Float.pow(3.0, 1.5)\n    5.196152422706632\n\n    iex> Float.pow(-2.0, 3)\n    -8.0\n    iex> Float.pow(-2.0, 4)\n    16.0\n\n    iex> Float.pow(-1.0, 0.5)\n    ** (ArithmeticError) bad argument in arithmetic expression\n\n"}
{"completion":"","prompt":"Elixir.Float.ratio(float): Returns a pair of integers whose ratio is exactly equal\nto the original float and with a positive denominator.\n\n## Examples\n\n    iex> Float.ratio(0.0)\n    {0, 1}\n    iex> Float.ratio(3.14)\n    {7070651414971679, 2251799813685248}\n    iex> Float.ratio(-3.14)\n    {-7070651414971679, 2251799813685248}\n    iex> Float.ratio(1.5)\n    {3, 2}\n    iex> Float.ratio(-1.5)\n    {-3, 2}\n    iex> Float.ratio(16.0)\n    {16, 1}\n    iex> Float.ratio(-16.0)\n    {-16, 1}\n\n"}
{"completion":"","prompt":"Elixir.Float.round(float, precision \\\\ 0): Rounds a floating-point value to an arbitrary number of fractional\ndigits (between 0 and 15).\n\nThe rounding direction always ties to half up. The operation is\nperformed on the binary floating point, without a conversion to decimal.\n\nThis function only accepts floats and always returns a float. Use\n`Kernel.round/1` if you want a function that accepts both floats\nand integers and always returns an integer.\n\n## Known issues\n\nThe behaviour of `round/2` for floats can be surprising. For example:\n\n    iex> Float.round(5.5675, 3)\n    5.567\n\nOne may have expected it to round to the half up 5.568. This is not a bug.\nMost decimal fractions cannot be represented as a binary floating point\nand therefore the number above is internally represented as 5.567499999,\nwhich explains the behaviour above. If you want exact rounding for decimals,\nyou must use a decimal library. The behaviour above is also in accordance\nto reference implementations, such as \"Correctly Rounded Binary-Decimal and\nDecimal-Binary Conversions\" by David M. Gay.\n\n## Examples\n\n    iex> Float.round(12.5)\n    13.0\n    iex> Float.round(5.5674, 3)\n    5.567\n    iex> Float.round(5.5675, 3)\n    5.567\n    iex> Float.round(-5.5674, 3)\n    -5.567\n    iex> Float.round(-5.5675)\n    -6.0\n    iex> Float.round(12.341444444444441, 15)\n    12.341444444444441\n\n"}
{"completion":"","prompt":"Elixir.Float.to_charlist(float): Returns a charlist which corresponds to the shortest text representation\nof the given float.\n\nThe underlying algorithm changes depending on the Erlang/OTP version:\n\n  * For OTP >= 24, it uses the algorithm presented in \"RyÅ«: fast\n    float-to-string conversion\" in Proceedings of the SIGPLAN '2018\n    Conference on Programming Language Design and Implementation.\n\n  * For OTP < 24, it uses the algorithm presented in \"Printing Floating-Point\n    Numbers Quickly and Accurately\" in Proceedings of the SIGPLAN '1996\n    Conference on Programming Language Design and Implementation.\n\nFor a configurable representation, use `:erlang.float_to_list/2`.\n\n## Examples\n\n    iex> Float.to_charlist(7.0)\n    '7.0'\n\n"}
{"completion":"","prompt":"Elixir.Float.to_string(float): Returns a binary which corresponds to the shortest text representation\nof the given float.\n\nThe underlying algorithm changes depending on the Erlang/OTP version:\n\n  * For OTP >= 24, it uses the algorithm presented in \"RyÅ«: fast\n    float-to-string conversion\" in Proceedings of the SIGPLAN '2018\n    Conference on Programming Language Design and Implementation.\n\n  * For OTP < 24, it uses the algorithm presented in \"Printing Floating-Point\n    Numbers Quickly and Accurately\" in Proceedings of the SIGPLAN '1996\n    Conference on Programming Language Design and Implementation.\n\nFor a configurable representation, use `:erlang.float_to_binary/2`.\n\n## Examples\n\n    iex> Float.to_string(7.0)\n    \"7.0\"\n\n"}
{"completion":"","prompt":"Elixir.Function.capture(module, function_name, arity): Captures the given function.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Function.capture(String, :length, 1)\n    &String.length/1\n\n"}
{"completion":"","prompt":"Elixir.Function.identity(value): Returns its input `value`. This function can be passed as an anonymous function\nto transformation functions.\n\n## Examples\n\n    iex> Function.identity(\"Hello world!\")\n    \"Hello world!\"\n\n    iex> 'abcdaabccc' |> Enum.sort() |> Enum.chunk_by(&Function.identity/1)\n    ['aaa', 'bb', 'cccc', 'd']\n\n    iex> Enum.group_by('abracadabra', &Function.identity/1)\n    %{97 => 'aaaaa', 98 => 'bb', 99 => 'c', 100 => 'd', 114 => 'rr'}\n\n    iex> Enum.map([1, 2, 3, 4], &Function.identity/1)\n    [1, 2, 3, 4]\n\n"}
{"completion":"","prompt":"Elixir.Function.info(fun): Returns a keyword list with information about a function.\n\nThe returned keys (with the corresponding possible values) for\nall types of functions (local and external) are the following:\n\n  * `:type` - `:local` (for anonymous functions) or `:external` (for\n    named functions).\n\n  * `:module` - an atom which is the module where the function is defined when\n  anonymous or the module which the function refers to when it's a named function.\n\n  * `:arity` - (integer) the number of arguments the function is to be called with.\n\n  * `:name` - (atom) the name of the function.\n\n  * `:env` - a list of the environment or free variables. For named\n    functions, the returned list is always empty.\n\nWhen `fun` is an anonymous function (that is, the type is `:local`), the following\nadditional keys are returned:\n\n  * `:pid` - PID of the process that originally created the function.\n\n  * `:index` - (integer) an index into the module function table.\n\n  * `:new_index` - (integer) an index into the module function table.\n\n  * `:new_uniq` - (binary) a unique value for this function. It's\n    calculated from the compiled code for the entire module.\n\n  * `:uniq` - (integer) a unique value for this function. This integer is\n    calculated from the compiled code for the entire module.\n\n**Note**: this function must be used only for debugging purposes.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> fun = fn x -> x end\n    iex> info = Function.info(fun)\n    iex> Keyword.get(info, :arity)\n    1\n    iex> Keyword.get(info, :type)\n    :local\n\n    iex> fun = &String.length/1\n    iex> info = Function.info(fun)\n    iex> Keyword.get(info, :type)\n    :external\n    iex> Keyword.get(info, :name)\n    :length\n\n"}
{"completion":"","prompt":"Elixir.Function.info(fun, item): Returns a specific information about the function.\n\nThe returned information is a two-element tuple in the shape of\n`{info, value}`.\n\nFor any function, the information asked for can be any of the atoms\n`:module`, `:name`, `:arity`, `:env`, or `:type`.\n\nFor anonymous functions, there is also information about any of the\natoms `:index`, `:new_index`, `:new_uniq`, `:uniq`, and `:pid`.\nFor a named function, the value of any of these items is always the\natom `:undefined`.\n\nFor more information on each of the possible returned values, see\n`info/1`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> f = fn x -> x end\n    iex> Function.info(f, :arity)\n    {:arity, 1}\n    iex> Function.info(f, :type)\n    {:type, :local}\n\n    iex> fun = &String.length/1\n    iex> Function.info(fun, :name)\n    {:name, :length}\n    iex> Function.info(fun, :pid)\n    {:pid, :undefined}\n\n"}
{"completion":"","prompt":"Elixir.GenServer.abcast(nodes \\\\ [node() | Node.list()], name, request): Casts all servers locally registered as `name` at the specified nodes.\n\nThis function returns immediately and ignores nodes that do not exist, or where the\nserver name does not exist.\n\nSee `multi_call/4` for more information.\n"}
{"completion":"","prompt":"Elixir.GenServer.call(server, request, timeout \\\\ 5000): Makes a synchronous call to the `server` and waits for its reply.\n\nThe client sends the given `request` to the server and waits until a reply\narrives or a timeout occurs. `c:handle_call/3` will be called on the server\nto handle the request.\n\n`server` can be any of the values described in the \"Name registration\"\nsection of the documentation for this module.\n\n## Timeouts\n\n`timeout` is an integer greater than zero which specifies how many\nmilliseconds to wait for a reply, or the atom `:infinity` to wait\nindefinitely. The default value is `5000`. If no reply is received within\nthe specified time, the function call fails and the caller exits. If the\ncaller catches the failure and continues running, and the server is just late\nwith the reply, it may arrive at any time later into the caller's message\nqueue. The caller must in this case be prepared for this and discard any such\ngarbage messages that are two-element tuples with a reference as the first\nelement.\n"}
{"completion":"","prompt":"Elixir.GenServer.cast(server, request): Sends an asynchronous request to the `server`.\n\nThis function always returns `:ok` regardless of whether\nthe destination `server` (or node) exists. Therefore it\nis unknown whether the destination `server` successfully\nhandled the message.\n\n`server` can be any of the values described in the \"Name registration\"\nsection of the documentation for this module.\n"}
{"completion":"","prompt":"Elixir.GenServer.multi_call(nodes \\\\ [node() | Node.list()], name, request, timeout \\\\ :infinity): Calls all servers locally registered as `name` at the specified `nodes`.\n\nFirst, the `request` is sent to every node in `nodes`; then, the caller waits\nfor the replies. This function returns a two-element tuple `{replies,\nbad_nodes}` where:\n\n  * `replies` - is a list of `{node, reply}` tuples where `node` is the node\n    that replied and `reply` is its reply\n  * `bad_nodes` - is a list of nodes that either did not exist or where a\n    server with the given `name` did not exist or did not reply\n\n`nodes` is a list of node names to which the request is sent. The default\nvalue is the list of all known nodes (including this node).\n\nTo avoid that late answers (after the timeout) pollute the caller's message\nqueue, a middleman process is used to do the actual calls. Late answers will\nthen be discarded when they arrive to a terminated process.\n\n## Examples\n\nAssuming the `Stack` GenServer mentioned in the docs for the `GenServer`\nmodule is registered as `Stack` in the `:\"foo@my-machine\"` and\n`:\"bar@my-machine\"` nodes:\n\n    GenServer.multi_call(Stack, :pop)\n    #=> {[{:\"foo@my-machine\", :hello}, {:\"bar@my-machine\", :world}], []}\n\n"}
{"completion":"","prompt":"Elixir.GenServer.reply(client, reply): Replies to a client.\n\nThis function can be used to explicitly send a reply to a client that called\n`call/3` or `multi_call/4` when the reply cannot be specified in the return\nvalue of `c:handle_call/3`.\n\n`client` must be the `from` argument (the second argument) accepted by\n`c:handle_call/3` callbacks. `reply` is an arbitrary term which will be given\nback to the client as the return value of the call.\n\nNote that `reply/2` can be called from any process, not just the GenServer\nthat originally received the call (as long as that GenServer communicated the\n`from` argument somehow).\n\nThis function always returns `:ok`.\n\n## Examples\n\n    def handle_call(:reply_in_one_second, from, state) do\n      Process.send_after(self(), {:reply, from}, 1_000)\n      {:noreply, state}\n    end\n\n    def handle_info({:reply, from}, state) do\n      GenServer.reply(from, :one_second_has_passed)\n      {:noreply, state}\n    end\n\n"}
{"completion":"","prompt":"Elixir.GenServer.start(module, init_arg, options \\\\ []): Starts a `GenServer` process without links (outside of a supervision tree).\n\nSee `start_link/3` for more information.\n"}
{"completion":"","prompt":"Elixir.GenServer.start_link(module, init_arg, options \\\\ []): Starts a `GenServer` process linked to the current process.\n\nThis is often used to start the `GenServer` as part of a supervision tree.\n\nOnce the server is started, the `c:init/1` function of the given `module` is\ncalled with `init_arg` as its argument to initialize the server. To ensure a\nsynchronized start-up procedure, this function does not return until `c:init/1`\nhas returned.\n\nNote that a `GenServer` started with `start_link/3` is linked to the\nparent process and will exit in case of crashes from the parent. The GenServer\nwill also exit due to the `:normal` reasons in case it is configured to trap\nexits in the `c:init/1` callback.\n\n## Options\n\n  * `:name` - used for name registration as described in the \"Name\n    registration\" section in the documentation for `GenServer`\n\n  * `:timeout` - if present, the server is allowed to spend the given number of\n    milliseconds initializing or it will be terminated and the start function\n    will return `{:error, :timeout}`\n\n  * `:debug` - if present, the corresponding function in the [`:sys` module](`:sys`) is invoked\n\n  * `:spawn_opt` - if present, its value is passed as options to the\n    underlying process as in `Process.spawn/4`\n\n  * `:hibernate_after` - if present, the GenServer process awaits any message for\n    the given number of milliseconds and if no message is received, the process goes\n    into hibernation automatically (by calling `:proc_lib.hibernate/3`).\n\n## Return values\n\nIf the server is successfully created and initialized, this function returns\n`{:ok, pid}`, where `pid` is the PID of the server. If a process with the\nspecified server name already exists, this function returns\n`{:error, {:already_started, pid}}` with the PID of that process.\n\nIf the `c:init/1` callback fails with `reason`, this function returns\n`{:error, reason}`. Otherwise, if it returns `{:stop, reason}`\nor `:ignore`, the process is terminated and this function returns\n`{:error, reason}` or `:ignore`, respectively.\n"}
{"completion":"","prompt":"Elixir.GenServer.stop(server, reason \\\\ :normal, timeout \\\\ :infinity): Synchronously stops the server with the given `reason`.\n\nThe `c:terminate/2` callback of the given `server` will be invoked before\nexiting. This function returns `:ok` if the server terminates with the\ngiven reason; if it terminates with another reason, the call exits.\n\nThis function keeps OTP semantics regarding error reporting.\nIf the reason is any other than `:normal`, `:shutdown` or\n`{:shutdown, _}`, an error report is logged.\n"}
{"completion":"","prompt":"Elixir.GenServer.whereis(server): Returns the `pid` or `{name, node}` of a GenServer process, `nil` otherwise.\n\nTo be precise, `nil` is returned whenever a `pid` or `{name, node}` cannot\nbe returned. Note there is no guarantee the returned `pid` or `{name, node}`\nis alive, as a process could terminate immediately after it is looked up.\n\n## Examples\n\nFor example, to lookup a server process, monitor it and send a cast to it:\n\n    process = GenServer.whereis(server)\n    monitor = Process.monitor(process)\n    GenServer.cast(process, :hello)\n\n"}
{"completion":"","prompt":"Elixir.HashDict.new(): Creates a new empty dict.\n"}
{"completion":"","prompt":"Elixir.IO.ANSI.Docs.default_options(): The default options used by this module.\n\nThe supported keys are:\n\n  * `:enabled`           - toggles coloring on and off (true)\n  * `:doc_bold`          - bold text (bright)\n  * `:doc_code`          - code blocks (cyan)\n  * `:doc_headings`      - h1, h2, h3, h4, h5, h6 headings (yellow)\n  * `:doc_metadata`      - documentation metadata keys (yellow)\n  * `:doc_quote`         - leading quote character `> ` (light black)\n  * `:doc_inline_code`   - inline code (cyan)\n  * `:doc_table_heading` - the style for table headings\n  * `:doc_title`         - top level heading (reverse, yellow)\n  * `:doc_underline`     - underlined text (underline)\n  * `:width`             - the width to format the text (80)\n\nValues for the color settings are strings with\ncomma-separated ANSI values.\n"}
{"completion":"","prompt":"Elixir.IO.ANSI.Docs.print(doc, format, options \\\\ []): Prints the documentation body `doc` according to `format`.\n\nIt takes a set of `options` defined in `default_options/0`.\n"}
{"completion":"","prompt":"Elixir.IO.ANSI.Docs.print_headings(headings, options \\\\ []): Prints the head of the documentation (i.e. the function signature).\n\nSee `default_options/0` for docs on the supported options.\n"}
{"completion":"","prompt":"Elixir.IO.ANSI.Docs.print_metadata(metadata, options \\\\ []): Prints documentation metadata (only `delegate_to`, `deprecated`, `guard`, and `since` for now).\n\nSee `default_options/0` for docs on the supported options.\n"}
{"completion":"","prompt":"Elixir.IO.ANSI.black(): Sets foreground color to black."}
{"completion":"","prompt":"Elixir.IO.ANSI.black_background(): Sets background color to black."}
{"completion":"","prompt":"Elixir.IO.ANSI.blink_off(): Blink: off."}
{"completion":"","prompt":"Elixir.IO.ANSI.blink_rapid(): Blink: rapid. MS-DOS ANSI.SYS; 150 per minute or more; not widely supported."}
{"completion":"","prompt":"Elixir.IO.ANSI.blink_slow(): Blink: slow. Less than 150 per minute."}
{"completion":"","prompt":"Elixir.IO.ANSI.blue(): Sets foreground color to blue."}
{"completion":"","prompt":"Elixir.IO.ANSI.blue_background(): Sets background color to blue."}
{"completion":"","prompt":"Elixir.IO.ANSI.bright(): Bright (increased intensity) or bold."}
{"completion":"","prompt":"Elixir.IO.ANSI.clear(): Clears screen."}
{"completion":"","prompt":"Elixir.IO.ANSI.clear_line(): Clears line."}
{"completion":"","prompt":"Elixir.IO.ANSI.color(code): Sets foreground color."}
{"completion":"","prompt":"Elixir.IO.ANSI.color(r, g, b): Sets the foreground color from individual RGB values.\n\nValid values for each color are in the range 0 to 5.\n"}
{"completion":"","prompt":"Elixir.IO.ANSI.color_background(code): Sets background color."}
{"completion":"","prompt":"Elixir.IO.ANSI.color_background(r, g, b): Sets the background color from individual RGB values.\n\nValid values for each color are in the range 0 to 5.\n"}
{"completion":"","prompt":"Elixir.IO.ANSI.conceal(): Conceal. Not widely supported."}
{"completion":"","prompt":"Elixir.IO.ANSI.crossed_out(): Crossed-out. Characters legible, but marked for deletion. Not widely supported."}
{"completion":"","prompt":"Elixir.IO.ANSI.cursor(line, column): Sends cursor to the absolute position specified by `line` and `column`.\n\nLine `0` and column `0` would mean the top left corner.\n"}
{"completion":"","prompt":"Elixir.IO.ANSI.cursor_down(lines \\\\ 1): Sends cursor `lines` down."}
{"completion":"","prompt":"Elixir.IO.ANSI.cursor_left(columns \\\\ 1): Sends cursor `columns` to the left."}
{"completion":"","prompt":"Elixir.IO.ANSI.cursor_right(columns \\\\ 1): Sends cursor `columns` to the right."}
{"completion":"","prompt":"Elixir.IO.ANSI.cursor_up(lines \\\\ 1): Sends cursor `lines` up."}
{"completion":"","prompt":"Elixir.IO.ANSI.cyan(): Sets foreground color to cyan."}
{"completion":"","prompt":"Elixir.IO.ANSI.cyan_background(): Sets background color to cyan."}
{"completion":"","prompt":"Elixir.IO.ANSI.default_background(): Default background color."}
{"completion":"","prompt":"Elixir.IO.ANSI.default_color(): Default text color."}
{"completion":"","prompt":"Elixir.IO.ANSI.enabled?(): Checks if ANSI coloring is supported and enabled on this machine.\n\nThis function simply reads the configuration value for\n`:ansi_enabled` in the `:elixir` application. The value is by\ndefault `false` unless Elixir can detect during startup that\nboth `stdout` and `stderr` are terminals.\n"}
{"completion":"","prompt":"Elixir.IO.ANSI.encircled(): Encircled."}
{"completion":"","prompt":"Elixir.IO.ANSI.faint(): Faint (decreased intensity). Not widely supported."}
{"completion":"","prompt":"Elixir.IO.ANSI.font_1(): Sets alternative font 1."}
{"completion":"","prompt":"Elixir.IO.ANSI.font_2(): Sets alternative font 2."}
{"completion":"","prompt":"Elixir.IO.ANSI.font_3(): Sets alternative font 3."}
{"completion":"","prompt":"Elixir.IO.ANSI.font_4(): Sets alternative font 4."}
{"completion":"","prompt":"Elixir.IO.ANSI.font_5(): Sets alternative font 5."}
{"completion":"","prompt":"Elixir.IO.ANSI.font_6(): Sets alternative font 6."}
{"completion":"","prompt":"Elixir.IO.ANSI.font_7(): Sets alternative font 7."}
{"completion":"","prompt":"Elixir.IO.ANSI.font_8(): Sets alternative font 8."}
{"completion":"","prompt":"Elixir.IO.ANSI.font_9(): Sets alternative font 9."}
{"completion":"","prompt":"Elixir.IO.ANSI.format(ansidata, emit? \\\\ enabled?()): Formats a chardata-like argument by converting named ANSI sequences into actual\nANSI codes.\n\nThe named sequences are represented by atoms.\n\nIt will also append an `IO.ANSI.reset/0` to the chardata when a conversion is\nperformed. If you don't want this behaviour, use `format_fragment/2`.\n\nAn optional boolean parameter can be passed to enable or disable\nemitting actual ANSI codes. When `false`, no ANSI codes will be emitted.\nBy default checks if ANSI is enabled using the `enabled?/0` function.\n\n## Examples\n\n    iex> IO.ANSI.format([\"Hello, \", :red, :bright, \"world!\"], true)\n    [[[[[[], \"Hello, \"] | \"\\e[31m\"] | \"\\e[1m\"], \"world!\"] | \"\\e[0m\"]\n\n"}
{"completion":"","prompt":"Elixir.IO.ANSI.format_fragment(ansidata, emit? \\\\ enabled?()): Formats a chardata-like argument by converting named ANSI sequences into actual\nANSI codes.\n\nThe named sequences are represented by atoms.\n\nAn optional boolean parameter can be passed to enable or disable\nemitting actual ANSI codes. When `false`, no ANSI codes will be emitted.\nBy default checks if ANSI is enabled using the `enabled?/0` function.\n\n## Examples\n\n    iex> IO.ANSI.format_fragment([:bright, 'Word'], true)\n    [[[[[[] | \"\\e[1m\"], 87], 111], 114], 100]\n\n"}
{"completion":"","prompt":"Elixir.IO.ANSI.framed(): Framed."}
{"completion":"","prompt":"Elixir.IO.ANSI.green(): Sets foreground color to green."}
{"completion":"","prompt":"Elixir.IO.ANSI.green_background(): Sets background color to green."}
{"completion":"","prompt":"Elixir.IO.ANSI.home(): Sends cursor home."}
{"completion":"","prompt":"Elixir.IO.ANSI.inverse(): Image: negative. Swap foreground and background."}
{"completion":"","prompt":"Elixir.IO.ANSI.inverse_off(): Image: positive. Normal foreground and background."}
{"completion":"","prompt":"Elixir.IO.ANSI.italic(): Italic: on. Not widely supported. Sometimes treated as inverse."}
{"completion":"","prompt":"Elixir.IO.ANSI.light_black(): Sets foreground color to light black."}
{"completion":"","prompt":"Elixir.IO.ANSI.light_black_background(): Sets background color to light black."}
{"completion":"","prompt":"Elixir.IO.ANSI.light_blue(): Sets foreground color to light blue."}
{"completion":"","prompt":"Elixir.IO.ANSI.light_blue_background(): Sets background color to light blue."}
{"completion":"","prompt":"Elixir.IO.ANSI.light_cyan(): Sets foreground color to light cyan."}
{"completion":"","prompt":"Elixir.IO.ANSI.light_cyan_background(): Sets background color to light cyan."}
{"completion":"","prompt":"Elixir.IO.ANSI.light_green(): Sets foreground color to light green."}
{"completion":"","prompt":"Elixir.IO.ANSI.light_green_background(): Sets background color to light green."}
{"completion":"","prompt":"Elixir.IO.ANSI.light_magenta(): Sets foreground color to light magenta."}
{"completion":"","prompt":"Elixir.IO.ANSI.light_magenta_background(): Sets background color to light magenta."}
{"completion":"","prompt":"Elixir.IO.ANSI.light_red(): Sets foreground color to light red."}
{"completion":"","prompt":"Elixir.IO.ANSI.light_red_background(): Sets background color to light red."}
{"completion":"","prompt":"Elixir.IO.ANSI.light_white(): Sets foreground color to light white."}
{"completion":"","prompt":"Elixir.IO.ANSI.light_white_background(): Sets background color to light white."}
{"completion":"","prompt":"Elixir.IO.ANSI.light_yellow(): Sets foreground color to light yellow."}
{"completion":"","prompt":"Elixir.IO.ANSI.light_yellow_background(): Sets background color to light yellow."}
{"completion":"","prompt":"Elixir.IO.ANSI.magenta(): Sets foreground color to magenta."}
{"completion":"","prompt":"Elixir.IO.ANSI.magenta_background(): Sets background color to magenta."}
{"completion":"","prompt":"Elixir.IO.ANSI.no_underline(): Underline: none."}
{"completion":"","prompt":"Elixir.IO.ANSI.normal(): Normal color or intensity."}
{"completion":"","prompt":"Elixir.IO.ANSI.not_framed_encircled(): Not framed or encircled."}
{"completion":"","prompt":"Elixir.IO.ANSI.not_italic(): Not italic."}
{"completion":"","prompt":"Elixir.IO.ANSI.not_overlined(): Not overlined."}
{"completion":"","prompt":"Elixir.IO.ANSI.overlined(): Overlined."}
{"completion":"","prompt":"Elixir.IO.ANSI.primary_font(): Sets primary (default) font."}
{"completion":"","prompt":"Elixir.IO.ANSI.red(): Sets foreground color to red."}
{"completion":"","prompt":"Elixir.IO.ANSI.red_background(): Sets background color to red."}
{"completion":"","prompt":"Elixir.IO.ANSI.reset(): Resets all attributes."}
{"completion":"","prompt":"Elixir.IO.ANSI.reverse(): Image: negative. Swap foreground and background."}
{"completion":"","prompt":"Elixir.IO.ANSI.reverse_off(): Image: positive. Normal foreground and background."}
{"completion":"","prompt":"Elixir.IO.ANSI.syntax_colors(): Syntax colors to be used by `Inspect`.\n\nThose colors are used throughout Elixir's standard library,\nsuch as `dbg/2` and `IEx`.\n\nThe colors can be changed by setting the `:ansi_syntax_colors`\nin the `:elixir` application configuration. Configuration for\nmost built-in data types are supported: `:atom`, `:binary`,\n`:boolean`, `:charlist`, `:list`, `:map`, `:nil`, `:number`,\n`:string`, and `:tuple`. The default is:\n\n    [\n      atom: :cyan\n      boolean: :magenta,\n      charlist: :yellow,\n      nil: :magenta,\n      number: :yellow,\n      string: :green\n    ]\n\n"}
{"completion":"","prompt":"Elixir.IO.ANSI.underline(): Underline: single."}
{"completion":"","prompt":"Elixir.IO.ANSI.white(): Sets foreground color to white."}
{"completion":"","prompt":"Elixir.IO.ANSI.white_background(): Sets background color to white."}
{"completion":"","prompt":"Elixir.IO.ANSI.yellow(): Sets foreground color to yellow."}
{"completion":"","prompt":"Elixir.IO.ANSI.yellow_background(): Sets background color to yellow."}
{"completion":"","prompt":"Elixir.IO.binread(device \\\\ :stdio, line_or_chars): Reads from the IO `device`. The operation is Unicode unsafe.\n\nThe `device` is iterated as specified by the `line_or_chars` argument:\n\n  * if `line_or_chars` is an integer, it represents a number of bytes. The device is\n    iterated by that number of bytes.\n\n  * if `line_or_chars` is `:line`, the device is iterated line by line.\n\n  * if `line_or_chars` is `:eof`, the device is iterated until `:eof`. `line_or_chars`\n    can only be `:eof` since Elixir 1.13.0. `:eof` replaces the deprecated `:all`,\n    with the difference that `:all` returns `\"\"` on end of file, while `:eof` returns\n    `:eof` itself.\n\nIt returns:\n\n  * `data` - the output bytes\n\n  * `:eof` - end of file was encountered\n\n  * `{:error, reason}` - other (rare) error condition;\n    for instance, `{:error, :estale}` if reading from an\n    NFS volume\n\nNote: do not use this function on IO devices in Unicode mode\nas it will return the wrong result.\n"}
{"completion":"","prompt":"Elixir.IO.binstream(): Returns a raw, line-based `IO.Stream` on `:stdio`. The operation is Unicode unsafe.\n\nThis is equivalent to:\n\n    IO.binstream(:stdio, :line)\n\n"}
{"completion":"","prompt":"Elixir.IO.binstream(device \\\\ :stdio, line_or_bytes): Converts the IO `device` into an `IO.Stream`. The operation is Unicode unsafe.\n\nAn `IO.Stream` implements both `Enumerable` and\n`Collectable`, allowing it to be used for both read\nand write.\n\nThe `device` is iterated by the given number of bytes or line by line if\n`:line` is given. This reads from the IO device as a raw binary.\n\nNote that an IO stream has side effects and every time\nyou go over the stream you may get different results.\n\nFinally, do not use this function on IO devices in Unicode\nmode as it will return the wrong result.\n\n`binstream/0` has been introduced in Elixir v1.12.0,\nwhile `binstream/2` has been available since v1.0.0.\n"}
{"completion":"","prompt":"Elixir.IO.binwrite(device \\\\ :stdio, iodata): Writes `iodata` to the given `device`.\n\nThis operation is meant to be used with \"raw\" devices\nthat are started without an encoding. The given `iodata`\nis written as is to the device, without conversion. For\nmore information on IO data, see the \"IO data\" section in\nthe module documentation.\n\nUse `write/2` for devices with encoding.\n\nImportant: do **not** use this function on IO devices in\nUnicode mode as it will write the wrong data. In particular,\nthe standard IO device is set to Unicode by default, so writing\nto stdio with this function will likely result in the wrong data\nbeing sent down the wire.\n"}
{"completion":"","prompt":"Elixir.IO.chardata_to_string(chardata): Converts chardata into a string.\n\nFor more information about chardata, see the [\"Chardata\"](#module-chardata)\nsection in the module documentation.\n\nIn case the conversion fails, it raises an `UnicodeConversionError`.\nIf a string is given, it returns the string itself.\n\n## Examples\n\n    iex> IO.chardata_to_string([0x00E6, 0x00DF])\n    \"Ã¦Ã\"\n\n    iex> IO.chardata_to_string([0x0061, \"bc\"])\n    \"abc\"\n\n    iex> IO.chardata_to_string(\"string\")\n    \"string\"\n\n"}
{"completion":"","prompt":"Elixir.IO.getn(prompt, count \\\\ 1): Gets a number of bytes from IO device `:stdio`.\n\nIf `:stdio` is a Unicode device, `count` implies\nthe number of Unicode code points to be retrieved.\nOtherwise, `count` is the number of raw bytes to be retrieved.\n\nSee `IO.getn/3` for a description of return values.\n"}
{"completion":"","prompt":"Elixir.IO.getn(device, prompt, count): Gets a number of bytes from the IO `device`.\n\nIf the IO `device` is a Unicode device, `count` implies\nthe number of Unicode code points to be retrieved.\nOtherwise, `count` is the number of raw bytes to be retrieved.\n\nIt returns:\n\n  * `data` - the input characters\n\n  * `:eof` - end of file was encountered\n\n  * `{:error, reason}` - other (rare) error condition;\n    for instance, `{:error, :estale}` if reading from an\n    NFS volume\n\n"}
{"completion":"","prompt":"Elixir.IO.gets(device \\\\ :stdio, prompt): Reads a line from the IO `device`.\n\nIt returns:\n\n  * `data` - the characters in the line terminated\n    by a line-feed (LF) or end of file (EOF)\n\n  * `:eof` - end of file was encountered\n\n  * `{:error, reason}` - other (rare) error condition;\n    for instance, `{:error, :estale}` if reading from an\n    NFS volume\n\n## Examples\n\nTo display \"What is your name?\" as a prompt and await user input:\n\n    IO.gets(\"What is your name?\\n\")\n\n"}
{"completion":"","prompt":"Elixir.IO.inspect(item, opts \\\\ []): Inspects and writes the given `item` to the device.\n\nIt's important to note that it returns the given `item` unchanged.\nThis makes it possible to \"spy\" on values by inserting an\n`IO.inspect/2` call almost anywhere in your code, for example,\nin the middle of a pipeline.\n\nIt enables pretty printing by default with width of\n80 characters. The width can be changed by explicitly\npassing the `:width` option.\n\nThe output can be decorated with a label, by providing the `:label`\noption to easily distinguish it from other `IO.inspect/2` calls.\nThe label will be printed before the inspected `item`.\n\nSee `Inspect.Opts` for a full list of remaining formatting options.\n\n## Examples\n\n    IO.inspect(<<0, 1, 2>>, width: 40)\n\nPrints:\n\n    <<0, 1, 2>>\n\nWe can use the `:label` option to decorate the output:\n\n    IO.inspect(1..100, label: \"a wonderful range\")\n\nPrints:\n\n    a wonderful range: 1..100\n\nThe `:label` option is especially useful with pipelines:\n\n    [1, 2, 3]\n    |> IO.inspect(label: \"before\")\n    |> Enum.map(&(&1 * 2))\n    |> IO.inspect(label: \"after\")\n    |> Enum.sum()\n\nPrints:\n\n    before: [1, 2, 3]\n    after: [2, 4, 6]\n\n"}
{"completion":"","prompt":"Elixir.IO.inspect(device, item, opts): Inspects `item` according to the given options using the IO `device`.\n\nSee `inspect/2` for a full list of options.\n"}
{"completion":"","prompt":"Elixir.IO.iodata_length(iodata): Returns the size of an IO data.\n\nFor more information about IO data, see the [\"IO data\"](#module-io-data)\nsection in the module documentation.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> IO.iodata_length([1, 2 | <<3, 4>>])\n    4\n\n"}
{"completion":"","prompt":"Elixir.IO.iodata_to_binary(iodata): Converts IO data into a binary\n\nThe operation is Unicode unsafe.\n\nNote that this function treats integers in the given IO data as\nraw bytes and does not perform any kind of encoding conversion.\nIf you want to convert from a charlist to a UTF-8-encoded string,\nuse `chardata_to_string/1` instead. For more information about\nIO data and chardata, see the [\"IO data\"](#module-io-data) section in the\nmodule documentation.\n\nIf this function receives a binary, the same binary is returned.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> bin1 = <<1, 2, 3>>\n    iex> bin2 = <<4, 5>>\n    iex> bin3 = <<6>>\n    iex> IO.iodata_to_binary([bin1, 1, [2, 3, bin2], 4 | bin3])\n    <<1, 2, 3, 1, 2, 3, 4, 5, 4, 6>>\n\n    iex> bin = <<1, 2, 3>>\n    iex> IO.iodata_to_binary(bin)\n    <<1, 2, 3>>\n\n"}
{"completion":"","prompt":"Elixir.IO.puts(device \\\\ :stdio, item): Writes `item` to the given `device`, similar to `write/2`,\nbut adds a newline at the end.\n\nBy default, the `device` is the standard output. It returns `:ok`\nif it succeeds.\n\n## Examples\n\n    IO.puts(\"Hello World!\")\n    #=> Hello World!\n\n    IO.puts(:stderr, \"error\")\n    #=> error\n\n"}
{"completion":"","prompt":"Elixir.IO.read(device \\\\ :stdio, line_or_chars): Reads from the IO `device`.\n\nThe `device` is iterated by the given number of characters, line by line if\n`:line` is given, or until `:eof`.\n\nIt returns:\n\n  * `data` - the output characters\n\n  * `:eof` - end of file was encountered\n\n  * `{:error, reason}` - other (rare) error condition;\n    for instance, `{:error, :estale}` if reading from an\n    NFS volume\n\n"}
{"completion":"","prompt":"Elixir.IO.stream(): Returns a line-based `IO.Stream` on `:stdio`.\n\nThis is equivalent to:\n\n    IO.stream(:stdio, :line)\n\n"}
{"completion":"","prompt":"Elixir.IO.stream(device \\\\ :stdio, line_or_codepoints): Converts the IO `device` into an `IO.Stream`.\n\nAn `IO.Stream` implements both `Enumerable` and\n`Collectable`, allowing it to be used for both read\nand write.\n\nThe `device` is iterated by the given number of characters or line by line if\n`:line` is given.\n\nThis reads from the IO as UTF-8. Check out\n`IO.binstream/2` to handle the IO as a raw binary.\n\nNote that an IO stream has side effects and every time\nyou go over the stream you may get different results.\n\n`stream/0` has been introduced in Elixir v1.12.0,\nwhile `stream/2` has been available since v1.0.0.\n\n## Examples\n\nHere is an example on how we mimic an echo server\nfrom the command line:\n\n    Enum.each(IO.stream(:stdio, :line), &IO.write(&1))\n\n"}
{"completion":"","prompt":"Elixir.IO.warn(message): Writes a `message` to stderr, along with the current stacktrace.\n\nIt returns `:ok` if it succeeds.\n\nDo not call this function at the tail of another function. Due to tail\ncall optimization, a stacktrace entry would not be added and the\nstacktrace would be incorrectly trimmed. Therefore make sure at least\none expression (or an atom such as `:ok`) follows the `IO.warn/1` call.\n\n## Examples\n\n    IO.warn(\"variable bar is unused\")\n    #=> warning: variable bar is unused\n    #=>   (iex) evaluator.ex:108: IEx.Evaluator.eval/4\n\n"}
{"completion":"","prompt":"Elixir.IO.warn(message, stacktrace_info): Writes a `message` to stderr, along with the given `stacktrace_info`.\n\nThe `stacktrace_info` must be one of:\n\n  * a `__STACKTRACE__`, where all entries in the stacktrace will be\n    included in the error message\n\n  * a `Macro.Env` structure (since v1.14.0), where a single stacktrace\n    entry from the compilation environment will be used\n\n  * a keyword list with at least the `:file` option representing\n    a single stacktrace entry (since v1.14.0). The `:line`, `:module`,\n    `:function` options are also supported\n\nThis function also notifies the compiler a warning was printed\n(in case --warnings-as-errors was enabled). It returns `:ok`\nif it succeeds.\n\n## Examples\n\n    stacktrace = [{MyApp, :main, 1, [file: 'my_app.ex', line: 4]}]\n    IO.warn(\"variable bar is unused\", stacktrace)\n    #=> warning: variable bar is unused\n    #=>   my_app.ex:4: MyApp.main/1\n\n"}
{"completion":"","prompt":"Elixir.IO.write(device \\\\ :stdio, chardata): Writes `chardata` to the given `device`.\n\nBy default, the `device` is the standard output.\n\n## Examples\n\n    IO.write(\"sample\")\n    #=> sample\n\n    IO.write(:stderr, \"error\")\n    #=> error\n\n"}
{"completion":"","prompt":"Elixir.Inspect.Algebra.break(string \\\\ \" \"): Returns a break document based on the given `string`.\n\nThis break can be rendered as a linebreak or as the given `string`,\ndepending on the `mode` of the chosen layout.\n\n## Examples\n\nLet's create a document by concatenating two strings with a break between\nthem:\n\n    iex> doc = Inspect.Algebra.concat([\"a\", Inspect.Algebra.break(\"\\t\"), \"b\"])\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"a\", \"\\t\", \"b\"]\n\nNote that the break was represented with the given string, because we didn't\nreach a line limit. Once we do, it is replaced by a newline:\n\n    iex> break = Inspect.Algebra.break(\"\\t\")\n    iex> doc = Inspect.Algebra.concat([String.duplicate(\"a\", 20), break, \"b\"])\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> Inspect.Algebra.format(doc, 10)\n    [\"aaaaaaaaaaaaaaaaaaaa\", \"\\n\", \"b\"]\n\n"}
{"completion":"","prompt":"Elixir.Inspect.Algebra.collapse_lines(max): Collapse any new lines and whitespace following this\nnode, emitting up to `max` new lines.\n"}
{"completion":"","prompt":"Elixir.Inspect.Algebra.color(doc, color_key, opts): Colors a document if the `color_key` has a color in the options.\n"}
{"completion":"","prompt":"Elixir.Inspect.Algebra.concat(docs): Concatenates a list of documents returning a new document.\n\n## Examples\n\n    iex> doc = Inspect.Algebra.concat([\"a\", \"b\", \"c\"])\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"a\", \"b\", \"c\"]\n\n"}
{"completion":"","prompt":"Elixir.Inspect.Algebra.concat(doc1, doc2): Concatenates two document entities returning a new document.\n\n## Examples\n\n    iex> doc = Inspect.Algebra.concat(\"hello\", \"world\")\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"hello\", \"world\"]\n\n"}
{"completion":"","prompt":"Elixir.Inspect.Algebra.container_doc(left, collection, right, inspect_opts, fun, opts \\\\ []): Wraps `collection` in `left` and `right` according to limit and contents.\n\nIt uses the given `left` and `right` documents as surrounding and the\nseparator document `separator` to separate items in `docs`. If all entries\nin the collection are simple documents (texts or strings), then this function\nattempts to put as much as possible on the same line. If they are not simple,\nonly one entry is shown per line if they do not fit.\n\nThe limit in the given `inspect_opts` is respected and when reached this\nfunction stops processing and outputs `\"...\"` instead.\n\n## Options\n\n  * `:separator` - the separator used between each doc\n  * `:break` - If `:strict`, always break between each element. If `:flex`,\n    breaks only when necessary. If `:maybe`, chooses `:flex` only if all\n    elements are text-based, otherwise is `:strict`\n\n## Examples\n\n    iex> inspect_opts = %Inspect.Opts{limit: :infinity}\n    iex> fun = fn i, _opts -> to_string(i) end\n    iex> doc = Inspect.Algebra.container_doc(\"[\", Enum.to_list(1..5), \"]\", inspect_opts, fun)\n    iex> Inspect.Algebra.format(doc, 5) |> IO.iodata_to_binary()\n    \"[1,\\n 2,\\n 3,\\n 4,\\n 5]\"\n\n    iex> inspect_opts = %Inspect.Opts{limit: 3}\n    iex> fun = fn i, _opts -> to_string(i) end\n    iex> doc = Inspect.Algebra.container_doc(\"[\", Enum.to_list(1..5), \"]\", inspect_opts, fun)\n    iex> Inspect.Algebra.format(doc, 20) |> IO.iodata_to_binary()\n    \"[1, 2, 3, ...]\"\n\n    iex> inspect_opts = %Inspect.Opts{limit: 3}\n    iex> fun = fn i, _opts -> to_string(i) end\n    iex> opts = [separator: \"!\"]\n    iex> doc = Inspect.Algebra.container_doc(\"[\", Enum.to_list(1..5), \"]\", inspect_opts, fun, opts)\n    iex> Inspect.Algebra.format(doc, 20) |> IO.iodata_to_binary()\n    \"[1! 2! 3! ...]\"\n\n"}
{"completion":"","prompt":"Elixir.Inspect.Algebra.empty(): Returns a document entity used to represent nothingness.\n\n## Examples\n\n    iex> Inspect.Algebra.empty()\n    :doc_nil\n\n"}
{"completion":"","prompt":"Elixir.Inspect.Algebra.flex_break(string \\\\ \" \"): Returns a flex break document based on the given `string`.\n\nA flex break still causes a group to break, like `break/1`,\nbut it is re-evaluated when the documented is rendered.\n\nFor example, take a group document represented as `[1, 2, 3]`\nwhere the space after every comma is a break. When the document\nabove does not fit a single line, all breaks are enabled,\ncausing the document to be rendered as:\n\n    [1,\n     2,\n     3]\n\nHowever, if flex breaks are used, then each break is re-evaluated\nwhen rendered, so the document could be possible rendered as:\n\n    [1, 2,\n     3]\n\nHence the name \"flex\". they are more flexible when it comes\nto the document fitting. On the other hand, they are more expensive\nsince each break needs to be re-evaluated.\n\nThis function is used by `container_doc/6` and friends to the\nmaximum number of entries on the same line.\n"}
{"completion":"","prompt":"Elixir.Inspect.Algebra.flex_glue(doc1, break_string \\\\ \" \", doc2): Glues two documents (`doc1` and `doc2`) inserting a\n`flex_break/1` given by `break_string` between them.\n\nThis function is used by `container_doc/6` and friends\nto the maximum number of entries on the same line.\n"}
{"completion":"","prompt":"Elixir.Inspect.Algebra.fold_doc(docs, folder_fun): Folds a list of documents into a document using the given folder function.\n\nThe list of documents is folded \"from the right\"; in that, this function is\nsimilar to `List.foldr/3`, except that it doesn't expect an initial\naccumulator and uses the last element of `docs` as the initial accumulator.\n\n## Examples\n\n    iex> docs = [\"A\", \"B\", \"C\"]\n    iex> docs =\n    ...>   Inspect.Algebra.fold_doc(docs, fn doc, acc ->\n    ...>     Inspect.Algebra.concat([doc, \"!\", acc])\n    ...>   end)\n    iex> Inspect.Algebra.format(docs, 80)\n    [\"A\", \"!\", \"B\", \"!\", \"C\"]\n\n"}
{"completion":"","prompt":"Elixir.Inspect.Algebra.force_unfit(doc): Forces the current group to be unfit.\n"}
{"completion":"","prompt":"Elixir.Inspect.Algebra.format(doc, width): Formats a given document for a given width.\n\nTakes the maximum width and a document to print as its arguments\nand returns an IO data representation of the best layout for the\ndocument to fit in the given width.\n\nThe document starts flat (without breaks) until a group is found.\n\n## Examples\n\n    iex> doc = Inspect.Algebra.glue(\"hello\", \" \", \"world\")\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> doc |> Inspect.Algebra.format(30) |> IO.iodata_to_binary()\n    \"hello world\"\n    iex> doc |> Inspect.Algebra.format(10) |> IO.iodata_to_binary()\n    \"hello\\nworld\"\n\n"}
{"completion":"","prompt":"Elixir.Inspect.Algebra.glue(doc1, break_string \\\\ \" \", doc2): Glues two documents (`doc1` and `doc2`) inserting the given\nbreak `break_string` between them.\n\nFor more information on how the break is inserted, see `break/1`.\n\n## Examples\n\n    iex> doc = Inspect.Algebra.glue(\"hello\", \"world\")\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"hello\", \" \", \"world\"]\n\n    iex> doc = Inspect.Algebra.glue(\"hello\", \"\\t\", \"world\")\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"hello\", \"\\t\", \"world\"]\n\n"}
{"completion":"","prompt":"Elixir.Inspect.Algebra.group(doc, mode \\\\ :self): Returns a group containing the specified document `doc`.\n\nDocuments in a group are attempted to be rendered together\nto the best of the renderer ability.\n\nThe group mode can also be set to `:inherit`, which means it\nautomatically breaks if the parent group has broken too.\n\n## Examples\n\n    iex> doc =\n    ...>   Inspect.Algebra.group(\n    ...>     Inspect.Algebra.concat(\n    ...>       Inspect.Algebra.group(\n    ...>         Inspect.Algebra.concat(\n    ...>           \"Hello,\",\n    ...>           Inspect.Algebra.concat(\n    ...>             Inspect.Algebra.break(),\n    ...>             \"A\"\n    ...>           )\n    ...>         )\n    ...>       ),\n    ...>       Inspect.Algebra.concat(\n    ...>         Inspect.Algebra.break(),\n    ...>         \"B\"\n    ...>       )\n    ...>     )\n    ...>   )\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"Hello,\", \" \", \"A\", \" \", \"B\"]\n    iex> Inspect.Algebra.format(doc, 6)\n    [\"Hello,\", \"\\n\", \"A\", \"\\n\", \"B\"]\n\n"}
{"completion":"","prompt":"Elixir.Inspect.Algebra.line(): A mandatory linebreak.\n\nA group with linebreaks will fit if all lines in the group fit.\n\n## Examples\n\n    iex> doc =\n    ...>   Inspect.Algebra.concat(\n    ...>     Inspect.Algebra.concat(\n    ...>       \"Hughes\",\n    ...>       Inspect.Algebra.line()\n    ...>     ),\n    ...>     \"Wadler\"\n    ...>   )\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"Hughes\", \"\\n\", \"Wadler\"]\n\n"}
{"completion":"","prompt":"Elixir.Inspect.Algebra.line(doc1, doc2): Inserts a mandatory linebreak between two documents.\n\nSee `line/0`.\n\n## Examples\n\n    iex> doc = Inspect.Algebra.line(\"Hughes\", \"Wadler\")\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"Hughes\", \"\\n\", \"Wadler\"]\n\n"}
{"completion":"","prompt":"Elixir.Inspect.Algebra.nest(doc, level, mode \\\\ :always): Nests the given document at the given `level`.\n\nIf `level` is an integer, that's the indentation appended\nto line breaks whenever they occur. If the level is `:cursor`,\nthe current position of the \"cursor\" in the document becomes\nthe nesting. If the level is `:reset`, it is set back to 0.\n\n`mode` can be `:always`, which means nesting always happen,\nor `:break`, which means nesting only happens inside a group\nthat has been broken.\n\n## Examples\n\n    iex> doc = Inspect.Algebra.nest(Inspect.Algebra.glue(\"hello\", \"world\"), 5)\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> Inspect.Algebra.format(doc, 5)\n    [\"hello\", \"\\n     \", \"world\"]\n\n"}
{"completion":"","prompt":"Elixir.Inspect.Algebra.next_break_fits(doc, mode \\\\ :enabled): Considers the next break as fit.\n\n`mode` can be `:enabled` or `:disabled`. When `:enabled`,\nit will consider the document as fit as soon as it finds\nthe next break, effectively cancelling the break. It will\nalso ignore any `force_unfit/1` in search of the next break.\n\nWhen disabled, it behaves as usual and it will ignore\nany further `next_break_fits/2` instruction.\n\n## Examples\n\nThis is used by Elixir's code formatter to avoid breaking\ncode at some specific locations. For example, consider this\ncode:\n\n    some_function_call(%{..., key: value, ...})\n\nNow imagine that this code does not fit its line. The code\nformatter introduces breaks inside `(` and `)` and inside\n`%{` and `}`. Therefore the document would break as:\n\n    some_function_call(\n      %{\n        ...,\n        key: value,\n        ...\n      }\n    )\n\nThe formatter wraps the algebra document representing the\nmap in `next_break_fits/1` so the code is formatted as:\n\n    some_function_call(%{\n      ...,\n      key: value,\n      ...\n    })\n\n"}
{"completion":"","prompt":"Elixir.Inspect.Algebra.space(doc1, doc2): Inserts a mandatory single space between two documents.\n\n## Examples\n\n    iex> doc = Inspect.Algebra.space(\"Hughes\", \"Wadler\")\n    iex> Inspect.Algebra.format(doc, 5)\n    [\"Hughes\", \" \", \"Wadler\"]\n\n"}
{"completion":"","prompt":"Elixir.Inspect.Algebra.string(string): Creates a document represented by string.\n\nWhile `Inspect.Algebra` accepts binaries as documents,\nthose are counted by binary size. On the other hand,\n`string` documents are measured in terms of graphemes\ntowards the document size.\n\n## Examples\n\nThe following document has 10 bytes and therefore it\ndoes not format to width 9 without breaks:\n\n    iex> doc = Inspect.Algebra.glue(\"olÃ¡\", \" \", \"mundo\")\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> Inspect.Algebra.format(doc, 9)\n    [\"olÃ¡\", \"\\n\", \"mundo\"]\n\nHowever, if we use `string`, then the string length is\nused, instead of byte size, correctly fitting:\n\n    iex> string = Inspect.Algebra.string(\"olÃ¡\")\n    iex> doc = Inspect.Algebra.glue(string, \" \", \"mundo\")\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> Inspect.Algebra.format(doc, 9)\n    [\"olÃ¡\", \" \", \"mundo\"]\n\n"}
{"completion":"","prompt":"Elixir.Inspect.Algebra.to_doc(term, opts): Converts an Elixir term to an algebra document\naccording to the `Inspect` protocol.\n"}
{"completion":"","prompt":"Elixir.Inspect.Opts.default_inspect_fun(): Returns the default inspect function.\n"}
{"completion":"","prompt":"Elixir.Inspect.Opts.default_inspect_fun(fun): Sets the default inspect function.\n\nSet this option with care as it will change how all values\nin the system are inspected. The main use of this functionality\nis to provide an entry point to filter inspected values,\nin order for entities to comply with rules and legislations\non data security and data privacy.\n\nIt is **extremely discouraged** for libraries to set their own\nfunction as this must be controlled by applications. Libraries\nshould instead define their own structs with custom inspect\nimplementations. If a library must change the default inspect\nfunction, then it is best to define to ask users of your library\nto explicitly call `default_inspect_fun/1` with your function of\nchoice.\n\nThe default is `Inspect.inspect/2`.\n\n## Examples\n\n    previous_fun = Inspect.Opts.default_inspect_fun()\n\n    Inspect.Opts.default_inspect_fun(fn\n      %{address: _} = map, opts ->\n        previous_fun.(%{map | address: \"[REDACTED]\"}, opts)\n\n      value, opts ->\n        previous_fun.(value, opts)\n    end)\n\n"}
{"completion":"","prompt":"Elixir.Inspect.Opts.new(opts): Builds an `Inspect.Opts` struct.\n"}
{"completion":"","prompt":"Elixir.Inspect.inspect(term, opts): Converts `term` into an algebra document.\n\nThis function shouldn't be invoked directly, unless when implementing\na custom `inspect_fun` to be given to `Inspect.Opts`. Everywhere else,\n`Inspect.Algebra.to_doc/2` should be preferred as it handles structs\nand exceptions.\n"}
{"completion":"","prompt":"Elixir.Integer.digits(integer, base \\\\ 10): Returns the ordered digits for the given `integer`.\n\nAn optional `base` value may be provided representing the radix for the returned\ndigits. This one must be an integer >= 2.\n\n## Examples\n\n    iex> Integer.digits(123)\n    [1, 2, 3]\n\n    iex> Integer.digits(170, 2)\n    [1, 0, 1, 0, 1, 0, 1, 0]\n\n    iex> Integer.digits(-170, 2)\n    [-1, 0, -1, 0, -1, 0, -1, 0]\n\n"}
{"completion":"","prompt":"Elixir.Integer.extended_gcd(a, b): Returns the extended greatest common divisor of the two given integers.\n\nThis function uses the extended Euclidean algorithm to return a three-element tuple with the `gcd`\nand the coefficients `m` and `n` of BÃ©zout's identity such that:\n\n    gcd(a, b) = m*a + n*b\n\nBy convention, `extended_gcd(0, 0)` returns `{0, 0, 0}`.\n\n## Examples\n\n    iex> Integer.extended_gcd(240, 46)\n    {2, -9, 47}\n    iex> Integer.extended_gcd(46, 240)\n    {2, 47, -9}\n    iex> Integer.extended_gcd(-46, 240)\n    {2, -47, -9}\n    iex> Integer.extended_gcd(-46, -240)\n    {2, -47, 9}\n\n    iex> Integer.extended_gcd(14, 21)\n    {7, -1, 1}\n\n    iex> Integer.extended_gcd(10, 0)\n    {10, 1, 0}\n    iex> Integer.extended_gcd(0, 10)\n    {10, 0, 1}\n    iex> Integer.extended_gcd(0, 0)\n    {0, 0, 0}\n\n"}
{"completion":"","prompt":"Elixir.Integer.floor_div(dividend, divisor): Performs a floored integer division.\n\nRaises an `ArithmeticError` exception if one of the arguments is not an\ninteger, or when the `divisor` is `0`.\n\nThis function performs a *floored* integer division, which means that\nthe result will always be rounded towards negative infinity.\n\nIf you want to perform truncated integer division (rounding towards zero),\nuse `Kernel.div/2` instead.\n\n## Examples\n\n    iex> Integer.floor_div(5, 2)\n    2\n    iex> Integer.floor_div(6, -4)\n    -2\n    iex> Integer.floor_div(-99, 2)\n    -50\n\n"}
{"completion":"","prompt":"Elixir.Integer.gcd(integer1, integer2): Returns the greatest common divisor of the two given integers.\n\nThe greatest common divisor (GCD) of `integer1` and `integer2` is the largest positive\ninteger that divides both `integer1` and `integer2` without leaving a remainder.\n\nBy convention, `gcd(0, 0)` returns `0`.\n\n## Examples\n\n    iex> Integer.gcd(2, 3)\n    1\n\n    iex> Integer.gcd(8, 12)\n    4\n\n    iex> Integer.gcd(8, -12)\n    4\n\n    iex> Integer.gcd(10, 0)\n    10\n\n    iex> Integer.gcd(7, 7)\n    7\n\n    iex> Integer.gcd(0, 0)\n    0\n\n"}
{"completion":"","prompt":"Elixir.Integer.mod(dividend, divisor): Computes the modulo remainder of an integer division.\n\nThis function performs a [floored division](`floor_div/2`), which means that\nthe result will always have the sign of the `divisor`.\n\nRaises an `ArithmeticError` exception if one of the arguments is not an\ninteger, or when the `divisor` is `0`.\n\n## Examples\n\n    iex> Integer.mod(5, 2)\n    1\n    iex> Integer.mod(6, -4)\n    -2\n\n"}
{"completion":"","prompt":"Elixir.Integer.parse(binary, base \\\\ 10): Parses a text representation of an integer.\n\nAn optional `base` to the corresponding integer can be provided.\nIf `base` is not given, 10 will be used.\n\nIf successful, returns a tuple in the form of `{integer, remainder_of_binary}`.\nOtherwise `:error`.\n\nRaises an error if `base` is less than 2 or more than 36.\n\nIf you want to convert a string-formatted integer directly to an integer,\n`String.to_integer/1` or `String.to_integer/2` can be used instead.\n\n## Examples\n\n    iex> Integer.parse(\"34\")\n    {34, \"\"}\n\n    iex> Integer.parse(\"34.5\")\n    {34, \".5\"}\n\n    iex> Integer.parse(\"three\")\n    :error\n\n    iex> Integer.parse(\"34\", 10)\n    {34, \"\"}\n\n    iex> Integer.parse(\"f4\", 16)\n    {244, \"\"}\n\n    iex> Integer.parse(\"Awww++\", 36)\n    {509216, \"++\"}\n\n    iex> Integer.parse(\"fab\", 10)\n    :error\n\n    iex> Integer.parse(\"a2\", 38)\n    ** (ArgumentError) invalid base 38\n\n"}
{"completion":"","prompt":"Elixir.Integer.pow(base, exponent): Computes `base` raised to power of `exponent`.\n\nBoth `base` and `exponent` must be integers.\nThe exponent must be zero or positive.\n\nSee `Float.pow/2` for exponentiation of negative\nexponents as well as floats.\n\n## Examples\n\n    iex> Integer.pow(2, 0)\n    1\n    iex> Integer.pow(2, 1)\n    2\n    iex> Integer.pow(2, 10)\n    1024\n    iex> Integer.pow(2, 11)\n    2048\n    iex> Integer.pow(2, 64)\n    0x10000000000000000\n\n    iex> Integer.pow(3, 4)\n    81\n    iex> Integer.pow(4, 3)\n    64\n\n    iex> Integer.pow(-2, 3)\n    -8\n    iex> Integer.pow(-2, 4)\n    16\n\n    iex> Integer.pow(2, -2)\n    ** (ArithmeticError) bad argument in arithmetic expression\n\n"}
{"completion":"","prompt":"Elixir.Integer.to_charlist(integer, base \\\\ 10): Returns a charlist which corresponds to the text representation\nof `integer` in the given `base`.\n\n`base` can be an integer between 2 and 36. If no `base` is given,\nit defaults to `10`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Integer.to_charlist(123)\n    '123'\n\n    iex> Integer.to_charlist(+456)\n    '456'\n\n    iex> Integer.to_charlist(-789)\n    '-789'\n\n    iex> Integer.to_charlist(0123)\n    '123'\n\n    iex> Integer.to_charlist(100, 16)\n    '64'\n\n    iex> Integer.to_charlist(-100, 16)\n    '-64'\n\n    iex> Integer.to_charlist(882_681_651, 36)\n    'ELIXIR'\n\n"}
{"completion":"","prompt":"Elixir.Integer.to_string(integer, base \\\\ 10): Returns a binary which corresponds to the text representation\nof `integer` in the given `base`.\n\n`base` can be an integer between 2 and 36. If no `base` is given,\nit defaults to `10`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Integer.to_string(123)\n    \"123\"\n\n    iex> Integer.to_string(+456)\n    \"456\"\n\n    iex> Integer.to_string(-789)\n    \"-789\"\n\n    iex> Integer.to_string(0123)\n    \"123\"\n\n    iex> Integer.to_string(100, 16)\n    \"64\"\n\n    iex> Integer.to_string(-100, 16)\n    \"-64\"\n\n    iex> Integer.to_string(882_681_651, 36)\n    \"ELIXIR\"\n\n"}
{"completion":"","prompt":"Elixir.Integer.undigits(digits, base \\\\ 10): Returns the integer represented by the ordered `digits`.\n\nAn optional `base` value may be provided representing the radix for the `digits`.\nBase has to be an integer greater than or equal to `2`.\n\n## Examples\n\n    iex> Integer.undigits([1, 2, 3])\n    123\n\n    iex> Integer.undigits([1, 4], 16)\n    20\n\n    iex> Integer.undigits([])\n    0\n\n"}
{"completion":"","prompt":"Elixir.Kernel.CLI.format_error(kind, reason, stacktrace): Shared helper for error formatting on CLI tools.\n"}
{"completion":"","prompt":"Elixir.Kernel.CLI.main(argv): This is the API invoked by Elixir boot process.\n"}
{"completion":"","prompt":"Elixir.Kernel.CLI.parse_argv(argv): Parses the CLI arguments. Made public for testing.\n"}
{"completion":"","prompt":"Elixir.Kernel.CLI.process_commands(config): Process CLI commands. Made public for testing.\n"}
{"completion":"","prompt":"Elixir.Kernel.CLI.rpc_eval(expr): Function invoked across nodes for `--rpc-eval`.\n"}
{"completion":"","prompt":"Elixir.Kernel.CLI.run(fun): Runs the given function by catching any failure\nand printing them to stdout. `at_exit` hooks are\nalso invoked before exiting.\n\nThis function is used by Elixir's CLI and also\nby escripts generated by Elixir.\n"}
{"completion":"","prompt":"Elixir.Kernel.LexicalTracker.references(pid): Returns all references in this lexical scope.\n"}
{"completion":"","prompt":"Elixir.Kernel.ParallelCompiler.async(fun): Starts a task for parallel compilation.\n\nIf you have a file that needs to compile other modules in parallel,\nthe spawned processes need to be aware of the compiler environment.\nThis function allows a developer to create a task that is aware of\nthose environments.\n\nSee `Task.async/1` for more information. The task spawned must be\nalways awaited on by calling `Task.await/1`\n"}
{"completion":"","prompt":"Elixir.Kernel.ParallelCompiler.compile(files, options \\\\ []): Compiles the given files.\n\nThose files are compiled in parallel and can automatically\ndetect dependencies between them. Once a dependency is found,\nthe current file stops being compiled until the dependency is\nresolved.\n\nIt returns `{:ok, modules, warnings}` or `{:error, errors, warnings}`.\n\nBoth errors and warnings are a list of three-element tuples containing\nthe file, line and the formatted error/warning.\n\n## Options\n\n  * `:each_file` - for each file compiled, invokes the callback passing the\n    file\n\n  * `:each_long_compilation` - for each file that takes more than a given\n    timeout (see the `:long_compilation_threshold` option) to compile, invoke\n    this callback passing the file as its argument\n\n  * `:each_module` - for each module compiled, invokes the callback passing\n    the file, module and the module bytecode\n\n  * `:each_cycle` - after the given files are compiled, invokes this function\n    that should return the following values:\n    * `{:compile, modules, warnings}` - to continue compilation with a list of\n      further modules to compile\n    * `{:runtime, modules, warnings}` - to stop compilation and verify the list\n      of modules because dependent modules have changed\n\n  * `:long_compilation_threshold` - the timeout (in seconds) to check for modules\n    taking too long to compile. For each file that exceeds the threshold, the\n    `:each_long_compilation` callback is invoked. From Elixir v1.11, only the time\n    spent compiling the actual module is taken into account by the threshold, the\n    time spent waiting is not considered. Defaults to `10` seconds.\n\n  * `:profile` - if set to `:time` measure the compilation time of each compilation cycle\n     and group pass checker\n\n  * `:dest` - the destination directory for the BEAM files. When using `compile/2`,\n    this information is only used to properly annotate the BEAM files before\n    they are loaded into memory. If you want a file to actually be written to\n    `dest`, use `compile_to_path/3` instead.\n\n  * `:beam_timestamp` - the modification timestamp to give all BEAM files\n\n"}
{"completion":"","prompt":"Elixir.Kernel.ParallelCompiler.compile_to_path(files, path, options \\\\ []): Compiles the given files and writes resulting BEAM files into path.\n\nSee `compile/2` for more information.\n"}
{"completion":"","prompt":"Elixir.Kernel.ParallelCompiler.print_warning(arg): Prints a warning returned by the compiler.\n"}
{"completion":"","prompt":"Elixir.Kernel.ParallelCompiler.require(files, options \\\\ []): Requires the given files in parallel.\n\nOpposite to compile, dependencies are not attempted to be\nautomatically solved between files.\n\nIt returns `{:ok, modules, warnings}` or `{:error, errors, warnings}`.\n\nBoth errors and warnings are a list of three-element tuples containing\nthe file, line and the formatted error/warning.\n\n## Options\n\n  * `:each_file` - for each file compiled, invokes the callback passing the\n    file\n\n  * `:each_module` - for each module compiled, invokes the callback passing\n    the file, module and the module bytecode\n\n"}
{"completion":"","prompt":"Elixir.Kernel.Typespec.deftypespec(kind, expr, line, file, module, pos): Defines a typespec.\n\nInvoked by `@/1` expansion.\n"}
{"completion":"","prompt":"Elixir.Kernel.Utils.announce_struct(module): Announcing callback for defstruct.\n"}
{"completion":"","prompt":"Elixir.Kernel.Utils.defdelegate_all(funs, opts, env): Callback for defdelegate entry point.\n"}
{"completion":"","prompt":"Elixir.Kernel.Utils.defdelegate_each(fun, opts): Callback for each function in defdelegate.\n"}
{"completion":"","prompt":"Elixir.Kernel.Utils.defstruct(module, fields, bootstrapped?): Callback for defstruct.\n"}
{"completion":"","prompt":"Elixir.Kernel.Utils.destructure(list, count): Callback for destructure.\n"}
{"completion":"","prompt":"Elixir.Kernel.Utils.raise(msg): Callback for raise.\n"}
{"completion":"","prompt":"Elixir.Kernel.left != right: Not equal to operator.\n\nReturns `true` if the two terms are not equal.\n\nThis operator considers 1 and 1.0 to be equal. For match\ncomparison, use `!==/2` instead.\n\nAll terms in Elixir can be compared with each other.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 != 2\n    true\n\n    iex> 1 != 1.0\n    false\n\n"}
{"completion":"","prompt":"Elixir.Kernel.left !== right: Strictly not equal to operator.\n\nReturns `true` if the two terms are not exactly equal.\nSee `===/2` for a definition of what is considered \"exactly equal\".\n\nAll terms in Elixir can be compared with each other.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 !== 2\n    true\n\n    iex> 1 !== 1.0\n    true\n\n"}
{"completion":"","prompt":"Elixir.Kernel.left * right: Arithmetic multiplication operator.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 * 2\n    2\n\n"}
{"completion":"","prompt":"Elixir.Kernel.base ** exponent: Power operator.\n\nIt expects two numbers are input. If the left-hand side is an integer\nand the right-hand side is more than or equal to 0, then the result is\ninteger. Otherwise it returns a float.\n\n## Examples\n\n    iex> 2 ** 2\n    4\n    iex> 2 ** -4\n    0.0625\n\n    iex> 2.0 ** 2\n    4.0\n    iex> 2 ** 2.0\n    4.0\n\n"}
{"completion":"","prompt":"Elixir.Kernel.+value: Arithmetic positive unary operator.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> +1\n    1\n\n"}
{"completion":"","prompt":"Elixir.Kernel.left + right: Arithmetic addition operator.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 + 2\n    3\n\n"}
{"completion":"","prompt":"Elixir.Kernel.left ++ right: List concatenation operator. Concatenates a proper list and a term, returning a list.\n\nThe complexity of `a ++ b` is proportional to `length(a)`, so avoid repeatedly\nappending to lists of arbitrary length, for example, `list ++ [element]`.\nInstead, consider prepending via `[element | rest]` and then reversing.\n\nIf the `right` operand is not a proper list, it returns an improper list.\nIf the `left` operand is not a proper list, it raises `ArgumentError`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> [1] ++ [2, 3]\n    [1, 2, 3]\n\n    iex> 'foo' ++ 'bar'\n    'foobar'\n\n    # returns an improper list\n    iex> [1] ++ 2\n    [1 | 2]\n\n    # returns a proper list\n    iex> [1] ++ [2]\n    [1, 2]\n\n    # improper list on the right will return an improper list\n    iex> [1] ++ [2 | 3]\n    [1, 2 | 3]\n\n"}
{"completion":"","prompt":"Elixir.Kernel.-value: Arithmetic negative unary operator.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> -2\n    -2\n\n"}
{"completion":"","prompt":"Elixir.Kernel.left - right: Arithmetic subtraction operator.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 - 2\n    -1\n\n"}
{"completion":"","prompt":"Elixir.Kernel.left -- right: List subtraction operator. Removes the first occurrence of an element\non the left list for each element on the right.\n\nThis function is optimized so the complexity of `a -- b` is proportional\nto `length(a) * log(length(b))`. See also the [Erlang efficiency\nguide](https://www.erlang.org/doc/efficiency_guide/retired_myths.html).\n\nInlined by the compiler.\n\n## Examples\n\n    iex> [1, 2, 3] -- [1, 2]\n    [3]\n\n    iex> [1, 2, 3, 2, 1] -- [1, 2, 2]\n    [3, 1]\n\nThe `--/2` operator is right associative, meaning:\n\n    iex> [1, 2, 3] -- [2] -- [3]\n    [1, 3]\n\nAs it is equivalent to:\n\n    iex> [1, 2, 3] -- ([2] -- [3])\n    [1, 3]\n\n"}
{"completion":"","prompt":"Elixir.Kernel.left / right: Arithmetic division operator.\n\nThe result is always a float. Use `div/2` and `rem/2` if you want\nan integer division or the remainder.\n\nRaises `ArithmeticError` if `right` is 0 or 0.0.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    1 / 2\n    #=> 0.5\n\n    -3.0 / 2.0\n    #=> -1.5\n\n    5 / 1\n    #=> 5.0\n\n    7 / 0\n    ** (ArithmeticError) bad argument in arithmetic expression\n\n"}
{"completion":"","prompt":"Elixir.Kernel.left < right: Less-than operator.\n\nReturns `true` if `left` is less than `right`.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\" section](#module-structural-comparison) section\nfor more information.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 < 2\n    true\n\n"}
{"completion":"","prompt":"Elixir.Kernel.left <= right: Less-than or equal to operator.\n\nReturns `true` if `left` is less than or equal to `right`.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\" section](#module-structural-comparison) section\nfor more information.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 <= 2\n    true\n\n"}
{"completion":"","prompt":"Elixir.Kernel.left == right: Equal to operator. Returns `true` if the two terms are equal.\n\nThis operator considers 1 and 1.0 to be equal. For stricter\nsemantics, use `===/2` instead.\n\nAll terms in Elixir can be compared with each other.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 == 2\n    false\n\n    iex> 1 == 1.0\n    true\n\n"}
{"completion":"","prompt":"Elixir.Kernel.left === right: Strictly equal to operator.\n\nReturns `true` if the two terms are exactly equal.\n\nThe terms are only considered to be exactly equal if they\nhave the same value and are of the same type. For example,\n`1 == 1.0` returns `true`, but since they are of different\ntypes, `1 === 1.0` returns `false`.\n\nAll terms in Elixir can be compared with each other.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 === 2\n    false\n\n    iex> 1 === 1.0\n    false\n\n"}
{"completion":"","prompt":"Elixir.Kernel.left =~ right: Text-based match operator. Matches the term on the `left`\nagainst the regular expression or string on the `right`.\n\nIf `right` is a regular expression, returns `true` if `left` matches right.\n\nIf `right` is a string, returns `true` if `left` contains `right`.\n\n## Examples\n\n    iex> \"abcd\" =~ ~r/c(d)/\n    true\n\n    iex> \"abcd\" =~ ~r/e/\n    false\n\n    iex> \"abcd\" =~ ~r//\n    true\n\n    iex> \"abcd\" =~ \"bc\"\n    true\n\n    iex> \"abcd\" =~ \"ad\"\n    false\n\n    iex> \"abcd\" =~ \"abcd\"\n    true\n\n    iex> \"abcd\" =~ \"\"\n    true\n\nFor more information about regular expressions, please check the `Regex` module.\n"}
{"completion":"","prompt":"Elixir.Kernel.left > right: Greater-than operator.\n\nReturns `true` if `left` is more than `right`.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\" section](#module-structural-comparison) section\nfor more information.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 > 2\n    false\n\n"}
{"completion":"","prompt":"Elixir.Kernel.left >= right: Greater-than or equal to operator.\n\nReturns `true` if `left` is more than or equal to `right`.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\" section](#module-structural-comparison) section\nfor more information.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 >= 2\n    false\n\n"}
{"completion":"","prompt":"Elixir.Kernel.abs(number): Returns an integer or float which is the arithmetical absolute value of `number`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> abs(-3.33)\n    3.33\n\n    iex> abs(-3)\n    3\n\n"}
{"completion":"","prompt":"Elixir.Kernel.apply(fun, args): Invokes the given anonymous function `fun` with the list of\narguments `args`.\n\nIf the number of arguments is known at compile time, prefer\n`fun.(arg_1, arg_2, ..., arg_n)` as it is clearer than\n`apply(fun, [arg_1, arg_2, ..., arg_n])`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> apply(fn x -> x * 2 end, [2])\n    4\n\n"}
{"completion":"","prompt":"Elixir.Kernel.apply(module, function_name, args): Invokes the given function from `module` with the list of\narguments `args`.\n\n`apply/3` is used to invoke functions where the module, function\nname or arguments are defined dynamically at runtime. For this\nreason, you can't invoke macros using `apply/3`, only functions.\n\nIf the number of arguments and the function name are known at compile time,\nprefer `module.function(arg_1, arg_2, ..., arg_n)` as it is clearer than\n`apply(module, :function, [arg_1, arg_2, ..., arg_n])`.\n\n`apply/3` cannot be used to call private functions.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> apply(Enum, :reverse, [[1, 2, 3]])\n    [3, 2, 1]\n\n"}
{"completion":"","prompt":"Elixir.Kernel.binary_part(binary, start, length): Extracts the part of the binary starting at `start` with length `length`.\nBinaries are zero-indexed.\n\nIf `start` or `length` reference in any way outside the binary, an\n`ArgumentError` exception is raised.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> binary_part(\"foo\", 1, 2)\n    \"oo\"\n\nA negative `length` can be used to extract bytes that come *before* the byte\nat `start`:\n\n    iex> binary_part(\"Hello\", 5, -3)\n    \"llo\"\n\nAn `ArgumentError` is raised when the length is outside of the binary:\n\n    binary_part(\"Hello\", 0, 10)\n    ** (ArgumentError) argument error\n\n"}
{"completion":"","prompt":"Elixir.Kernel.binary_slice(binary, range): Returns a binary from the offset given by the start of the\nrange to the offset given by the end of the range.\n\nIf the start or end of the range are negative, they are converted\ninto positive indices based on the binary size. For example,\n`-1` means the last byte of the binary.\n\nThis is similar to `binary_part/3` except that it works with ranges\nand it is not allowed in guards.\n\nThis function works with bytes. For a slicing operation that\nconsiders characters, see `String.slice/2`.\n\n## Examples\n\n    iex> binary_slice(\"elixir\", 0..5)\n    \"elixir\"\n    iex> binary_slice(\"elixir\", 1..3)\n    \"lix\"\n    iex> binary_slice(\"elixir\", 1..10)\n    \"lixir\"\n\n    iex> binary_slice(\"elixir\", -4..-1)\n    \"ixir\"\n    iex> binary_slice(\"elixir\", -4..6)\n    \"ixir\"\n    iex> binary_slice(\"elixir\", -10..10)\n    \"elixir\"\n\nFor ranges where `start > stop`, you need to explicitly\nmark them as increasing:\n\n    iex> binary_slice(\"elixir\", 2..-1//1)\n    \"ixir\"\n    iex> binary_slice(\"elixir\", 1..-2//1)\n    \"lixi\"\n\nYou can use `../0` as a shortcut for `0..-1//1`, which returns\nthe whole binary as is:\n\n    iex> binary_slice(\"elixir\", ..)\n    \"elixir\"\n\nThe step can be any positive number. For example, to\nget every 2 characters of the binary:\n\n    iex> binary_slice(\"elixir\", 0..-1//2)\n    \"eii\"\n\nIf the first position is after the string ends or after\nthe last position of the range, it returns an empty string:\n\n    iex> binary_slice(\"elixir\", 10..3//1)\n    \"\"\n    iex> binary_slice(\"elixir\", -10..-7)\n    \"\"\n    iex> binary_slice(\"a\", 1..1500)\n    \"\"\n\n"}
{"completion":"","prompt":"Elixir.Kernel.binary_slice(binary, start, size): Returns a binary starting at the offset `start` and of the given `size`.\n\nThis is similar to `binary_part/3` except that if `start + size`\nis greater than the binary size, it automatically clips it to\nthe binary size instead of raising. Opposite to `binary_part/3`,\nthis function is not allowed in guards.\n\nThis function works with bytes. For a slicing operation that\nconsiders characters, see `String.slice/3`.\n\n## Examples\n\n    iex> binary_slice(\"elixir\", 0, 6)\n    \"elixir\"\n    iex> binary_slice(\"elixir\", 0, 5)\n    \"elixi\"\n    iex> binary_slice(\"elixir\", 1, 4)\n    \"lixi\"\n    iex> binary_slice(\"elixir\", 0, 10)\n    \"elixir\"\n\nIf `start` is negative, it is normalized against the binary\nsize and clamped to 0:\n\n    iex> binary_slice(\"elixir\", -3, 10)\n    \"xir\"\n    iex> binary_slice(\"elixir\", -10, 10)\n    \"elixir\"\n\nIf the `size` is zero, an empty binary is returned:\n\n    iex> binary_slice(\"elixir\", 1, 0)\n    \"\"\n\nIf `start` is greater than or equal to the binary size,\nan empty binary is returned:\n\n    iex> binary_slice(\"elixir\", 10, 10)\n    \"\"\n\n"}
{"completion":"","prompt":"Elixir.Kernel.bit_size(bitstring): Returns an integer which is the size in bits of `bitstring`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> bit_size(<<433::16, 3::3>>)\n    19\n\n    iex> bit_size(<<1, 2, 3>>)\n    24\n\n"}
{"completion":"","prompt":"Elixir.Kernel.byte_size(bitstring): Returns the number of bytes needed to contain `bitstring`.\n\nThat is, if the number of bits in `bitstring` is not divisible by 8, the\nresulting number of bytes will be rounded up (by excess). This operation\nhappens in constant time.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> byte_size(<<433::16, 3::3>>)\n    3\n\n    iex> byte_size(<<1, 2, 3>>)\n    3\n\n"}
{"completion":"","prompt":"Elixir.Kernel.ceil(number): Returns the smallest integer greater than or equal to `number`.\n\nIf you want to perform ceil operation on other decimal places,\nuse `Float.ceil/2` instead.\n\nAllowed in guard tests. Inlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Kernel.div(dividend, divisor): Performs an integer division.\n\nRaises an `ArithmeticError` exception if one of the arguments is not an\ninteger, or when the `divisor` is `0`.\n\n`div/2` performs *truncated* integer division. This means that\nthe result is always rounded towards zero.\n\nIf you want to perform floored integer division (rounding towards negative infinity),\nuse `Integer.floor_div/2` instead.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    div(5, 2)\n    #=> 2\n\n    div(6, -4)\n    #=> -1\n\n    div(-99, 2)\n    #=> -49\n\n    div(100, 0)\n    ** (ArithmeticError) bad argument in arithmetic expression\n\n"}
{"completion":"","prompt":"Elixir.Kernel.elem(tuple, index): Gets the element at the zero-based `index` in `tuple`.\n\nIt raises `ArgumentError` when index is negative or it is out of range of the tuple elements.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    tuple = {:foo, :bar, 3}\n    elem(tuple, 1)\n    #=> :bar\n\n    elem({}, 0)\n    ** (ArgumentError) argument error\n\n    elem({:foo, :bar}, 2)\n    ** (ArgumentError) argument error\n\n"}
{"completion":"","prompt":"Elixir.Kernel.exit(reason): Stops the execution of the calling process with the given reason.\n\nSince evaluating this function causes the process to terminate,\nit has no return value.\n\nInlined by the compiler.\n\n## Examples\n\nWhen a process reaches its end, by default it exits with\nreason `:normal`. You can also call `exit/1` explicitly if you\nwant to terminate a process but not signal any failure:\n\n    exit(:normal)\n\nIn case something goes wrong, you can also use `exit/1` with\na different reason:\n\n    exit(:seems_bad)\n\nIf the exit reason is not `:normal`, all the processes linked to the process\nthat exited will crash (unless they are trapping exits).\n\n## OTP exits\n\nExits are used by the OTP to determine if a process exited abnormally\nor not. The following exits are considered \"normal\":\n\n  * `exit(:normal)`\n  * `exit(:shutdown)`\n  * `exit({:shutdown, term})`\n\nExiting with any other reason is considered abnormal and treated\nas a crash. This means the default supervisor behaviour kicks in,\nerror reports are emitted, and so forth.\n\nThis behaviour is relied on in many different places. For example,\n`ExUnit` uses `exit(:shutdown)` when exiting the test process to\nsignal linked processes, supervision trees and so on to politely\nshut down too.\n\n## CLI exits\n\nBuilding on top of the exit signals mentioned above, if the\nprocess started by the command line exits with any of the three\nreasons above, its exit is considered normal and the Operating\nSystem process will exit with status 0.\n\nIt is, however, possible to customize the operating system exit\nsignal by invoking:\n\n    exit({:shutdown, integer})\n\nThis will cause the operating system process to exit with the status given by\n`integer` while signaling all linked Erlang processes to politely\nshut down.\n\nAny other exit reason will cause the operating system process to exit with\nstatus `1` and linked Erlang processes to crash.\n"}
{"completion":"","prompt":"Elixir.Kernel.floor(number): Returns the largest integer smaller than or equal to `number`.\n\nIf you want to perform floor operation on other decimal places,\nuse `Float.floor/2` instead.\n\nAllowed in guard tests. Inlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Kernel.function_exported?(module, function, arity): Returns `true` if `module` is loaded and contains a\npublic `function` with the given `arity`, otherwise `false`.\n\nNote that this function does not load the module in case\nit is not loaded. Check `Code.ensure_loaded/1` for more\ninformation.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> function_exported?(Enum, :map, 2)\n    true\n\n    iex> function_exported?(Enum, :map, 10)\n    false\n\n    iex> function_exported?(List, :to_string, 1)\n    true\n"}
{"completion":"","prompt":"Elixir.Kernel.get_and_update_in(data, keys, fun): Gets a value and updates a nested structure.\n\n`data` is a nested structure (that is, a map, keyword\nlist, or struct that implements the `Access` behaviour).\n\nThe `fun` argument receives the value of `key` (or `nil` if `key`\nis not present) and must return one of the following values:\n\n  * a two-element tuple `{current_value, new_value}`. In this case,\n    `current_value` is the retrieved value which can possibly be operated on before\n    being returned. `new_value` is the new value to be stored under `key`.\n\n  * `:pop`, which implies that the current value under `key`\n    should be removed from the structure and returned.\n\nThis function uses the `Access` module to traverse the structures\naccording to the given `keys`, unless the `key` is a function,\nwhich is detailed in a later section.\n\n## Examples\n\nThis function is useful when there is a need to retrieve the current\nvalue (or something calculated in function of the current value) and\nupdate it at the same time. For example, it could be used to read the\ncurrent age of a user while increasing it by one in one pass:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> get_and_update_in(users, [\"john\", :age], &{&1, &1 + 1})\n    {27, %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}}\n\nNote the current value given to the anonymous function may be `nil`.\nIf any of the intermediate values are nil, it will raise:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> get_and_update_in(users, [\"jane\", :age], &{&1, &1 + 1})\n    ** (ArgumentError) could not put/update key :age on a nil value\n\n## Functions as keys\n\nIf a key is a function, the function will be invoked passing three\narguments:\n\n  * the operation (`:get_and_update`)\n  * the data to be accessed\n  * a function to be invoked next\n\nThis means `get_and_update_in/3` can be extended to provide custom\nlookups. The downside is that functions cannot be stored as keys\nin the accessed data structures.\n\nWhen one of the keys is a function, the function is invoked.\nIn the example below, we use a function to get and increment all\nages inside a list:\n\n    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n    iex> all = fn :get_and_update, data, next ->\n    ...>   data |> Enum.map(next) |> Enum.unzip()\n    ...> end\n    iex> get_and_update_in(users, [all, :age], &{&1, &1 + 1})\n    {[27, 23], [%{name: \"john\", age: 28}, %{name: \"meg\", age: 24}]}\n\nIf the previous value before invoking the function is `nil`,\nthe function *will* receive `nil` as a value and must handle it\naccordingly (be it by failing or providing a sane default).\n\nThe `Access` module ships with many convenience accessor functions,\nlike the `all` anonymous function defined above. See `Access.all/0`,\n`Access.key/2`, and others as examples.\n"}
{"completion":"","prompt":"Elixir.Kernel.get_in(data, keys): Gets a value from a nested structure.\n\nUses the `Access` module to traverse the structures\naccording to the given `keys`, unless the `key` is a\nfunction, which is detailed in a later section.\n\nNote that if none of the given keys are functions,\nthere is rarely a reason to use `get_in` over\nwriting \"regular\" Elixir code using `[]`.\n\n## Examples\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> get_in(users, [\"john\", :age])\n    27\n    iex> # Equivalent to:\n    iex> users[\"john\"][:age]\n    27\n\n`get_in/2` can also use the accessors in the `Access` module\nto traverse more complex data structures. For example, here we\nuse `Access.all/0` to traverse a list:\n\n    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n    iex> get_in(users, [Access.all(), :age])\n    [27, 23]\n\nIn case any of the components returns `nil`, `nil` will be returned\nand `get_in/2` won't traverse any further:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> get_in(users, [\"unknown\", :age])\n    nil\n    iex> # Equivalent to:\n    iex> users[\"unknown\"][:age]\n    nil\n\n    iex> users = nil\n    iex> get_in(users, [Access.all(), :age])\n    nil\n\nAlternatively, if you need to access complex data-structures, you can\nuse pattern matching:\n\n    case users do\n      %{\"john\" => %{age: age}} -> age\n      _ -> default_value\n    end\n\n## Functions as keys\n\nIf a key given to `get_in/2` is a function, the function will be invoked\npassing three arguments:\n\n  * the operation (`:get`)\n  * the data to be accessed\n  * a function to be invoked next\n\nThis means `get_in/2` can be extended to provide custom lookups.\nThat's precisely how the `Access.all/0` key in the previous section\nbehaves. For example, we can manually implement such traversal as\nfollows:\n\n    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n    iex> all = fn :get, data, next -> Enum.map(data, next) end\n    iex> get_in(users, [all, :age])\n    [27, 23]\n\nThe `Access` module ships with many convenience accessor functions.\nSee `Access.all/0`, `Access.key/2`, and others as examples.\n\n## Working with structs\n\nBy default, structs do not implement the `Access` behaviour required\nby this function. Therefore, you can't do this:\n\n    get_in(some_struct, [:some_key, :nested_key])\n\nThe good news is that structs have predefined shape. Therefore,\nyou can write instead:\n\n    some_struct.some_key.nested_key\n\nIf, by any chance, `some_key` can return nil, you can always\nfallback to pattern matching to provide nested struct handling:\n\n    case some_struct do\n      %{some_key: %{nested_key: value}} -> value\n      %{} -> nil\n    end\n\n"}
{"completion":"","prompt":"Elixir.Kernel.hd(list): Returns the head of a list. Raises `ArgumentError` if the list is empty.\n\nThe head of a list is its first element.\n\nIt works with improper lists.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    hd([1, 2, 3, 4])\n    #=> 1\n\n    hd([1 | 2])\n    #=> 1\n\nGiving it an empty list raises:\n\n    hd([])\n    #=> ** (ArgumentError) argument error\n\n"}
{"completion":"","prompt":"Elixir.Kernel.inspect(term, opts \\\\ []): Inspects the given argument according to the `Inspect` protocol.\nThe second argument is a keyword list with options to control\ninspection.\n\n## Options\n\n`inspect/2` accepts a list of options that are internally\ntranslated to an `Inspect.Opts` struct. Check the docs for\n`Inspect.Opts` to see the supported options.\n\n## Examples\n\n    iex> inspect(:foo)\n    \":foo\"\n\n    iex> inspect([1, 2, 3, 4, 5], limit: 3)\n    \"[1, 2, 3, ...]\"\n\n    iex> inspect([1, 2, 3], pretty: true, width: 0)\n    \"[1,\\n 2,\\n 3]\"\n\n    iex> inspect(\"olÃ¡\" <> <<0>>)\n    \"<<111, 108, 195, 161, 0>>\"\n\n    iex> inspect(\"olÃ¡\" <> <<0>>, binaries: :as_strings)\n    \"\\\"olÃ¡\\\\0\\\"\"\n\n    iex> inspect(\"olÃ¡\", binaries: :as_binaries)\n    \"<<111, 108, 195, 161>>\"\n\n    iex> inspect('bar')\n    \"'bar'\"\n\n    iex> inspect([0 | 'bar'])\n    \"[0, 98, 97, 114]\"\n\n    iex> inspect(100, base: :octal)\n    \"0o144\"\n\n    iex> inspect(100, base: :hex)\n    \"0x64\"\n\nNote that the `Inspect` protocol does not necessarily return a valid\nrepresentation of an Elixir term. In such cases, the inspected result\nmust start with `#`. For example, inspecting a function will return:\n\n    inspect(fn a, b -> a + b end)\n    #=> #Function<...>\n\nThe `Inspect` protocol can be derived to hide certain fields\nfrom structs, so they don't show up in logs, inspects and similar.\nSee the \"Deriving\" section of the documentation of the `Inspect`\nprotocol for more information.\n"}
{"completion":"","prompt":"Elixir.Kernel.is_atom(term): Returns `true` if `term` is an atom; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> is_atom(false)\n    true\n\n    iex> is_atom(:name)\n    true\n\n    iex> is_atom(AnAtom)\n    true\n\n    iex> is_atom(\"true\")\n    false\n\n"}
{"completion":"","prompt":"Elixir.Kernel.is_binary(term): Returns `true` if `term` is a binary; otherwise returns `false`.\n\nA binary always contains a complete number of bytes.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> is_binary(\"foo\")\n    true\n    iex> is_binary(<<1::3>>)\n    false\n\n"}
{"completion":"","prompt":"Elixir.Kernel.is_bitstring(term): Returns `true` if `term` is a bitstring (including a binary); otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> is_bitstring(\"foo\")\n    true\n    iex> is_bitstring(<<1::3>>)\n    true\n\n"}
{"completion":"","prompt":"Elixir.Kernel.is_boolean(term): Returns `true` if `term` is either the atom `true` or the atom `false` (i.e.,\na boolean); otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> is_boolean(false)\n    true\n\n    iex> is_boolean(true)\n    true\n\n    iex> is_boolean(:test)\n    false\n\n"}
{"completion":"","prompt":"Elixir.Kernel.is_float(term): Returns `true` if `term` is a floating-point number; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Kernel.is_function(term): Returns `true` if `term` is a function; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> is_function(fn x -> x + x end)\n    true\n\n    iex> is_function(\"not a function\")\n    false\n\n"}
{"completion":"","prompt":"Elixir.Kernel.is_function(term, arity): Returns `true` if `term` is a function that can be applied with `arity` number of arguments;\notherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> is_function(fn x -> x * 2 end, 1)\n    true\n    iex> is_function(fn x -> x * 2 end, 2)\n    false\n\n"}
{"completion":"","prompt":"Elixir.Kernel.is_integer(term): Returns `true` if `term` is an integer; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Kernel.is_list(term): Returns `true` if `term` is a list with zero or more elements; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Kernel.is_map(term): Returns `true` if `term` is a map; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Kernel.is_map_key(map, key): Returns `true` if `key` is a key in `map`; otherwise returns `false`.\n\nIt raises `BadMapError` if the first element is not a map.\n\nAllowed in guard tests. Inlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Kernel.is_number(term): Returns `true` if `term` is either an integer or a floating-point number;\notherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Kernel.is_pid(term): Returns `true` if `term` is a PID (process identifier); otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Kernel.is_port(term): Returns `true` if `term` is a port identifier; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Kernel.is_reference(term): Returns `true` if `term` is a reference; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Kernel.is_tuple(term): Returns `true` if `term` is a tuple; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Kernel.length(list): Returns the length of `list`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> length([1, 2, 3, 4, 5, 6, 7, 8, 9])\n    9\n\n"}
{"completion":"","prompt":"Elixir.Kernel.macro_exported?(module, macro, arity): Returns `true` if `module` is loaded and contains a\npublic `macro` with the given `arity`, otherwise `false`.\n\nNote that this function does not load the module in case\nit is not loaded. Check `Code.ensure_loaded/1` for more\ninformation.\n\nIf `module` is an Erlang module (as opposed to an Elixir module), this\nfunction always returns `false`.\n\n## Examples\n\n    iex> macro_exported?(Kernel, :use, 2)\n    true\n\n    iex> macro_exported?(:erlang, :abs, 1)\n    false\n\n"}
{"completion":"","prompt":"Elixir.Kernel.make_ref(): Returns an almost unique reference.\n\nThe returned reference will re-occur after approximately 2^82 calls;\ntherefore it is unique enough for practical purposes.\n\nInlined by the compiler.\n\n## Examples\n\n    make_ref()\n    #=> #Reference<0.0.0.135>\n\n"}
{"completion":"","prompt":"Elixir.Kernel.map_size(map): Returns the size of a map.\n\nThe size of a map is the number of key-value pairs that the map contains.\n\nThis operation happens in constant time.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> map_size(%{a: \"foo\", b: \"bar\"})\n    2\n\n"}
{"completion":"","prompt":"Elixir.Kernel.max(first, second): Returns the biggest of the two given terms according to\ntheir structural comparison.\n\nIf the terms compare equal, the first one is returned.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\" section](#module-structural-comparison) section\nfor more information.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> max(1, 2)\n    2\n    iex> max(:a, :b)\n    :b\n\n"}
{"completion":"","prompt":"Elixir.Kernel.min(first, second): Returns the smallest of the two given terms according to\ntheir structural comparison.\n\nIf the terms compare equal, the first one is returned.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\" section](#module-structural-comparison) section\nfor more information.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> min(1, 2)\n    1\n    iex> min(\"foo\", \"bar\")\n    \"bar\"\n\n"}
{"completion":"","prompt":"Elixir.Kernel.node(): Returns an atom representing the name of the local node.\nIf the node is not alive, `:nonode@nohost` is returned instead.\n\nAllowed in guard tests. Inlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Kernel.node(arg): Returns the node where the given argument is located.\nThe argument can be a PID, a reference, or a port.\nIf the local node is not alive, `:nonode@nohost` is returned.\n\nAllowed in guard tests. Inlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Kernel.not value: Strictly boolean \"not\" operator.\n\n`value` must be a boolean; if it's not, an `ArgumentError` exception is raised.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> not false\n    true\n\n"}
{"completion":"","prompt":"Elixir.Kernel.pop_in(data, keys): Pops a key from the given nested structure.\n\nUses the `Access` protocol to traverse the structures\naccording to the given `keys`, unless the `key` is a\nfunction. If the key is a function, it will be invoked\nas specified in `get_and_update_in/3`.\n\n## Examples\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> pop_in(users, [\"john\", :age])\n    {27, %{\"john\" => %{}, \"meg\" => %{age: 23}}}\n\nIn case any entry returns `nil`, its key will be removed\nand the deletion will be considered a success.\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> pop_in(users, [\"jane\", :age])\n    {nil, %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}}\n\n"}
{"completion":"","prompt":"Elixir.Kernel.put_elem(tuple, index, value): Puts `value` at the given zero-based `index` in `tuple`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> tuple = {:foo, :bar, 3}\n    iex> put_elem(tuple, 0, :baz)\n    {:baz, :bar, 3}\n\n"}
{"completion":"","prompt":"Elixir.Kernel.put_in(data, keys, value): Puts a value in a nested structure.\n\nUses the `Access` module to traverse the structures\naccording to the given `keys`, unless the `key` is a\nfunction. If the key is a function, it will be invoked\nas specified in `get_and_update_in/3`.\n\n## Examples\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> put_in(users, [\"john\", :age], 28)\n    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n\nIf any of the intermediate values are nil, it will raise:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> put_in(users, [\"jane\", :age], \"oops\")\n    ** (ArgumentError) could not put/update key :age on a nil value\n\n"}
{"completion":"","prompt":"Elixir.Kernel.rem(dividend, divisor): Computes the remainder of an integer division.\n\n`rem/2` uses truncated division, which means that\nthe result will always have the sign of the `dividend`.\n\nRaises an `ArithmeticError` exception if one of the arguments is not an\ninteger, or when the `divisor` is `0`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> rem(5, 2)\n    1\n    iex> rem(6, -4)\n    2\n\n"}
{"completion":"","prompt":"Elixir.Kernel.round(number): Rounds a number to the nearest integer.\n\nIf the number is equidistant to the two nearest integers, rounds away from zero.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> round(5.6)\n    6\n\n    iex> round(5.2)\n    5\n\n    iex> round(-9.9)\n    -10\n\n    iex> round(-9)\n    -9\n\n    iex> round(2.5)\n    3\n\n    iex> round(-2.5)\n    -3\n\n"}
{"completion":"","prompt":"Elixir.Kernel.self(): Returns the PID (process identifier) of the calling process.\n\nAllowed in guard clauses. Inlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Kernel.send(dest, message): Sends a message to the given `dest` and returns the message.\n\n`dest` may be a remote or local PID, a local port, a locally\nregistered name, or a tuple in the form of `{registered_name, node}` for a\nregistered name at another node.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> send(self(), :hello)\n    :hello\n\n"}
{"completion":"","prompt":"Elixir.Kernel.spawn(fun): Spawns the given function and returns its PID.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions.\n\nThe anonymous function receives 0 arguments, and may return any value.\n\nInlined by the compiler.\n\n## Examples\n\n    current = self()\n    child = spawn(fn -> send(current, {self(), 1 + 2}) end)\n\n    receive do\n      {^child, 3} -> IO.puts(\"Received 3 back\")\n    end\n\n"}
{"completion":"","prompt":"Elixir.Kernel.spawn(module, fun, args): Spawns the given function `fun` from the given `module` passing it the given\n`args` and returns its PID.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions.\n\nInlined by the compiler.\n\n## Examples\n\n    spawn(SomeModule, :function, [1, 2, 3])\n\n"}
{"completion":"","prompt":"Elixir.Kernel.spawn_link(fun): Spawns the given function, links it to the current process, and returns its PID.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions. For more\ninformation on linking, check `Process.link/1`.\n\nThe anonymous function receives 0 arguments, and may return any value.\n\nInlined by the compiler.\n\n## Examples\n\n    current = self()\n    child = spawn_link(fn -> send(current, {self(), 1 + 2}) end)\n\n    receive do\n      {^child, 3} -> IO.puts(\"Received 3 back\")\n    end\n\n"}
{"completion":"","prompt":"Elixir.Kernel.spawn_link(module, fun, args): Spawns the given function `fun` from the given `module` passing it the given\n`args`, links it to the current process, and returns its PID.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions. For more\ninformation on linking, check `Process.link/1`.\n\nInlined by the compiler.\n\n## Examples\n\n    spawn_link(SomeModule, :function, [1, 2, 3])\n\n"}
{"completion":"","prompt":"Elixir.Kernel.spawn_monitor(fun): Spawns the given function, monitors it and returns its PID\nand monitoring reference.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions.\n\nThe anonymous function receives 0 arguments, and may return any value.\n\nInlined by the compiler.\n\n## Examples\n\n    current = self()\n    spawn_monitor(fn -> send(current, {self(), 1 + 2}) end)\n\n"}
{"completion":"","prompt":"Elixir.Kernel.spawn_monitor(module, fun, args): Spawns the given module and function passing the given args,\nmonitors it and returns its PID and monitoring reference.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions.\n\nInlined by the compiler.\n\n## Examples\n\n    spawn_monitor(SomeModule, :function, [1, 2, 3])\n\n"}
{"completion":"","prompt":"Elixir.Kernel.struct(struct, fields \\\\ []): Creates and updates a struct.\n\nThe `struct` argument may be an atom (which defines `defstruct`)\nor a `struct` itself. The second argument is any `Enumerable` that\nemits two-element tuples (key-value pairs) during enumeration.\n\nKeys in the `Enumerable` that don't exist in the struct are automatically\ndiscarded. Note that keys must be atoms, as only atoms are allowed when\ndefining a struct. If keys in the `Enumerable` are duplicated, the last\nentry will be taken (same behaviour as `Map.new/1`).\n\nThis function is useful for dynamically creating and updating structs, as\nwell as for converting maps to structs; in the latter case, just inserting\nthe appropriate `:__struct__` field into the map may not be enough and\n`struct/2` should be used instead.\n\n## Examples\n\n    defmodule User do\n      defstruct name: \"john\"\n    end\n\n    struct(User)\n    #=> %User{name: \"john\"}\n\n    opts = [name: \"meg\"]\n    user = struct(User, opts)\n    #=> %User{name: \"meg\"}\n\n    struct(user, unknown: \"value\")\n    #=> %User{name: \"meg\"}\n\n    struct(User, %{name: \"meg\"})\n    #=> %User{name: \"meg\"}\n\n    # String keys are ignored\n    struct(User, %{\"name\" => \"meg\"})\n    #=> %User{name: \"john\"}\n\n"}
{"completion":"","prompt":"Elixir.Kernel.struct!(struct, fields \\\\ []): Similar to `struct/2` but checks for key validity.\n\nThe function `struct!/2` emulates the compile time behaviour\nof structs. This means that:\n\n  * when building a struct, as in `struct!(SomeStruct, key: :value)`,\n    it is equivalent to `%SomeStruct{key: :value}` and therefore this\n    function will check if every given key-value belongs to the struct.\n    If the struct is enforcing any key via `@enforce_keys`, those will\n    be enforced as well;\n\n  * when updating a struct, as in `struct!(%SomeStruct{}, key: :value)`,\n    it is equivalent to `%SomeStruct{struct | key: :value}` and therefore this\n    function will check if every given key-value belongs to the struct.\n    However, updating structs does not enforce keys, as keys are enforced\n    only when building;\n\n"}
{"completion":"","prompt":"Elixir.Kernel.throw(term): A non-local return from a function.\n\nUsing `throw/1` is generally discouraged, as it allows a function\nto escape from its regular execution flow, which can make the code\nharder to read. Furthermore, all thrown values must be caught by\n`try/catch`. See `try/1` for more information.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Kernel.tl(list): Returns the tail of a list. Raises `ArgumentError` if the list is empty.\n\nThe tail of a list is the list without its first element.\n\nIt works with improper lists.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    tl([1, 2, 3, :go])\n    #=> [2, 3, :go]\n\n    tl([:one])\n    #=> []\n\n    tl([:a, :b | :improper_end])\n    #=> [:b | :improper_end]\n\n    tl([:a | %{b: 1}])\n    #=> %{b: 1}\n\nGiving it an empty list raises:\n\n    tl([])\n    #=> ** (ArgumentError) argument error\n\n"}
{"completion":"","prompt":"Elixir.Kernel.trunc(number): Returns the integer part of `number`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> trunc(5.4)\n    5\n\n    iex> trunc(-5.99)\n    -5\n\n    iex> trunc(-5)\n    -5\n\n"}
{"completion":"","prompt":"Elixir.Kernel.tuple_size(tuple): Returns the size of a tuple.\n\nThis operation happens in constant time.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> tuple_size({:a, :b, :c})\n    3\n\n"}
{"completion":"","prompt":"Elixir.Kernel.update_in(data, keys, fun): Updates a key in a nested structure.\n\nUses the `Access` module to traverse the structures\naccording to the given `keys`, unless the `key` is a\nfunction. If the key is a function, it will be invoked\nas specified in `get_and_update_in/3`.\n\n`data` is a nested structure (that is, a map, keyword\nlist, or struct that implements the `Access` behaviour).\nThe `fun` argument receives the value of `key` (or `nil`\nif `key` is not present) and the result replaces the value\nin the structure.\n\n## Examples\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> update_in(users, [\"john\", :age], &(&1 + 1))\n    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n\nNote the current value given to the anonymous function may be `nil`.\nIf any of the intermediate values are nil, it will raise:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> update_in(users, [\"jane\", :age], & &1 + 1)\n    ** (ArgumentError) could not put/update key :age on a nil value\n\n"}
{"completion":"","prompt":"Elixir.Keyword.delete(keywords, key): Deletes the entries in the keyword list under a specific `key`.\n\nIf the `key` does not exist, it returns the keyword list unchanged.\nUse `delete_first/2` to delete just the first entry in case of\nduplicate keys.\n\n## Examples\n\n    iex> Keyword.delete([a: 1, b: 2], :a)\n    [b: 2]\n    iex> Keyword.delete([a: 1, b: 2, a: 3], :a)\n    [b: 2]\n    iex> Keyword.delete([b: 2], :a)\n    [b: 2]\n\n"}
{"completion":"","prompt":"Elixir.Keyword.delete_first(keywords, key): Deletes the first entry in the keyword list under a specific `key`.\n\nIf the `key` does not exist, it returns the keyword list unchanged.\n\n## Examples\n\n    iex> Keyword.delete_first([a: 1, b: 2, a: 3], :a)\n    [b: 2, a: 3]\n    iex> Keyword.delete_first([b: 2], :a)\n    [b: 2]\n\n"}
{"completion":"","prompt":"Elixir.Keyword.drop(keywords, keys): Drops the given `keys` from the keyword list.\n\nRemoves duplicate keys from the new keyword list.\n\n## Examples\n\n    iex> Keyword.drop([a: 1, a: 2], [:a])\n    []\n    iex> Keyword.drop([a: 1, b: 2, c: 3], [:b, :d])\n    [a: 1, c: 3]\n    iex> Keyword.drop([a: 1, b: 2, b: 3, c: 3, a: 5], [:b, :d])\n    [a: 1, c: 3, a: 5]\n\n"}
{"completion":"","prompt":"Elixir.Keyword.equal?(left, right): Checks if two keywords are equal.\n\nConsiders two keywords to be equal if they contain\nthe same keys and those keys contain the same values.\n\n## Examples\n\n    iex> Keyword.equal?([a: 1, b: 2], [b: 2, a: 1])\n    true\n    iex> Keyword.equal?([a: 1, b: 2], [b: 1, a: 2])\n    false\n    iex> Keyword.equal?([a: 1, b: 2, a: 3], [b: 2, a: 3, a: 1])\n    true\n\nComparison between values is done with `===/3`,\nwhich means integers are not equivalent to floats:\n\n    iex> Keyword.equal?([a: 1.0], [a: 1])\n    false\n\n"}
{"completion":"","prompt":"Elixir.Keyword.fetch(keywords, key): Fetches the value for a specific `key` and returns it in a tuple.\n\nIf the `key` does not exist, it returns `:error`.\n\n## Examples\n\n    iex> Keyword.fetch([a: 1], :a)\n    {:ok, 1}\n    iex> Keyword.fetch([a: 1], :b)\n    :error\n\n"}
{"completion":"","prompt":"Elixir.Keyword.fetch!(keywords, key): Fetches the value for specific `key`.\n\nIf the `key` does not exist, it raises a `KeyError`.\n\n## Examples\n\n    iex> Keyword.fetch!([a: 1], :a)\n    1\n    iex> Keyword.fetch!([a: 1], :b)\n    ** (KeyError) key :b not found in: [a: 1]\n\n"}
{"completion":"","prompt":"Elixir.Keyword.filter(keywords, fun): Returns a keyword list containing only the entries from `keywords`\nfor which the function `fun` returns a truthy value.\n\nSee also `reject/2` which discards all entries where the function\nreturns a truthy value.\n\n## Examples\n\n    iex> Keyword.filter([one: 1, two: 2, three: 3], fn {_key, val} -> rem(val, 2) == 1 end)\n    [one: 1, three: 3]\n\n"}
{"completion":"","prompt":"Elixir.Keyword.from_keys(keys, value): Builds a keyword from the given `keys` and the fixed `value`.\n\n## Examples\n\n    iex> Keyword.from_keys([:foo, :bar, :baz], :atom)\n    [foo: :atom, bar: :atom, baz: :atom]\n\n"}
{"completion":"","prompt":"Elixir.Keyword.get(keywords, key, default \\\\ nil): Gets the value under the given `key`.\n\nReturns the default value if `key` does not exist\n(`nil` if no default value is provided).\n\nIf duplicate entries exist, it returns the first one.\nUse `get_values/2` to retrieve all entries.\n\n## Examples\n\n    iex> Keyword.get([], :a)\n    nil\n    iex> Keyword.get([a: 1], :a)\n    1\n    iex> Keyword.get([a: 1], :b)\n    nil\n    iex> Keyword.get([a: 1], :b, 3)\n    3\n\nWith duplicate keys:\n\n    iex> Keyword.get([a: 1, a: 2], :a, 3)\n    1\n    iex> Keyword.get([a: 1, a: 2], :b, 3)\n    3\n\n"}
{"completion":"","prompt":"Elixir.Keyword.get_and_update(keywords, key, fun): Gets the value from `key` and updates it, all in one pass.\n\nThe `fun` argument receives the value of `key` (or `nil` if `key`\nis not present) and must return a two-element tuple: the current value\n(the retrieved value, which can be operated on before being returned)\nand the new value to be stored under `key`. The `fun` may also\nreturn `:pop`, implying the current value shall be removed from the\nkeyword list and returned.\n\nReturns a tuple that contains the current value returned by\n`fun` and a new keyword list with the updated value under `key`.\n\n## Examples\n\n    iex> Keyword.get_and_update([a: 1], :a, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {1, [a: \"new value!\"]}\n\n    iex> Keyword.get_and_update([a: 1], :b, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {nil, [b: \"new value!\", a: 1]}\n\n    iex> Keyword.get_and_update([a: 2], :a, fn number ->\n    ...>   {2 * number, 3 * number}\n    ...> end)\n    {4, [a: 6]}\n\n    iex> Keyword.get_and_update([a: 1], :a, fn _ -> :pop end)\n    {1, []}\n\n    iex> Keyword.get_and_update([a: 1], :b, fn _ -> :pop end)\n    {nil, [a: 1]}\n\n"}
{"completion":"","prompt":"Elixir.Keyword.get_and_update!(keywords, key, fun): Gets the value under `key` and updates it. Raises if there is no `key`.\n\nThe `fun` argument receives the value under `key` and must return a\ntwo-element tuple: the current value (the retrieved value, which can be\noperated on before being returned) and the new value to be stored under\n`key`.\n\nReturns a tuple that contains the current value returned by\n`fun` and a new keyword list with the updated value under `key`.\n\n## Examples\n\n    iex> Keyword.get_and_update!([a: 1], :a, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {1, [a: \"new value!\"]}\n\n    iex> Keyword.get_and_update!([a: 1], :b, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    ** (KeyError) key :b not found in: [a: 1]\n\n    iex> Keyword.get_and_update!([a: 1], :a, fn _ ->\n    ...>   :pop\n    ...> end)\n    {1, []}\n\n"}
{"completion":"","prompt":"Elixir.Keyword.get_lazy(keywords, key, fun): Gets the value under the given `key`.\n\nIf `key` does not exist, lazily evaluates `fun` and returns its result.\n\nThis is useful if the default value is very expensive to calculate or\ngenerally difficult to set up and tear down again.\n\nIf duplicate entries exist, it returns the first one.\nUse `get_values/2` to retrieve all entries.\n\n## Examples\n\n    iex> keyword = [a: 1]\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   13\n    ...> end\n    iex> Keyword.get_lazy(keyword, :a, fun)\n    1\n    iex> Keyword.get_lazy(keyword, :b, fun)\n    13\n\n"}
{"completion":"","prompt":"Elixir.Keyword.get_values(keywords, key): Gets all values under a specific `key`.\n\n## Examples\n\n    iex> Keyword.get_values([], :a)\n    []\n    iex> Keyword.get_values([a: 1], :a)\n    [1]\n    iex> Keyword.get_values([a: 1, a: 2], :a)\n    [1, 2]\n\n"}
{"completion":"","prompt":"Elixir.Keyword.has_key?(keywords, key): Returns whether a given `key` exists in the given `keywords`.\n\n## Examples\n\n    iex> Keyword.has_key?([a: 1], :a)\n    true\n    iex> Keyword.has_key?([a: 1], :b)\n    false\n\n"}
{"completion":"","prompt":"Elixir.Keyword.keys(keywords): Returns all keys from the keyword list.\n\nKeeps duplicate keys in the resulting list of keys.\n\n## Examples\n\n    iex> Keyword.keys(a: 1, b: 2)\n    [:a, :b]\n\n    iex> Keyword.keys(a: 1, b: 2, a: 3)\n    [:a, :b, :a]\n\n    iex> Keyword.keys([{:a, 1}, {\"b\", 2}, {:c, 3}])\n    ** (ArgumentError) expected a keyword list, but an entry in the list is not a two-element tuple with an atom as its first element, got: {\"b\", 2}\n\n"}
{"completion":"","prompt":"Elixir.Keyword.keyword?(term): Returns `true` if `term` is a keyword list, otherwise `false`.\n\nWhen `term` is a list it is traversed to the end.\n\n## Examples\n\n    iex> Keyword.keyword?([])\n    true\n    iex> Keyword.keyword?(a: 1)\n    true\n    iex> Keyword.keyword?([{Foo, 1}])\n    true\n    iex> Keyword.keyword?([{}])\n    false\n    iex> Keyword.keyword?([:key])\n    false\n    iex> Keyword.keyword?(%{})\n    false\n\n"}
{"completion":"","prompt":"Elixir.Keyword.merge(keywords1, keywords2): Merges two keyword lists into one.\n\nAdds all keys, including duplicate keys, given in `keywords2`\nto `keywords1`, overriding any existing ones.\n\nThere are no guarantees about the order of the keys in the returned keyword.\n\n## Examples\n\n    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4])\n    [b: 2, a: 3, d: 4]\n\n    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4, a: 5])\n    [b: 2, a: 3, d: 4, a: 5]\n\n    iex> Keyword.merge([a: 1], [2, 3])\n    ** (ArgumentError) expected a keyword list as the second argument, got: [2, 3]\n\n"}
{"completion":"","prompt":"Elixir.Keyword.merge(keywords1, keywords2, fun): Merges two keyword lists into one.\n\nAdds all keys, including duplicate keys, given in `keywords2`\nto `keywords1`. Invokes the given function to solve conflicts.\n\nIf `keywords2` has duplicate keys, it invokes the given function\nfor each matching pair in `keywords1`.\n\nThere are no guarantees about the order of the keys in the returned keyword.\n\n## Examples\n\n    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4], fn _k, v1, v2 ->\n    ...>   v1 + v2\n    ...> end)\n    [b: 2, a: 4, d: 4]\n\n    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4, a: 5], fn :a, v1, v2 ->\n    ...>   v1 + v2\n    ...> end)\n    [b: 2, a: 4, d: 4, a: 5]\n\n    iex> Keyword.merge([a: 1, b: 2, a: 3], [a: 3, d: 4, a: 5], fn :a, v1, v2 ->\n    ...>   v1 + v2\n    ...> end)\n    [b: 2, a: 4, d: 4, a: 8]\n\n    iex> Keyword.merge([a: 1, b: 2], [:a, :b], fn :a, v1, v2 ->\n    ...>   v1 + v2\n    ...> end)\n    ** (ArgumentError) expected a keyword list as the second argument, got: [:a, :b]\n\n"}
{"completion":"","prompt":"Elixir.Keyword.new(): Returns an empty keyword list, i.e. an empty list.\n\n## Examples\n\n    iex> Keyword.new()\n    []\n\n"}
{"completion":"","prompt":"Elixir.Keyword.new(pairs): Creates a keyword list from an enumerable.\n\nRemoves duplicate entries and the last one prevails.\nUnlike `Enum.into(enumerable, [])`, `Keyword.new(enumerable)`\nguarantees the keys are unique.\n\n## Examples\n\n    iex> Keyword.new([{:b, 1}, {:a, 2}])\n    [b: 1, a: 2]\n\n    iex> Keyword.new([{:a, 1}, {:a, 2}, {:a, 3}])\n    [a: 3]\n\n"}
{"completion":"","prompt":"Elixir.Keyword.new(pairs, transform): Creates a keyword list from an enumerable via the transformation function.\n\nRemoves duplicate entries and the last one prevails.\nUnlike `Enum.into(enumerable, [], fun)`,\n`Keyword.new(enumerable, fun)` guarantees the keys are unique.\n\n## Examples\n\n    iex> Keyword.new([:a, :b], fn x -> {x, x} end)\n    [a: :a, b: :b]\n\n"}
{"completion":"","prompt":"Elixir.Keyword.pop(keywords, key, default \\\\ nil): Returns the first value for `key` and removes all associated entries in the keyword list.\n\nIt returns a tuple where the first element is the first value for `key` and the\nsecond element is a keyword list with all entries associated with `key` removed.\nIf the `key` is not present in the keyword list, it returns `{default, keyword_list}`.\n\nIf you don't want to remove all the entries associated with `key` use `pop_first/3`\ninstead, which will remove only the first entry.\n\n## Examples\n\n    iex> Keyword.pop([a: 1], :a)\n    {1, []}\n    iex> Keyword.pop([a: 1], :b)\n    {nil, [a: 1]}\n    iex> Keyword.pop([a: 1], :b, 3)\n    {3, [a: 1]}\n    iex> Keyword.pop([a: 1, a: 2], :a)\n    {1, []}\n\n"}
{"completion":"","prompt":"Elixir.Keyword.pop!(keywords, key): Returns the first value for `key` and removes all associated entries in the keyword list,\nraising if `key` is not present.\n\nThis function behaves like `pop/3`, but raises in case the `key` is not present in the\ngiven `keywords`.\n\n## Examples\n\n    iex> Keyword.pop!([a: 1], :a)\n    {1, []}\n    iex> Keyword.pop!([a: 1, a: 2], :a)\n    {1, []}\n    iex> Keyword.pop!([a: 1], :b)\n    ** (KeyError) key :b not found in: [a: 1]\n\n"}
{"completion":"","prompt":"Elixir.Keyword.pop_first(keywords, key, default \\\\ nil): Returns and removes the first value associated with `key` in the keyword list.\n\nKeeps duplicate keys in the resulting keyword list.\n\n## Examples\n\n    iex> Keyword.pop_first([a: 1], :a)\n    {1, []}\n    iex> Keyword.pop_first([a: 1], :b)\n    {nil, [a: 1]}\n    iex> Keyword.pop_first([a: 1], :b, 3)\n    {3, [a: 1]}\n    iex> Keyword.pop_first([a: 1, a: 2], :a)\n    {1, [a: 2]}\n\n"}
{"completion":"","prompt":"Elixir.Keyword.pop_lazy(keywords, key, fun): Lazily returns and removes all values associated with `key` in the keyword list.\n\nThis is useful if the default value is very expensive to calculate or\ngenerally difficult to set up and tear down again.\n\nRemoves all duplicate keys. See `pop_first/3` for removing only the first entry.\n\n## Examples\n\n    iex> keyword = [a: 1]\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   13\n    ...> end\n    iex> Keyword.pop_lazy(keyword, :a, fun)\n    {1, []}\n    iex> Keyword.pop_lazy(keyword, :b, fun)\n    {13, [a: 1]}\n\n"}
{"completion":"","prompt":"Elixir.Keyword.pop_values(keywords, key): Returns all values for `key` and removes all associated entries in the keyword list.\n\nIt returns a tuple where the first element is a list of values for `key` and the\nsecond element is a keyword list with all entries associated with `key` removed.\nIf the `key` is not present in the keyword list, it returns `{[], keyword_list}`.\n\nIf you don't want to remove all the entries associated with `key` use `pop_first/3`\ninstead, which will remove only the first entry.\n\n## Examples\n\n    iex> Keyword.pop_values([a: 1], :a)\n    {[1], []}\n    iex> Keyword.pop_values([a: 1], :b)\n    {[], [a: 1]}\n    iex> Keyword.pop_values([a: 1, a: 2], :a)\n    {[1, 2], []}\n\n"}
{"completion":"","prompt":"Elixir.Keyword.put(keywords, key, value): Puts the given `value` under the specified `key`.\n\nIf a value under `key` already exists, it overrides the value\nand removes all duplicate entries.\n\n## Examples\n\n    iex> Keyword.put([a: 1], :b, 2)\n    [b: 2, a: 1]\n    iex> Keyword.put([a: 1, b: 2], :a, 3)\n    [a: 3, b: 2]\n    iex> Keyword.put([a: 1, b: 2, a: 4], :a, 3)\n    [a: 3, b: 2]\n\n"}
{"completion":"","prompt":"Elixir.Keyword.put_new(keywords, key, value): Puts the given `value` under `key`, unless the entry `key` already exists.\n\n## Examples\n\n    iex> Keyword.put_new([a: 1], :b, 2)\n    [b: 2, a: 1]\n    iex> Keyword.put_new([a: 1, b: 2], :a, 3)\n    [a: 1, b: 2]\n\n"}
{"completion":"","prompt":"Elixir.Keyword.put_new_lazy(keywords, key, fun): Evaluates `fun` and puts the result under `key`\nin keyword list unless `key` is already present.\n\nThis is useful if the value is very expensive to calculate or\ngenerally difficult to set up and tear down again.\n\n## Examples\n\n    iex> keyword = [a: 1]\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   13\n    ...> end\n    iex> Keyword.put_new_lazy(keyword, :a, fun)\n    [a: 1]\n    iex> Keyword.put_new_lazy(keyword, :b, fun)\n    [b: 13, a: 1]\n\n"}
{"completion":"","prompt":"Elixir.Keyword.reject(keywords, fun): Returns a keyword list excluding the entries from `keywords`\nfor which the function `fun` returns a truthy value.\n\nSee also `filter/2`.\n\n## Examples\n\n    iex> Keyword.reject([one: 1, two: 2, three: 3], fn {_key, val} -> rem(val, 2) == 1 end)\n    [two: 2]\n\n"}
{"completion":"","prompt":"Elixir.Keyword.replace(keywords, key, value): Puts a value under `key` only if the `key` already exists in `keywords`.\n\nIn case a key exists multiple times in the keyword list,\nit removes later occurrences.\n\n## Examples\n\n    iex> Keyword.replace([a: 1, b: 2, a: 4], :a, 3)\n    [a: 3, b: 2]\n\n    iex> Keyword.replace([a: 1], :b, 2)\n    [a: 1]\n\n"}
{"completion":"","prompt":"Elixir.Keyword.replace!(keywords, key, value): Puts a value under `key` only if the `key` already exists in `keywords`.\n\nIf `key` is not present in `keywords`, it raises a `KeyError`.\n\n## Examples\n\n    iex> Keyword.replace!([a: 1, b: 2, a: 3], :a, :new)\n    [a: :new, b: 2]\n    iex> Keyword.replace!([a: 1, b: 2, c: 3, b: 4], :b, :new)\n    [a: 1, b: :new, c: 3]\n\n    iex> Keyword.replace!([a: 1], :b, 2)\n    ** (KeyError) key :b not found in: [a: 1]\n\n"}
{"completion":"","prompt":"Elixir.Keyword.replace_lazy(keywords, key, fun): Replaces the value under `key` using the given function only if\n`key` already exists in `keywords`.\n\nIn comparison to `replace/3`, this can be useful when it's expensive to calculate the value.\n\nIf `key` does not exist, the original keyword list is returned unchanged.\n\n## Examples\n\n    iex> Keyword.replace_lazy([a: 1, b: 2], :a, fn v -> v * 4 end)\n    [a: 4, b: 2]\n\n    iex> Keyword.replace_lazy([a: 2, b: 2, a: 1], :a, fn v -> v * 4 end)\n    [a: 8, b: 2]\n\n    iex> Keyword.replace_lazy([a: 1, b: 2], :c, fn v -> v * 4 end)\n    [a: 1, b: 2]\n\n"}
{"completion":"","prompt":"Elixir.Keyword.split(keywords, keys): Takes all entries corresponding to the given `keys` and extracts them into a\nseparate keyword list.\n\nReturns a tuple with the new list and the old list with removed keys.\n\nIgnores keys for which there are no entries in the keyword list.\n\nEntries with duplicate keys end up in the same keyword list.\n\n## Examples\n\n    iex> Keyword.split([a: 1, b: 2, c: 3], [:a, :c, :e])\n    {[a: 1, c: 3], [b: 2]}\n    iex> Keyword.split([a: 1, b: 2, c: 3, a: 4], [:a, :c, :e])\n    {[a: 1, c: 3, a: 4], [b: 2]}\n\n"}
{"completion":"","prompt":"Elixir.Keyword.take(keywords, keys): Takes all entries corresponding to the given `keys` and returns them as a new\nkeyword list.\n\nPreserves duplicate keys in the new keyword list.\n\n## Examples\n\n    iex> Keyword.take([a: 1, b: 2, c: 3], [:a, :c, :e])\n    [a: 1, c: 3]\n    iex> Keyword.take([a: 1, b: 2, c: 3, a: 5], [:a, :c, :e])\n    [a: 1, c: 3, a: 5]\n\n"}
{"completion":"","prompt":"Elixir.Keyword.to_list(keywords): Returns the keyword list itself.\n\n## Examples\n\n    iex> Keyword.to_list(a: 1)\n    [a: 1]\n\n"}
{"completion":"","prompt":"Elixir.Keyword.update(keywords, key, default, fun): Updates the value under `key` in `keywords` using the given function.\n\nIf the `key` does not exist, it inserts the given `default` value.\nDoes not pass the `default` value through the update function.\n\nRemoves all duplicate keys and only updates the first one.\n\n## Examples\n\n    iex> Keyword.update([a: 1], :a, 13, fn existing_value -> existing_value * 2 end)\n    [a: 2]\n\n    iex> Keyword.update([a: 1, a: 2], :a, 13, fn existing_value -> existing_value * 2 end)\n    [a: 2]\n\n    iex> Keyword.update([a: 1], :b, 11, fn existing_value -> existing_value * 2 end)\n    [a: 1, b: 11]\n\n"}
{"completion":"","prompt":"Elixir.Keyword.update!(keywords, key, fun): Updates the value under `key` using the given function.\n\nRaises `KeyError` if the `key` does not exist.\n\nRemoves all duplicate keys and only updates the first one.\n\n## Examples\n\n    iex> Keyword.update!([a: 1, b: 2, a: 3], :a, &(&1 * 2))\n    [a: 2, b: 2]\n    iex> Keyword.update!([a: 1, b: 2, c: 3], :b, &(&1 * 2))\n    [a: 1, b: 4, c: 3]\n\n    iex> Keyword.update!([a: 1], :b, &(&1 * 2))\n    ** (KeyError) key :b not found in: [a: 1]\n\n"}
{"completion":"","prompt":"Elixir.Keyword.validate(keyword, values): Ensures the given `keyword` has only the keys given in `values`.\n\nThe second argument must be a list of atoms, specifying\na given key, or tuples specifying a key and a default value.\n\nIf the keyword list has only the given keys, it returns\n`{:ok, keyword}` with default values applied. Otherwise it\nreturns `{:error, invalid_keys}` with invalid keys.\n\nSee also: `validate!/2`.\n\n## Examples\n\n    iex> {:ok, result} = Keyword.validate([], [one: 1, two: 2])\n    iex> Enum.sort(result)\n    [one: 1, two: 2]\n\n    iex> {:ok, result} = Keyword.validate([two: 3], [one: 1, two: 2])\n    iex> Enum.sort(result)\n    [one: 1, two: 3]\n\nIf atoms are given, they are supported as keys but do not\nprovide a default value:\n\n    iex> {:ok, result} = Keyword.validate([], [:one, two: 2])\n    iex> Enum.sort(result)\n    [two: 2]\n\n    iex> {:ok, result} = Keyword.validate([one: 1], [:one, two: 2])\n    iex> Enum.sort(result)\n    [one: 1, two: 2]\n\nPassing unknown keys returns an error:\n\n    iex> Keyword.validate([three: 3, four: 4], [one: 1, two: 2])\n    {:error, [:four, :three]}\n\nPassing the same key multiple times also errors:\n\n    iex> Keyword.validate([one: 1, two: 2, one: 1], [:one, :two])\n    {:error, [:one]}\n\n"}
{"completion":"","prompt":"Elixir.Keyword.validate!(keyword, values): Similar to `validate/2` but returns the keyword or raises an error.\n\n## Examples\n\n    iex> Keyword.validate!([], [one: 1, two: 2]) |> Enum.sort()\n    [one: 1, two: 2]\n    iex> Keyword.validate!([two: 3], [one: 1, two: 2]) |> Enum.sort()\n    [one: 1, two: 3]\n\nIf atoms are given, they are supported as keys but do not\nprovide a default value:\n\n    iex> Keyword.validate!([], [:one, two: 2]) |> Enum.sort()\n    [two: 2]\n    iex> Keyword.validate!([one: 1], [:one, two: 2]) |> Enum.sort()\n    [one: 1, two: 2]\n\nPassing unknown keys raises an error:\n\n    iex> Keyword.validate!([three: 3], [one: 1, two: 2])\n    ** (ArgumentError) unknown keys [:three] in [three: 3], the allowed keys are: [:one, :two]\n\nPassing the same key multiple times also errors:\n\n    iex> Keyword.validate!([one: 1, two: 2, one: 1], [:one, :two])\n    ** (ArgumentError) duplicate keys [:one] in [one: 1, two: 2, one: 1]\n\n"}
{"completion":"","prompt":"Elixir.Keyword.values(keywords): Returns all values from the keyword list.\n\nKeeps values from duplicate keys in the resulting list of values.\n\n## Examples\n\n    iex> Keyword.values(a: 1, b: 2)\n    [1, 2]\n    iex> Keyword.values(a: 1, b: 2, a: 3)\n    [1, 2, 3]\n\n"}
{"completion":"","prompt":"Elixir.List.Chars.BitString.to_charlist(term): Returns the given binary `term` converted to a charlist.\n"}
{"completion":"","prompt":"Elixir.List.Chars.to_charlist(term): Converts `term` to a charlist.\n"}
{"completion":"","prompt":"Elixir.List.ascii_printable?(list, limit \\\\ :infinity): Checks if `list` is a charlist made only of printable ASCII characters.\n\nTakes an optional `limit` as a second argument. `ascii_printable?/2` only\nchecks the printability of the list up to the `limit`.\n\nA printable charlist in Elixir contains only the printable characters in the\nstandard seven-bit ASCII character encoding, which are characters ranging from\n32 to 126 in decimal notation, plus the following control characters:\n\n  * `?\\a` - Bell\n  * `?\\b` - Backspace\n  * `?\\t` - Horizontal tab\n  * `?\\n` - Line feed\n  * `?\\v` - Vertical tab\n  * `?\\f` - Form feed\n  * `?\\r` - Carriage return\n  * `?\\e` - Escape\n\nFor more information read the [Character groups](https://en.wikipedia.org/wiki/ASCII#Character_groups)\nsection in the Wikipedia article of the [ASCII](https://en.wikipedia.org/wiki/ASCII) standard.\n\n## Examples\n\n    iex> List.ascii_printable?('abc')\n    true\n\n    iex> List.ascii_printable?('abc' ++ [0])\n    false\n\n    iex> List.ascii_printable?('abc' ++ [0], 2)\n    true\n\nImproper lists are not printable, even if made only of ASCII characters:\n\n    iex> List.ascii_printable?('abc' ++ ?d)\n    false\n\n"}
{"completion":"","prompt":"Elixir.List.delete(list, element): Deletes the given `element` from the `list`. Returns a new list without\nthe element.\n\nIf the `element` occurs more than once in the `list`, just\nthe first occurrence is removed.\n\n## Examples\n\n    iex> List.delete([:a, :b, :c], :a)\n    [:b, :c]\n\n    iex> List.delete([:a, :b, :c], :d)\n    [:a, :b, :c]\n\n    iex> List.delete([:a, :b, :b, :c], :b)\n    [:a, :b, :c]\n\n    iex> List.delete([], :b)\n    []\n\n"}
{"completion":"","prompt":"Elixir.List.delete_at(list, index): Produces a new list by removing the value at the specified `index`.\n\nNegative indices indicate an offset from the end of the `list`.\nIf `index` is out of bounds, the original `list` is returned.\n\n## Examples\n\n    iex> List.delete_at([1, 2, 3], 0)\n    [2, 3]\n\n    iex> List.delete_at([1, 2, 3], 10)\n    [1, 2, 3]\n\n    iex> List.delete_at([1, 2, 3], -1)\n    [1, 2]\n\n"}
{"completion":"","prompt":"Elixir.List.duplicate(elem, n): Duplicates the given element `n` times in a list.\n\n`n` is an integer greater than or equal to `0`.\n\nIf `n` is `0`, an empty list is returned.\n\n## Examples\n\n    iex> List.duplicate(\"hello\", 0)\n    []\n\n    iex> List.duplicate(\"hi\", 1)\n    [\"hi\"]\n\n    iex> List.duplicate(\"bye\", 2)\n    [\"bye\", \"bye\"]\n\n    iex> List.duplicate([1, 2], 3)\n    [[1, 2], [1, 2], [1, 2]]\n\n"}
{"completion":"","prompt":"Elixir.List.first(list, default \\\\ nil): Returns the first element in `list` or `default` if `list` is empty.\n\n`first/2` has been introduced in Elixir v1.12.0, while `first/1` has been available since v1.0.0.\n\n## Examples\n\n    iex> List.first([])\n    nil\n\n    iex> List.first([], 1)\n    1\n\n    iex> List.first([1])\n    1\n\n    iex> List.first([1, 2, 3])\n    1\n\n"}
{"completion":"","prompt":"Elixir.List.flatten(list): Flattens the given `list` of nested lists.\n\nEmpty list elements are discarded.\n\n## Examples\n\n    iex> List.flatten([1, [[2], 3]])\n    [1, 2, 3]\n\n    iex> List.flatten([[], [[], []]])\n    []\n\n"}
{"completion":"","prompt":"Elixir.List.flatten(list, tail): Flattens the given `list` of nested lists.\nThe list `tail` will be added at the end of\nthe flattened list.\n\nEmpty list elements from `list` are discarded,\nbut not the ones from `tail`.\n\n## Examples\n\n    iex> List.flatten([1, [[2], 3]], [4, 5])\n    [1, 2, 3, 4, 5]\n\n    iex> List.flatten([1, [], 2], [3, [], 4])\n    [1, 2, 3, [], 4]\n\n"}
{"completion":"","prompt":"Elixir.List.foldl(list, acc, fun): Folds (reduces) the given list from the left with\na function. Requires an accumulator, which can be any value.\n\n## Examples\n\n    iex> List.foldl([5, 5], 10, fn x, acc -> x + acc end)\n    20\n\n    iex> List.foldl([1, 2, 3, 4], 0, fn x, acc -> x - acc end)\n    2\n\n    iex> List.foldl([1, 2, 3], {0, 0}, fn x, {a1, a2} -> {a1 + x, a2 - x} end)\n    {6, -6}\n\n"}
{"completion":"","prompt":"Elixir.List.foldr(list, acc, fun): Folds (reduces) the given list from the right with\na function. Requires an accumulator, which can be any value.\n\n## Examples\n\n    iex> List.foldr([1, 2, 3, 4], 0, fn x, acc -> x - acc end)\n    -2\n\n    iex> List.foldr([1, 2, 3, 4], %{sum: 0, product: 1}, fn x, %{sum: a1, product: a2} -> %{sum: a1 + x, product: a2 * x} end)\n    %{product: 24, sum: 10}\n\n"}
{"completion":"","prompt":"Elixir.List.improper?(list): Returns `true` if `list` is an improper list. Otherwise returns `false`.\n\n## Examples\n\n    iex> List.improper?([1, 2 | 3])\n    true\n\n    iex> List.improper?([1, 2, 3])\n    false\n\n"}
{"completion":"","prompt":"Elixir.List.insert_at(list, index, value): Returns a list with `value` inserted at the specified `index`.\n\nNote that `index` is capped at the list length. Negative indices\nindicate an offset from the end of the `list`.\n\n## Examples\n\n    iex> List.insert_at([1, 2, 3, 4], 2, 0)\n    [1, 2, 0, 3, 4]\n\n    iex> List.insert_at([1, 2, 3], 10, 0)\n    [1, 2, 3, 0]\n\n    iex> List.insert_at([1, 2, 3], -1, 0)\n    [1, 2, 3, 0]\n\n    iex> List.insert_at([1, 2, 3], -10, 0)\n    [0, 1, 2, 3]\n\n"}
{"completion":"","prompt":"Elixir.List.keydelete(list, key, position): Receives a `list` of tuples and deletes the first tuple\nwhere the element at `position` matches the\ngiven `key`. Returns the new list.\n\n## Examples\n\n    iex> List.keydelete([a: 1, b: 2], :a, 0)\n    [b: 2]\n\n    iex> List.keydelete([a: 1, b: 2], 2, 1)\n    [a: 1]\n\n    iex> List.keydelete([a: 1, b: 2], :c, 0)\n    [a: 1, b: 2]\n\nThis function works for any list of tuples:\n\n    iex> List.keydelete([{22, \"SSH\"}, {80, \"HTTP\"}], 80, 0)\n    [{22, \"SSH\"}]\n\n"}
{"completion":"","prompt":"Elixir.List.keyfind(list, key, position, default \\\\ nil): Receives a list of tuples and returns the first tuple\nwhere the element at `position` in the tuple matches the\ngiven `key`.\n\nIf no matching tuple is found, `default` is returned.\n\n## Examples\n\n    iex> List.keyfind([a: 1, b: 2], :a, 0)\n    {:a, 1}\n\n    iex> List.keyfind([a: 1, b: 2], 2, 1)\n    {:b, 2}\n\n    iex> List.keyfind([a: 1, b: 2], :c, 0)\n    nil\n\nThis function works for any list of tuples:\n\n    iex> List.keyfind([{22, \"SSH\"}, {80, \"HTTP\"}], 22, 0)\n    {22, \"SSH\"}\n\n"}
{"completion":"","prompt":"Elixir.List.keyfind!(list, key, position): Receives a list of tuples and returns the first tuple\nwhere the element at `position` in the tuple matches the\ngiven `key`.\n\nIf no matching tuple is found, an error is raised.\n\n## Examples\n\n    iex> List.keyfind!([a: 1, b: 2], :a, 0)\n    {:a, 1}\n\n    iex> List.keyfind!([a: 1, b: 2], 2, 1)\n    {:b, 2}\n\n    iex> List.keyfind!([a: 1, b: 2], :c, 0)\n    ** (KeyError) key :c at position 0 not found in: [a: 1, b: 2]\n\nThis function works for any list of tuples:\n\n    iex> List.keyfind!([{22, \"SSH\"}, {80, \"HTTP\"}], 22, 0)\n    {22, \"SSH\"}\n\n"}
{"completion":"","prompt":"Elixir.List.keymember?(list, key, position): Receives a list of tuples and returns `true` if there is\na tuple where the element at `position` in the tuple matches\nthe given `key`.\n\n## Examples\n\n    iex> List.keymember?([a: 1, b: 2], :a, 0)\n    true\n\n    iex> List.keymember?([a: 1, b: 2], 2, 1)\n    true\n\n    iex> List.keymember?([a: 1, b: 2], :c, 0)\n    false\n\nThis function works for any list of tuples:\n\n    iex> List.keymember?([{22, \"SSH\"}, {80, \"HTTP\"}], 22, 0)\n    true\n\n"}
{"completion":"","prompt":"Elixir.List.keyreplace(list, key, position, new_tuple): Receives a list of tuples and if the identified element by `key` at `position`\nexists, it is replaced with `new_tuple`.\n\n## Examples\n\n    iex> List.keyreplace([a: 1, b: 2], :a, 0, {:a, 3})\n    [a: 3, b: 2]\n\n    iex> List.keyreplace([a: 1, b: 2], :a, 1, {:a, 3})\n    [a: 1, b: 2]\n\nThis function works for any list of tuples:\n\n    iex> List.keyreplace([{22, \"SSH\"}, {80, \"HTTP\"}], 22, 0, {22, \"Secure Shell\"})\n    [{22, \"Secure Shell\"}, {80, \"HTTP\"}]\n\n"}
{"completion":"","prompt":"Elixir.List.keysort(list, position, sorter \\\\ :asc): Receives a list of tuples and sorts the elements\nat `position` of the tuples.\n\nThe sort is stable.\n\nA `sorter` argument is available since Elixir v1.14.0. Similar to\n`Enum.sort/2`, the sorter can be an anonymous function, the atoms\n`:asc` or `:desc`, or module that implements a compare function.\n\n## Examples\n\n    iex> List.keysort([a: 5, b: 1, c: 3], 1)\n    [b: 1, c: 3, a: 5]\n\n    iex> List.keysort([a: 5, c: 1, b: 3], 0)\n    [a: 5, b: 3, c: 1]\n\nTo sort in descending order:\n\n    iex> List.keysort([a: 5, c: 1, b: 3], 0, :desc)\n    [c: 1, b: 3, a: 5]\n\nAs in `Enum.sort/2`, avoid using the default sorting function to sort\nstructs, as by default it performs structural comparison instead of a\nsemantic one. In such cases, you shall pass a sorting function as third\nelement or any module that implements a `compare/2` function. For example,\nif you have tuples with user names and their birthday, and you want to\nsort on their birthday, in both ascending and descending order, you should\ndo:\n\n    iex> users = [\n    ...>   {\"Ellis\", ~D[1943-05-11]},\n    ...>   {\"Lovelace\", ~D[1815-12-10]},\n    ...>   {\"Turing\", ~D[1912-06-23]}\n    ...> ]\n    iex> List.keysort(users, 1, Date)\n    [\n      {\"Lovelace\", ~D[1815-12-10]},\n      {\"Turing\", ~D[1912-06-23]},\n      {\"Ellis\", ~D[1943-05-11]}\n    ]\n    iex> List.keysort(users, 1, {:desc, Date})\n    [\n      {\"Ellis\", ~D[1943-05-11]},\n      {\"Turing\", ~D[1912-06-23]},\n      {\"Lovelace\", ~D[1815-12-10]}\n    ]\n\n"}
{"completion":"","prompt":"Elixir.List.keystore(list, key, position, new_tuple): Receives a `list` of tuples and replaces the element\nidentified by `key` at `position` with `new_tuple`.\n\nIf the element does not exist, it is added to the end of the `list`.\n\n## Examples\n\n    iex> List.keystore([a: 1, b: 2], :a, 0, {:a, 3})\n    [a: 3, b: 2]\n\n    iex> List.keystore([a: 1, b: 2], :c, 0, {:c, 3})\n    [a: 1, b: 2, c: 3]\n\nThis function works for any list of tuples:\n\n    iex> List.keystore([{22, \"SSH\"}], 80, 0, {80, \"HTTP\"})\n    [{22, \"SSH\"}, {80, \"HTTP\"}]\n\n"}
{"completion":"","prompt":"Elixir.List.keytake(list, key, position): Receives a `list` of tuples and returns the first tuple\nwhere the element at `position` in the tuple matches the\ngiven `key`, as well as the `list` without found tuple.\n\nIf such a tuple is not found, `nil` will be returned.\n\n## Examples\n\n    iex> List.keytake([a: 1, b: 2], :a, 0)\n    {{:a, 1}, [b: 2]}\n\n    iex> List.keytake([a: 1, b: 2], 2, 1)\n    {{:b, 2}, [a: 1]}\n\n    iex> List.keytake([a: 1, b: 2], :c, 0)\n    nil\n\nThis function works for any list of tuples:\n\n    iex> List.keytake([{22, \"SSH\"}, {80, \"HTTP\"}], 80, 0)\n    {{80, \"HTTP\"}, [{22, \"SSH\"}]}\n\n"}
{"completion":"","prompt":"Elixir.List.last(list, default \\\\ nil): Returns the last element in `list` or `default` if `list` is empty.\n\n`last/2` has been introduced in Elixir v1.12.0, while `last/1` has been available since v1.0.0.\n\n## Examples\n\n    iex> List.last([])\n    nil\n\n    iex> List.last([], 1)\n    1\n\n    iex> List.last([1])\n    1\n\n    iex> List.last([1, 2, 3])\n    3\n\n"}
{"completion":"","prompt":"Elixir.List.myers_difference(list1, list2): Returns a keyword list that represents an *edit script*.\n\nThe algorithm is outlined in the\n\"An O(ND) Difference Algorithm and Its Variations\" paper by E. Myers.\n\nAn *edit script* is a keyword list. Each key describes the \"editing action\" to\ntake in order to bring `list1` closer to being equal to `list2`; a key can be\n`:eq`, `:ins`, or `:del`. Each value is a sublist of either `list1` or `list2`\nthat should be inserted (if the corresponding key `:ins`), deleted (if the\ncorresponding key is `:del`), or left alone (if the corresponding key is\n`:eq`) in `list1` in order to be closer to `list2`.\n\nSee `myers_difference/3` if you want to handle nesting in the diff scripts.\n\n## Examples\n\n    iex> List.myers_difference([1, 4, 2, 3], [1, 2, 3, 4])\n    [eq: [1], del: [4], eq: [2, 3], ins: [4]]\n\n"}
{"completion":"","prompt":"Elixir.List.myers_difference(list1, list2, diff_script): Returns a keyword list that represents an *edit script* with nested diffs.\n\nThis is an extension of `myers_difference/2` where a `diff_script` function\ncan be given in case it is desired to compute nested differences. The function\nmay return a list with the inner edit script or `nil` in case there is no\nsuch script. The returned inner edit script will be under the `:diff` key.\n\n## Examples\n\n    iex> List.myers_difference([\"a\", \"db\", \"c\"], [\"a\", \"bc\"], &String.myers_difference/2)\n    [eq: [\"a\"], diff: [del: \"d\", eq: \"b\", ins: \"c\"], del: [\"c\"]]\n\n"}
{"completion":"","prompt":"Elixir.List.pop_at(list, index, default \\\\ nil): Returns and removes the value at the specified `index` in the `list`.\n\nNegative indices indicate an offset from the end of the `list`.\nIf `index` is out of bounds, the original `list` is returned.\n\n## Examples\n\n    iex> List.pop_at([1, 2, 3], 0)\n    {1, [2, 3]}\n    iex> List.pop_at([1, 2, 3], 5)\n    {nil, [1, 2, 3]}\n    iex> List.pop_at([1, 2, 3], 5, 10)\n    {10, [1, 2, 3]}\n    iex> List.pop_at([1, 2, 3], -1)\n    {3, [1, 2]}\n\n"}
{"completion":"","prompt":"Elixir.List.replace_at(list, index, value): Returns a list with a replaced value at the specified `index`.\n\nNegative indices indicate an offset from the end of the `list`.\nIf `index` is out of bounds, the original `list` is returned.\n\n## Examples\n\n    iex> List.replace_at([1, 2, 3], 0, 0)\n    [0, 2, 3]\n\n    iex> List.replace_at([1, 2, 3], 10, 0)\n    [1, 2, 3]\n\n    iex> List.replace_at([1, 2, 3], -1, 0)\n    [1, 2, 0]\n\n    iex> List.replace_at([1, 2, 3], -10, 0)\n    [1, 2, 3]\n\n"}
{"completion":"","prompt":"Elixir.List.starts_with?(list, prefix): Returns `true` if `list` starts with the given `prefix` list; otherwise returns `false`.\n\nIf `prefix` is an empty list, it returns `true`.\n\n### Examples\n\n    iex> List.starts_with?([1, 2, 3], [1, 2])\n    true\n\n    iex> List.starts_with?([1, 2], [1, 2, 3])\n    false\n\n    iex> List.starts_with?([:alpha], [])\n    true\n\n    iex> List.starts_with?([], [:alpha])\n    false\n\n"}
{"completion":"","prompt":"Elixir.List.to_atom(charlist): Converts a charlist to an atom.\n\nElixir supports conversions from charlists which contains any Unicode\ncode point.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> List.to_atom('Elixir')\n    :Elixir\n\n    iex> List.to_atom('ð¢ Elixir')\n    :\"ð¢ Elixir\"\n\n"}
{"completion":"","prompt":"Elixir.List.to_charlist(list): Converts a list of integers representing Unicode code points, lists or\nstrings into a charlist.\n\nNote that this function expects a list of integers representing\nUnicode code points. If you have a list of bytes, you must instead use\nthe [`:binary` module](`:binary`).\n\n## Examples\n\n    iex> List.to_charlist([0x00E6, 0x00DF])\n    'Ã¦Ã'\n\n    iex> List.to_charlist([0x0061, \"bc\"])\n    'abc'\n\n    iex> List.to_charlist([0x0064, \"ee\", ['p']])\n    'deep'\n\n"}
{"completion":"","prompt":"Elixir.List.to_existing_atom(charlist): Converts a charlist to an existing atom.\n\nElixir supports conversions from charlists which contains any Unicode\ncode point. Raises an `ArgumentError` if the atom does not exist.\n\nInlined by the compiler.\n\n> #### Atoms and modules {: .info}\n>\n> Since Elixir is a compiled language, the atoms defined in a module\n> will only exist after said module is loaded, which typically happens\n> whenever a function in the module is executed. Therefore, it is\n> generally recommended to call `List.to_existing_atom/1` only to\n> convert atoms defined within the module making the function call\n> to `to_existing_atom/1`.\n\n## Examples\n\n    iex> _ = :my_atom\n    iex> List.to_existing_atom('my_atom')\n    :my_atom\n\n    iex> _ = :\"ð¢ Elixir\"\n    iex> List.to_existing_atom('ð¢ Elixir')\n    :\"ð¢ Elixir\"\n\n"}
{"completion":"","prompt":"Elixir.List.to_float(charlist): Returns the float whose text representation is `charlist`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> List.to_float('2.2017764e+0')\n    2.2017764\n\n"}
{"completion":"","prompt":"Elixir.List.to_integer(charlist): Returns an integer whose text representation is `charlist`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> List.to_integer('123')\n    123\n\n"}
{"completion":"","prompt":"Elixir.List.to_integer(charlist, base): Returns an integer whose text representation is `charlist` in base `base`.\n\nInlined by the compiler.\n\nThe base needs to be between `2` and `36`.\n\n## Examples\n\n    iex> List.to_integer('3FF', 16)\n    1023\n\n"}
{"completion":"","prompt":"Elixir.List.to_string(list): Converts a list of integers representing code points, lists or\nstrings into a string.\n\nTo be converted to a string, a list must either be empty or only\ncontain the following elements:\n\n  * strings\n  * integers representing Unicode code points\n  * a list containing one of these three elements\n\nNote that this function expects a list of integers representing\nUnicode code points. If you have a list of bytes, you must instead use\nthe [`:binary` module](`:binary`).\n\n## Examples\n\n    iex> List.to_string([0x00E6, 0x00DF])\n    \"Ã¦Ã\"\n\n    iex> List.to_string([0x0061, \"bc\"])\n    \"abc\"\n\n    iex> List.to_string([0x0064, \"ee\", ['p']])\n    \"deep\"\n\n    iex> List.to_string([])\n    \"\"\n\n"}
{"completion":"","prompt":"Elixir.List.to_tuple(list): Converts a list to a tuple.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> List.to_tuple([:share, [:elixir, 163]])\n    {:share, [:elixir, 163]}\n\n"}
{"completion":"","prompt":"Elixir.List.update_at(list, index, fun): Returns a list with an updated value at the specified `index`.\n\nNegative indices indicate an offset from the end of the `list`.\nIf `index` is out of bounds, the original `list` is returned.\n\n## Examples\n\n    iex> List.update_at([1, 2, 3], 0, &(&1 + 10))\n    [11, 2, 3]\n\n    iex> List.update_at([1, 2, 3], 10, &(&1 + 10))\n    [1, 2, 3]\n\n    iex> List.update_at([1, 2, 3], -1, &(&1 + 10))\n    [1, 2, 13]\n\n    iex> List.update_at([1, 2, 3], -10, &(&1 + 10))\n    [1, 2, 3]\n\n"}
{"completion":"","prompt":"Elixir.List.wrap(term): Wraps `term` in a list if this is not list.\n\nIf `term` is already a list, it returns the list.\nIf `term` is `nil`, it returns an empty list.\n\n## Examples\n\n    iex> List.wrap(\"hello\")\n    [\"hello\"]\n\n    iex> List.wrap([1, 2, 3])\n    [1, 2, 3]\n\n    iex> List.wrap(nil)\n    []\n\n"}
{"completion":"","prompt":"Elixir.List.zip(list_of_lists): Zips corresponding elements from each list in `list_of_lists`.\n\nThe zipping finishes as soon as any list terminates.\n\n## Examples\n\n    iex> List.zip([[1, 2], [3, 4], [5, 6]])\n    [{1, 3, 5}, {2, 4, 6}]\n\n    iex> List.zip([[1, 2], [3], [5, 6]])\n    [{1, 3, 5}]\n\n"}
{"completion":"","prompt":"Elixir.Macro.Env.fetch_alias(map, atom): Fetches the alias for the given atom.\n\nReturns `{:ok, alias}` if the alias exists, `:error`\notherwise.\n\n## Examples\n\n    iex> alias Foo.Bar, as: Baz\n    iex> Baz\n    Foo.Bar\n    iex> Macro.Env.fetch_alias(__ENV__, :Baz)\n    {:ok, Foo.Bar}\n    iex> Macro.Env.fetch_alias(__ENV__, :Unknown)\n    :error\n\n"}
{"completion":"","prompt":"Elixir.Macro.Env.fetch_macro_alias(map, atom): Fetches the macro alias for the given atom.\n\nReturns `{:ok, macro_alias}` if the alias exists, `:error`\notherwise.\n\nA macro alias is only used inside quoted expansion. See\n`fetch_alias/2` for a more general example.\n"}
{"completion":"","prompt":"Elixir.Macro.Env.has_var?(env, var): Checks if a variable belongs to the environment.\n\n## Examples\n\n    iex> x = 13\n    iex> x\n    13\n    iex> Macro.Env.has_var?(__ENV__, {:x, nil})\n    true\n    iex> Macro.Env.has_var?(__ENV__, {:unknown, nil})\n    false\n\n"}
{"completion":"","prompt":"Elixir.Macro.Env.in_guard?(env): Returns whether the compilation environment is currently\ninside a guard.\n"}
{"completion":"","prompt":"Elixir.Macro.Env.in_match?(env): Returns whether the compilation environment is currently\ninside a match clause.\n"}
{"completion":"","prompt":"Elixir.Macro.Env.location(env): Returns a keyword list containing the file and line\ninformation as keys.\n"}
{"completion":"","prompt":"Elixir.Macro.Env.lookup_import(map, pair): Returns the modules from which the given `{name, arity}` was\nimported.\n\nIt returns a list of two element tuples in the shape of\n`{:function | :macro, module}`. The elements in the list\nare in no particular order and the order is not guaranteed.\n\n## Examples\n\n    iex> Macro.Env.lookup_import(__ENV__, {:duplicate, 2})\n    []\n    iex> import Tuple, only: [duplicate: 2], warn: false\n    iex> Macro.Env.lookup_import(__ENV__, {:duplicate, 2})\n    [{:function, Tuple}]\n    iex> import List, only: [duplicate: 2], warn: false\n    iex> Macro.Env.lookup_import(__ENV__, {:duplicate, 2})\n    [{:function, List}, {:function, Tuple}]\n\n    iex> Macro.Env.lookup_import(__ENV__, {:def, 1})\n    [{:macro, Kernel}]\n\n"}
{"completion":"","prompt":"Elixir.Macro.Env.prepend_tracer(env, tracer): Prepend a tracer to the list of tracers in the environment.\n\n## Examples\n\n    Macro.Env.prepend_tracer(__ENV__, MyCustomTracer)\n\n"}
{"completion":"","prompt":"Elixir.Macro.Env.prune_compile_info(env): Prunes compile information from the environment.\n\nThis happens when the environment is captured at compilation\ntime, for example, in the module body, and then used to\nevaluate code after the module has been defined.\n"}
{"completion":"","prompt":"Elixir.Macro.Env.required?(map, mod): Returns true if the given module has been required.\n\n## Examples\n\n    iex> Macro.Env.required?(__ENV__, Integer)\n    false\n    iex> require Integer\n    iex> Macro.Env.required?(__ENV__, Integer)\n    true\n\n    iex> Macro.Env.required?(__ENV__, Kernel)\n    true\n"}
{"completion":"","prompt":"Elixir.Macro.Env.stacktrace(env): Returns the environment stacktrace.\n"}
{"completion":"","prompt":"Elixir.Macro.Env.to_match(env): Returns a `Macro.Env` in the match context.\n"}
{"completion":"","prompt":"Elixir.Macro.Env.vars(env): Returns a list of variables in the current environment.\n\nEach variable is identified by a tuple of two elements,\nwhere the first element is the variable name as an atom\nand the second element is its context, which may be an\natom or an integer.\n"}
{"completion":"","prompt":"Elixir.Macro.camelize(string): Converts the given string to CamelCase format.\n\nThis function was designed to camelize language identifiers/tokens,\nthat's why it belongs to the `Macro` module. Do not use it as a general\nmechanism for camelizing strings as it does not support Unicode or\ncharacters that are not valid in Elixir identifiers.\n\n## Examples\n\n    iex> Macro.camelize(\"foo_bar\")\n    \"FooBar\"\n\n    iex> Macro.camelize(\"foo/bar\")\n    \"Foo.Bar\"\n\nIf uppercase characters are present, they are not modified in any way\nas a mechanism to preserve acronyms:\n\n    iex> Macro.camelize(\"API.V1\")\n    \"API.V1\"\n    iex> Macro.camelize(\"API_SPEC\")\n    \"API_SPEC\"\n\n"}
{"completion":"","prompt":"Elixir.Macro.classify_atom(atom): Classifies a runtime `atom` based on its possible AST placement.\n\nIt returns one of the following atoms:\n\n  * `:alias` - the atom represents an alias\n\n  * `:identifier` - the atom can be used as a variable or local function\n    call (as well as be an unquoted atom)\n\n  * `:unquoted` - the atom can be used in its unquoted form,\n    includes operators and atoms with `@` in them\n\n  * `:quoted` - all other atoms which can only be used in their quoted form\n\nMost operators are going to be `:unquoted`, such as `:+`, with\nsome exceptions returning `:quoted` due to ambiguity, such as\n`:\"::\"`. Use `operator?/2` to check if a given atom is an operator.\n\n## Examples\n\n    iex> Macro.classify_atom(:foo)\n    :identifier\n    iex> Macro.classify_atom(Foo)\n    :alias\n    iex> Macro.classify_atom(:foo@bar)\n    :unquoted\n    iex> Macro.classify_atom(:+)\n    :unquoted\n    iex> Macro.classify_atom(:Foo)\n    :unquoted\n    iex> Macro.classify_atom(:\"with spaces\")\n    :quoted\n\n"}
{"completion":"","prompt":"Elixir.Macro.dbg(code, options, env): Default backend for `Kernel.dbg/2`.\n\nThis function provides a default backend for `Kernel.dbg/2`. See the\n`Kernel.dbg/2` documentation for more information.\n\nThis function:\n\n  * prints information about the given `env`\n  * prints information about `code` and its returned value (using `opts` to inspect terms)\n  * returns the value returned by evaluating `code`\n\nYou can call this function directly to build `Kernel.dbg/2` backends that fall back\nto this function.\n"}
{"completion":"","prompt":"Elixir.Macro.decompose_call(ast): Decomposes a local or remote call into its remote part (when provided),\nfunction name and argument list.\n\nReturns `:error` when an invalid call syntax is provided.\n\n## Examples\n\n    iex> Macro.decompose_call(quote(do: foo))\n    {:foo, []}\n\n    iex> Macro.decompose_call(quote(do: foo()))\n    {:foo, []}\n\n    iex> Macro.decompose_call(quote(do: foo(1, 2, 3)))\n    {:foo, [1, 2, 3]}\n\n    iex> Macro.decompose_call(quote(do: Elixir.M.foo(1, 2, 3)))\n    {{:__aliases__, [], [:Elixir, :M]}, :foo, [1, 2, 3]}\n\n    iex> Macro.decompose_call(quote(do: 42))\n    :error\n\n    iex> Macro.decompose_call(quote(do: {:foo, [], []}))\n    :error\n\n"}
{"completion":"","prompt":"Elixir.Macro.escape(expr, opts \\\\ []): Recursively escapes a value so it can be inserted into a syntax tree.\n\n## Examples\n\n    iex> Macro.escape(:foo)\n    :foo\n\n    iex> Macro.escape({:a, :b, :c})\n    {:{}, [], [:a, :b, :c]}\n\n    iex> Macro.escape({:unquote, [], [1]}, unquote: true)\n    1\n\n## Options\n\n  * `:unquote` - when true, this function leaves `unquote/1` and\n    `unquote_splicing/1` statements unescaped, effectively unquoting\n    the contents on escape. This option is useful only when escaping\n    ASTs which may have quoted fragments in them. Defaults to false.\n\n  * `:prune_metadata` - when true, removes metadata from escaped AST\n    nodes. Note this option changes the semantics of escaped code and\n    it should only be used when escaping ASTs. Defaults to false.\n\n    As an example, `ExUnit` stores the AST of every assertion, so when\n    an assertion fails we can show code snippets to users. Without this\n    option, each time the test module is compiled, we get a different\n    MD5 of the module bytecode, because the AST contains metadata,\n    such as counters, specific to the compilation environment. By pruning\n    the metadata, we ensure that the module is deterministic and reduce\n    the amount of data `ExUnit` needs to keep around. Only the minimal\n    amount of metadata is kept, such as `:line` and `:no_parens`.\n\n## Comparison to `quote/2`\n\nThe `escape/2` function is sometimes confused with `quote/2`,\nbecause the above examples behave the same with both. The key difference is\nbest illustrated when the value to escape is stored in a variable.\n\n    iex> Macro.escape({:a, :b, :c})\n    {:{}, [], [:a, :b, :c]}\n    iex> quote do: {:a, :b, :c}\n    {:{}, [], [:a, :b, :c]}\n\n    iex> value = {:a, :b, :c}\n    iex> Macro.escape(value)\n    {:{}, [], [:a, :b, :c]}\n\n    iex> quote do: value\n    {:value, [], __MODULE__}\n\n    iex> value = {:a, :b, :c}\n    iex> quote do: unquote(value)\n    {:a, :b, :c}\n\n`escape/2` is used to escape *values* (either directly passed or variable\nbound), while `quote/2` produces syntax trees for\nexpressions.\n"}
{"completion":"","prompt":"Elixir.Macro.expand(ast, env): Receives an AST node and expands it until it can no longer\nbe expanded.\n\nNote this function does not traverse the AST, only the root\nnode is expanded.\n\nThis function uses `expand_once/2` under the hood. Check\nit out for more information and examples.\n"}
{"completion":"","prompt":"Elixir.Macro.expand_literals(ast, env): Expands all literals in `ast` with the given `env`.\n\nThis function is mostly used to remove compile-time dependencies\nfrom AST nodes. In such cases, the given environment is usually\nmanipulated to represent a function:\n\n    Macro.expand_literals(ast, %{env | function: {:my_code, 1}})\n\nAt the moment, the only expandable literal nodes in an AST are\naliases, so this function only expands aliases.\n\nHowever, be careful when removing compile-time dependencies between\nmodules. If you remove them but you still invoke the module at\ncompile-time, Elixir will be unable to properly recompile modules\nwhen they change.\n"}
{"completion":"","prompt":"Elixir.Macro.expand_literals(ast, acc, fun): Expands all literals in `ast` with the given `acc` and `fun`.\n\n`fun` will be invoked with an expandable AST node and `acc` and\nmust return a new node with `acc`. This is a general version of\n`expand_literals/2` which supports a custom expansion function.\nPlease check `expand_literals/2` for use cases and pitfalls.\n"}
{"completion":"","prompt":"Elixir.Macro.expand_once(ast, env): Receives an AST node and expands it once.\n\nThe following contents are expanded:\n\n  * Macros (local or remote)\n  * Aliases are expanded (if possible) and return atoms\n  * Compilation environment macros (`__CALLER__/0`, `__DIR__/0`, `__ENV__/0` and `__MODULE__/0`)\n  * Module attributes reader (`@foo`)\n\nIf the expression cannot be expanded, it returns the expression\nitself. This function does not traverse the AST, only the root\nnode is expanded.\n\n`expand_once/2` performs the expansion just once. Check `expand/2`\nto perform expansion until the node can no longer be expanded.\n\n## Examples\n\nIn the example below, we have a macro that generates a module\nwith a function named `name_length` that returns the length\nof the module name. The value of this function will be calculated\nat compilation time and not at runtime.\n\nConsider the implementation below:\n\n    defmacro defmodule_with_length(name, do: block) do\n      length = length(Atom.to_charlist(name))\n\n      quote do\n        defmodule unquote(name) do\n          def name_length, do: unquote(length)\n          unquote(block)\n        end\n      end\n    end\n\nWhen invoked like this:\n\n    defmodule_with_length My.Module do\n      def other_function, do: ...\n    end\n\nThe compilation will fail because `My.Module` when quoted\nis not an atom, but a syntax tree as follows:\n\n    {:__aliases__, [], [:My, :Module]}\n\nThat said, we need to expand the aliases node above to an\natom, so we can retrieve its length. Expanding the node is\nnot straightforward because we also need to expand the\ncaller aliases. For example:\n\n    alias MyHelpers, as: My\n\n    defmodule_with_length My.Module do\n      def other_function, do: ...\n    end\n\nThe final module name will be `MyHelpers.Module` and not\n`My.Module`. With `Macro.expand/2`, such aliases are taken\ninto consideration. Local and remote macros are also\nexpanded. We could rewrite our macro above to use this\nfunction as:\n\n    defmacro defmodule_with_length(name, do: block) do\n      expanded = Macro.expand(name, __CALLER__)\n      length = length(Atom.to_charlist(expanded))\n\n      quote do\n        defmodule unquote(name) do\n          def name_length, do: unquote(length)\n          unquote(block)\n        end\n      end\n    end\n\n"}
{"completion":"","prompt":"Elixir.Macro.generate_arguments(amount, context): Generates AST nodes for a given number of required argument\nvariables using `Macro.var/2`.\n\nNote the arguments are not unique. If you later on want\nto access the same variables, you can invoke this function\nwith the same inputs. Use `generate_unique_arguments/2` to\ngenerate a unique arguments that can't be overridden.\n\n## Examples\n\n    iex> Macro.generate_arguments(2, __MODULE__)\n    [{:arg1, [], __MODULE__}, {:arg2, [], __MODULE__}]\n\n"}
{"completion":"","prompt":"Elixir.Macro.generate_unique_arguments(amount, context): Generates AST nodes for a given number of required argument\nvariables using `Macro.unique_var/2`.\n\n## Examples\n\n    iex> [var1, var2] = Macro.generate_unique_arguments(2, __MODULE__)\n    iex> {:arg1, [counter: c1], __MODULE__} = var1\n    iex> {:arg2, [counter: c2], __MODULE__} = var2\n    iex> is_integer(c1) and is_integer(c2)\n    true\n\n"}
{"completion":"","prompt":"Elixir.Macro.inspect_atom(source_format, atom): Inspects `atom` according to different source formats.\n\nThe atom can be inspected according to the three different\nformats it appears in the AST: as a literal (`:literal`),\nas a key (`:key`), or as the function name of a remote call\n(`:remote_call`).\n\n## Examples\n\n### As a literal\n\nLiterals include regular atoms, quoted atoms, operators,\naliases, and the special `nil`, `true`, and `false` atoms.\n\n    iex> Macro.inspect_atom(:literal, nil)\n    \"nil\"\n    iex> Macro.inspect_atom(:literal, :foo)\n    \":foo\"\n    iex> Macro.inspect_atom(:literal, :<>)\n    \":<>\"\n    iex> Macro.inspect_atom(:literal, :Foo)\n    \":Foo\"\n    iex> Macro.inspect_atom(:literal, Foo.Bar)\n    \"Foo.Bar\"\n    iex> Macro.inspect_atom(:literal, :\"with spaces\")\n    \":\\\"with spaces\\\"\"\n\n### As a key\n\nInspect an atom as a key of a keyword list or a map.\n\n    iex> Macro.inspect_atom(:key, :foo)\n    \"foo:\"\n    iex> Macro.inspect_atom(:key, :<>)\n    \"<>:\"\n    iex> Macro.inspect_atom(:key, :Foo)\n    \"Foo:\"\n    iex> Macro.inspect_atom(:key, :\"with spaces\")\n    \"\\\"with spaces\\\":\"\n\n### As a remote call\n\nInspect an atom the function name of a remote call.\n\n    iex> Macro.inspect_atom(:remote_call, :foo)\n    \"foo\"\n    iex> Macro.inspect_atom(:remote_call, :<>)\n    \"<>\"\n    iex> Macro.inspect_atom(:remote_call, :Foo)\n    \"\\\"Foo\\\"\"\n    iex> Macro.inspect_atom(:remote_call, :\"with spaces\")\n    \"\\\"with spaces\\\"\"\n\n"}
{"completion":"","prompt":"Elixir.Macro.operator?(name, arity): Returns `true` if the given name and arity is an operator.\n\n## Examples\n\n    iex> Macro.operator?(:not_an_operator, 3)\n    false\n    iex> Macro.operator?(:.., 0)\n    true\n    iex> Macro.operator?(:+, 1)\n    true\n    iex> Macro.operator?(:++, 2)\n    true\n    iex> Macro.operator?(:..//, 3)\n    true\n\n"}
{"completion":"","prompt":"Elixir.Macro.path(ast, fun): Returns the path to the node in `ast` which `fun` returns true.\n\nThe path is a list, starting with the node in which `fun` returns\ntrue, followed by all of its parents.\n\nComputing the path can be an efficient operation when you want\nto find a particular node in the AST within its context and then\nassert something about it.\n\n## Examples\n\n    iex> Macro.path(quote(do: [1, 2, 3]), & &1 == 3)\n    [3, [1, 2, 3]]\n\n    iex> Macro.path(quote(do: Foo.bar(3)), & &1 == 3)\n    [3, quote(do: Foo.bar(3))]\n\n    iex> Macro.path(quote(do: %{foo: [bar: :baz]}), & &1 == :baz)\n    [\n      :baz,\n      {:bar, :baz},\n      [bar: :baz],\n      {:foo, [bar: :baz]},\n      {:%{}, [], [foo: [bar: :baz]]}\n    ]\n\n"}
{"completion":"","prompt":"Elixir.Macro.pipe(expr, call_args, position): Pipes `expr` into the `call_args` at the given `position`.\n\nThis function can be used to implement `|>` like functionality. For example,\n`|>` itself is implemented as:\n\n    defmacro left |> right do\n      Macro.pipe(left, right, 0)\n    end\n\n`expr` is the AST of an expression. `call_args` must be the AST *of a call*,\notherwise this function will raise an error. As an example, consider the pipe\noperator `|>/2`, which uses this function to build pipelines.\n\nEven if the expression is piped into the AST, it doesn't necessarily mean that\nthe AST is valid. For example, you could pipe an argument to `div/2`, effectively\nturning it into a call to `div/3`, which is a function that doesn't exist by\ndefault. The code will raise unless a `div/3` function is locally defined.\n"}
{"completion":"","prompt":"Elixir.Macro.postwalk(ast, fun): This function behaves like `prewalk/2`, but performs a depth-first,\npost-order traversal of quoted expressions.\n"}
{"completion":"","prompt":"Elixir.Macro.postwalk(ast, acc, fun): This functions behaves like `prewalk/3`, but performs a depth-first,\npost-order traversal of quoted expressions using an accumulator.\n"}
{"completion":"","prompt":"Elixir.Macro.postwalker(ast): Returns an enumerable that traverses the  `ast` in depth-first,\npost-order traversal.\n\n## Examples\n\n    iex> ast = quote do: foo(1, \"abc\")\n    iex> Enum.map(Macro.postwalker(ast), & &1)\n    [1, \"abc\", {:foo, [], [1, \"abc\"]}]\n\n"}
{"completion":"","prompt":"Elixir.Macro.prewalk(ast, fun): Performs a depth-first, pre-order traversal of quoted expressions.\n\nReturns a new AST where each node is the result of invoking `fun` on each\ncorresponding node of `ast`.\n\n## Examples\n\n    iex> ast = quote do: 5 + 3 * 7\n    iex> {:+, _, [5, {:*, _, [3, 7]}]} = ast\n    iex> new_ast = Macro.prewalk(ast, fn\n    ...>   {:+, meta, children} -> {:*, meta, children}\n    ...>   {:*, meta, children} -> {:+, meta, children}\n    ...>   other -> other\n    ...> end)\n    iex> {:*, _, [5, {:+, _, [3, 7]}]} = new_ast\n    iex> Code.eval_quoted(ast)\n    {26, []}\n    iex> Code.eval_quoted(new_ast)\n    {50, []}\n\n"}
{"completion":"","prompt":"Elixir.Macro.prewalk(ast, acc, fun): Performs a depth-first, pre-order traversal of quoted expressions\nusing an accumulator.\n\nReturns a tuple where the first element is a new AST where each node is the\nresult of invoking `fun` on each corresponding node and the second one is the\nfinal accumulator.\n\n## Examples\n\n    iex> ast = quote do: 5 + 3 * 7\n    iex> {:+, _, [5, {:*, _, [3, 7]}]} = ast\n    iex> {new_ast, acc} = Macro.prewalk(ast, [], fn\n    ...>   {:+, meta, children}, acc -> {{:*, meta, children}, [:+ | acc]}\n    ...>   {:*, meta, children}, acc -> {{:+, meta, children}, [:* | acc]}\n    ...>   other, acc -> {other, acc}\n    ...> end)\n    iex> {{:*, _, [5, {:+, _, [3, 7]}]}, [:*, :+]} = {new_ast, acc}\n    iex> Code.eval_quoted(ast)\n    {26, []}\n    iex> Code.eval_quoted(new_ast)\n    {50, []}\n\n"}
{"completion":"","prompt":"Elixir.Macro.prewalker(ast): Returns an enumerable that traverses the  `ast` in depth-first,\npre-order traversal.\n\n## Examples\n\n    iex> ast = quote do: foo(1, \"abc\")\n    iex> Enum.map(Macro.prewalker(ast), & &1)\n    [{:foo, [], [1, \"abc\"]}, 1, \"abc\"]\n\n"}
{"completion":"","prompt":"Elixir.Macro.quoted_literal?(term): Returns `true` if the given quoted expression represents a quoted literal.\n\nAtoms and numbers are always literals. Binaries, lists, tuples,\nmaps, and structs are only literals if all of their terms are also literals.\n\n## Examples\n\n    iex> Macro.quoted_literal?(quote(do: \"foo\"))\n    true\n    iex> Macro.quoted_literal?(quote(do: {\"foo\", 1}))\n    true\n    iex> Macro.quoted_literal?(quote(do: {\"foo\", 1, :baz}))\n    true\n    iex> Macro.quoted_literal?(quote(do: %{foo: \"bar\"}))\n    true\n    iex> Macro.quoted_literal?(quote(do: %URI{path: \"/\"}))\n    true\n    iex> Macro.quoted_literal?(quote(do: URI.parse(\"/\")))\n    false\n    iex> Macro.quoted_literal?(quote(do: {foo, var}))\n    false\n\n"}
{"completion":"","prompt":"Elixir.Macro.special_form?(name, arity): Returns `true` if the given name and arity is a special form.\n"}
{"completion":"","prompt":"Elixir.Macro.struct!(module, env): Expands the struct given by `module` in the given `env`.\n\nThis is useful when a struct needs to be expanded at\ncompilation time and the struct being expanded may or may\nnot have been compiled. This function is also capable of\nexpanding structs defined under the module being compiled.\n\nIt will raise `CompileError` if the struct is not available.\nFrom Elixir v1.12, calling this function also adds an export\ndependency on the given struct.\n"}
{"completion":"","prompt":"Elixir.Macro.to_string(tree): Converts the given expression AST to a string.\n\nThis is a convenience function for converting AST into\na string, which discards all formatting of the original\ncode and wraps newlines around 98 characters. See\n`Code.quoted_to_algebra/2` as a lower level function\nwith more control around formatting.\n\n## Examples\n\n    iex> Macro.to_string(quote(do: foo.bar(1, 2, 3)))\n    \"foo.bar(1, 2, 3)\"\n\n"}
{"completion":"","prompt":"Elixir.Macro.to_string(tree, fun): Converts the given expression AST to a string.\n\nThe given `fun` is called for every node in the AST with two arguments: the\nAST of the node being printed and the string representation of that same\nnode. The return value of this function is used as the final string\nrepresentation for that AST node.\n\nThis function discards all formatting of the original code.\n\n## Examples\n\n    Macro.to_string(quote(do: 1 + 2), fn\n      1, _string -> \"one\"\n      2, _string -> \"two\"\n      _ast, string -> string\n    end)\n    #=> \"one + two\"\n\n"}
{"completion":"","prompt":"Elixir.Macro.traverse(ast, acc, pre, post): Performs a depth-first traversal of quoted expressions\nusing an accumulator.\n\nReturns a tuple where the first element is a new AST and the second one is\nthe final accumulator. The new AST is the result of invoking `pre` on each\nnode of `ast` during the pre-order phase and `post` during the post-order\nphase.\n\n## Examples\n\n    iex> ast = quote do: 5 + 3 * 7\n    iex> {:+, _, [5, {:*, _, [3, 7]}]} = ast\n    iex> {new_ast, acc} =\n    ...>  Macro.traverse(\n    ...>    ast,\n    ...>    [],\n    ...>    fn\n    ...>      {:+, meta, children}, acc -> {{:-, meta, children}, [:- | acc]}\n    ...>      {:*, meta, children}, acc -> {{:/, meta, children}, [:/ | acc]}\n    ...>      other, acc -> {other, acc}\n    ...>    end,\n    ...>    fn\n    ...>      {:-, meta, children}, acc -> {{:min, meta, children}, [:min | acc]}\n    ...>      {:/, meta, children}, acc -> {{:max, meta, children}, [:max | acc]}\n    ...>      other, acc -> {other, acc}\n    ...>    end\n    ...>  )\n    iex> {:min, _, [5, {:max, _, [3, 7]}]} = new_ast\n    iex> [:min, :max, :/, :-] = acc\n    iex> Code.eval_quoted(new_ast)\n    {5, []}\n\n"}
{"completion":"","prompt":"Elixir.Macro.underscore(atom_or_string): Converts the given argument to a string with the underscore-slash format.\n\nThe argument must either be an atom or a string.\nIf an atom is given, it is assumed to be an Elixir module,\nso it is converted to a string and then processed.\n\nThis function was designed to format language identifiers/tokens with the underscore-slash format,\nthat's why it belongs to the `Macro` module. Do not use it as a general\nmechanism for underscoring strings as it does not support Unicode or\ncharacters that are not valid in Elixir identifiers.\n\n## Examples\n\n    iex> Macro.underscore(\"FooBar\")\n    \"foo_bar\"\n\n    iex> Macro.underscore(\"Foo.Bar\")\n    \"foo/bar\"\n\n    iex> Macro.underscore(Foo.Bar)\n    \"foo/bar\"\n\nIn general, `underscore` can be thought of as the reverse of\n`camelize`, however, in some cases formatting may be lost:\n\n    iex> Macro.underscore(\"SAPExample\")\n    \"sap_example\"\n\n    iex> Macro.camelize(\"sap_example\")\n    \"SapExample\"\n\n    iex> Macro.camelize(\"hello_10\")\n    \"Hello10\"\n\n    iex> Macro.camelize(\"foo/bar\")\n    \"Foo.Bar\"\n\n"}
{"completion":"","prompt":"Elixir.Macro.unescape_string(string): Unescapes characters in a string.\n\nThis is the unescaping behaviour used by default in Elixir\nsingle- and double-quoted strings. Check `unescape_string/2`\nfor information on how to customize the escaping map.\n\nIn this setup, Elixir will escape the following: `\\0`, `\\a`, `\\b`,\n`\\d`, `\\e`, `\\f`, `\\n`, `\\r`, `\\s`, `\\t` and `\\v`. Bytes can be\ngiven as hexadecimals via `\\xNN` and Unicode code points as\n`\\uNNNN` escapes.\n\nThis function is commonly used on sigil implementations\n(like `~r`, `~s` and others), which receive a raw, unescaped\nstring, and it can be used anywhere that needs to mimic how\nElixir parses strings.\n\n## Examples\n\n    iex> Macro.unescape_string(\"example\\\\n\")\n    \"example\\n\"\n\nIn the example above, we pass a string with `\\n` escaped\nand return a version with it unescaped.\n"}
{"completion":"","prompt":"Elixir.Macro.unescape_string(string, map): Unescapes characters in a string according to the given mapping.\n\nCheck `unescape_string/1` if you want to use the same mapping\nas Elixir single- and double-quoted strings.\n\n## Mapping function\n\nThe mapping function receives an integer representing the code point\nof the character it wants to unescape. There are also the special atoms\n`:newline`, `:unicode`, and `:hex`, which control newline, unicode,\nand escaping respectively.\n\nHere is the default mapping function implemented by Elixir:\n\n    def unescape_map(:newline), do: true\n    def unescape_map(:unicode), do: true\n    def unescape_map(:hex), do: true\n    def unescape_map(?0), do: ?0\n    def unescape_map(?a), do: ?\\a\n    def unescape_map(?b), do: ?\\b\n    def unescape_map(?d), do: ?\\d\n    def unescape_map(?e), do: ?\\e\n    def unescape_map(?f), do: ?\\f\n    def unescape_map(?n), do: ?\\n\n    def unescape_map(?r), do: ?\\r\n    def unescape_map(?s), do: ?\\s\n    def unescape_map(?t), do: ?\\t\n    def unescape_map(?v), do: ?\\v\n    def unescape_map(e), do: e\n\nIf the `unescape_map/1` function returns `false`, the char is\nnot escaped and the backslash is kept in the string.\n\n## Examples\n\nUsing the `unescape_map/1` function defined above is easy:\n\n    Macro.unescape_string(\"example\\\\n\", &unescape_map(&1))\n\n"}
{"completion":"","prompt":"Elixir.Macro.unique_var(var, context): Generates an AST node representing a unique variable\ngiven by the atoms `var` and `context`.\n\nCalling this function with the same arguments will\ngenerate another variable, with its own unique counter.\nSee `var/2` for an alternative.\n\n## Examples\n\n    iex> {:foo, [counter: c], __MODULE__} = Macro.unique_var(:foo, __MODULE__)\n    iex> is_integer(c)\n    true\n\n"}
{"completion":"","prompt":"Elixir.Macro.unpipe(expr): Breaks a pipeline expression into a list.\n\nThe AST for a pipeline (a sequence of applications of `|>/2`) is similar to the\nAST of a sequence of binary operators or function applications: the top-level\nexpression is the right-most `:|>` (which is the last one to be executed), and\nits left-hand and right-hand sides are its arguments:\n\n    quote do: 100 |> div(5) |> div(2)\n    #=> {:|>, _, [arg1, arg2]}\n\nIn the example above, the `|>/2` pipe is the right-most pipe; `arg1` is the AST\nfor `100 |> div(5)`, and `arg2` is the AST for `div(2)`.\n\nIt's often useful to have the AST for such a pipeline as a list of function\napplications. This function does exactly that:\n\n    Macro.unpipe(quote do: 100 |> div(5) |> div(2))\n    #=> [{100, 0}, {{:div, [], [5]}, 0}, {{:div, [], [2]}, 0}]\n\nWe get a list that follows the pipeline directly: first the `100`, then the\n`div(5)` (more precisely, its AST), then `div(2)`. The `0` as the second\nelement of the tuples is the position of the previous element in the pipeline\ninside the current function application: `{{:div, [], [5]}, 0}` means that the\nprevious element (`100`) will be inserted as the 0th (first) argument to the\n`div/2` function, so that the AST for that function will become `{:div, [],\n[100, 5]}` (`div(100, 5)`).\n"}
{"completion":"","prompt":"Elixir.Macro.update_meta(quoted, fun): Applies the given function to the node metadata if it contains one.\n\nThis is often useful when used with `Macro.prewalk/2` to remove\ninformation like lines and hygienic counters from the expression\nfor either storage or comparison.\n\n## Examples\n\n    iex> quoted = quote line: 10, do: sample()\n    {:sample, [line: 10], []}\n    iex> Macro.update_meta(quoted, &Keyword.delete(&1, :line))\n    {:sample, [], []}\n\n"}
{"completion":"","prompt":"Elixir.Macro.validate(expr): Validates the given expressions are valid quoted expressions.\n\nCheck the type `t:Macro.t/0` for a complete specification of a\nvalid quoted expression.\n\nIt returns `:ok` if the expression is valid. Otherwise it returns\na tuple in the form of `{:error, remainder}` where `remainder` is\nthe invalid part of the quoted expression.\n\n## Examples\n\n    iex> Macro.validate({:two_element, :tuple})\n    :ok\n    iex> Macro.validate({:three, :element, :tuple})\n    {:error, {:three, :element, :tuple}}\n\n    iex> Macro.validate([1, 2, 3])\n    :ok\n    iex> Macro.validate([1, 2, 3, {4}])\n    {:error, {4}}\n\n"}
{"completion":"","prompt":"Elixir.Macro.var(var, context): Generates an AST node representing the variable given\nby the atoms `var` and `context`.\n\nNote this variable is not unique. If you later on want\nto access this same variable, you can invoke `var/2`\nagain with the same arguments. Use `unique_var/2` to\ngenerate a unique variable that can't be overridden.\n\n## Examples\n\nIn order to build a variable, a context is expected.\nMost of the times, in order to preserve hygiene, the\ncontext must be `__MODULE__/0`:\n\n    iex> Macro.var(:foo, __MODULE__)\n    {:foo, [], __MODULE__}\n\nHowever, if there is a need to access the user variable,\nnil can be given:\n\n    iex> Macro.var(:foo, nil)\n    {:foo, [], nil}\n\n"}
{"completion":"","prompt":"Elixir.Map.delete(map, key): Deletes the entry in `map` for a specific `key`.\n\nIf the `key` does not exist, returns `map` unchanged.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.delete(%{a: 1, b: 2}, :a)\n    %{b: 2}\n    iex> Map.delete(%{b: 2}, :a)\n    %{b: 2}\n\n"}
{"completion":"","prompt":"Elixir.Map.drop(map, keys): Drops the given `keys` from `map`.\n\nIf `keys` contains keys that are not in `map`, they're simply ignored.\n\n## Examples\n\n    iex> Map.drop(%{a: 1, b: 2, c: 3}, [:b, :d])\n    %{a: 1, c: 3}\n\n"}
{"completion":"","prompt":"Elixir.Map.equal?(map1, map2): Checks if two maps are equal.\n\nTwo maps are considered to be equal if they contain\nthe same keys and those keys contain the same values.\n\nNote this function exists for completeness so the `Map`\nand `Keyword` modules provide similar APIs. In practice,\ndevelopers often compare maps using `==/2` or `===/2`\ndirectly.\n\n## Examples\n\n    iex> Map.equal?(%{a: 1, b: 2}, %{b: 2, a: 1})\n    true\n    iex> Map.equal?(%{a: 1, b: 2}, %{b: 1, a: 2})\n    false\n\nComparison between keys and values is done with `===/3`,\nwhich means integers are not equivalent to floats:\n\n    iex> Map.equal?(%{a: 1.0}, %{a: 1})\n    false\n\n"}
{"completion":"","prompt":"Elixir.Map.fetch(map, key): Fetches the value for a specific `key` in the given `map`.\n\nIf `map` contains the given `key` then its value is returned in the shape of `{:ok, value}`.\nIf `map` doesn't contain `key`, `:error` is returned.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.fetch(%{a: 1}, :a)\n    {:ok, 1}\n    iex> Map.fetch(%{a: 1}, :b)\n    :error\n\n"}
{"completion":"","prompt":"Elixir.Map.fetch!(map, key): Fetches the value for a specific `key` in the given `map`, erroring out if\n`map` doesn't contain `key`.\n\nIf `map` contains `key`, the corresponding value is returned. If\n`map` doesn't contain `key`, a `KeyError` exception is raised.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.fetch!(%{a: 1}, :a)\n    1\n\n"}
{"completion":"","prompt":"Elixir.Map.filter(map, fun): Returns a map containing only those pairs from `map`\nfor which `fun` returns a truthy value.\n\n`fun` receives the key and value of each of the\nelements in the map as a key-value pair.\n\nSee also `reject/2` which discards all elements where the\nfunction returns a truthy value.\n\n> Note: if you find yourself doing multiple calls to `Map.filter/2`\n> and `Map.reject/2` in a pipeline, it is likely more efficient\n> to use `Enum.map/2` and `Enum.filter/2` instead and convert to\n> a map at the end using `Map.new/1`.\n\n## Examples\n\n    iex> Map.filter(%{one: 1, two: 2, three: 3}, fn {_key, val} -> rem(val, 2) == 1 end)\n    %{one: 1, three: 3}\n\n"}
{"completion":"","prompt":"Elixir.Map.from_keys(keys, value): Builds a map from the given `keys` and the fixed `value`.\n\n## Examples\n\n    iex> Map.from_keys([1, 2, 3], :number)\n    %{1 => :number, 2 => :number, 3 => :number}\n\n"}
{"completion":"","prompt":"Elixir.Map.from_struct(struct): Converts a `struct` to map.\n\nIt accepts the struct module or a struct itself and\nsimply removes the `__struct__` field from the given struct\nor from a new struct generated from the given module.\n\n## Example\n\n    defmodule User do\n      defstruct [:name]\n    end\n\n    Map.from_struct(User)\n    #=> %{name: nil}\n\n    Map.from_struct(%User{name: \"john\"})\n    #=> %{name: \"john\"}\n\n"}
{"completion":"","prompt":"Elixir.Map.get(map, key, default \\\\ nil): Gets the value for a specific `key` in `map`.\n\nIf `key` is present in `map` then its value `value` is\nreturned. Otherwise, `default` is returned.\n\nIf `default` is not provided, `nil` is used.\n\n## Examples\n\n    iex> Map.get(%{}, :a)\n    nil\n    iex> Map.get(%{a: 1}, :a)\n    1\n    iex> Map.get(%{a: 1}, :b)\n    nil\n    iex> Map.get(%{a: 1}, :b, 3)\n    3\n\n"}
{"completion":"","prompt":"Elixir.Map.get_and_update(map, key, fun): Gets the value from `key` and updates it, all in one pass.\n\n`fun` is called with the current value under `key` in `map` (or `nil` if `key`\nis not present in `map`) and must return a two-element tuple: the current value\n(the retrieved value, which can be operated on before being returned) and the\nnew value to be stored under `key` in the resulting new map. `fun` may also\nreturn `:pop`, which means the current value shall be removed from `map` and\nreturned (making this function behave like `Map.pop(map, key)`).\n\nThe returned value is a two-element tuple with the current value returned by\n`fun` and a new map with the updated value under `key`.\n\n## Examples\n\n    iex> Map.get_and_update(%{a: 1}, :a, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {1, %{a: \"new value!\"}}\n\n    iex> Map.get_and_update(%{a: 1}, :b, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {nil, %{a: 1, b: \"new value!\"}}\n\n    iex> Map.get_and_update(%{a: 1}, :a, fn _ -> :pop end)\n    {1, %{}}\n\n    iex> Map.get_and_update(%{a: 1}, :b, fn _ -> :pop end)\n    {nil, %{a: 1}}\n\n"}
{"completion":"","prompt":"Elixir.Map.get_and_update!(map, key, fun): Gets the value from `key` and updates it, all in one pass. Raises if there is no `key`.\n\nBehaves exactly like `get_and_update/3`, but raises a `KeyError` exception if\n`key` is not present in `map`.\n\n## Examples\n\n    iex> Map.get_and_update!(%{a: 1}, :a, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {1, %{a: \"new value!\"}}\n\n    iex> Map.get_and_update!(%{a: 1}, :b, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    ** (KeyError) key :b not found in: %{a: 1}\n\n    iex> Map.get_and_update!(%{a: 1}, :a, fn _ ->\n    ...>   :pop\n    ...> end)\n    {1, %{}}\n\n"}
{"completion":"","prompt":"Elixir.Map.get_lazy(map, key, fun): Gets the value for a specific `key` in `map`.\n\nIf `key` is present in `map` then its value `value` is\nreturned. Otherwise, `fun` is evaluated and its result is returned.\n\nThis is useful if the default value is very expensive to calculate or\ngenerally difficult to setup and teardown again.\n\n## Examples\n\n    iex> map = %{a: 1}\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   13\n    ...> end\n    iex> Map.get_lazy(map, :a, fun)\n    1\n    iex> Map.get_lazy(map, :b, fun)\n    13\n\n"}
{"completion":"","prompt":"Elixir.Map.has_key?(map, key): Returns whether the given `key` exists in the given `map`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.has_key?(%{a: 1}, :a)\n    true\n    iex> Map.has_key?(%{a: 1}, :b)\n    false\n\n"}
{"completion":"","prompt":"Elixir.Map.keys(map): Returns all keys from `map`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.keys(%{a: 1, b: 2})\n    [:a, :b]\n\n"}
{"completion":"","prompt":"Elixir.Map.merge(map1, map2): Merges two maps into one.\n\nAll keys in `map2` will be added to `map1`, overriding any existing one\n(i.e., the keys in `map2` \"have precedence\" over the ones in `map1`).\n\nIf you have a struct and you would like to merge a set of keys into the\nstruct, do not use this function, as it would merge all keys on the right\nside into the struct, even if the key is not part of the struct. Instead,\nuse `struct/2`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4})\n    %{a: 3, b: 2, d: 4}\n\n"}
{"completion":"","prompt":"Elixir.Map.merge(map1, map2, fun): Merges two maps into one, resolving conflicts through the given `fun`.\n\nAll keys in `map2` will be added to `map1`. The given function will be invoked\nwhen there are duplicate keys; its arguments are `key` (the duplicate key),\n`value1` (the value of `key` in `map1`), and `value2` (the value of `key` in\n`map2`). The value returned by `fun` is used as the value under `key` in\nthe resulting map.\n\n## Examples\n\n    iex> Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4}, fn _k, v1, v2 ->\n    ...>   v1 + v2\n    ...> end)\n    %{a: 4, b: 2, d: 4}\n\n"}
{"completion":"","prompt":"Elixir.Map.new(): Returns a new empty map.\n\n## Examples\n\n    iex> Map.new()\n    %{}\n\n"}
{"completion":"","prompt":"Elixir.Map.new(enumerable): Creates a map from an `enumerable`.\n\nDuplicated keys are removed; the latest one prevails.\n\n## Examples\n\n    iex> Map.new([{:b, 1}, {:a, 2}])\n    %{a: 2, b: 1}\n    iex> Map.new(a: 1, a: 2, a: 3)\n    %{a: 3}\n\n"}
{"completion":"","prompt":"Elixir.Map.new(enumerable, transform): Creates a map from an `enumerable` via the given transformation function.\n\nDuplicated keys are removed; the latest one prevails.\n\n## Examples\n\n    iex> Map.new([:a, :b], fn x -> {x, x} end)\n    %{a: :a, b: :b}\n\n"}
{"completion":"","prompt":"Elixir.Map.pop(map, key, default \\\\ nil): Removes the value associated with `key` in `map` and returns the value and the updated map.\n\nIf `key` is present in `map`, it returns `{value, updated_map}` where `value` is the value of\nthe key and `updated_map` is the result of removing `key` from `map`. If `key`\nis not present in `map`, `{default, map}` is returned.\n\n## Examples\n\n    iex> Map.pop(%{a: 1}, :a)\n    {1, %{}}\n    iex> Map.pop(%{a: 1}, :b)\n    {nil, %{a: 1}}\n    iex> Map.pop(%{a: 1}, :b, 3)\n    {3, %{a: 1}}\n\n"}
{"completion":"","prompt":"Elixir.Map.pop!(map, key): Removes the value associated with `key` in `map` and returns the value\nand the updated map, or it raises if `key` is not present.\n\nBehaves the same as `pop/3` but raises if `key` is not present in `map`.\n\n## Examples\n\n    iex> Map.pop!(%{a: 1}, :a)\n    {1, %{}}\n    iex> Map.pop!(%{a: 1, b: 2}, :a)\n    {1, %{b: 2}}\n    iex> Map.pop!(%{a: 1}, :b)\n    ** (KeyError) key :b not found in: %{a: 1}\n\n"}
{"completion":"","prompt":"Elixir.Map.pop_lazy(map, key, fun): Lazily returns and removes the value associated with `key` in `map`.\n\nIf `key` is present in `map`, it returns `{value, new_map}` where `value` is the value of\nthe key and `new_map` is the result of removing `key` from `map`. If `key`\nis not present in `map`, `{fun_result, map}` is returned, where `fun_result`\nis the result of applying `fun`.\n\nThis is useful if the default value is very expensive to calculate or\ngenerally difficult to setup and teardown again.\n\n## Examples\n\n    iex> map = %{a: 1}\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   13\n    ...> end\n    iex> Map.pop_lazy(map, :a, fun)\n    {1, %{}}\n    iex> Map.pop_lazy(map, :b, fun)\n    {13, %{a: 1}}\n\n"}
{"completion":"","prompt":"Elixir.Map.put(map, key, value): Puts the given `value` under `key` in `map`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.put(%{a: 1}, :b, 2)\n    %{a: 1, b: 2}\n    iex> Map.put(%{a: 1, b: 2}, :a, 3)\n    %{a: 3, b: 2}\n\n"}
{"completion":"","prompt":"Elixir.Map.put_new(map, key, value): Puts the given `value` under `key` unless the entry `key`\nalready exists in `map`.\n\n## Examples\n\n    iex> Map.put_new(%{a: 1}, :b, 2)\n    %{a: 1, b: 2}\n    iex> Map.put_new(%{a: 1, b: 2}, :a, 3)\n    %{a: 1, b: 2}\n\n"}
{"completion":"","prompt":"Elixir.Map.put_new_lazy(map, key, fun): Evaluates `fun` and puts the result under `key`\nin `map` unless `key` is already present.\n\nThis function is useful in case you want to compute the value to put under\n`key` only if `key` is not already present, as for example, when the value is expensive to\ncalculate or generally difficult to setup and teardown again.\n\n## Examples\n\n    iex> map = %{a: 1}\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   3\n    ...> end\n    iex> Map.put_new_lazy(map, :a, fun)\n    %{a: 1}\n    iex> Map.put_new_lazy(map, :b, fun)\n    %{a: 1, b: 3}\n\n"}
{"completion":"","prompt":"Elixir.Map.reject(map, fun): Returns map excluding the pairs from `map` for which `fun` returns\na truthy value.\n\nSee also `filter/2`.\n\n## Examples\n\n    iex> Map.reject(%{one: 1, two: 2, three: 3}, fn {_key, val} -> rem(val, 2) == 1 end)\n    %{two: 2}\n\n"}
{"completion":"","prompt":"Elixir.Map.replace(map, key, value): Puts a value under `key` only if the `key` already exists in `map`.\n\n## Examples\n\n    iex> Map.replace(%{a: 1, b: 2}, :a, 3)\n    %{a: 3, b: 2}\n\n    iex> Map.replace(%{a: 1}, :b, 2)\n    %{a: 1}\n\n"}
{"completion":"","prompt":"Elixir.Map.replace!(map, key, value): Puts a value under `key` only if the `key` already exists in `map`.\n\nIf `key` is not present in `map`, a `KeyError` exception is raised.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.replace!(%{a: 1, b: 2}, :a, 3)\n    %{a: 3, b: 2}\n\n    iex> Map.replace!(%{a: 1}, :b, 2)\n    ** (KeyError) key :b not found in: %{a: 1}\n\n"}
{"completion":"","prompt":"Elixir.Map.replace_lazy(map, key, fun): Replaces the value under `key` using the given function only if\n`key` already exists in `map`.\n\nIn comparison to `replace/3`, this can be useful when it's expensive to calculate the value.\n\nIf `key` does not exist, the original map is returned unchanged.\n\n## Examples\n\n    iex> Map.replace_lazy(%{a: 1, b: 2}, :a, fn v -> v * 4 end)\n    %{a: 4, b: 2}\n\n    iex> Map.replace_lazy(%{a: 1, b: 2}, :c, fn v -> v * 4 end)\n    %{a: 1, b: 2}\n\n"}
{"completion":"","prompt":"Elixir.Map.split(map, keys): Takes all entries corresponding to the given `keys` in `map` and extracts\nthem into a separate map.\n\nReturns a tuple with the new map and the old map with removed keys.\n\nKeys for which there are no entries in `map` are ignored.\n\n## Examples\n\n    iex> Map.split(%{a: 1, b: 2, c: 3}, [:a, :c, :e])\n    {%{a: 1, c: 3}, %{b: 2}}\n\n"}
{"completion":"","prompt":"Elixir.Map.take(map, keys): Returns a new map with all the key-value pairs in `map` where the key\nis in `keys`.\n\nIf `keys` contains keys that are not in `map`, they're simply ignored.\n\n## Examples\n\n    iex> Map.take(%{a: 1, b: 2, c: 3}, [:a, :c, :e])\n    %{a: 1, c: 3}\n\n"}
{"completion":"","prompt":"Elixir.Map.to_list(map): Converts `map` to a list.\n\nEach key-value pair in the map is converted to a two-element tuple `{key,\nvalue}` in the resulting list.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.to_list(%{a: 1})\n    [a: 1]\n    iex> Map.to_list(%{1 => 2})\n    [{1, 2}]\n\n"}
{"completion":"","prompt":"Elixir.Map.update(map, key, default, fun): Updates the `key` in `map` with the given function.\n\nIf `key` is present in `map` then the existing value is passed to `fun` and its result is\nused as the updated value of `key`. If `key` is\nnot present in `map`, `default` is inserted as the value of `key`. The default\nvalue will not be passed through the update function.\n\n## Examples\n\n    iex> Map.update(%{a: 1}, :a, 13, fn existing_value -> existing_value * 2 end)\n    %{a: 2}\n    iex> Map.update(%{a: 1}, :b, 11, fn existing_value -> existing_value * 2 end)\n    %{a: 1, b: 11}\n\n"}
{"completion":"","prompt":"Elixir.Map.update!(map, key, fun): Updates `key` with the given function.\n\nIf `key` is present in `map` then the existing value is passed to `fun` and its result is\nused as the updated value of `key`. If `key` is\nnot present in `map`, a `KeyError` exception is raised.\n\n## Examples\n\n    iex> Map.update!(%{a: 1}, :a, &(&1 * 2))\n    %{a: 2}\n\n    iex> Map.update!(%{a: 1}, :b, &(&1 * 2))\n    ** (KeyError) key :b not found in: %{a: 1}\n\n"}
{"completion":"","prompt":"Elixir.Map.values(map): Returns all values from `map`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.values(%{a: 1, b: 2})\n    [1, 2]\n\n"}
{"completion":"","prompt":"Elixir.MapSet.delete(map_set, value): Deletes `value` from `map_set`.\n\nReturns a new set which is a copy of `map_set` but without `value`.\n\n## Examples\n\n    iex> map_set = MapSet.new([1, 2, 3])\n    iex> MapSet.delete(map_set, 4)\n    MapSet.new([1, 2, 3])\n    iex> MapSet.delete(map_set, 2)\n    MapSet.new([1, 3])\n\n"}
{"completion":"","prompt":"Elixir.MapSet.difference(map_set1, map_set2): Returns a set that is `map_set1` without the members of `map_set2`.\n\n## Examples\n\n    iex> MapSet.difference(MapSet.new([1, 2]), MapSet.new([2, 3, 4]))\n    MapSet.new([1])\n\n"}
{"completion":"","prompt":"Elixir.MapSet.disjoint?(map_set1, map_set2): Checks if `map_set1` and `map_set2` have no members in common.\n\n## Examples\n\n    iex> MapSet.disjoint?(MapSet.new([1, 2]), MapSet.new([3, 4]))\n    true\n    iex> MapSet.disjoint?(MapSet.new([1, 2]), MapSet.new([2, 3]))\n    false\n\n"}
{"completion":"","prompt":"Elixir.MapSet.equal?(map_set1, map_set2): Checks if two sets are equal.\n\nThe comparison between elements is done using `===/2`,\nwhich a set with `1` is not equivalent to a set with\n`1.0`.\n\n## Examples\n\n    iex> MapSet.equal?(MapSet.new([1, 2]), MapSet.new([2, 1, 1]))\n    true\n    iex> MapSet.equal?(MapSet.new([1, 2]), MapSet.new([3, 4]))\n    false\n    iex> MapSet.equal?(MapSet.new([1]), MapSet.new([1.0]))\n    false\n\n"}
{"completion":"","prompt":"Elixir.MapSet.filter(map_set, fun): Filters the set by returning only the elements from `set` for which invoking\n`fun` returns a truthy value.\n\nAlso see `reject/2` which discards all elements where the function returns\na truthy value.\n\n> Note: if you find yourself doing multiple calls to `MapSet.filter/2`\n> and `MapSet.reject/2` in a pipeline, it is likely more efficient\n> to use `Enum.map/2` and `Enum.filter/2` instead and convert to\n> a map at the end using `Map.new/1`.\n\n## Examples\n\n    iex> MapSet.filter(MapSet.new(1..5), fn x -> x > 3 end)\n    MapSet.new([4, 5])\n\n    iex> MapSet.filter(MapSet.new([\"a\", :b, \"c\"]), &is_atom/1)\n    MapSet.new([:b])\n\n"}
{"completion":"","prompt":"Elixir.MapSet.intersection(map_set, map_set): Returns a set containing only members that `map_set1` and `map_set2` have in common.\n\n## Examples\n\n    iex> MapSet.intersection(MapSet.new([1, 2]), MapSet.new([2, 3, 4]))\n    MapSet.new([2])\n\n    iex> MapSet.intersection(MapSet.new([1, 2]), MapSet.new([3, 4]))\n    MapSet.new([])\n\n"}
{"completion":"","prompt":"Elixir.MapSet.member?(map_set, value): Checks if `map_set` contains `value`.\n\n## Examples\n\n    iex> MapSet.member?(MapSet.new([1, 2, 3]), 2)\n    true\n    iex> MapSet.member?(MapSet.new([1, 2, 3]), 4)\n    false\n\n"}
{"completion":"","prompt":"Elixir.MapSet.new(): Returns a new set.\n\n## Examples\n\n    iex> MapSet.new()\n    MapSet.new([])\n\n"}
{"completion":"","prompt":"Elixir.MapSet.new(enumerable): Creates a set from an enumerable.\n\n## Examples\n\n    iex> MapSet.new([:b, :a, 3])\n    MapSet.new([3, :a, :b])\n    iex> MapSet.new([3, 3, 3, 2, 2, 1])\n    MapSet.new([1, 2, 3])\n\n"}
{"completion":"","prompt":"Elixir.MapSet.new(enumerable, transform): Creates a set from an enumerable via the transformation function.\n\n## Examples\n\n    iex> MapSet.new([1, 2, 1], fn x -> 2 * x end)\n    MapSet.new([2, 4])\n\n"}
{"completion":"","prompt":"Elixir.MapSet.put(map_set, value): Inserts `value` into `map_set` if `map_set` doesn't already contain it.\n\n## Examples\n\n    iex> MapSet.put(MapSet.new([1, 2, 3]), 3)\n    MapSet.new([1, 2, 3])\n    iex> MapSet.put(MapSet.new([1, 2, 3]), 4)\n    MapSet.new([1, 2, 3, 4])\n\n"}
{"completion":"","prompt":"Elixir.MapSet.reject(map_set, fun): Returns a set by excluding the elements from `set` for which invoking `fun`\nreturns a truthy value.\n\nSee also `filter/2`.\n\n## Examples\n\n    iex> MapSet.reject(MapSet.new(1..5), fn x -> rem(x, 2) != 0 end)\n    MapSet.new([2, 4])\n\n    iex> MapSet.reject(MapSet.new([\"a\", :b, \"c\"]), &is_atom/1)\n    MapSet.new([\"a\", \"c\"])\n\n"}
{"completion":"","prompt":"Elixir.MapSet.size(map_set): Returns the number of elements in `map_set`.\n\n## Examples\n\n    iex> MapSet.size(MapSet.new([1, 2, 3]))\n    3\n\n"}
{"completion":"","prompt":"Elixir.MapSet.subset?(map_set1, map_set2): Checks if `map_set1`'s members are all contained in `map_set2`.\n\nThis function checks if `map_set1` is a subset of `map_set2`.\n\n## Examples\n\n    iex> MapSet.subset?(MapSet.new([1, 2]), MapSet.new([1, 2, 3]))\n    true\n    iex> MapSet.subset?(MapSet.new([1, 2, 3]), MapSet.new([1, 2]))\n    false\n\n"}
{"completion":"","prompt":"Elixir.MapSet.symmetric_difference(map_set1, map_set2): Returns a set with elements that are present in only one but not both sets.\n\n## Examples\n\n    iex> MapSet.symmetric_difference(MapSet.new([1, 2, 3]), MapSet.new([2, 3, 4]))\n    MapSet.new([1, 4])\n"}
{"completion":"","prompt":"Elixir.MapSet.to_list(map_set): Converts `map_set` to a list.\n\n## Examples\n\n    iex> MapSet.to_list(MapSet.new([1, 2, 3]))\n    [1, 2, 3]\n\n"}
{"completion":"","prompt":"Elixir.MapSet.union(map_set1, map_set2): Returns a set containing all members of `map_set1` and `map_set2`.\n\n## Examples\n\n    iex> MapSet.union(MapSet.new([1, 2]), MapSet.new([2, 3, 4]))\n    MapSet.new([1, 2, 3, 4])\n\n"}
{"completion":"","prompt":"Elixir.Module.LocalsTracker.add_defaults(arg, kind, pair, defaults, meta): Adds and tracks defaults for a definition into the tracker.\n"}
{"completion":"","prompt":"Elixir.Module.LocalsTracker.add_import(arg, function, module, imported): Adds an import dispatch to the given target.\n"}
{"completion":"","prompt":"Elixir.Module.LocalsTracker.add_local(arg, from, to, meta, macro_dispatch?): Adds a local dispatch from-to the given target.\n"}
{"completion":"","prompt":"Elixir.Module.LocalsTracker.collect_imports_conflicts(arg, all_defined): Collect all conflicting imports with the given functions\n"}
{"completion":"","prompt":"Elixir.Module.LocalsTracker.collect_undefined_locals(arg, all_defined): Collect undefined functions based on local calls and existing definitions.\n"}
{"completion":"","prompt":"Elixir.Module.LocalsTracker.collect_unused_locals(arg, all_defined, private): Collect all unused definitions based on the private\ngiven, also accounting the expected number of default\nclauses a private function have.\n"}
{"completion":"","prompt":"Elixir.Module.LocalsTracker.reachable_from(arg, local): Returns all local nodes reachable from `vertex`.\n\nBy default, all public functions are reachable.\nA private function is only reachable if it has\na public function that it invokes directly.\n"}
{"completion":"","prompt":"Elixir.Module.LocalsTracker.reattach(arg, tuple, kind, function, out_neighbours, meta): Reattach a previously yanked node.\n"}
{"completion":"","prompt":"Elixir.Module.LocalsTracker.yank(arg, local): Yanks a local node. Returns its in and out vertices in a tuple.\n"}
{"completion":"","prompt":"Elixir.Module.ParallelChecker.all_exports(arg, module): Returns all exported functions and macros for the given module from\nthe cache.\n"}
{"completion":"","prompt":"Elixir.Module.ParallelChecker.fetch_export(arg, module, fun, arity): Returns the export kind and deprecation reason for the given MFA from\nthe cache. If the module does not exist return `{:error, :module}`,\nor if the function does not exist return `{:error, :function}`.\n"}
{"completion":"","prompt":"Elixir.Module.ParallelChecker.get(): Gets the parallel checker data from pdict.\n"}
{"completion":"","prompt":"Elixir.Module.ParallelChecker.preload_module(arg, module): Preloads a module into the cache. Call this function before any other\ncache lookups for the module.\n"}
{"completion":"","prompt":"Elixir.Module.ParallelChecker.put(pid, checker): Stores the parallel checker information.\n"}
{"completion":"","prompt":"Elixir.Module.ParallelChecker.spawn(arg, module, info): Spawns a process that runs the parallel checker.\n"}
{"completion":"","prompt":"Elixir.Module.ParallelChecker.start_link(schedulers \\\\ nil): Initializes the parallel checker process.\n"}
{"completion":"","prompt":"Elixir.Module.ParallelChecker.stop(checker): Stops the parallel checker process.\n"}
{"completion":"","prompt":"Elixir.Module.ParallelChecker.test_cache(): Test cache.\n"}
{"completion":"","prompt":"Elixir.Module.ParallelChecker.verify(fun): Verifies the given compilation function\nby starting a checker if one does not exist.\nSee `verify/3`.\n"}
{"completion":"","prompt":"Elixir.Module.ParallelChecker.verify(checker, runtime_files): Receives pairs of module maps and BEAM binaries. In parallel it verifies\nthe modules and adds the ExCk chunk to the binaries. Returns the updated\nlist of warnings from the verification.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Helpers.flat_map_ok(list, fun): Like `Enum.flat_map/2` but only continues while `fun` returns `{:ok, list}`\nand stops on `{:error, reason}`.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Helpers.flat_map_reduce_ok(list, acc, fun): Like `Enum.flat_map_reduce/3` but only continues while `fun` returns `{:ok, list, acc}`\nand stops on `{:error, reason}`.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Helpers.get_meta(arg1): Returns the AST metadata.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Helpers.guards_to_or(guards): Combines a list of guard expressions `when x when y when z` to an expression\ncombined with `or`, `x or y or z`.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Helpers.map_ok(list, fun): Like `Enum.map/2` but only continues while `fun` returns `{:ok, elem}`\nand stops on `{:error, reason}`.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Helpers.map_reduce_ok(list, acc, fun): Like `Enum.map_reduce/3` but only continues while `fun` returns `{:ok, elem, acc}`\nand stops on `{:error, reason}`.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Helpers.oks_or_errors(list): Given a list of `[{:ok, term()} | {:error, term()}]` it returns a list of\nerrors `{:error, [term()]}` in case of at least one error or `{:ok, [term()]}`\nif there are no errors.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Helpers.reduce_ok(list, acc, fun): Like `Enum.reduce/3` but only continues while `fun` returns `{:ok, acc}`\nand stops on `{:error, reason}`.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Helpers.unzip_ok(list): Like `Enum.unzip/1` but only continues while `fun` returns `{:ok, elem1, elem2}`\nand stops on `{:error, reason}`.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Helpers.var_name(arg): Returns unique identifier for the current assignment of the variable.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Helpers.zip_many(lists): Like `Enum.zip/1` but will zip multiple lists together instead of only two.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Of.binary(list, stack, context, of_fun): Handles binaries.\n\nIn the stack, we add nodes such as <<expr>>, <<..., expr>>, etc,\nbased on the position of the expression within the binary.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Of.closed_map(args, stack, context, of_fun): Handles closed maps (without dynamic => dynamic).\n"}
{"completion":"","prompt":"Elixir.Module.Types.Of.open_map(args, stack, context, of_fun): Handles open maps (with dynamic => dynamic).\n"}
{"completion":"","prompt":"Elixir.Module.Types.Of.remote(module, fun, arity, meta, context): Handles remote calls.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Of.struct(struct, meta, context): Handles structs.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Pattern.of_guard(expr, expected, stack, context): Refines the type variables in the typing context using type check guards\nsuch as `is_integer/1`.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Pattern.of_head(patterns, guards, stack, context): Handles patterns and guards at once.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Pattern.of_pattern(pattern, stack, context): Return the type and typing context of a pattern expression or an error\nin case of a typing conflict.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Unify.add_var(context): Adds an internal variable to the typing context and returns its type variable.\nAn internal variable is used to help unify complex expressions,\nit does not belong to a specific AST expression.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Unify.collect_var_indexes(type, context, acc \\\\ %{}): Collects all type vars recursively.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Unify.flatten_union(type, context): Expand unions so that all unions are at the top level.\n\n    {integer() | float()} => {integer()} | {float()}\n"}
{"completion":"","prompt":"Elixir.Module.Types.Unify.format_type(atom, simplify?): Formats types.\n\nThe second argument says when complex types such as maps and\nstructs should be simplified and not shown.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Unify.get_var!(var, context): Gets a variable.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Unify.has_unbound_var?(type, context): Checks if the type has a type var.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Unify.lift_types(types, context): Lifts type variables to their inferred types from the context.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Unify.new_var(var, context): Adds a variable to the typing context and returns its type variable.\nIf the variable has already been added, return the existing type variable.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Unify.push_expr_stack(expr, stack): Push expression to stack.\n\nThe expression stack is used to give the context where a type variable\nwas refined when show a type conflict error.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Unify.refine_var!(var, type, stack, context): Set the type for a variable and add trace.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Unify.remove_var(var, context): Remove type variable and all its traces.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Unify.resolve_var(other, context): Maybe resolves a variable.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Unify.restore_var!(var, new_context, old_context): Restores the variable information from the old context into new context.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Unify.singleton?(arg1, context): Returns true if it is a singleton type.\n\nOnly atoms are singleton types. Unbound vars are not\nconsidered singleton types.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Unify.subtype?(type, type, context): Checks if the first argument is a subtype of the second argument.\n\nThis function assumes that:\n\n  * unbound variables are not subtype of anything\n\n  * dynamic is not considered a subtype of all other types but the top type.\n    This allows this function can be used for ordering, in other cases, you\n    may need to check for both sides\n\n"}
{"completion":"","prompt":"Elixir.Module.Types.Unify.to_union(types, context): Returns a \"simplified\" union using `subtype?/3` to remove redundant types.\n\nDue to limitations in `subtype?/3` some overlapping types may still be\nincluded. For example unions with overlapping non-concrete types such as\n`{boolean()} | {atom()}` will not be merged or types with variables that\nare distinct but equivalent such as `a | b when a ~ b`.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Unify.unify(same, same, stack, context): Unifies two types and returns the unified type and an updated typing context\nor an error in case of a typing conflict.\n"}
{"completion":"","prompt":"Elixir.Module.Types.Unify.walk(type, acc, fun): Performs a depth-first, pre-order traversal of the type tree using an accumulator.\n"}
{"completion":"","prompt":"Elixir.Module.attributes_in(module): Returns all module attributes names defined in `module`.\n\nThis function can only be used on modules that have not yet been compiled.\n\n## Examples\n\n    defmodule Example do\n      @foo 1\n      Module.register_attribute(__MODULE__, :bar, accumulate: true)\n\n      :foo in Module.attributes_in(__MODULE__)\n      #=> true\n\n      :bar in Module.attributes_in(__MODULE__)\n      #=> true\n    end\n\n"}
{"completion":"","prompt":"Elixir.Module.concat(list): Concatenates a list of aliases and returns a new alias.\n\nIt handles binaries and atoms.\n\n## Examples\n\n    iex> Module.concat([Foo, Bar])\n    Foo.Bar\n\n    iex> Module.concat([Foo, \"Bar\"])\n    Foo.Bar\n\n"}
{"completion":"","prompt":"Elixir.Module.concat(left, right): Concatenates two aliases and returns a new alias.\n\nIt handles binaries and atoms.\n\n## Examples\n\n    iex> Module.concat(Foo, Bar)\n    Foo.Bar\n\n    iex> Module.concat(Foo, \"Bar\")\n    Foo.Bar\n\n"}
{"completion":"","prompt":"Elixir.Module.create(module, quoted, opts): Creates a module with the given name and defined by\nthe given quoted expressions.\n\nThe line where the module is defined and its file **must**\nbe passed as options.\n\nIt returns a tuple of shape `{:module, module, binary, term}`\nwhere `module` is the module name, `binary` is the module\nbytecode and `term` is the result of the last expression in\n`quoted`.\n\nSimilar to `Kernel.defmodule/2`, the binary will only be\nwritten to disk as a `.beam` file if `Module.create/3` is\ninvoked in a file that is currently being compiled.\n\n## Examples\n\n    contents =\n      quote do\n        def world, do: true\n      end\n\n    Module.create(Hello, contents, Macro.Env.location(__ENV__))\n\n    Hello.world()\n    #=> true\n\n## Differences from `defmodule`\n\n`Module.create/3` works similarly to `Kernel.defmodule/2`\nand return the same results. While one could also use\n`Kernel.defmodule/2` to define modules dynamically, this function\nis preferred when the module body is given by a quoted\nexpression.\n\nAnother important distinction is that `Module.create/3`\nallows you to control the environment variables used\nwhen defining the module, while `Kernel.defmodule/2`\nautomatically uses the environment it is invoked at.\n"}
{"completion":"","prompt":"Elixir.Module.defines?(module, tuple): Checks if the module defines the given function or macro.\n\nUse `defines?/3` to assert for a specific type.\n\nThis function can only be used on modules that have not yet been compiled.\nUse `Kernel.function_exported?/3` and `Kernel.macro_exported?/3` to check for\npublic functions and macros respectively in compiled modules.\n\nNote that `defines?` returns false for functions and macros that have\nbeen defined but then marked as overridable and no other implementation\nhas been provided. You can check the overridable status by calling\n`overridable?/2`.\n\n## Examples\n\n    defmodule Example do\n      Module.defines?(__MODULE__, {:version, 0}) #=> false\n      def version, do: 1\n      Module.defines?(__MODULE__, {:version, 0}) #=> true\n    end\n\n"}
{"completion":"","prompt":"Elixir.Module.defines?(module, tuple, def_kind): Checks if the module defines a function or macro of the\ngiven `kind`.\n\n`kind` can be any of `:def`, `:defp`, `:defmacro`, or `:defmacrop`.\n\nThis function can only be used on modules that have not yet been compiled.\nUse `Kernel.function_exported?/3` and `Kernel.macro_exported?/3` to check for\npublic functions and macros respectively in compiled modules.\n\n## Examples\n\n    defmodule Example do\n      Module.defines?(__MODULE__, {:version, 0}, :def) #=> false\n      def version, do: 1\n      Module.defines?(__MODULE__, {:version, 0}, :def) #=> true\n    end\n\n"}
{"completion":"","prompt":"Elixir.Module.defines_type?(module, definition): Checks if the current module defines the given type (private, opaque or not).\n\nThis function is only available for modules being compiled.\n"}
{"completion":"","prompt":"Elixir.Module.definitions_in(module): Returns all functions and macros defined in `module`.\n\nIt returns a list with all defined functions and macros, public and private,\nin the shape of `[{name, arity}, ...]`.\n\nThis function can only be used on modules that have not yet been compiled.\nUse the `c:Module.__info__/1` callback to get the public functions and macros in\ncompiled modules.\n\n## Examples\n\n    defmodule Example do\n      def version, do: 1\n      defmacrop test(arg), do: arg\n      Module.definitions_in(__MODULE__) #=> [{:version, 0}, {:test, 1}]\n    end\n\n"}
{"completion":"","prompt":"Elixir.Module.definitions_in(module, kind): Returns all functions defined in `module`, according\nto its kind.\n\nThis function can only be used on modules that have not yet been compiled.\nUse the `c:Module.__info__/1` callback to get the public functions and macros in\ncompiled modules.\n\n## Examples\n\n    defmodule Example do\n      def version, do: 1\n      Module.definitions_in(__MODULE__, :def)  #=> [{:version, 0}]\n      Module.definitions_in(__MODULE__, :defp) #=> []\n    end\n\n"}
{"completion":"","prompt":"Elixir.Module.delete_attribute(module, key): Deletes the entry (or entries) for the given module attribute.\n\nIt returns the deleted attribute value. If the attribute has not\nbeen set nor configured to accumulate, it returns `nil`.\n\nIf the attribute is set to accumulate, then this function always\nreturns a list. Deleting the attribute removes existing entries\nbut the attribute will still accumulate.\n\n## Examples\n\n    defmodule MyModule do\n      Module.put_attribute(__MODULE__, :custom_threshold_for_lib, 10)\n      Module.delete_attribute(__MODULE__, :custom_threshold_for_lib)\n    end\n\n"}
{"completion":"","prompt":"Elixir.Module.delete_definition(module, arg): Deletes a definition from a module.\n\nIt returns true if the definition exists and it was removed,\notherwise it returns false.\n"}
{"completion":"","prompt":"Elixir.Module.eval_quoted(module_or_env, quoted, binding \\\\ [], opts \\\\ []): Evaluates the quoted contents in the given module's context.\n\nA list of environment options can also be given as argument.\nSee `Code.eval_string/3` for more information.\n\nRaises an error if the module was already compiled.\n\n## Examples\n\n    defmodule Foo do\n      contents =\n        quote do\n          def sum(a, b), do: a + b\n        end\n\n      Module.eval_quoted(__MODULE__, contents)\n    end\n\n    Foo.sum(1, 2)\n    #=> 3\n\nFor convenience, you can pass any `Macro.Env` struct, such\nas  `__ENV__/0`, as the first argument or as options. Both\nthe module and all options will be automatically extracted\nfrom the environment:\n\n    defmodule Foo do\n      contents =\n        quote do\n          def sum(a, b), do: a + b\n        end\n\n      Module.eval_quoted(__ENV__, contents)\n    end\n\n    Foo.sum(1, 2)\n    #=> 3\n\nNote that if you pass a `Macro.Env` struct as first argument\nwhile also passing `opts`, they will be merged with `opts`\nhaving precedence.\n"}
{"completion":"","prompt":"Elixir.Module.get_attribute(module, key, default \\\\ nil): Gets the given attribute from a module.\n\nIf the attribute was marked with `accumulate` with\n`Module.register_attribute/3`, a list is always returned.\n`nil` is returned if the attribute has not been marked with\n`accumulate` and has not been set to any value.\n\nThe `@` macro compiles to a call to this function. For example,\nthe following code:\n\n    @foo\n\nExpands to something akin to:\n\n    Module.get_attribute(__MODULE__, :foo)\n\nThis function can only be used on modules that have not yet been compiled.\nUse the `c:Module.__info__/1` callback to get all persisted attributes, or\n`Code.fetch_docs/1` to retrieve all documentation related attributes in\ncompiled modules.\n\n## Examples\n\n    defmodule Foo do\n      Module.put_attribute(__MODULE__, :value, 1)\n      Module.get_attribute(__MODULE__, :value) #=> 1\n\n      Module.get_attribute(__MODULE__, :value, :default) #=> 1\n      Module.get_attribute(__MODULE__, :not_found, :default) #=> :default\n\n      Module.register_attribute(__MODULE__, :value, accumulate: true)\n      Module.put_attribute(__MODULE__, :value, 1)\n      Module.get_attribute(__MODULE__, :value) #=> [1]\n    end\n\n"}
{"completion":"","prompt":"Elixir.Module.get_definition(module, arg, options \\\\ []): Returns the definition for the given name-arity pair.\n\nIt returns a tuple with the `version`, the `kind`,\nthe definition `metadata`, and a list with each clause.\nEach clause is a four-element tuple with metadata,\nthe arguments, the guards, and the clause AST.\n\nThe clauses are returned in the Elixir AST but a subset\nthat has already been expanded and normalized. This makes\nit useful for analyzing code but it cannot be reinjected\ninto the module as it will have lost some of its original\ncontext. Given this AST representation is mostly internal,\nit is versioned and it may change at any time. Therefore,\n**use this API with caution**.\n\n## Options\n\n  * `:skip_clauses` (since v1.14.0) - returns `[]` instead\n    of returning the clauses. This is useful when there is\n    only an interest in fetching the kind and the metadata\n\n"}
{"completion":"","prompt":"Elixir.Module.has_attribute?(module, key): Checks if the given attribute has been defined.\n\nAn attribute is defined if it has been registered with `register_attribute/3`\nor assigned a value. If an attribute has been deleted with `delete_attribute/2`\nit is no longer considered defined.\n\nThis function can only be used on modules that have not yet been compiled.\n\n## Examples\n\n    defmodule MyModule do\n      @value 1\n      Module.register_attribute(__MODULE__, :other_value)\n      Module.put_attribute(__MODULE__, :another_value, 1)\n\n      Module.has_attribute?(__MODULE__, :value) #=> true\n      Module.has_attribute?(__MODULE__, :other_value) #=> true\n      Module.has_attribute?(__MODULE__, :another_value) #=> true\n\n      Module.has_attribute?(__MODULE__, :undefined) #=> false\n\n      Module.delete_attribute(__MODULE__, :value)\n      Module.has_attribute?(__MODULE__, :value) #=> false\n    end\n\n"}
{"completion":"","prompt":"Elixir.Module.make_overridable(module, tuples): Makes the given functions in `module` overridable.\n\nAn overridable function is lazily defined, allowing a\ndeveloper to customize it. See `Kernel.defoverridable/1` for\nmore information and documentation.\n\nOnce a function or a macro is marked as overridable, it will\nno longer be listed under `definitions_in/1` or return true\nwhen given to `defines?/2` until another implementation is\ngiven.\n"}
{"completion":"","prompt":"Elixir.Module.open?(module): Checks if a module is open.\n\nA module is \"open\" if it is currently being defined and its attributes and\nfunctions can be modified.\n"}
{"completion":"","prompt":"Elixir.Module.overridable?(module, tuple): Returns `true` if `tuple` in `module` was marked as overridable\nat some point.\n\nNote `overridable?/2` returns true even if the definition was\nalready overridden. You can use `defines?/2` to see if a definition\nexists or one is pending.\n"}
{"completion":"","prompt":"Elixir.Module.overridables_in(module): Returns all overridable definitions in `module`.\n\nNote a definition is included even if it was was already overridden.\nYou can use `defines?/2` to see if a definition exists or one is pending.\n\nThis function can only be used on modules that have not yet been compiled.\n\n## Examples\n\n    defmodule Example do\n      def foo, do: 1\n      def bar, do: 2\n\n      defoverridable foo: 0, bar: 0\n      def foo, do: 3\n\n      [bar: 0, foo: 0] = Module.overridables_in(__MODULE__) |> Enum.sort()\n    end\n\n"}
{"completion":"","prompt":"Elixir.Module.put_attribute(module, key, value): Puts a module attribute with `key` and `value` in the given `module`.\n\n## Examples\n\n    defmodule MyModule do\n      Module.put_attribute(__MODULE__, :custom_threshold_for_lib, 10)\n    end\n\n"}
{"completion":"","prompt":"Elixir.Module.register_attribute(module, attribute, options): Registers an attribute.\n\nBy registering an attribute, a developer is able to customize\nhow Elixir will store and accumulate the attribute values.\n\n## Options\n\nWhen registering an attribute, two options can be given:\n\n  * `:accumulate` - several calls to the same attribute will\n    accumulate instead of overriding the previous one. New attributes\n    are always added to the top of the accumulated list.\n\n  * `:persist` - the attribute will be persisted in the Erlang\n    Abstract Format. Useful when interfacing with Erlang libraries.\n\nBy default, both options are `false`. Once an attribute has been\nset to accumulate or persist, the behaviour cannot be reverted.\n\n## Examples\n\n    defmodule MyModule do\n      Module.register_attribute(__MODULE__, :custom_threshold_for_lib, accumulate: true)\n\n      @custom_threshold_for_lib 10\n      @custom_threshold_for_lib 20\n      @custom_threshold_for_lib #=> [20, 10]\n    end\n\n"}
{"completion":"","prompt":"Elixir.Module.reserved_attributes(): Returns information about module attributes used by Elixir.\n\nSee the \"Module attributes\" section in the module documentation for more\ninformation on each attribute.\n\n## Examples\n\n    iex> map = Module.reserved_attributes()\n    iex> Map.has_key?(map, :moduledoc)\n    true\n    iex> Map.has_key?(map, :doc)\n    true\n\n"}
{"completion":"","prompt":"Elixir.Module.safe_concat(list): Concatenates a list of aliases and returns a new alias only if the alias\nwas already referenced.\n\nIf the alias was not referenced yet, fails with `ArgumentError`.\nIt handles binaries and atoms.\n\n## Examples\n\n    iex> Module.safe_concat([List, Chars])\n    List.Chars\n\n"}
{"completion":"","prompt":"Elixir.Module.safe_concat(left, right): Concatenates two aliases and returns a new alias only if the alias was\nalready referenced.\n\nIf the alias was not referenced yet, fails with `ArgumentError`.\nIt handles binaries and atoms.\n\n## Examples\n\n    iex> Module.safe_concat(List, Chars)\n    List.Chars\n\n"}
{"completion":"","prompt":"Elixir.Module.spec_to_callback(module, definition): Copies the given spec as a callback.\n\nReturns `true` if there is such a spec and it was copied as a callback.\nIf the function associated to the spec has documentation defined prior to\ninvoking this function, the docs are copied too.\n"}
{"completion":"","prompt":"Elixir.Module.split(module): Splits the given module name into binary parts.\n\n`module` has to be an Elixir module, as `split/1` won't work with Erlang-style\nmodules (for example, `split(:lists)` raises an error).\n\n`split/1` also supports splitting the string representation of Elixir modules\n(that is, the result of calling `Atom.to_string/1` with the module name).\n\n## Examples\n\n    iex> Module.split(Very.Long.Module.Name.And.Even.Longer)\n    [\"Very\", \"Long\", \"Module\", \"Name\", \"And\", \"Even\", \"Longer\"]\n    iex> Module.split(\"Elixir.String.Chars\")\n    [\"String\", \"Chars\"]\n\n"}
{"completion":"","prompt":"Elixir.NaiveDateTime.add(naive_datetime, amount_to_add, unit \\\\ :second): Adds a specified amount of time to a `NaiveDateTime`.\n\nAccepts an `amount_to_add` in any `unit`. `unit` can be `:day`,\n`:hour`, `:minute`, `:second` or any subsecond precision from\n`t:System.time_unit/0`. It defaults to `:second`. Negative values\nwill move backwards in time.\n\nThis function always consider the unit to be computed according\nto the `Calendar.ISO`.\n\n## Examples\n\nIt uses seconds by default:\n\n    # adds seconds by default\n    iex> NaiveDateTime.add(~N[2014-10-02 00:29:10], 2)\n    ~N[2014-10-02 00:29:12]\n\n    # accepts negative offsets\n    iex> NaiveDateTime.add(~N[2014-10-02 00:29:10], -2)\n    ~N[2014-10-02 00:29:08]\n\nIt can also work with subsecond precisions:\n\n    iex> NaiveDateTime.add(~N[2014-10-02 00:29:10], 2_000, :millisecond)\n    ~N[2014-10-02 00:29:12.000]\n\nAs well as days/hours/minutes:\n\n    iex> NaiveDateTime.add(~N[2015-02-28 00:29:10], 2, :day)\n    ~N[2015-03-02 00:29:10]\n    iex> NaiveDateTime.add(~N[2015-02-28 00:29:10], 36, :hour)\n    ~N[2015-03-01 12:29:10]\n    iex> NaiveDateTime.add(~N[2015-02-28 00:29:10], 60, :minute)\n    ~N[2015-02-28 01:29:10]\n\nThis operation merges the precision of the naive date time with the given unit:\n\n    iex> result = NaiveDateTime.add(~N[2014-10-02 00:29:10], 21, :millisecond)\n    ~N[2014-10-02 00:29:10.021]\n    iex> result.microsecond\n    {21000, 3}\n\nOperations on top of gregorian seconds or the Unix epoch are optimized:\n\n    # from Gregorian seconds\n    iex> NaiveDateTime.add(~N[0000-01-01 00:00:00], 63_579_428_950)\n    ~N[2014-10-02 00:29:10]\n\nPassing a `DateTime` automatically converts it to `NaiveDateTime`,\ndiscarding the time zone information:\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> NaiveDateTime.add(dt, 21, :second)\n    ~N[2000-02-29 23:00:28]\n\n"}
{"completion":"","prompt":"Elixir.NaiveDateTime.compare(naive_datetime1, naive_datetime2): Compares two `NaiveDateTime` structs.\n\nReturns `:gt` if first is later than the second\nand `:lt` for vice versa. If the two NaiveDateTime\nare equal `:eq` is returned.\n\n## Examples\n\n    iex> NaiveDateTime.compare(~N[2016-04-16 13:30:15], ~N[2016-04-28 16:19:25])\n    :lt\n    iex> NaiveDateTime.compare(~N[2016-04-16 13:30:15.1], ~N[2016-04-16 13:30:15.01])\n    :gt\n\nThis function can also be used to compare a DateTime without\nthe time zone information:\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> NaiveDateTime.compare(dt, ~N[2000-02-29 23:00:07])\n    :eq\n    iex> NaiveDateTime.compare(dt, ~N[2000-01-29 23:00:07])\n    :gt\n    iex> NaiveDateTime.compare(dt, ~N[2000-03-29 23:00:07])\n    :lt\n\n"}
{"completion":"","prompt":"Elixir.NaiveDateTime.convert(naive_datetime, calendar): Converts the given `naive_datetime` from one calendar to another.\n\nIf it is not possible to convert unambiguously between the calendars\n(see `Calendar.compatible_calendars?/2`), an `{:error, :incompatible_calendars}` tuple\nis returned.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> NaiveDateTime.convert(~N[2000-01-01 13:30:15], Calendar.Holocene)\n    {:ok, %NaiveDateTime{calendar: Calendar.Holocene, year: 12000, month: 1, day: 1,\n                         hour: 13, minute: 30, second: 15, microsecond: {0, 0}}}\n\n"}
{"completion":"","prompt":"Elixir.NaiveDateTime.convert!(naive_datetime, calendar): Converts the given `naive_datetime` from one calendar to another.\n\nIf it is not possible to convert unambiguously between the calendars\n(see `Calendar.compatible_calendars?/2`), an ArgumentError is raised.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> NaiveDateTime.convert!(~N[2000-01-01 13:30:15], Calendar.Holocene)\n    %NaiveDateTime{calendar: Calendar.Holocene, year: 12000, month: 1, day: 1,\n                   hour: 13, minute: 30, second: 15, microsecond: {0, 0}}\n\n"}
{"completion":"","prompt":"Elixir.NaiveDateTime.diff(naive_datetime1, naive_datetime2, unit \\\\ :second): Subtracts `naive_datetime2` from `naive_datetime1`.\n\nThe answer can be returned in any `:day`, `:hour`, `:minute`, or any `unit`\navailable from `t:System.time_unit/0`. The unit is measured according to\n`Calendar.ISO` and defaults to `:second`.\n\nFractional results are not supported and are truncated.\n\n## Examples\n\n    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:12], ~N[2014-10-02 00:29:10])\n    2\n    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:12], ~N[2014-10-02 00:29:10], :microsecond)\n    2_000_000\n\n    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:10.042], ~N[2014-10-02 00:29:10.021])\n    0\n    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:10.042], ~N[2014-10-02 00:29:10.021], :millisecond)\n    21\n\n    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:10], ~N[2014-10-02 00:29:12])\n    -2\n    iex> NaiveDateTime.diff(~N[-0001-10-02 00:29:10], ~N[-0001-10-02 00:29:12])\n    -2\n\nIt can also compute the difference in days, hours, or minutes:\n\n    iex> NaiveDateTime.diff(~N[2014-10-10 00:29:10], ~N[2014-10-02 00:29:10], :day)\n    8\n    iex> NaiveDateTime.diff(~N[2014-10-02 12:29:10], ~N[2014-10-02 00:29:10], :hour)\n    12\n    iex> NaiveDateTime.diff(~N[2014-10-02 00:39:10], ~N[2014-10-02 00:29:10], :minute)\n    10\n\nBut it also rounds incomplete days to zero:\n\n    iex> NaiveDateTime.diff(~N[2014-10-10 00:29:09], ~N[2014-10-02 00:29:10], :day)\n    7\n\n"}
{"completion":"","prompt":"Elixir.NaiveDateTime.from_erl(tuple, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO): Converts an Erlang datetime tuple to a `NaiveDateTime` struct.\n\nAttempting to convert an invalid ISO calendar date will produce an error tuple.\n\n## Examples\n\n    iex> NaiveDateTime.from_erl({{2000, 1, 1}, {13, 30, 15}})\n    {:ok, ~N[2000-01-01 13:30:15]}\n    iex> NaiveDateTime.from_erl({{2000, 1, 1}, {13, 30, 15}}, {5000, 3})\n    {:ok, ~N[2000-01-01 13:30:15.005]}\n    iex> NaiveDateTime.from_erl({{2000, 13, 1}, {13, 30, 15}})\n    {:error, :invalid_date}\n    iex> NaiveDateTime.from_erl({{2000, 13, 1}, {13, 30, 15}})\n    {:error, :invalid_date}\n\n"}
{"completion":"","prompt":"Elixir.NaiveDateTime.from_erl!(tuple, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO): Converts an Erlang datetime tuple to a `NaiveDateTime` struct.\n\nRaises if the datetime is invalid.\nAttempting to convert an invalid ISO calendar date will produce an error tuple.\n\n## Examples\n\n    iex> NaiveDateTime.from_erl!({{2000, 1, 1}, {13, 30, 15}})\n    ~N[2000-01-01 13:30:15]\n    iex> NaiveDateTime.from_erl!({{2000, 1, 1}, {13, 30, 15}}, {5000, 3})\n    ~N[2000-01-01 13:30:15.005]\n    iex> NaiveDateTime.from_erl!({{2000, 13, 1}, {13, 30, 15}})\n    ** (ArgumentError) cannot convert {{2000, 13, 1}, {13, 30, 15}} to naive datetime, reason: :invalid_date\n\n"}
{"completion":"","prompt":"Elixir.NaiveDateTime.from_gregorian_seconds(seconds, arg \\\\ {0, 0}, calendar \\\\ Calendar.ISO): Converts a number of gregorian seconds to a `NaiveDateTime` struct.\n\n## Examples\n\n    iex> NaiveDateTime.from_gregorian_seconds(1)\n    ~N[0000-01-01 00:00:01]\n    iex> NaiveDateTime.from_gregorian_seconds(63_755_511_991, {5000, 3})\n    ~N[2020-05-01 00:26:31.005]\n    iex> NaiveDateTime.from_gregorian_seconds(-1)\n    ~N[-0001-12-31 23:59:59]\n\n"}
{"completion":"","prompt":"Elixir.NaiveDateTime.from_iso8601(string, calendar \\\\ Calendar.ISO): Parses the extended \"Date and time of day\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nTime zone offset may be included in the string but they will be\nsimply discarded as such information is not included in naive date\ntimes.\n\nAs specified in the standard, the separator \"T\" may be omitted if\ndesired as there is no ambiguity within this function.\n\nNote leap seconds are not supported by the built-in Calendar.ISO.\n\n## Examples\n\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07\")\n    {:ok, ~N[2015-01-23 23:50:07]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07\")\n    {:ok, ~N[2015-01-23 23:50:07]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07Z\")\n    {:ok, ~N[2015-01-23 23:50:07]}\n\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07.0\")\n    {:ok, ~N[2015-01-23 23:50:07.0]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07,0123456\")\n    {:ok, ~N[2015-01-23 23:50:07.012345]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07.0123456\")\n    {:ok, ~N[2015-01-23 23:50:07.012345]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123Z\")\n    {:ok, ~N[2015-01-23 23:50:07.123]}\n\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23P23:50:07\")\n    {:error, :invalid_format}\n    iex> NaiveDateTime.from_iso8601(\"2015:01:23 23-50-07\")\n    {:error, :invalid_format}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07A\")\n    {:error, :invalid_format}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:61\")\n    {:error, :invalid_time}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-32 23:50:07\")\n    {:error, :invalid_date}\n\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123+02:30\")\n    {:ok, ~N[2015-01-23 23:50:07.123]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123+00:00\")\n    {:ok, ~N[2015-01-23 23:50:07.123]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-02:30\")\n    {:ok, ~N[2015-01-23 23:50:07.123]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-00:00\")\n    {:error, :invalid_format}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-00:60\")\n    {:error, :invalid_format}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-24:00\")\n    {:error, :invalid_format}\n\n"}
{"completion":"","prompt":"Elixir.NaiveDateTime.from_iso8601!(string, calendar \\\\ Calendar.ISO): Parses the extended \"Date and time of day\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nRaises if the format is invalid.\n\n## Examples\n\n    iex> NaiveDateTime.from_iso8601!(\"2015-01-23T23:50:07.123Z\")\n    ~N[2015-01-23 23:50:07.123]\n    iex> NaiveDateTime.from_iso8601!(\"2015-01-23T23:50:07,123Z\")\n    ~N[2015-01-23 23:50:07.123]\n    iex> NaiveDateTime.from_iso8601!(\"2015-01-23P23:50:07\")\n    ** (ArgumentError) cannot parse \"2015-01-23P23:50:07\" as naive datetime, reason: :invalid_format\n\n"}
{"completion":"","prompt":"Elixir.NaiveDateTime.local_now(calendar \\\\ Calendar.ISO): Returns the \"local time\" for the machine the Elixir program is running on.\n\nWARNING: This function can cause insidious bugs. It depends on the time zone\nconfiguration at run time. This can changed and be set to a time zone that has\ndaylight saving jumps (spring forward or fall back).\n\nThis function can be used to display what the time is right now for the time\nzone configuration that the machine happens to have. An example would be a\ndesktop program displaying a clock to the user. For any other uses it is\nprobably a bad idea to use this function.\n\nFor most cases, use `DateTime.now/2` or `DateTime.utc_now/1` instead.\n\nDoes not include fractional seconds.\n\n## Examples\n\n    iex> naive_datetime = NaiveDateTime.local_now()\n    iex> naive_datetime.year >= 2019\n    true\n\n"}
{"completion":"","prompt":"Elixir.NaiveDateTime.new(date, time): Builds a naive datetime from date and time structs.\n\n## Examples\n\n    iex> NaiveDateTime.new(~D[2010-01-13], ~T[23:00:07.005])\n    {:ok, ~N[2010-01-13 23:00:07.005]}\n\n"}
{"completion":"","prompt":"Elixir.NaiveDateTime.new(year, month, day, hour, minute, second, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO): Builds a new ISO naive datetime.\n\nExpects all values to be integers. Returns `{:ok, naive_datetime}`\nif each entry fits its appropriate range, returns `{:error, reason}`\notherwise.\n\n## Examples\n\n    iex> NaiveDateTime.new(2000, 1, 1, 0, 0, 0)\n    {:ok, ~N[2000-01-01 00:00:00]}\n    iex> NaiveDateTime.new(2000, 13, 1, 0, 0, 0)\n    {:error, :invalid_date}\n    iex> NaiveDateTime.new(2000, 2, 29, 0, 0, 0)\n    {:ok, ~N[2000-02-29 00:00:00]}\n    iex> NaiveDateTime.new(2000, 2, 30, 0, 0, 0)\n    {:error, :invalid_date}\n    iex> NaiveDateTime.new(2001, 2, 29, 0, 0, 0)\n    {:error, :invalid_date}\n\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 59, {0, 1})\n    {:ok, ~N[2000-01-01 23:59:59.0]}\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 59, 999_999)\n    {:ok, ~N[2000-01-01 23:59:59.999999]}\n    iex> NaiveDateTime.new(2000, 1, 1, 24, 59, 59, 999_999)\n    {:error, :invalid_time}\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 60, 59, 999_999)\n    {:error, :invalid_time}\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 60, 999_999)\n    {:error, :invalid_time}\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 59, 1_000_000)\n    {:error, :invalid_time}\n\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 59, {0, 1}, Calendar.ISO)\n    {:ok, ~N[2000-01-01 23:59:59.0]}\n\n"}
{"completion":"","prompt":"Elixir.NaiveDateTime.new!(date, time): Builds a naive datetime from date and time structs.\n\n## Examples\n\n    iex> NaiveDateTime.new!(~D[2010-01-13], ~T[23:00:07.005])\n    ~N[2010-01-13 23:00:07.005]\n\n"}
{"completion":"","prompt":"Elixir.NaiveDateTime.new!(year, month, day, hour, minute, second, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO): Builds a new ISO naive datetime.\n\nExpects all values to be integers. Returns `naive_datetime`\nif each entry fits its appropriate range, raises if\ntime or date is invalid.\n\n## Examples\n\n    iex> NaiveDateTime.new!(2000, 1, 1, 0, 0, 0)\n    ~N[2000-01-01 00:00:00]\n    iex> NaiveDateTime.new!(2000, 2, 29, 0, 0, 0)\n    ~N[2000-02-29 00:00:00]\n    iex> NaiveDateTime.new!(2000, 1, 1, 23, 59, 59, {0, 1})\n    ~N[2000-01-01 23:59:59.0]\n    iex> NaiveDateTime.new!(2000, 1, 1, 23, 59, 59, 999_999)\n    ~N[2000-01-01 23:59:59.999999]\n    iex> NaiveDateTime.new!(2000, 1, 1, 23, 59, 59, {0, 1}, Calendar.ISO)\n    ~N[2000-01-01 23:59:59.0]\n    iex> NaiveDateTime.new!(2000, 1, 1, 24, 59, 59, 999_999)\n    ** (ArgumentError) cannot build naive datetime, reason: :invalid_time\n\n"}
{"completion":"","prompt":"Elixir.NaiveDateTime.to_date(map): Converts a `NaiveDateTime` into a `Date`.\n\nBecause `Date` does not hold time information,\ndata will be lost during the conversion.\n\n## Examples\n\n    iex> NaiveDateTime.to_date(~N[2002-01-13 23:00:07])\n    ~D[2002-01-13]\n\n"}
{"completion":"","prompt":"Elixir.NaiveDateTime.to_erl(naive_datetime): Converts a `NaiveDateTime` struct to an Erlang datetime tuple.\n\nOnly supports converting naive datetimes which are in the ISO calendar,\nattempting to convert naive datetimes from other calendars will raise.\n\nWARNING: Loss of precision may occur, as Erlang time tuples only store\nhour/minute/second.\n\n## Examples\n\n    iex> NaiveDateTime.to_erl(~N[2000-01-01 13:30:15])\n    {{2000, 1, 1}, {13, 30, 15}}\n\nThis function can also be used to convert a DateTime to an Erlang\ndatetime tuple without the time zone information:\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> NaiveDateTime.to_erl(dt)\n    {{2000, 2, 29}, {23, 00, 07}}\n\n"}
{"completion":"","prompt":"Elixir.NaiveDateTime.to_gregorian_seconds(map): Converts a `NaiveDateTime` struct to a number of gregorian seconds and microseconds.\n\n## Examples\n\n    iex> NaiveDateTime.to_gregorian_seconds(~N[0000-01-01 00:00:01])\n    {1, 0}\n    iex> NaiveDateTime.to_gregorian_seconds(~N[2020-05-01 00:26:31.005])\n    {63_755_511_991, 5000}\n\n"}
{"completion":"","prompt":"Elixir.NaiveDateTime.to_iso8601(naive_datetime, format \\\\ :extended): Converts the given naive datetime to\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nBy default, `NaiveDateTime.to_iso8601/2` returns naive datetimes formatted in the \"extended\"\nformat, for human readability. It also supports the \"basic\" format through passing the `:basic` option.\n\nOnly supports converting naive datetimes which are in the ISO calendar,\nattempting to convert naive datetimes from other calendars will raise.\n\n### Examples\n\n    iex> NaiveDateTime.to_iso8601(~N[2000-02-28 23:00:13])\n    \"2000-02-28T23:00:13\"\n\n    iex> NaiveDateTime.to_iso8601(~N[2000-02-28 23:00:13.001])\n    \"2000-02-28T23:00:13.001\"\n\n    iex> NaiveDateTime.to_iso8601(~N[2000-02-28 23:00:13.001], :basic)\n    \"20000228T230013.001\"\n\nThis function can also be used to convert a DateTime to ISO 8601 without\nthe time zone information:\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> NaiveDateTime.to_iso8601(dt)\n    \"2000-02-29T23:00:07\"\n\n"}
{"completion":"","prompt":"Elixir.NaiveDateTime.to_string(naive_datetime): Converts the given naive datetime to a string according to its calendar.\n\n### Examples\n\n    iex> NaiveDateTime.to_string(~N[2000-02-28 23:00:13])\n    \"2000-02-28 23:00:13\"\n    iex> NaiveDateTime.to_string(~N[2000-02-28 23:00:13.001])\n    \"2000-02-28 23:00:13.001\"\n    iex> NaiveDateTime.to_string(~N[-0100-12-15 03:20:31])\n    \"-0100-12-15 03:20:31\"\n\nThis function can also be used to convert a DateTime to a string without\nthe time zone information:\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> NaiveDateTime.to_string(dt)\n    \"2000-02-29 23:00:07\"\n\n"}
{"completion":"","prompt":"Elixir.NaiveDateTime.to_time(map): Converts a `NaiveDateTime` into `Time`.\n\nBecause `Time` does not hold date information,\ndata will be lost during the conversion.\n\n## Examples\n\n    iex> NaiveDateTime.to_time(~N[2002-01-13 23:00:07])\n    ~T[23:00:07]\n\n"}
{"completion":"","prompt":"Elixir.NaiveDateTime.truncate(naive_datetime, precision): Returns the given naive datetime with the microsecond field truncated to the\ngiven precision (`:microsecond`, `:millisecond` or `:second`).\n\nThe given naive datetime is returned unchanged if it already has lower precision\nthan the given precision.\n\n## Examples\n\n    iex> NaiveDateTime.truncate(~N[2017-11-06 00:23:51.123456], :microsecond)\n    ~N[2017-11-06 00:23:51.123456]\n\n    iex> NaiveDateTime.truncate(~N[2017-11-06 00:23:51.123456], :millisecond)\n    ~N[2017-11-06 00:23:51.123]\n\n    iex> NaiveDateTime.truncate(~N[2017-11-06 00:23:51.123456], :second)\n    ~N[2017-11-06 00:23:51]\n\n"}
{"completion":"","prompt":"Elixir.NaiveDateTime.utc_now(calendar \\\\ Calendar.ISO): Returns the current naive datetime in UTC.\n\nPrefer using `DateTime.utc_now/0` when possible as, opposite\nto `NaiveDateTime`, it will keep the time zone information.\n\n## Examples\n\n    iex> naive_datetime = NaiveDateTime.utc_now()\n    iex> naive_datetime.year >= 2016\n    true\n\n"}
{"completion":"","prompt":"Elixir.Node.alive?(): Returns `true` if the local node is alive.\n\nThat is, if the node can be part of a distributed system.\n"}
{"completion":"","prompt":"Elixir.Node.connect(node): Establishes a connection to `node`.\n\nReturns `true` if successful, `false` if not, and the atom\n`:ignored` if the local node is not alive.\n\nFor more information, see `:net_kernel.connect_node/1`.\n"}
{"completion":"","prompt":"Elixir.Node.disconnect(node): Forces the disconnection of a node.\n\nThis will appear to the `node` as if the local node has crashed.\nThis function is mainly used in the Erlang network authentication\nprotocols. Returns `true` if disconnection succeeds, otherwise `false`.\nIf the local node is not alive, the function returns `:ignored`.\n\nFor more information, see `:erlang.disconnect_node/1`.\n"}
{"completion":"","prompt":"Elixir.Node.get_cookie(): Returns the magic cookie of the local node.\n\nReturns the cookie if the node is alive, otherwise `:nocookie`.\n"}
{"completion":"","prompt":"Elixir.Node.list(): Returns a list of all visible nodes in the system, excluding\nthe local node.\n\nSame as `list(:visible)`.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Node.list(args): Returns a list of nodes according to argument given.\n\nThe result returned when the argument is a list, is the list of nodes\nsatisfying the disjunction(s) of the list elements.\n\nFor more information, see `:erlang.nodes/1`.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Node.monitor(node, flag): Monitors the status of the node.\n\nIf `flag` is `true`, monitoring is turned on.\nIf `flag` is `false`, monitoring is turned off.\n\nFor more information, see `:erlang.monitor_node/2`.\n\nFor monitoring status changes of all nodes, see `:net_kernel.monitor_nodes/2`.\n"}
{"completion":"","prompt":"Elixir.Node.monitor(node, flag, options): Behaves as `monitor/2` except that it allows an extra\noption to be given, namely `:allow_passive_connect`.\n\nFor more information, see `:erlang.monitor_node/3`.\n\nFor monitoring status changes of all nodes, see `:net_kernel.monitor_nodes/2`.\n"}
{"completion":"","prompt":"Elixir.Node.ping(node): Tries to set up a connection to node.\n\nReturns `:pang` if it fails, or `:pong` if it is successful.\n\n## Examples\n\n    iex> Node.ping(:unknown_node)\n    :pang\n\n"}
{"completion":"","prompt":"Elixir.Node.self(): Returns the current node.\n\nIt returns the same as the built-in `node()`.\n"}
{"completion":"","prompt":"Elixir.Node.set_cookie(node \\\\ Node.self(), cookie): Sets the magic cookie of `node` to the atom `cookie`.\n\nThe default node is `Node.self/0`, the local node. If `node` is the local node,\nthe function also sets the cookie of all other unknown nodes to `cookie`.\n\nThis function will raise `FunctionClauseError` if the given `node` is not alive.\n"}
{"completion":"","prompt":"Elixir.Node.spawn(node, fun): Returns the PID of a new process started by the application of `fun`\non `node`. If `node` does not exist, a useless PID is returned.\n\nFor the list of available options, see `:erlang.spawn/2`.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Node.spawn(node, fun, opts): Returns the PID of a new process started by the application of `fun`\non `node`.\n\nIf `node` does not exist, a useless PID is returned.\n\nFor the list of available options, see `:erlang.spawn_opt/3`.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Node.spawn(node, module, fun, args): Returns the PID of a new process started by the application of\n`module.function(args)` on `node`.\n\nIf `node` does not exist, a useless PID is returned.\n\nFor the list of available options, see `:erlang.spawn/4`.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Node.spawn(node, module, fun, args, opts): Returns the PID of a new process started by the application of\n`module.function(args)` on `node`.\n\nIf `node` does not exist, a useless PID is returned.\n\nFor the list of available options, see `:erlang.spawn/4`.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Node.spawn_link(node, fun): Returns the PID of a new linked process started by the application of `fun` on `node`.\n\nA link is created between the calling process and the new process, atomically.\nIf `node` does not exist, a useless PID is returned (and due to the link, an exit\nsignal with exit reason `:noconnection` will be received).\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Node.spawn_link(node, module, fun, args): Returns the PID of a new linked process started by the application of\n`module.function(args)` on `node`.\n\nA link is created between the calling process and the new process, atomically.\nIf `node` does not exist, a useless PID is returned (and due to the link, an exit\nsignal with exit reason `:noconnection` will be received).\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Node.spawn_monitor(node, fun): Spawns the given function on a node, monitors it and returns its PID\nand monitoring reference.\n\nThis functionality was added on Erlang/OTP 23. Using this function to\ncommunicate with nodes running on earlier versions will fail.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Node.spawn_monitor(node, module, fun, args): Spawns the given module and function passing the given args on a node,\nmonitors it and returns its PID and monitoring reference.\n\nThis functionality was added on Erlang/OTP 23. Using this function\nto communicate with nodes running on earlier versions will fail.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Node.start(name, type \\\\ :longnames, tick_time \\\\ 15000): Turns a non-distributed node into a distributed node.\n\nThis functionality starts the `:net_kernel` and other related\nprocesses.\n\nThis function is rarely invoked in practice. Instead, nodes are\nnamed and started via the command line by using the `--sname` and\n`--name` flags. If you need to use this function to dynamically\nname a node, please make sure the `epmd` operating system process\nis running by calling `epmd -daemon`.\n\nInvoking this function when the distribution has already been started,\neither via the command line interface or dynamically, will return an\nerror.\n\n## Examples\n\n    {:ok, pid} = Node.start(:example, :shortnames, 15000)\n\n"}
{"completion":"","prompt":"Elixir.Node.stop(): Turns a distributed node into a non-distributed node.\n\nFor other nodes in the network, this is the same as the node going down.\nOnly possible when the node was started with `Node.start/3`, otherwise\nreturns `{:error, :not_allowed}`. Returns `{:error, :not_found}` if the\nlocal node is not alive.\n"}
{"completion":"","prompt":"Elixir.OptionParser.next(argv, opts \\\\ []): Low-level function that parses one option.\n\nIt accepts the same options as `parse/2` and `parse_head/2`\nas both functions are built on top of this function. This function\nmay return:\n\n  * `{:ok, key, value, rest}` - the option `key` with `value` was\n    successfully parsed\n\n  * `{:invalid, key, value, rest}` - the option `key` is invalid with `value`\n    (returned when the value cannot be parsed according to the switch type)\n\n  * `{:undefined, key, value, rest}` - the option `key` is undefined\n    (returned in strict mode when the switch is unknown or on nonexistent atoms)\n\n  * `{:error, rest}` - there are no switches at the head of the given `argv`\n\n"}
{"completion":"","prompt":"Elixir.OptionParser.parse(argv, opts \\\\ []): Parses `argv` into a keyword list.\n\nIt returns a three-element tuple with the form `{parsed, args, invalid}`, where:\n\n  * `parsed` is a keyword list of parsed switches with `{switch_name, value}`\n    tuples in it; `switch_name` is the atom representing the switch name while\n    `value` is the value for that switch parsed according to `opts` (see the\n    \"Examples\" section for more information)\n  * `args` is a list of the remaining arguments in `argv` as strings\n  * `invalid` is a list of invalid options as `{option_name, value}` where\n    `option_name` is the raw option and `value` is `nil` if the option wasn't\n    expected or the string value if the value didn't have the expected type for\n    the corresponding option\n\nElixir converts switches to underscored atoms, so `--source-path` becomes\n`:source_path`. This is done to better suit Elixir conventions. However, this\nmeans that switches can't contain underscores and switches that do contain\nunderscores are always returned in the list of invalid switches.\n\nWhen parsing, it is common to list switches and their expected types:\n\n    iex> OptionParser.parse([\"--debug\"], strict: [debug: :boolean])\n    {[debug: true], [], []}\n\n    iex> OptionParser.parse([\"--source\", \"lib\"], strict: [source: :string])\n    {[source: \"lib\"], [], []}\n\n    iex> OptionParser.parse(\n    ...>   [\"--source-path\", \"lib\", \"test/enum_test.exs\", \"--verbose\"],\n    ...>   strict: [source_path: :string, verbose: :boolean]\n    ...> )\n    {[source_path: \"lib\", verbose: true], [\"test/enum_test.exs\"], []}\n\nWe will explore the valid switches and operation modes of option parser below.\n\n## Options\n\nThe following options are supported:\n\n  * `:switches` or `:strict` - see the \"Switch definitions\" section below\n  * `:allow_nonexistent_atoms` - see the \"Parsing unknown switches\" section below\n  * `:aliases` - see the \"Aliases\" section below\n\n## Switch definitions\n\nSwitches can be specified via one of two options:\n\n  * `:strict` - defines strict switches and their types. Any switch\n    in `argv` that is not specified in the list is returned in the\n    invalid options list. This is the preferred way to parse options.\n\n  * `:switches` - defines switches and their types. This function\n    still attempts to parse switches that are not in this list.\n\nBoth these options accept a keyword list where the key is an atom\ndefining the name of the switch and value is the `type` of the\nswitch (see the \"Types\" section below for more information).\n\nNote that you should only supply the `:switches` or the `:strict` option.\nIf you supply both, an `ArgumentError` exception will be raised.\n\n### Types\n\nSwitches parsed by `OptionParser` may take zero or one arguments.\n\nThe following switches types take no arguments:\n\n  * `:boolean` - sets the value to `true` when given (see also the\n    \"Negation switches\" section below)\n  * `:count` - counts the number of times the switch is given\n\nThe following switches take one argument:\n\n  * `:integer` - parses the value as an integer\n  * `:float` - parses the value as a float\n  * `:string` - parses the value as a string\n\nIf a switch can't be parsed according to the given type, it is\nreturned in the invalid options list.\n\n### Modifiers\n\nSwitches can be specified with modifiers, which change how\nthey behave. The following modifiers are supported:\n\n  * `:keep` - keeps duplicated elements instead of overriding them;\n    works with all types except `:count`. Specifying `switch_name: :keep`\n    assumes the type of `:switch_name` will be `:string`.\n\nTo use `:keep` with a type other than `:string`, use a list as the type\nfor the switch. For example: `[foo: [:integer, :keep]]`.\n\n### Negation switches\n\nIn case a switch `SWITCH` is specified to have type `:boolean`, it may be\npassed as `--no-SWITCH` as well which will set the option to `false`:\n\n    iex> OptionParser.parse([\"--no-op\", \"path/to/file\"], switches: [op: :boolean])\n    {[op: false], [\"path/to/file\"], []}\n\n### Parsing unknown switches\n\nWhen the `:switches` option is given, `OptionParser` will attempt to parse\nunknown switches:\n\n    iex> OptionParser.parse([\"--debug\"], switches: [key: :string])\n    {[debug: true], [], []}\n\nEven though we haven't specified `--debug` in the list of switches, it is part\nof the returned options. This would also work:\n\n    iex> OptionParser.parse([\"--debug\", \"value\"], switches: [key: :string])\n    {[debug: \"value\"], [], []}\n\nSwitches followed by a value will be assigned the value, as a string. Switches\nwithout an argument will be set automatically to `true`. Since we cannot assert\nthe type of the switch value, it is preferred to use the `:strict` option that\naccepts only known switches and always verify their types.\n\nIf you do want to parse unknown switches, remember that Elixir converts switches\nto atoms. Since atoms are not garbage-collected, OptionParser will only parse\nswitches that translate to atoms used by the runtime to avoid leaking atoms.\nFor instance, the code below will discard the `--option-parser-example` switch\nbecause the `:option_parser_example` atom is never used anywhere:\n\n    OptionParser.parse([\"--option-parser-example\"], switches: [debug: :boolean])\n    # The :option_parser_example atom is not used anywhere below\n\nHowever, the code below would work as long as `:option_parser_example` atom is\nused at some point later (or earlier) **in the same module**. For example:\n\n    {opts, _, _} = OptionParser.parse([\"--option-parser-example\"], switches: [debug: :boolean])\n    # ... then somewhere in the same module you access it ...\n    opts[:option_parser_example]\n\nIn other words, Elixir will only parse options that are used by the runtime,\nignoring all others. If you would like to parse all switches, regardless if\nthey exist or not, you can force creation of atoms by passing\n`allow_nonexistent_atoms: true` as option. Use this option with care. It is\nonly useful when you are building command-line applications that receive\ndynamically-named arguments and must be avoided in long-running systems.\n\n## Aliases\n\nA set of aliases can be specified in the `:aliases` option:\n\n    iex> OptionParser.parse([\"-d\"], aliases: [d: :debug], strict: [debug: :boolean])\n    {[debug: true], [], []}\n\n## Examples\n\nHere are some examples of working with different types and modifiers:\n\n    iex> OptionParser.parse([\"--unlock\", \"path/to/file\"], strict: [unlock: :boolean])\n    {[unlock: true], [\"path/to/file\"], []}\n\n    iex> OptionParser.parse(\n    ...>   [\"--unlock\", \"--limit\", \"0\", \"path/to/file\"],\n    ...>   strict: [unlock: :boolean, limit: :integer]\n    ...> )\n    {[unlock: true, limit: 0], [\"path/to/file\"], []}\n\n    iex> OptionParser.parse([\"--limit\", \"3\"], strict: [limit: :integer])\n    {[limit: 3], [], []}\n\n    iex> OptionParser.parse([\"--limit\", \"xyz\"], strict: [limit: :integer])\n    {[], [], [{\"--limit\", \"xyz\"}]}\n\n    iex> OptionParser.parse([\"--verbose\"], switches: [verbose: :count])\n    {[verbose: 1], [], []}\n\n    iex> OptionParser.parse([\"-v\", \"-v\"], aliases: [v: :verbose], strict: [verbose: :count])\n    {[verbose: 2], [], []}\n\n    iex> OptionParser.parse([\"--unknown\", \"xyz\"], strict: [])\n    {[], [\"xyz\"], [{\"--unknown\", nil}]}\n\n    iex> OptionParser.parse(\n    ...>   [\"--limit\", \"3\", \"--unknown\", \"xyz\"],\n    ...>   switches: [limit: :integer]\n    ...> )\n    {[limit: 3, unknown: \"xyz\"], [], []}\n\n    iex> OptionParser.parse(\n    ...>   [\"--unlock\", \"path/to/file\", \"--unlock\", \"path/to/another/file\"],\n    ...>   strict: [unlock: :keep]\n    ...> )\n    {[unlock: \"path/to/file\", unlock: \"path/to/another/file\"], [], []}\n\n"}
{"completion":"","prompt":"Elixir.OptionParser.parse!(argv, opts \\\\ []): The same as `parse/2` but raises an `OptionParser.ParseError`\nexception if any invalid options are given.\n\nIf there are no errors, returns a `{parsed, rest}` tuple where:\n\n  * `parsed` is the list of parsed switches (same as in `parse/2`)\n  * `rest` is the list of arguments (same as in `parse/2`)\n\n## Examples\n\n    iex> OptionParser.parse!([\"--debug\", \"path/to/file\"], strict: [debug: :boolean])\n    {[debug: true], [\"path/to/file\"]}\n\n    iex> OptionParser.parse!([\"--limit\", \"xyz\"], strict: [limit: :integer])\n    ** (OptionParser.ParseError) 1 error found!\n    --limit : Expected type integer, got \"xyz\"\n\n    iex> OptionParser.parse!([\"--unknown\", \"xyz\"], strict: [])\n    ** (OptionParser.ParseError) 1 error found!\n    --unknown : Unknown option\n\n    iex> OptionParser.parse!(\n    ...>   [\"-l\", \"xyz\", \"-f\", \"bar\"],\n    ...>   switches: [limit: :integer, foo: :integer],\n    ...>   aliases: [l: :limit, f: :foo]\n    ...> )\n    ** (OptionParser.ParseError) 2 errors found!\n    -l : Expected type integer, got \"xyz\"\n    -f : Expected type integer, got \"bar\"\n\n"}
{"completion":"","prompt":"Elixir.OptionParser.parse_head(argv, opts \\\\ []): Similar to `parse/2` but only parses the head of `argv`;\nas soon as it finds a non-switch, it stops parsing.\n\nSee `parse/2` for more information.\n\n## Example\n\n    iex> OptionParser.parse_head(\n    ...>   [\"--source\", \"lib\", \"test/enum_test.exs\", \"--verbose\"],\n    ...>   switches: [source: :string, verbose: :boolean]\n    ...> )\n    {[source: \"lib\"], [\"test/enum_test.exs\", \"--verbose\"], []}\n\n    iex> OptionParser.parse_head(\n    ...>   [\"--verbose\", \"--source\", \"lib\", \"test/enum_test.exs\", \"--unlock\"],\n    ...>   switches: [source: :string, verbose: :boolean, unlock: :boolean]\n    ...> )\n    {[verbose: true, source: \"lib\"], [\"test/enum_test.exs\", \"--unlock\"], []}\n\n"}
{"completion":"","prompt":"Elixir.OptionParser.parse_head!(argv, opts \\\\ []): The same as `parse_head/2` but raises an `OptionParser.ParseError`\nexception if any invalid options are given.\n\nIf there are no errors, returns a `{parsed, rest}` tuple where:\n\n  * `parsed` is the list of parsed switches (same as in `parse_head/2`)\n  * `rest` is the list of arguments (same as in `parse_head/2`)\n\n## Examples\n\n    iex> OptionParser.parse_head!(\n    ...>   [\"--source\", \"lib\", \"path/to/file\", \"--verbose\"],\n    ...>   switches: [source: :string, verbose: :boolean]\n    ...> )\n    {[source: \"lib\"], [\"path/to/file\", \"--verbose\"]}\n\n    iex> OptionParser.parse_head!(\n    ...>   [\"--number\", \"lib\", \"test/enum_test.exs\", \"--verbose\"],\n    ...>   strict: [number: :integer]\n    ...> )\n    ** (OptionParser.ParseError) 1 error found!\n    --number : Expected type integer, got \"lib\"\n\n    iex> OptionParser.parse_head!(\n    ...>   [\"--verbose\", \"--source\", \"lib\", \"test/enum_test.exs\", \"--unlock\"],\n    ...>   strict: [verbose: :integer, source: :integer]\n    ...> )\n    ** (OptionParser.ParseError) 2 errors found!\n    --verbose : Missing argument of type integer\n    --source : Expected type integer, got \"lib\"\n\n"}
{"completion":"","prompt":"Elixir.OptionParser.split(string): Splits a string into `t:argv/0` chunks.\n\nThis function splits the given `string` into a list of strings in a similar\nway to many shells.\n\n## Examples\n\n    iex> OptionParser.split(\"foo bar\")\n    [\"foo\", \"bar\"]\n\n    iex> OptionParser.split(\"foo \\\"bar baz\\\"\")\n    [\"foo\", \"bar baz\"]\n\n"}
{"completion":"","prompt":"Elixir.OptionParser.to_argv(enum, options \\\\ []): Receives a key-value enumerable and converts it to `t:argv/0`.\n\nKeys must be atoms. Keys with `nil` value are discarded,\nboolean values are converted to `--key` or `--no-key`\n(if the value is `true` or `false`, respectively),\nand all other values are converted using `to_string/1`.\n\nIt is advised to pass to `to_argv/2` the same set of `options`\ngiven to `parse/2`. Some switches can only be reconstructed\ncorrectly with the `:switches` information in hand.\n\n## Examples\n\n    iex> OptionParser.to_argv(foo_bar: \"baz\")\n    [\"--foo-bar\", \"baz\"]\n    iex> OptionParser.to_argv(bool: true, bool: false, discarded: nil)\n    [\"--bool\", \"--no-bool\"]\n\nSome switches will output different values based on the switches\ntypes:\n\n    iex> OptionParser.to_argv([number: 2], switches: [])\n    [\"--number\", \"2\"]\n    iex> OptionParser.to_argv([number: 2], switches: [number: :count])\n    [\"--number\", \"--number\"]\n\n"}
{"completion":"","prompt":"Elixir.PartitionSupervisor.count_children(supervisor): Returns a map containing count values for the supervisor.\n\nThe map contains the following keys:\n\n  * `:specs` - the number of partitions (children processes)\n\n  * `:active` - the count of all actively running child processes managed by\n    this supervisor\n\n  * `:supervisors` - the count of all supervisors whether or not the child\n    process is still alive\n\n  * `:workers` - the count of all workers, whether or not the child process\n    is still alive\n\n"}
{"completion":"","prompt":"Elixir.PartitionSupervisor.partitions(name): Returns the number of partitions for the partition supervisor.\n"}
{"completion":"","prompt":"Elixir.PartitionSupervisor.start_link(opts): Starts a partition supervisor with the given options.\n\nThis function is typically not invoked directly, instead it is invoked\nwhen using a `PartitionSupervisor` as a child of another supervisor:\n\n    children = [\n      {PartitionSupervisor, child_spec: SomeChild, name: MyPartitionSupervisor}\n    ]\n\nIf the supervisor is successfully spawned, this function returns\n`{:ok, pid}`, where `pid` is the PID of the supervisor. If the given name\nfor the partition supervisor is already assigned to a process,\nthe function returns `{:error, {:already_started, pid}}`, where `pid`\nis the PID of that process.\n\nNote that a supervisor started with this function is linked to the parent\nprocess and exits not only on crashes but also if the parent process exits\nwith `:normal` reason.\n\n## Options\n\n  * `:name` - an atom or via tuple representing the name of the partition\n    supervisor (see `t:name/0`).\n\n  * `:partitions` - a positive integer with the number of partitions.\n    Defaults to `System.schedulers_online()` (typically the number of cores).\n\n  * `:strategy` - the restart strategy option, defaults to `:one_for_one`.\n    You can learn more about strategies in the `Supervisor` module docs.\n\n  * `:max_restarts` - the maximum number of restarts allowed in\n    a time frame. Defaults to `3`.\n\n  * `:max_seconds` - the time frame in which `:max_restarts` applies.\n    Defaults to `5`.\n\n  * `:with_arguments` - a two-argument anonymous function that allows\n    the partition to be given to the child starting function. See the\n    `:with_arguments` section below.\n\n## `:with_arguments`\n\nSometimes you want each partition to know their partition assigned number.\nThis can be done with the `:with_arguments` option. This function receives\nthe list of arguments of the child specification and the partition. It\nmust return a new list of arguments that will be passed to the child specification\nof children.\n\nFor example, most processes are started by calling `start_link(opts)`,\nwhere `opts` is a keyword list. You could inject the partition into the\noptions given to the child:\n\n    with_arguments: fn [opts], partition ->\n      [Keyword.put(opts, :partition, partition)]\n    end\n\n"}
{"completion":"","prompt":"Elixir.PartitionSupervisor.stop(supervisor, reason \\\\ :normal, timeout \\\\ :infinity): Synchronously stops the given partition supervisor with the given `reason`.\n\nIt returns `:ok` if the supervisor terminates with the given\nreason. If it terminates with another reason, the call exits.\n\nThis function keeps OTP semantics regarding error reporting.\nIf the reason is any other than `:normal`, `:shutdown` or\n`{:shutdown, _}`, an error report is logged.\n"}
{"completion":"","prompt":"Elixir.PartitionSupervisor.which_children(name): Returns a list with information about all children.\n\nThis function returns a list of tuples containing:\n\n  * `id` - the partition number\n\n  * `child` - the PID of the corresponding child process or the\n    atom `:restarting` if the process is about to be restarted\n\n  * `type` - `:worker` or `:supervisor` as defined in the child\n    specification\n\n  * `modules` - as defined in the child specification\n\n"}
{"completion":"","prompt":"Elixir.Path.absname(path): Converts the given path to an absolute one.\n\nUnlike `expand/1`, no attempt is made to resolve `..`, `.`, or `~`.\n\n## Examples\n\n### Unix-like operating systems\n\n    Path.absname(\"foo\")\n    #=> \"/usr/local/foo\"\n\n    Path.absname(\"../x\")\n    #=> \"/usr/local/../x\"\n\n### Windows\n\n    Path.absname(\"foo\")\n    #=> \"D:/usr/local/foo\"\n\n    Path.absname(\"../x\")\n    #=> \"D:/usr/local/../x\"\n\n"}
{"completion":"","prompt":"Elixir.Path.absname(path, relative_to): Builds a path from `relative_to` to `path`.\n\nIf `path` is already an absolute path, `relative_to` is ignored. See also\n`relative_to/2`.\n\nUnlike `expand/2`, no attempt is made to\nresolve `..`, `.` or `~`.\n\n## Examples\n\n    iex> Path.absname(\"foo\", \"bar\")\n    \"bar/foo\"\n\n    iex> Path.absname(\"../x\", \"bar\")\n    \"bar/../x\"\n\n"}
{"completion":"","prompt":"Elixir.Path.basename(path): Returns the last component of the path or the path\nitself if it does not contain any directory separators.\n\n## Examples\n\n    iex> Path.basename(\"foo\")\n    \"foo\"\n\n    iex> Path.basename(\"foo/bar\")\n    \"bar\"\n\n    iex> Path.basename(\"lib/module/submodule.ex\")\n    \"submodule.ex\"\n\n    iex> Path.basename(\"/\")\n    \"\"\n\n"}
{"completion":"","prompt":"Elixir.Path.basename(path, extension): Returns the last component of `path` with the `extension`\nstripped.\n\nThis function should be used to remove a specific\nextension which may or may not be there.\n\n## Examples\n\n    iex> Path.basename(\"~/foo/bar.ex\", \".ex\")\n    \"bar\"\n\n    iex> Path.basename(\"~/foo/bar.exs\", \".ex\")\n    \"bar.exs\"\n\n    iex> Path.basename(\"~/foo/bar.old.ex\", \".ex\")\n    \"bar.old\"\n\n"}
{"completion":"","prompt":"Elixir.Path.dirname(path): Returns the directory component of `path`.\n\n## Examples\n\n    iex> Path.dirname(\"/foo/bar.ex\")\n    \"/foo\"\n\n    iex> Path.dirname(\"/foo/bar/baz.ex\")\n    \"/foo/bar\"\n\n    iex> Path.dirname(\"/foo/bar/\")\n    \"/foo/bar\"\n\n    iex> Path.dirname(\"bar.ex\")\n    \".\"\n\n"}
{"completion":"","prompt":"Elixir.Path.expand(path): Converts the path to an absolute one, expanding\nany `.` and `..` components and a leading `~`.\n\n## Examples\n\n    Path.expand(\"/foo/bar/../baz\")\n    #=> \"/foo/baz\"\n\n"}
{"completion":"","prompt":"Elixir.Path.expand(path, relative_to): Expands the path relative to the path given as the second argument\nexpanding any `.` and `..` characters.\n\nIf the path is already an absolute path, `relative_to` is ignored.\n\nNote that this function treats a `path` with a leading `~` as\nan absolute one.\n\nThe second argument is first expanded to an absolute path.\n\n## Examples\n\n    # Assuming that the absolute path to baz is /quux/baz\n    Path.expand(\"foo/bar/../bar\", \"baz\")\n    #=> \"/quux/baz/foo/bar\"\n\n    Path.expand(\"foo/bar/../bar\", \"/baz\")\n    #=> \"/baz/foo/bar\"\n\n    Path.expand(\"/foo/bar/../bar\", \"/baz\")\n    #=> \"/foo/bar\"\n\n"}
{"completion":"","prompt":"Elixir.Path.extname(path): Returns the extension of the last component of `path`.\n\nThe behaviour of this function changed in Erlang/OTP 24 for filenames\nstarting with a dot and without an extension. For example, for a file\nnamed `.gitignore`, `extname/1` now returns an empty string, while it\nwould return `\".gitignore\"` in previous Erlang/OTP versions. This was\ndone to match the behaviour of `rootname/1`, which would return\n`\".gitignore\"` as its name (and therefore it cannot also be an extension).\n\nSee `basename/1` and `rootname/1` for related functions to extract\ninformation from paths.\n\n## Examples\n\n    iex> Path.extname(\"foo.erl\")\n    \".erl\"\n\n    iex> Path.extname(\"~/foo/bar\")\n    \"\"\n\n"}
{"completion":"","prompt":"Elixir.Path.join(list): Joins a list of paths.\n\nThis function should be used to convert a list of paths to a path.\nNote that any trailing slash is removed when joining.\n\nRaises an error if the given list of paths is empty.\n\n## Examples\n\n    iex> Path.join([\"~\", \"foo\"])\n    \"~/foo\"\n\n    iex> Path.join([\"foo\"])\n    \"foo\"\n\n    iex> Path.join([\"/\", \"foo\", \"bar/\"])\n    \"/foo/bar\"\n\n"}
{"completion":"","prompt":"Elixir.Path.join(left, right): Joins two paths.\n\nThe right path will always be expanded to its relative format\nand any trailing slash will be removed when joining.\n\n## Examples\n\n    iex> Path.join(\"foo\", \"bar\")\n    \"foo/bar\"\n\n    iex> Path.join(\"/foo\", \"/bar/\")\n    \"/foo/bar\"\n\nThe functions in this module support chardata, so giving a list will\ntreat it as a single entity:\n\n    iex> Path.join(\"foo\", [\"bar\", \"fiz\"])\n    \"foo/barfiz\"\n\n    iex> Path.join([\"foo\", \"bar\"], \"fiz\")\n    \"foobar/fiz\"\n\nUse `join/1` if you need to join a list of paths instead.\n"}
{"completion":"","prompt":"Elixir.Path.relative(name): Forces the path to be a relative path.\n\n## Examples\n\n### Unix-like operating systems\n\n    Path.relative(\"/usr/local/bin\")   #=> \"usr/local/bin\"\n    Path.relative(\"usr/local/bin\")    #=> \"usr/local/bin\"\n    Path.relative(\"../usr/local/bin\") #=> \"../usr/local/bin\"\n\n### Windows\n\n    Path.relative(\"D:/usr/local/bin\") #=> \"usr/local/bin\"\n    Path.relative(\"usr/local/bin\")    #=> \"usr/local/bin\"\n    Path.relative(\"D:bar.ex\")         #=> \"bar.ex\"\n    Path.relative(\"/bar/foo.ex\")      #=> \"bar/foo.ex\"\n\n"}
{"completion":"","prompt":"Elixir.Path.relative_to(path, from): Returns the given `path` relative to the given `from` path.\n\nIn other words, this function tries to strip the `from` prefix from `path`.\n\nThis function does not query the file system, so it assumes\nno symlinks between the paths.\n\nIn case a direct relative path cannot be found, it returns\nthe original path.\n\n## Examples\n\n    iex> Path.relative_to(\"/usr/local/foo\", \"/usr/local\")\n    \"foo\"\n\n    iex> Path.relative_to(\"/usr/local/foo\", \"/\")\n    \"usr/local/foo\"\n\n    iex> Path.relative_to(\"/usr/local/foo\", \"/etc\")\n    \"/usr/local/foo\"\n\n    iex> Path.relative_to(\"/usr/local/foo\", \"/usr/local/foo\")\n    \".\"\n\n"}
{"completion":"","prompt":"Elixir.Path.relative_to_cwd(path): Convenience to get the path relative to the current working\ndirectory.\n\nIf, for some reason, the current working directory\ncannot be retrieved, this function returns the given `path`.\n"}
{"completion":"","prompt":"Elixir.Path.rootname(path): Returns the `path` with the `extension` stripped.\n\n## Examples\n\n    iex> Path.rootname(\"/foo/bar\")\n    \"/foo/bar\"\n\n    iex> Path.rootname(\"/foo/bar.ex\")\n    \"/foo/bar\"\n\n"}
{"completion":"","prompt":"Elixir.Path.rootname(path, extension): Returns the `path` with the `extension` stripped.\n\nThis function should be used to remove a specific extension which may\nor may not be there.\n\n## Examples\n\n    iex> Path.rootname(\"/foo/bar.erl\", \".erl\")\n    \"/foo/bar\"\n\n    iex> Path.rootname(\"/foo/bar.erl\", \".ex\")\n    \"/foo/bar.erl\"\n\n"}
{"completion":"","prompt":"Elixir.Path.safe_relative(path): Returns a path relative to the current working directory that is\nprotected from directory-traversal attacks.\n\nSame as `safe_relative_to/2` with the current working directory as\nthe second argument. If there is an issue retrieving the current working\ndirectory, this function raises an error.\n\n## Examples\n\n    iex> Path.safe_relative(\"foo\")\n    {:ok, \"foo\"}\n\n    iex> Path.safe_relative(\"foo/../bar\")\n    {:ok, \"bar\"}\n\n    iex> Path.safe_relative(\"foo/../..\")\n    :error\n\n    iex> Path.safe_relative(\"/usr/local\")\n    :error\n\n"}
{"completion":"","prompt":"Elixir.Path.safe_relative_to(path, relative_to): Returns a relative path that is protected from directory-traversal attacks.\n\nThe given relative path is sanitized by eliminating `..` and `.` components.\n\nThis function checks that, after expanding those components, the path is still \"safe\".\nPaths are considered unsafe if either of these is true:\n\n  * The path is not relative, such as `\"/foo/bar\"`.\n\n  * A `..` component would make it so that the path would travers up above\n    the root of `relative_to`.\n\n  * A symbolic link in the path points to something above the root of `relative_to`.\n\n## Examples\n\n    iex> Path.safe_relative_to(\"deps/my_dep/app.beam\", \"deps\")\n    {:ok, \"deps/my_dep/app.beam\"}\n\n    iex> Path.safe_relative_to(\"deps/my_dep/./build/../app.beam\", \"deps\")\n    {:ok, \"deps/my_dep/app.beam\"}\n\n    iex> Path.safe_relative_to(\"my_dep/../..\", \"deps\")\n    :error\n\n    iex> Path.safe_relative_to(\"/usr/local\", \".\")\n    :error\n\n"}
{"completion":"","prompt":"Elixir.Path.split(path): Splits the path into a list at the path separator.\n\nIf an empty string is given, returns an empty list.\n\nOn Windows, path is split on both `\"\\\"` and `\"/\"` separators\nand the driver letter, if there is one, is always returned\nin lowercase.\n\n## Examples\n\n    iex> Path.split(\"\")\n    []\n\n    iex> Path.split(\"foo\")\n    [\"foo\"]\n\n    iex> Path.split(\"/foo/bar\")\n    [\"/\", \"foo\", \"bar\"]\n\n"}
{"completion":"","prompt":"Elixir.Path.type(name): Returns the path type.\n\n## Examples\n\n### Unix-like operating systems\n\n    Path.type(\"/\")                #=> :absolute\n    Path.type(\"/usr/local/bin\")   #=> :absolute\n    Path.type(\"usr/local/bin\")    #=> :relative\n    Path.type(\"../usr/local/bin\") #=> :relative\n    Path.type(\"~/file\")           #=> :relative\n\n### Windows\n\n    Path.type(\"D:/usr/local/bin\") #=> :absolute\n    Path.type(\"usr/local/bin\")    #=> :relative\n    Path.type(\"D:bar.ex\")         #=> :volumerelative\n    Path.type(\"/bar/foo.ex\")      #=> :volumerelative\n\n"}
{"completion":"","prompt":"Elixir.Path.wildcard(glob, opts \\\\ []): Traverses paths according to the given `glob` expression and returns a\nlist of matches.\n\nThe wildcard looks like an ordinary path, except that the following\n\"wildcard characters\" are interpreted in a special way:\n\n  * `?` - matches one character.\n\n  * `*` - matches any number of characters up to the end of the filename, the\n    next dot, or the next slash.\n\n  * `**` - two adjacent `*`'s used as a single pattern will match all\n    files and zero or more directories and subdirectories.\n\n  * `[char1,char2,...]` - matches any of the characters listed; two\n    characters separated by a hyphen will match a range of characters.\n    Do not add spaces before and after the comma as it would then match\n    paths containing the space character itself.\n\n  * `{item1,item2,...}` - matches one of the alternatives.\n    Do not add spaces before and after the comma as it would then match\n    paths containing the space character itself.\n\nOther characters represent themselves. Only paths that have\nexactly the same character in the same position will match. Note\nthat matching is case-sensitive: `\"a\"` will not match `\"A\"`.\n\nDirectory separators must always be written as `/`, even on Windows.\nYou may call `Path.expand/1` to normalize the path before invoking\nthis function.\n\nBy default, the patterns `*` and `?` do not match files starting\nwith a dot `.`. See the `:match_dot` option in the \"Options\" section\nbelow.\n\n## Options\n\n  * `:match_dot` - (boolean) if `false`, the special wildcard characters `*` and `?`\n    will not match files starting with a dot (`.`). If `true`, files starting with\n    a `.` will not be treated specially. Defaults to `false`.\n\n## Examples\n\nImagine you have a directory called `projects` with three Elixir projects\ninside of it: `elixir`, `ex_doc`, and `plug`. You can find all `.beam` files\ninside the `ebin` directory of each project as follows:\n\n    Path.wildcard(\"projects/*/ebin/**/*.beam\")\n\nIf you want to search for both `.beam` and `.app` files, you could do:\n\n    Path.wildcard(\"projects/*/ebin/**/*.{beam,app}\")\n\n"}
{"completion":"","prompt":"Elixir.Port.close(port): Closes the `port`.\n\nFor more information, see `:erlang.port_close/1`.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Port.command(port, data, options \\\\ []): Sends `data` to the port driver `port`.\n\nFor more information, see `:erlang.port_command/3`.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Port.connect(port, pid): Associates the `port` identifier with a `pid`.\n\nFor more information, see `:erlang.port_connect/2`.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Port.demonitor(monitor_ref, options \\\\ []): Demonitors the monitor identified by the given `reference`.\n\nIf `monitor_ref` is a reference which the calling process\nobtained by calling `monitor/1`, that monitoring is turned off.\nIf the monitoring is already turned off, nothing happens.\n\nSee `:erlang.demonitor/2` for more information.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Port.info(port): Returns information about the `port` or `nil` if the port is closed.\n\nFor more information, see `:erlang.port_info/1`.\n"}
{"completion":"","prompt":"Elixir.Port.info(port, spec): Returns information about the `port` or `nil` if the port is closed.\n\nFor more information, see `:erlang.port_info/2`.\n"}
{"completion":"","prompt":"Elixir.Port.list(): Returns a list of all ports in the current node.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Port.monitor(port): Starts monitoring the given `port` from the calling process.\n\nOnce the monitored port process dies, a message is delivered to the\nmonitoring process in the shape of:\n\n    {:DOWN, ref, :port, object, reason}\n\nwhere:\n\n  * `ref` is a monitor reference returned by this function;\n  * `object` is either the `port` being monitored (when monitoring by port ID)\n  or `{name, node}` (when monitoring by a port name);\n  * `reason` is the exit reason.\n\nSee `:erlang.monitor/2` for more information.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Port.open(name, options): Opens a port given a tuple `name` and a list of `options`.\n\nThe module documentation above contains documentation and examples\nfor the supported `name` values, summarized below:\n\n  * `{:spawn, command}` - runs an external program. `command` must contain\n    the program name and optionally a list of arguments separated by space.\n    If passing programs or arguments with space in their name, use the next option.\n  * `{:spawn_executable, filename}` - runs the executable given by the absolute\n    file name `filename`. Arguments can be passed via the `:args` option.\n  * `{:spawn_driver, command}` - spawns so-called port drivers.\n  * `{:fd, fd_in, fd_out}` - accesses file descriptors, `fd_in` and `fd_out`\n    opened by the VM.\n\nFor more information and the list of options, see `:erlang.open_port/2`.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Process.alive?(pid): Tells whether the given process is alive on the local node.\n\nIf the process identified by `pid` is alive (that is, it's not exiting and has\nnot exited yet) than this function returns `true`. Otherwise, it returns\n`false`.\n\n`pid` must refer to a process running on the local node or `ArgumentError` is raised.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Process.cancel_timer(timer_ref, options \\\\ []): Cancels a timer returned by `send_after/3`.\n\nWhen the result is an integer, it represents the time in milliseconds\nleft until the timer would have expired.\n\nWhen the result is `false`, a timer corresponding to `timer_ref` could not be\nfound. This can happen either because the timer expired, because it has\nalready been canceled, or because `timer_ref` never corresponded to a timer.\n\nEven if the timer had expired and the message was sent, this function does not\ntell you if the timeout message has arrived at its destination yet.\n\nInlined by the compiler.\n\n## Options\n\n  * `:async` - (boolean) when `false`, the request for cancellation is\n    synchronous. When `true`, the request for cancellation is asynchronous,\n    meaning that the request to cancel the timer is issued and `:ok` is\n    returned right away. Defaults to `false`.\n\n  * `:info` - (boolean) whether to return information about the timer being\n    cancelled. When the `:async` option is `false` and `:info` is `true`, then\n    either an integer or `false` (like described above) is returned. If\n    `:async` is `false` and `:info` is `false`, `:ok` is returned. If `:async`\n    is `true` and `:info` is `true`, a message in the form `{:cancel_timer,\n    timer_ref, result}` (where `result` is an integer or `false` like\n    described above) is sent to the caller of this function when the\n    cancellation has been performed. If `:async` is `true` and `:info` is\n    `false`, no message is sent. Defaults to `true`.\n\n"}
{"completion":"","prompt":"Elixir.Process.delete(key): Deletes the given `key` from the process dictionary.\n\nReturns the value that was under `key` in the process dictionary,\nor `nil` if `key` was not stored in the process dictionary.\n\n## Examples\n\n    iex> Process.put(:comments, [\"comment\", \"other comment\"])\n    iex> Process.delete(:comments)\n    [\"comment\", \"other comment\"]\n    iex> Process.delete(:comments)\n    nil\n\n"}
{"completion":"","prompt":"Elixir.Process.demonitor(monitor_ref, options \\\\ []): Demonitors the monitor identified by the given `reference`.\n\nIf `monitor_ref` is a reference which the calling process\nobtained by calling `monitor/1`, that monitoring is turned off.\nIf the monitoring is already turned off, nothing happens.\n\nSee `:erlang.demonitor/2` for more information.\n\nInlined by the compiler.\n\n## Examples\n\n    pid = spawn(fn -> 1 + 2 end)\n    ref = Process.monitor(pid)\n    Process.demonitor(ref)\n    #=> true\n\n"}
{"completion":"","prompt":"Elixir.Process.exit(pid, reason): Sends an exit signal with the given `reason` to `pid`.\n\nThe following behaviour applies if `reason` is any term except `:normal`\nor `:kill`:\n\n  1. If `pid` is not trapping exits, `pid` will exit with the given\n     `reason`.\n\n  2. If `pid` is trapping exits, the exit signal is transformed into a\n     message `{:EXIT, from, reason}` and delivered to the message queue\n     of `pid`.\n\nIf `reason` is the atom `:normal`, `pid` will not exit (unless `pid` is\nthe calling process, in which case it will exit with the reason `:normal`).\nIf it is trapping exits, the exit signal is transformed into a message\n`{:EXIT, from, :normal}` and delivered to its message queue.\n\nIf `reason` is the atom `:kill`, that is if `Process.exit(pid, :kill)` is called,\nan untrappable exit signal is sent to `pid` which will unconditionally exit\nwith reason `:killed`.\n\nInlined by the compiler.\n\n## Examples\n\n    Process.exit(pid, :kill)\n    #=> true\n\n"}
{"completion":"","prompt":"Elixir.Process.flag(flag, value): Sets the given `flag` to `value` for the calling process.\n\nReturns the old value of `flag`.\n\nSee `:erlang.process_flag/2` for more information.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Process.flag(pid, flag, value): Sets the given `flag` to `value` for the given process `pid`.\n\nReturns the old value of `flag`.\n\nIt raises `ArgumentError` if `pid` is not a local process.\n\nThe allowed values for `flag` are only a subset of those allowed in `flag/2`,\nnamely `:save_calls`.\n\nSee `:erlang.process_flag/3` for more information.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Process.get(): Returns all key-value pairs in the process dictionary.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Process.get(key, default \\\\ nil): Returns the value for the given `key` in the process dictionary,\nor `default` if `key` is not set.\n\n## Examples\n\n    # Assuming :locale was not set\n    iex> Process.get(:locale, \"pt\")\n    \"pt\"\n    iex> Process.put(:locale, \"fr\")\n    nil\n    iex> Process.get(:locale, \"pt\")\n    \"fr\"\n\n"}
{"completion":"","prompt":"Elixir.Process.get_keys(): Returns all keys in the process dictionary.\n\nInlined by the compiler.\n\n## Examples\n\n    # Assuming :locale was not set\n    iex> :locale in Process.get_keys()\n    false\n    iex> Process.put(:locale, \"pt\")\n    nil\n    iex> :locale in Process.get_keys()\n    true\n\n"}
{"completion":"","prompt":"Elixir.Process.get_keys(value): Returns all keys in the process dictionary that have the given `value`.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Process.group_leader(): Returns the PID of the group leader for the calling process.\n\nInlined by the compiler.\n\n## Examples\n\n    Process.group_leader()\n    #=> #PID<0.53.0>\n\n"}
{"completion":"","prompt":"Elixir.Process.group_leader(pid, leader): Sets the group leader of the given `pid` to `leader`.\n\nTypically, this is used when a process started from a certain shell should\nhave a group leader other than `:init`.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Process.hibernate(mod, fun_name, args): Puts the calling process into a \"hibernation\" state.\n\nThe calling process is put into a waiting state\nwhere its memory allocation has been reduced as much as possible,\nwhich is useful if the process does not expect to receive any messages\nin the near future.\n\nSee `:erlang.hibernate/3` for more information.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Process.info(pid): Returns information about the process identified by `pid`, or returns `nil` if the process\nis not alive.\n\nUse this only for debugging information.\n\nSee `:erlang.process_info/1` for more information.\n"}
{"completion":"","prompt":"Elixir.Process.info(pid, spec): Returns information about the process identified by `pid`,\nor returns `nil` if the process is not alive.\n\nSee `:erlang.process_info/2` for more information.\n"}
{"completion":"","prompt":"Elixir.Process.link(pid_or_port): Creates a link between the calling process and the given item (process or\nport).\n\nLinks are bidirectional. Linked processes can be unlinked by using `unlink/1`.\n\nIf such a link exists already, this function does nothing since there can only\nbe one link between two given processes. If a process tries to create a link\nto itself, nothing will happen.\n\nWhen two processes are linked, each one receives exit signals from the other\n(see also `exit/2`). Let's assume `pid1` and `pid2` are linked. If `pid2`\nexits with a reason other than `:normal` (which is also the exit reason used\nwhen a process finishes its job) and `pid1` is not trapping exits (see\n`flag/2`), then `pid1` will exit with the same reason as `pid2` and in turn\nemit an exit signal to all its other linked processes. The behaviour when\n`pid1` is trapping exits is described in `exit/2`.\n\nSee `:erlang.link/1` for more information.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Process.list(): Returns a list of PIDs corresponding to all the\nprocesses currently existing on the local node.\n\nNote that if a process is exiting, it is considered to exist but not be\nalive. This means that for such process, `alive?/1` will return `false` but\nits PID will be part of the list of PIDs returned by this function.\n\nSee `:erlang.processes/0` for more information.\n\nInlined by the compiler.\n\n## Examples\n\n    Process.list()\n    #=> [#PID<0.0.0>, #PID<0.1.0>, #PID<0.2.0>, #PID<0.3.0>, ...]\n\n"}
{"completion":"","prompt":"Elixir.Process.monitor(item): Starts monitoring the given `item` from the calling process.\n\nOnce the monitored process dies, a message is delivered to the\nmonitoring process in the shape of:\n\n    {:DOWN, ref, :process, object, reason}\n\nwhere:\n\n  * `ref` is a monitor reference returned by this function;\n  * `object` is either a `pid` of the monitored process (if monitoring\n    a PID) or `{name, node}` (if monitoring a remote or local name);\n  * `reason` is the exit reason.\n\nIf the process is already dead when calling `Process.monitor/1`, a\n`:DOWN` message is delivered immediately.\n\nSee [\"The need for monitoring\"](https://elixir-lang.org/getting-started/mix-otp/genserver.html#the-need-for-monitoring)\nfor an example. See `:erlang.monitor/2` for more information.\n\nInlined by the compiler.\n\n## Examples\n\n    pid = spawn(fn -> 1 + 2 end)\n    #=> #PID<0.118.0>\n    Process.monitor(pid)\n    #=> #Reference<0.906660723.3006791681.40191>\n    Process.exit(pid, :kill)\n    #=> true\n    receive do\n      msg -> msg\n    end\n    #=> {:DOWN, #Reference<0.906660723.3006791681.40191>, :process, #PID<0.118.0>, :noproc}\n\n"}
{"completion":"","prompt":"Elixir.Process.put(key, value): Stores the given `key`-`value` pair in the process dictionary.\n\nThe return value of this function is the value that was previously stored\nunder `key`, or `nil` in case no value was stored under it.\n\n## Examples\n\n    # Assuming :locale was not set\n    iex> Process.put(:locale, \"en\")\n    nil\n    iex> Process.put(:locale, \"fr\")\n    \"en\"\n\n"}
{"completion":"","prompt":"Elixir.Process.read_timer(timer_ref): Reads a timer created by `send_after/3`.\n\nWhen the result is an integer, it represents the time in milliseconds\nleft until the timer will expire.\n\nWhen the result is `false`, a timer corresponding to `timer_ref` could not be\nfound. This can be either because the timer expired, because it has already\nbeen canceled, or because `timer_ref` never corresponded to a timer.\n\nEven if the timer had expired and the message was sent, this function does not\ntell you if the timeout message has arrived at its destination yet.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Process.register(pid_or_port, name): Registers the given `pid_or_port` under the given `name`.\n\n`name` must be an atom and can then be used instead of the\nPID/port identifier when sending messages with `Kernel.send/2`.\n\n`register/2` will fail with `ArgumentError` in any of the following cases:\n\n  * the PID/Port is not existing locally and alive\n  * the name is already registered\n  * the `pid_or_port` is already registered under a different `name`\n\nThe following names are reserved and cannot be assigned to\nprocesses nor ports:\n\n  * `nil`\n  * `false`\n  * `true`\n  * `:undefined`\n\n## Examples\n\n    Process.register(self(), :test)\n    #=> true\n    send(:test, :hello)\n    #=> :hello\n    send(:wrong_name, :hello)\n    ** (ArgumentError) argument error\n\n"}
{"completion":"","prompt":"Elixir.Process.registered(): Returns a list of names which have been registered using `register/2`.\n\nInlined by the compiler.\n\n## Examples\n\n    Process.register(self(), :test)\n    Process.registered()\n    #=> [:test, :elixir_config, :inet_db, ...]\n\n"}
{"completion":"","prompt":"Elixir.Process.send(dest, msg, options): Sends a message to the given `dest`.\n\n`dest` may be a remote or local PID, a local port, a locally\nregistered name, or a tuple in the form of `{registered_name, node}` for a\nregistered name at another node.\n\nInlined by the compiler.\n\n## Options\n\n  * `:noconnect` - when used, if sending the message would require an\n    auto-connection to another node the message is not sent and `:noconnect` is\n    returned.\n\n  * `:nosuspend` - when used, if sending the message would cause the sender to\n    be suspended the message is not sent and `:nosuspend` is returned.\n\nOtherwise the message is sent and `:ok` is returned.\n\n## Examples\n\n    iex> Process.send({:name, :node_that_does_not_exist}, :hi, [:noconnect])\n    :noconnect\n\n"}
{"completion":"","prompt":"Elixir.Process.send_after(dest, msg, time, opts \\\\ []): Sends `msg` to `dest` after `time` milliseconds.\n\nIf `dest` is a PID, it must be the PID of a local process, dead or alive.\nIf `dest` is an atom, it must be the name of a registered process\nwhich is looked up at the time of delivery. No error is produced if the name does\nnot refer to a process.\n\nThe message is not sent immediately. Therefore, `dest` can receive other messages\nin-between even when `time` is `0`.\n\nThis function returns a timer reference, which can be read with `read_timer/1`\nor canceled with `cancel_timer/1`.\n\nThe timer will be automatically canceled if the given `dest` is a PID\nwhich is not alive or when the given PID exits. Note that timers will not be\nautomatically canceled when `dest` is an atom (as the atom resolution is done\non delivery).\n\nInlined by the compiler.\n\n## Options\n\n  * `:abs` - (boolean) when `false`, `time` is treated as relative to the\n  current monotonic time. When `true`, `time` is the absolute value of the\n  Erlang monotonic time at which `msg` should be delivered to `dest`.\n  To read more about Erlang monotonic time and other time-related concepts,\n  look at the documentation for the `System` module. Defaults to `false`.\n\n## Examples\n\n    timer_ref = Process.send_after(pid, :hi, 1000)\n\n"}
{"completion":"","prompt":"Elixir.Process.sleep(timeout): Sleeps the current process for the given `timeout`.\n\n`timeout` is either the number of milliseconds to sleep as an\ninteger or the atom `:infinity`. When `:infinity` is given,\nthe current process will sleep forever, and not\nconsume or reply to messages.\n\n**Use this function with extreme care**. For almost all situations\nwhere you would use `sleep/1` in Elixir, there is likely a\nmore correct, faster and precise way of achieving the same with\nmessage passing.\n\nFor example, if you are waiting for a process to perform some\naction, it is better to communicate the progress of such action\nwith messages.\n\nIn other words, **do not**:\n\n    Task.start_link(fn ->\n      do_something()\n      ...\n    end)\n\n    # Wait until work is done\n    Process.sleep(2000)\n\nBut **do**:\n\n    parent = self()\n\n    Task.start_link(fn ->\n      do_something()\n      send(parent, :work_is_done)\n      ...\n    end)\n\n    receive do\n      :work_is_done -> :ok\n    after\n      # Optional timeout\n      30_000 -> :timeout\n    end\n\nFor cases like the one above, `Task.async/1` and `Task.await/2` are\npreferred.\n\nSimilarly, if you are waiting for a process to terminate,\nmonitor that process instead of sleeping. **Do not**:\n\n    Task.start_link(fn ->\n      ...\n    end)\n\n    # Wait until task terminates\n    Process.sleep(2000)\n\nInstead **do**:\n\n    {:ok, pid} =\n      Task.start_link(fn ->\n        ...\n      end)\n\n    ref = Process.monitor(pid)\n\n    receive do\n      {:DOWN, ^ref, _, _, _} -> :task_is_down\n    after\n      # Optional timeout\n      30_000 -> :timeout\n    end\n\n"}
{"completion":"","prompt":"Elixir.Process.spawn(fun, opts): Spawns the given function according to the given options.\n\nThe result depends on the given options. In particular,\nif `:monitor` is given as an option, it will return a tuple\ncontaining the PID and the monitoring reference, otherwise\njust the spawned process PID.\n\nMore options are available; for the comprehensive list of available options\ncheck `:erlang.spawn_opt/4`.\n\nInlined by the compiler.\n\n## Examples\n\n    Process.spawn(fn -> 1 + 2 end, [:monitor])\n    #=> {#PID<0.93.0>, #Reference<0.18808174.1939079169.202418>}\n    Process.spawn(fn -> 1 + 2 end, [:link])\n    #=> #PID<0.95.0>\n\n"}
{"completion":"","prompt":"Elixir.Process.spawn(mod, fun, args, opts): Spawns the given function `fun` from module `mod`, passing the given `args`\naccording to the given options.\n\nThe result depends on the given options. In particular,\nif `:monitor` is given as an option, it will return a tuple\ncontaining the PID and the monitoring reference, otherwise\njust the spawned process PID.\n\nIt also accepts extra options, for the list of available options\ncheck `:erlang.spawn_opt/4`.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Process.unlink(pid_or_port): Removes the link between the calling process and the given item (process or\nport).\n\nIf there is no such link, this function does nothing. If `pid_or_port` does\nnot exist, this function does not produce any errors and simply does nothing.\n\nThe return value of this function is always `true`.\n\nSee `:erlang.unlink/1` for more information.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.Process.unregister(name): Removes the registered `name`, associated with a PID\nor a port identifier.\n\nFails with `ArgumentError` if the name is not registered\nto any PID or port.\n\nInlined by the compiler.\n\n## Examples\n\n    Process.register(self(), :test)\n    #=> true\n    Process.unregister(:test)\n    #=> true\n    Process.unregister(:wrong_name)\n    ** (ArgumentError) argument error\n\n"}
{"completion":"","prompt":"Elixir.Process.whereis(name): Returns the PID or port identifier registered under `name` or `nil` if the\nname is not registered.\n\nSee `:erlang.whereis/1` for more information.\n\n## Examples\n\n    Process.register(self(), :test)\n    Process.whereis(:test)\n    #=> #PID<0.84.0>\n    Process.whereis(:wrong_name)\n    #=> nil\n\n"}
{"completion":"","prompt":"Elixir.Protocol.assert_impl!(protocol, base): Checks if the given module is loaded and is an implementation\nof the given protocol.\n\nReturns `:ok` if so, otherwise raises `ArgumentError`.\n"}
{"completion":"","prompt":"Elixir.Protocol.assert_protocol!(module): Checks if the given module is loaded and is protocol.\n\nReturns `:ok` if so, otherwise raises `ArgumentError`.\n"}
{"completion":"","prompt":"Elixir.Protocol.consolidate(protocol, types): Receives a protocol and a list of implementations and\nconsolidates the given protocol.\n\nConsolidation happens by changing the protocol `impl_for`\nin the abstract format to have fast lookup rules. Usually\nthe list of implementations to use during consolidation\nare retrieved with the help of `extract_impls/2`.\n\nIt returns the updated version of the protocol bytecode.\nIf the first element of the tuple is `:ok`, it means\nthe protocol was consolidated.\n\nA given bytecode or protocol implementation can be checked\nto be consolidated or not by analyzing the protocol\nattribute:\n\n    Protocol.consolidated?(Enumerable)\n\nThis function does not load the protocol at any point\nnor loads the new bytecode for the compiled module.\nHowever each implementation must be available and\nit will be loaded.\n"}
{"completion":"","prompt":"Elixir.Protocol.consolidated?(protocol): Returns `true` if the protocol was consolidated.\n"}
{"completion":"","prompt":"Elixir.Protocol.extract_impls(protocol, paths): Extracts all types implemented for the given protocol from\nthe given paths.\n\nThe paths can be either a charlist or a string. Internally\nthey are worked on as charlists, so passing them as lists\navoid extra conversion.\n\nDoes not load any of the implementations.\n\n## Examples\n\n    # Get Elixir's ebin directory path and retrieve all protocols\n    iex> path = :code.lib_dir(:elixir, :ebin)\n    iex> mods = Protocol.extract_impls(Enumerable, [path])\n    iex> List in mods\n    true\n\n"}
{"completion":"","prompt":"Elixir.Protocol.extract_protocols(paths): Extracts all protocols from the given paths.\n\nThe paths can be either a charlist or a string. Internally\nthey are worked on as charlists, so passing them as lists\navoid extra conversion.\n\nDoes not load any of the protocols.\n\n## Examples\n\n    # Get Elixir's ebin directory path and retrieve all protocols\n    iex> path = :code.lib_dir(:elixir, :ebin)\n    iex> mods = Protocol.extract_protocols([path])\n    iex> Enumerable in mods\n    true\n\n"}
{"completion":"","prompt":"Elixir.Range.disjoint?(range1, range2): Checks if two ranges are disjoint.\n\n## Examples\n\n    iex> Range.disjoint?(1..5, 6..9)\n    true\n    iex> Range.disjoint?(5..1, 6..9)\n    true\n    iex> Range.disjoint?(1..5, 5..9)\n    false\n    iex> Range.disjoint?(1..5, 2..7)\n    false\n\nSteps are also considered when computing the ranges to be disjoint:\n\n    iex> Range.disjoint?(1..10//2, 2..10//2)\n    true\n\n    # First element in common is 29\n    iex> Range.disjoint?(1..100//14, 8..100//21)\n    false\n    iex> Range.disjoint?(57..-1//-14, 8..100//21)\n    false\n    iex> Range.disjoint?(1..100//14, 50..8//-21)\n    false\n    iex> Range.disjoint?(1..28//14, 8..28//21)\n    true\n\n    # First element in common is 14\n    iex> Range.disjoint?(2..28//3, 9..28//5)\n    false\n    iex> Range.disjoint?(26..2//-3, 29..9//-5)\n    false\n\n    # Starting from the back without alignment\n    iex> Range.disjoint?(27..11//-3, 30..0//-7)\n    true\n\n"}
{"completion":"","prompt":"Elixir.Range.new(first, last): Creates a new range.\n\nIf `first` is less than `last`, the range will be increasing from\n`first` to `last`. If `first` is equal to `last`, the range will contain\none element, which is the number itself.\n\nIf `first` is greater than `last`, the range will be decreasing from `first`\nto `last`, albeit this behaviour is deprecated. Therefore, it is advised to\nexplicitly list the step with `new/3`.\n\n## Examples\n\n    iex> Range.new(-100, 100)\n    -100..100\n\n"}
{"completion":"","prompt":"Elixir.Range.new(first, last, step): Creates a new range with `step`.\n\n## Examples\n\n    iex> Range.new(-100, 100, 2)\n    -100..100//2\n\n"}
{"completion":"","prompt":"Elixir.Range.shift(arg, steps_to_shift): Shifts a range by the given number of steps.\n\n## Examples\n\n    iex> Range.shift(0..10, 1)\n    1..11\n    iex> Range.shift(0..10, 2)\n    2..12\n\n    iex> Range.shift(0..10//2, 2)\n    4..14//2\n"}
{"completion":"","prompt":"Elixir.Range.size(range): Returns the size of `range`.\n\n## Examples\n\n    iex> Range.size(1..10)\n    10\n    iex> Range.size(1..10//2)\n    5\n    iex> Range.size(1..10//3)\n    4\n    iex> Range.size(1..10//-1)\n    0\n\n    iex> Range.size(10..1)\n    10\n    iex> Range.size(10..1//-1)\n    10\n    iex> Range.size(10..1//-2)\n    5\n    iex> Range.size(10..1//-3)\n    4\n    iex> Range.size(10..1//1)\n    0\n\n"}
{"completion":"","prompt":"Elixir.Record.extract(name, opts): Extracts record information from an Erlang file.\n\nReturns a quoted expression containing the fields as a list\nof tuples.\n\n`name`, which is the name of the extracted record, is expected to be an atom\n*at compile time*.\n\n## Options\n\nThis function requires one of the following options, which are exclusive to each\nother (i.e., only one of them can be used in the same call):\n\n  * `:from` - (binary representing a path to a file) path to the Erlang file\n    that contains the record definition to extract; with this option, this\n    function uses the same path lookup used by the `-include` attribute used in\n    Erlang modules.\n\n  * `:from_lib` - (binary representing a path to a file) path to the Erlang\n    file that contains the record definition to extract; with this option,\n    this function uses the same path lookup used by the `-include_lib`\n    attribute used in Erlang modules.\n\nIt additionally accepts the following optional, non-exclusive options:\n\n  * `:includes` - (a list of directories as binaries) if the record being\n    extracted depends on relative includes, this option allows developers\n    to specify the directory where those relative includes exist.\n\n  * `:macros` - (keyword list of macro names and values) if the record\n    being extracted depends on the values of macros, this option allows\n    the value of those macros to be set.\n\nThese options are expected to be literals (including the binary values) at\ncompile time.\n\n## Examples\n\n    iex> Record.extract(:file_info, from_lib: \"kernel/include/file.hrl\")\n    [\n      size: :undefined,\n      type: :undefined,\n      access: :undefined,\n      atime: :undefined,\n      mtime: :undefined,\n      ctime: :undefined,\n      mode: :undefined,\n      links: :undefined,\n      major_device: :undefined,\n      minor_device: :undefined,\n      inode: :undefined,\n      uid: :undefined,\n      gid: :undefined\n    ]\n\n"}
{"completion":"","prompt":"Elixir.Record.extract_all(opts): Extracts all records information from an Erlang file.\n\nReturns a keyword list of `{record_name, fields}` tuples where `record_name`\nis the name of an extracted record and `fields` is a list of `{field, value}`\ntuples representing the fields for that record.\n\n## Options\n\nAccepts the same options as listed for `Record.extract/2`.\n\n"}
{"completion":"","prompt":"Elixir.Regex.compile(source, options \\\\ \"\"): Compiles the regular expression.\n\nThe given options can either be a binary with the characters\nrepresenting the same regex options given to the\n`~r` (see `sigil_r/2`) sigil, or a list of options, as\nexpected by the Erlang's [`:re`](`:re`) module.\n\nIt returns `{:ok, regex}` in case of success,\n`{:error, reason}` otherwise.\n\n## Examples\n\n    iex> Regex.compile(\"foo\")\n    {:ok, ~r/foo/}\n\n    iex> Regex.compile(\"*foo\")\n    {:error, {'nothing to repeat', 0}}\n\n    iex> Regex.compile(\"foo\", \"i\")\n    {:ok, ~r/foo/i}\n\n    iex> Regex.compile(\"foo\", [:caseless])\n    {:ok, Regex.compile!(\"foo\", [:caseless])}\n\n"}
{"completion":"","prompt":"Elixir.Regex.compile!(source, options \\\\ \"\"): Compiles the regular expression and raises `Regex.CompileError` in case of errors.\n"}
{"completion":"","prompt":"Elixir.Regex.escape(string): Escapes a string to be literally matched in a regex.\n\n## Examples\n\n    iex> Regex.escape(\".\")\n    \"\\\\.\"\n\n    iex> Regex.escape(\"\\\\what if\")\n    \"\\\\\\\\what\\\\ if\"\n\n"}
{"completion":"","prompt":"Elixir.Regex.match?(regex, string): Returns a boolean indicating whether there was a match or not.\n\n## Examples\n\n    iex> Regex.match?(~r/foo/, \"foo\")\n    true\n\n    iex> Regex.match?(~r/foo/, \"bar\")\n    false\n\nElixir also provides text-based match operator `=~/2` and function `String.match?/2` as\nan alternative to test strings against regular expressions and\nstrings.\n"}
{"completion":"","prompt":"Elixir.Regex.named_captures(regex, string, options \\\\ []): Returns the given captures as a map or `nil` if no captures are found.\n\n## Options\n\n  * `:return` - when set to `:index`, returns byte index and match length.\n    Defaults to `:binary`.\n\n## Examples\n\n    iex> Regex.named_captures(~r/c(?<foo>d)/, \"abcd\")\n    %{\"foo\" => \"d\"}\n\n    iex> Regex.named_captures(~r/a(?<foo>b)c(?<bar>d)/, \"abcd\")\n    %{\"bar\" => \"d\", \"foo\" => \"b\"}\n\n    iex> Regex.named_captures(~r/a(?<foo>b)c(?<bar>d)/, \"efgh\")\n    nil\n\n"}
{"completion":"","prompt":"Elixir.Regex.names(regex): Returns a list of names in the regex.\n\n## Examples\n\n    iex> Regex.names(~r/(?<foo>bar)/)\n    [\"foo\"]\n\n"}
{"completion":"","prompt":"Elixir.Regex.opts(regex): Returns the regex options, as a string or list depending on how\nit was compiled.\n\nSee the documentation of `Regex.compile/2` for more information.\n\n## Examples\n\n    iex> Regex.opts(~r/foo/m)\n    \"m\"\n\n    iex> Regex.opts(Regex.compile!(\"foo\", [:caseless]))\n    [:caseless]\n\n"}
{"completion":"","prompt":"Elixir.Regex.re_pattern(regex): Returns the underlying `re_pattern` in the regular expression.\n"}
{"completion":"","prompt":"Elixir.Regex.recompile(regex): Recompiles the existing regular expression if necessary.\n\nThis checks the version stored in the regular expression\nand recompiles the regex in case of version mismatch.\n"}
{"completion":"","prompt":"Elixir.Regex.recompile!(regex): Recompiles the existing regular expression and raises `Regex.CompileError` in case of errors.\n"}
{"completion":"","prompt":"Elixir.Regex.regex?(term): Returns `true` if the given `term` is a regex.\nOtherwise returns `false`.\n"}
{"completion":"","prompt":"Elixir.Regex.replace(regex, string, replacement, options \\\\ []): Receives a regex, a binary and a replacement, returns a new\nbinary where all matches are replaced by the replacement.\n\nThe replacement can be either a string or a function. The string\nis used as a replacement for every match and it allows specific\ncaptures to be accessed via `\\N` or `\\g{N}`, where `N` is the\ncapture. In case `\\0` is used, the whole match is inserted. Note\nthat in regexes the backslash needs to be escaped, hence in practice\nyou'll need to use `\\\\N` and `\\\\g{N}`.\n\nWhen the replacement is a function, the function may have arity\nN where each argument maps to a capture, with the first argument\nbeing the whole match. If the function expects more arguments\nthan captures found, the remaining arguments will receive `\"\"`.\n\n## Options\n\n  * `:global` - when `false`, replaces only the first occurrence\n    (defaults to `true`)\n\n## Examples\n\n    iex> Regex.replace(~r/d/, \"abc\", \"d\")\n    \"abc\"\n\n    iex> Regex.replace(~r/b/, \"abc\", \"d\")\n    \"adc\"\n\n    iex> Regex.replace(~r/b/, \"abc\", \"[\\\\0]\")\n    \"a[b]c\"\n\n    iex> Regex.replace(~r/a(b|d)c/, \"abcadc\", \"[\\\\1]\")\n    \"[b][d]\"\n\n    iex> Regex.replace(~r/\\.(\\d)$/, \"500.5\", \".\\\\g{1}0\")\n    \"500.50\"\n\n    iex> Regex.replace(~r/a(b|d)c/, \"abcadc\", fn _, x -> \"[#{x}]\" end)\n    \"[b][d]\"\n\n    iex> Regex.replace(~r/a/, \"abcadc\", \"A\", global: false)\n    \"Abcadc\"\n\n"}
{"completion":"","prompt":"Elixir.Regex.run(regex, string, options \\\\ []): Runs the regular expression against the given string until the first match.\nIt returns a list with all captures or `nil` if no match occurred.\n\n## Options\n\n  * `:return` - when set to `:index`, returns byte index and match length.\n    Defaults to `:binary`.\n  * `:capture` - what to capture in the result. Check the moduledoc for `Regex`\n    to see the possible capture values.\n  * `:offset` - (since v1.12.0) specifies the starting offset to match in the given string.\n    Defaults to zero.\n\n## Examples\n\n    iex> Regex.run(~r/c(d)/, \"abcd\")\n    [\"cd\", \"d\"]\n\n    iex> Regex.run(~r/e/, \"abcd\")\n    nil\n\n    iex> Regex.run(~r/c(d)/, \"abcd\", return: :index)\n    [{2, 2}, {3, 1}]\n\n"}
{"completion":"","prompt":"Elixir.Regex.scan(regex, string, options \\\\ []): Same as `run/3`, but scans the target several times collecting all\nmatches of the regular expression.\n\nA list of lists is returned, where each entry in the primary list represents a\nmatch and each entry in the secondary list represents the captured contents.\n\n## Options\n\n  * `:return` - when set to `:index`, returns byte index and match length.\n    Defaults to `:binary`.\n  * `:capture` - what to capture in the result. Check the moduledoc for `Regex`\n    to see the possible capture values.\n  * `:offset` - (since v1.12.0) specifies the starting offset to match in the given string.\n    Defaults to zero.\n\n## Examples\n\n    iex> Regex.scan(~r/c(d|e)/, \"abcd abce\")\n    [[\"cd\", \"d\"], [\"ce\", \"e\"]]\n\n    iex> Regex.scan(~r/c(?:d|e)/, \"abcd abce\")\n    [[\"cd\"], [\"ce\"]]\n\n    iex> Regex.scan(~r/e/, \"abcd\")\n    []\n\n    iex> Regex.scan(~r/\\p{Sc}/u, \"$, Â£, and â¬\")\n    [[\"$\"], [\"Â£\"], [\"â¬\"]]\n\n    iex> Regex.scan(~r/=+/, \"=Ã¼â Æ8===\", return: :index)\n    [[{0, 1}], [{9, 3}]]\n\n"}
{"completion":"","prompt":"Elixir.Regex.source(regex): Returns the regex source as a binary.\n\n## Examples\n\n    iex> Regex.source(~r/foo/)\n    \"foo\"\n\n"}
{"completion":"","prompt":"Elixir.Regex.split(regex, string, options \\\\ []): Splits the given target based on the given pattern and in the given number of\nparts.\n\n## Options\n\n  * `:parts` - when specified, splits the string into the given number of\n    parts. If not specified, `:parts` defaults to `:infinity`, which will\n    split the string into the maximum number of parts possible based on the\n    given pattern.\n\n  * `:trim` - when `true`, removes empty strings (`\"\"`) from the result.\n    Defaults to `false`.\n\n  * `:on` - specifies which captures to split the string on, and in what\n    order. Defaults to `:first` which means captures inside the regex do not\n    affect the splitting process.\n\n  * `:include_captures` - when `true`, includes in the result the matches of\n    the regular expression. The matches are not counted towards the maximum\n    number of parts if combined with the `:parts` option. Defaults to `false`.\n\n## Examples\n\n    iex> Regex.split(~r{-}, \"a-b-c\")\n    [\"a\", \"b\", \"c\"]\n\n    iex> Regex.split(~r{-}, \"a-b-c\", parts: 2)\n    [\"a\", \"b-c\"]\n\n    iex> Regex.split(~r{-}, \"abc\")\n    [\"abc\"]\n\n    iex> Regex.split(~r{}, \"abc\")\n    [\"\", \"a\", \"b\", \"c\", \"\"]\n\n    iex> Regex.split(~r{a(?<second>b)c}, \"abc\")\n    [\"\", \"\"]\n\n    iex> Regex.split(~r{a(?<second>b)c}, \"abc\", on: [:second])\n    [\"a\", \"c\"]\n\n    iex> Regex.split(~r{(x)}, \"Elixir\", include_captures: true)\n    [\"Eli\", \"x\", \"ir\"]\n\n    iex> Regex.split(~r{a(?<second>b)c}, \"abc\", on: [:second], include_captures: true)\n    [\"a\", \"b\", \"c\"]\n\n"}
{"completion":"","prompt":"Elixir.Regex.version(): Returns the version of the underlying Regex engine.\n"}
{"completion":"","prompt":"Elixir.Registry.Partition.child_spec(init_arg): Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.\n"}
{"completion":"","prompt":"Elixir.Registry.Partition.key_name(registry, partition): Returns the name of key partition table.\n"}
{"completion":"","prompt":"Elixir.Registry.Partition.pid_name(name, partition): Returns the name of pid partition table.\n"}
{"completion":"","prompt":"Elixir.Registry.Partition.start_link(registry, arg): Starts the registry partition.\n\nThe process is only responsible for monitoring, demonitoring\nand cleaning up when monitored processes crash.\n"}
{"completion":"","prompt":"Elixir.Registry.Supervisor.child_spec(init_arg): Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.\n"}
{"completion":"","prompt":"Elixir.Registry.child_spec(options): Returns a specification to start a registry under a supervisor.\n\nSee `Supervisor`.\n"}
{"completion":"","prompt":"Elixir.Registry.count(registry): Returns the number of registered keys in a registry.\nIt runs in constant time.\n\n## Examples\nIn the example below we register the current process and ask for the\nnumber of keys in the registry:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueCountTest)\n    iex> Registry.count(Registry.UniqueCountTest)\n    0\n    iex> {:ok, _} = Registry.register(Registry.UniqueCountTest, \"hello\", :world)\n    iex> {:ok, _} = Registry.register(Registry.UniqueCountTest, \"world\", :world)\n    iex> Registry.count(Registry.UniqueCountTest)\n    2\n\nThe same applies to duplicate registries:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateCountTest)\n    iex> Registry.count(Registry.DuplicateCountTest)\n    0\n    iex> {:ok, _} = Registry.register(Registry.DuplicateCountTest, \"hello\", :world)\n    iex> {:ok, _} = Registry.register(Registry.DuplicateCountTest, \"hello\", :world)\n    iex> Registry.count(Registry.DuplicateCountTest)\n    2\n\n"}
{"completion":"","prompt":"Elixir.Registry.count_match(registry, key, pattern, guards \\\\ []): Returns the number of `{pid, value}` pairs under the given `key` in `registry`\nthat match `pattern`.\n\nPattern must be an atom or a tuple that will match the structure of the\nvalue stored in the registry. The atom `:_` can be used to ignore a given\nvalue or tuple element, while the atom `:\"$1\"` can be used to temporarily assign part\nof pattern to a variable for a subsequent comparison.\n\nOptionally, it is possible to pass a list of guard conditions for more precise matching.\nEach guard is a tuple, which describes checks that should be passed by assigned part of pattern.\nFor example the `$1 > 1` guard condition would be expressed as the `{:>, :\"$1\", 1}` tuple.\nPlease note that guard conditions will work only for assigned\nvariables like `:\"$1\"`, `:\"$2\"`, and so forth.\nAvoid usage of special match variables `:\"$_\"` and `:\"$$\"`, because it might not work as expected.\n\nZero will be returned if there is no match.\n\nFor unique registries, a single partition lookup is necessary. For\nduplicate registries, all partitions must be looked up.\n\n## Examples\n\nIn the example below we register the current process under the same\nkey in a duplicate registry but with different values:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.CountMatchTest)\n    iex> {:ok, _} = Registry.register(Registry.CountMatchTest, \"hello\", {1, :atom, 1})\n    iex> {:ok, _} = Registry.register(Registry.CountMatchTest, \"hello\", {2, :atom, 2})\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {1, :_, :_})\n    1\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {2, :_, :_})\n    1\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {:_, :atom, :_})\n    2\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {:\"$1\", :_, :\"$1\"})\n    2\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {:_, :_, :\"$1\"}, [{:>, :\"$1\", 1}])\n    1\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {:_, :\"$1\", :_}, [{:is_atom, :\"$1\"}])\n    2\n\n"}
{"completion":"","prompt":"Elixir.Registry.count_select(registry, spec): Works like `select/2`, but only returns the number of matching records.\n\n## Examples\n\nIn the example below we register the current process under different\nkeys in a unique registry but with the same value:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.CountSelectTest)\n    iex> {:ok, _} = Registry.register(Registry.CountSelectTest, \"hello\", :value)\n    iex> {:ok, _} = Registry.register(Registry.CountSelectTest, \"world\", :value)\n    iex> Registry.count_select(Registry.CountSelectTest, [{{:_, :_, :value}, [], [true]}])\n    2\n"}
{"completion":"","prompt":"Elixir.Registry.delete_meta(registry, key): Deletes registry metadata for the given `key` in `registry`.\n\n## Examples\n\n    iex> Registry.start_link(keys: :unique, name: Registry.DeleteMetaTest)\n    iex> Registry.put_meta(Registry.DeleteMetaTest, :custom_key, \"custom_value\")\n    :ok\n    iex> Registry.meta(Registry.DeleteMetaTest, :custom_key)\n    {:ok, \"custom_value\"}\n    iex> Registry.delete_meta(Registry.DeleteMetaTest, :custom_key)\n    :ok\n    iex> Registry.meta(Registry.DeleteMetaTest, :custom_key)\n    :error\n\n"}
{"completion":"","prompt":"Elixir.Registry.dispatch(registry, key, mfa_or_fun, opts \\\\ []): Invokes the callback with all entries under `key` in each partition\nfor the given `registry`.\n\nThe list of `entries` is a non-empty list of two-element tuples where\nthe first element is the PID and the second element is the value\nassociated to the PID. If there are no entries for the given key,\nthe callback is never invoked.\n\nIf the registry is partitioned, the callback is invoked multiple times\nper partition. If the registry is partitioned and `parallel: true` is\ngiven as an option, the dispatching happens in parallel. In both cases,\nthe callback is only invoked if there are entries for that partition.\n\nSee the module documentation for examples of using the `dispatch/3`\nfunction for building custom dispatching or a pubsub system.\n"}
{"completion":"","prompt":"Elixir.Registry.keys(registry, pid): Returns the known keys for the given `pid` in `registry` in no particular order.\n\nIf the registry is unique, the keys are unique. Otherwise\nthey may contain duplicates if the process was registered\nunder the same key multiple times. The list will be empty\nif the process is dead or it has no keys in this registry.\n\n## Examples\n\nRegistering under a unique registry does not allow multiple entries:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueKeysTest)\n    iex> Registry.keys(Registry.UniqueKeysTest, self())\n    []\n    iex> {:ok, _} = Registry.register(Registry.UniqueKeysTest, \"hello\", :world)\n    iex> Registry.register(Registry.UniqueKeysTest, \"hello\", :later) # registry is :unique\n    {:error, {:already_registered, self()}}\n    iex> Registry.keys(Registry.UniqueKeysTest, self())\n    [\"hello\"]\n\nSuch is possible for duplicate registries though:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateKeysTest)\n    iex> Registry.keys(Registry.DuplicateKeysTest, self())\n    []\n    iex> {:ok, _} = Registry.register(Registry.DuplicateKeysTest, \"hello\", :world)\n    iex> {:ok, _} = Registry.register(Registry.DuplicateKeysTest, \"hello\", :world)\n    iex> Registry.keys(Registry.DuplicateKeysTest, self())\n    [\"hello\", \"hello\"]\n\n"}
{"completion":"","prompt":"Elixir.Registry.lookup(registry, key): Finds the `{pid, value}` pair for the given `key` in `registry` in no particular order.\n\nAn empty list if there is no match.\n\nFor unique registries, a single partition lookup is necessary. For\nduplicate registries, all partitions must be looked up.\n\n## Examples\n\nIn the example below we register the current process and look it up\nboth from itself and other processes:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueLookupTest)\n    iex> Registry.lookup(Registry.UniqueLookupTest, \"hello\")\n    []\n    iex> {:ok, _} = Registry.register(Registry.UniqueLookupTest, \"hello\", :world)\n    iex> Registry.lookup(Registry.UniqueLookupTest, \"hello\")\n    [{self(), :world}]\n    iex> Task.async(fn -> Registry.lookup(Registry.UniqueLookupTest, \"hello\") end) |> Task.await()\n    [{self(), :world}]\n\nThe same applies to duplicate registries:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateLookupTest)\n    iex> Registry.lookup(Registry.DuplicateLookupTest, \"hello\")\n    []\n    iex> {:ok, _} = Registry.register(Registry.DuplicateLookupTest, \"hello\", :world)\n    iex> Registry.lookup(Registry.DuplicateLookupTest, \"hello\")\n    [{self(), :world}]\n    iex> {:ok, _} = Registry.register(Registry.DuplicateLookupTest, \"hello\", :another)\n    iex> Enum.sort(Registry.lookup(Registry.DuplicateLookupTest, \"hello\"))\n    [{self(), :another}, {self(), :world}]\n\n"}
{"completion":"","prompt":"Elixir.Registry.match(registry, key, pattern, guards \\\\ []): Returns `{pid, value}` pairs under the given `key` in `registry` that match `pattern`.\n\nPattern must be an atom or a tuple that will match the structure of the\nvalue stored in the registry. The atom `:_` can be used to ignore a given\nvalue or tuple element, while the atom `:\"$1\"` can be used to temporarily assign part\nof pattern to a variable for a subsequent comparison.\n\nOptionally, it is possible to pass a list of guard conditions for more precise matching.\nEach guard is a tuple, which describes checks that should be passed by assigned part of pattern.\nFor example the `$1 > 1` guard condition would be expressed as the `{:>, :\"$1\", 1}` tuple.\nPlease note that guard conditions will work only for assigned\nvariables like `:\"$1\"`, `:\"$2\"`, and so forth.\nAvoid usage of special match variables `:\"$_\"` and `:\"$$\"`, because it might not work as expected.\n\nAn empty list will be returned if there is no match.\n\nFor unique registries, a single partition lookup is necessary. For\nduplicate registries, all partitions must be looked up.\n\n## Examples\n\nIn the example below we register the current process under the same\nkey in a duplicate registry but with different values:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.MatchTest)\n    iex> {:ok, _} = Registry.register(Registry.MatchTest, \"hello\", {1, :atom, 1})\n    iex> {:ok, _} = Registry.register(Registry.MatchTest, \"hello\", {2, :atom, 2})\n    iex> Registry.match(Registry.MatchTest, \"hello\", {1, :_, :_})\n    [{self(), {1, :atom, 1}}]\n    iex> Registry.match(Registry.MatchTest, \"hello\", {2, :_, :_})\n    [{self(), {2, :atom, 2}}]\n    iex> Registry.match(Registry.MatchTest, \"hello\", {:_, :atom, :_}) |> Enum.sort()\n    [{self(), {1, :atom, 1}}, {self(), {2, :atom, 2}}]\n    iex> Registry.match(Registry.MatchTest, \"hello\", {:\"$1\", :_, :\"$1\"}) |> Enum.sort()\n    [{self(), {1, :atom, 1}}, {self(), {2, :atom, 2}}]\n    iex> guards = [{:>, :\"$1\", 1}]\n    iex> Registry.match(Registry.MatchTest, \"hello\", {:_, :_, :\"$1\"}, guards)\n    [{self(), {2, :atom, 2}}]\n    iex> guards = [{:is_atom, :\"$1\"}]\n    iex> Registry.match(Registry.MatchTest, \"hello\", {:_, :\"$1\", :_}, guards) |> Enum.sort()\n    [{self(), {1, :atom, 1}}, {self(), {2, :atom, 2}}]\n\n"}
{"completion":"","prompt":"Elixir.Registry.meta(registry, key): Reads registry metadata given on `start_link/1`.\n\nAtoms and tuples are allowed as keys.\n\n## Examples\n\n    iex> Registry.start_link(keys: :unique, name: Registry.MetaTest, meta: [custom_key: \"custom_value\"])\n    iex> Registry.meta(Registry.MetaTest, :custom_key)\n    {:ok, \"custom_value\"}\n    iex> Registry.meta(Registry.MetaTest, :unknown_key)\n    :error\n\n"}
{"completion":"","prompt":"Elixir.Registry.put_meta(registry, key, value): Stores registry metadata.\n\nAtoms and tuples are allowed as keys.\n\n## Examples\n\n    iex> Registry.start_link(keys: :unique, name: Registry.PutMetaTest)\n    iex> Registry.put_meta(Registry.PutMetaTest, :custom_key, \"custom_value\")\n    :ok\n    iex> Registry.meta(Registry.PutMetaTest, :custom_key)\n    {:ok, \"custom_value\"}\n    iex> Registry.put_meta(Registry.PutMetaTest, {:tuple, :key}, \"tuple_value\")\n    :ok\n    iex> Registry.meta(Registry.PutMetaTest, {:tuple, :key})\n    {:ok, \"tuple_value\"}\n\n"}
{"completion":"","prompt":"Elixir.Registry.register(registry, key, value): Registers the current process under the given `key` in `registry`.\n\nA value to be associated with this registration must also be given.\nThis value will be retrieved whenever dispatching or doing a key\nlookup.\n\nThis function returns `{:ok, owner}` or `{:error, reason}`.\nThe `owner` is the PID in the registry partition responsible for\nthe PID. The owner is automatically linked to the caller.\n\nIf the registry has unique keys, it will return `{:ok, owner}` unless\nthe key is already associated to a PID, in which case it returns\n`{:error, {:already_registered, pid}}`.\n\nIf the registry has duplicate keys, multiple registrations from the\ncurrent process under the same key are allowed.\n\n## Examples\n\nRegistering under a unique registry does not allow multiple entries:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueRegisterTest)\n    iex> {:ok, _} = Registry.register(Registry.UniqueRegisterTest, \"hello\", :world)\n    iex> Registry.register(Registry.UniqueRegisterTest, \"hello\", :later)\n    {:error, {:already_registered, self()}}\n    iex> Registry.keys(Registry.UniqueRegisterTest, self())\n    [\"hello\"]\n\nSuch is possible for duplicate registries though:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateRegisterTest)\n    iex> {:ok, _} = Registry.register(Registry.DuplicateRegisterTest, \"hello\", :world)\n    iex> {:ok, _} = Registry.register(Registry.DuplicateRegisterTest, \"hello\", :world)\n    iex> Registry.keys(Registry.DuplicateRegisterTest, self())\n    [\"hello\", \"hello\"]\n\n"}
{"completion":"","prompt":"Elixir.Registry.select(registry, spec): Select key, pid, and values registered using full match specs.\n\nThe `spec` consists of a list of three part tuples, in the shape of `[{match_pattern, guards, body}]`.\n\nThe first part, the match pattern, must be a tuple that will match the structure of the\nthe data stored in the registry, which is `{key, pid, value}`. The atom `:_` can be used to\nignore a given value or tuple element, while the atom `:\"$1\"` can be used to temporarily\nassign part of pattern to a variable for a subsequent comparison. This can be combined\nlike `{:\"$1\", :_, :_}`.\n\nThe second part, the guards, is a list of conditions that allow filtering the results.\nEach guard is a tuple, which describes checks that should be passed by assigned part of pattern.\nFor example the `$1 > 1` guard condition would be expressed as the `{:>, :\"$1\", 1}` tuple.\nPlease note that guard conditions will work only for assigned\nvariables like `:\"$1\"`, `:\"$2\"`, and so forth.\n\nThe third part, the body, is a list of shapes of the returned entries. Like guards, you have access to\nassigned variables like `:\"$1\"`, which you can combine with hardcoded values to freely shape entries\nNote that tuples have to be wrapped in an additional tuple. To get a result format like\n`%{key: key, pid: pid, value: value}`, assuming you bound those variables in order in the match part,\nyou would provide a body like `[%{key: :\"$1\", pid: :\"$2\", value: :\"$3\"}]`. Like guards, you can use\nsome operations like `:element` to modify the output format.\n\nDo not use special match variables `:\"$_\"` and `:\"$$\"`, because they might not work as expected.\n\nNote that for large registries with many partitions this will be costly as it builds the result by\nconcatenating all the partitions.\n\n## Examples\n\nThis example shows how to get everything from the registry:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.SelectAllTest)\n    iex> {:ok, _} = Registry.register(Registry.SelectAllTest, \"hello\", :value)\n    iex> {:ok, _} = Registry.register(Registry.SelectAllTest, \"world\", :value)\n    iex> Registry.select(Registry.SelectAllTest, [{{:\"$1\", :\"$2\", :\"$3\"}, [], [{{:\"$1\", :\"$2\", :\"$3\"}}]}])\n    [{\"world\", self(), :value}, {\"hello\", self(), :value}]\n\nGet all keys in the registry:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.SelectAllTest)\n    iex> {:ok, _} = Registry.register(Registry.SelectAllTest, \"hello\", :value)\n    iex> {:ok, _} = Registry.register(Registry.SelectAllTest, \"world\", :value)\n    iex> Registry.select(Registry.SelectAllTest, [{{:\"$1\", :_, :_}, [], [:\"$1\"]}])\n    [\"world\", \"hello\"]\n\n"}
{"completion":"","prompt":"Elixir.Registry.start_link(options): Starts the registry as a supervisor process.\n\nManually it can be started as:\n\n    Registry.start_link(keys: :unique, name: MyApp.Registry)\n\nIn your supervisor tree, you would write:\n\n    Supervisor.start_link([\n      {Registry, keys: :unique, name: MyApp.Registry}\n    ], strategy: :one_for_one)\n\nFor intensive workloads, the registry may also be partitioned (by specifying\nthe `:partitions` option). If partitioning is required then a good default is to\nset the number of partitions to the number of schedulers available:\n\n    Registry.start_link(\n      keys: :unique,\n      name: MyApp.Registry,\n      partitions: System.schedulers_online()\n    )\n\nor:\n\n    Supervisor.start_link([\n      {Registry, keys: :unique, name: MyApp.Registry, partitions: System.schedulers_online()}\n    ], strategy: :one_for_one)\n\n## Options\n\nThe registry requires the following keys:\n\n  * `:keys` - chooses if keys are `:unique` or `:duplicate`\n  * `:name` - the name of the registry and its tables\n\nThe following keys are optional:\n\n  * `:partitions` - the number of partitions in the registry. Defaults to `1`.\n  * `:listeners` - a list of named processes which are notified of `:register`\n    and `:unregister` events. The registered process must be monitored by the\n    listener if the listener wants to be notified if the registered process\n    crashes.\n  * `:meta` - a keyword list of metadata to be attached to the registry.\n\n"}
{"completion":"","prompt":"Elixir.Registry.unregister(registry, key): Unregisters all entries for the given `key` associated to the current\nprocess in `registry`.\n\nAlways returns `:ok` and automatically unlinks the current process from\nthe owner if there are no more keys associated to the current process. See\nalso `register/3` to read more about the \"owner\".\n\n## Examples\n\nFor unique registries:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueUnregisterTest)\n    iex> Registry.register(Registry.UniqueUnregisterTest, \"hello\", :world)\n    iex> Registry.keys(Registry.UniqueUnregisterTest, self())\n    [\"hello\"]\n    iex> Registry.unregister(Registry.UniqueUnregisterTest, \"hello\")\n    :ok\n    iex> Registry.keys(Registry.UniqueUnregisterTest, self())\n    []\n\nFor duplicate registries:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateUnregisterTest)\n    iex> Registry.register(Registry.DuplicateUnregisterTest, \"hello\", :world)\n    iex> Registry.register(Registry.DuplicateUnregisterTest, \"hello\", :world)\n    iex> Registry.keys(Registry.DuplicateUnregisterTest, self())\n    [\"hello\", \"hello\"]\n    iex> Registry.unregister(Registry.DuplicateUnregisterTest, \"hello\")\n    :ok\n    iex> Registry.keys(Registry.DuplicateUnregisterTest, self())\n    []\n\n"}
{"completion":"","prompt":"Elixir.Registry.unregister_match(registry, key, pattern, guards \\\\ []): Unregisters entries for keys matching a pattern associated to the current\nprocess in `registry`.\n\n## Examples\n\nFor unique registries it can be used to conditionally unregister a key on\nthe basis of whether or not it matches a particular value.\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueUnregisterMatchTest)\n    iex> Registry.register(Registry.UniqueUnregisterMatchTest, \"hello\", :world)\n    iex> Registry.keys(Registry.UniqueUnregisterMatchTest, self())\n    [\"hello\"]\n    iex> Registry.unregister_match(Registry.UniqueUnregisterMatchTest, \"hello\", :foo)\n    :ok\n    iex> Registry.keys(Registry.UniqueUnregisterMatchTest, self())\n    [\"hello\"]\n    iex> Registry.unregister_match(Registry.UniqueUnregisterMatchTest, \"hello\", :world)\n    :ok\n    iex> Registry.keys(Registry.UniqueUnregisterMatchTest, self())\n    []\n\nFor duplicate registries:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateUnregisterMatchTest)\n    iex> Registry.register(Registry.DuplicateUnregisterMatchTest, \"hello\", :world_a)\n    iex> Registry.register(Registry.DuplicateUnregisterMatchTest, \"hello\", :world_b)\n    iex> Registry.register(Registry.DuplicateUnregisterMatchTest, \"hello\", :world_c)\n    iex> Registry.keys(Registry.DuplicateUnregisterMatchTest, self())\n    [\"hello\", \"hello\", \"hello\"]\n    iex> Registry.unregister_match(Registry.DuplicateUnregisterMatchTest, \"hello\", :world_a)\n    :ok\n    iex> Registry.keys(Registry.DuplicateUnregisterMatchTest, self())\n    [\"hello\", \"hello\"]\n    iex> Registry.lookup(Registry.DuplicateUnregisterMatchTest, \"hello\")\n    [{self(), :world_b}, {self(), :world_c}]\n\n"}
{"completion":"","prompt":"Elixir.Registry.update_value(registry, key, callback): Updates the value for `key` for the current process in the unique `registry`.\n\nReturns a `{new_value, old_value}` tuple or `:error` if there\nis no such key assigned to the current process.\n\nIf a non-unique registry is given, an error is raised.\n\n## Examples\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UpdateTest)\n    iex> {:ok, _} = Registry.register(Registry.UpdateTest, \"hello\", 1)\n    iex> Registry.lookup(Registry.UpdateTest, \"hello\")\n    [{self(), 1}]\n    iex> Registry.update_value(Registry.UpdateTest, \"hello\", &(&1 + 1))\n    {2, 1}\n    iex> Registry.lookup(Registry.UpdateTest, \"hello\")\n    [{self(), 2}]\n\n"}
{"completion":"","prompt":"Elixir.Registry.values(registry, key, pid): Reads the values for the given `key` for `pid` in `registry`.\n\nFor unique registries, it is either an empty list or a list\nwith a single element. For duplicate registries, it is a list\nwith zero, one, or multiple elements.\n\n## Examples\n\nIn the example below we register the current process and look it up\nboth from itself and other processes:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueLookupTest)\n    iex> Registry.values(Registry.UniqueLookupTest, \"hello\", self())\n    []\n    iex> {:ok, _} = Registry.register(Registry.UniqueLookupTest, \"hello\", :world)\n    iex> Registry.values(Registry.UniqueLookupTest, \"hello\", self())\n    [:world]\n    iex> Task.async(fn -> Registry.values(Registry.UniqueLookupTest, \"hello\", self()) end) |> Task.await()\n    []\n    iex> parent = self()\n    iex> Task.async(fn -> Registry.values(Registry.UniqueLookupTest, \"hello\", parent) end) |> Task.await()\n    [:world]\n\nThe same applies to duplicate registries:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateLookupTest)\n    iex> Registry.values(Registry.DuplicateLookupTest, \"hello\", self())\n    []\n    iex> {:ok, _} = Registry.register(Registry.DuplicateLookupTest, \"hello\", :world)\n    iex> Registry.values(Registry.DuplicateLookupTest, \"hello\", self())\n    [:world]\n    iex> {:ok, _} = Registry.register(Registry.DuplicateLookupTest, \"hello\", :another)\n    iex> Enum.sort(Registry.values(Registry.DuplicateLookupTest, \"hello\", self()))\n    [:another, :world]\n\n"}
{"completion":"","prompt":"Elixir.Stream.chunk_by(enum, fun): Chunks the `enum` by buffering elements for which `fun` returns the same value.\n\nElements are only emitted when `fun` returns a new value or the `enum` finishes.\n\n## Examples\n\n    iex> stream = Stream.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) == 1))\n    iex> Enum.to_list(stream)\n    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n\n"}
{"completion":"","prompt":"Elixir.Stream.chunk_every(enum, count): Shortcut to `chunk_every(enum, count, count)`.\n"}
{"completion":"","prompt":"Elixir.Stream.chunk_every(enum, count, step, leftover \\\\ []): Streams the enumerable in chunks, containing `count` elements each,\nwhere each new chunk starts `step` elements into the enumerable.\n\n`step` is optional and, if not passed, defaults to `count`, i.e.\nchunks do not overlap.\n\nIf the last chunk does not have `count` elements to fill the chunk,\nelements are taken from `leftover` to fill in the chunk. If `leftover`\ndoes not have enough elements to fill the chunk, then a partial chunk\nis returned with less than `count` elements.\n\nIf `:discard` is given in `leftover`, the last chunk is discarded\nunless it has exactly `count` elements.\n\n## Examples\n\n    iex> Stream.chunk_every([1, 2, 3, 4, 5, 6], 2) |> Enum.to_list()\n    [[1, 2], [3, 4], [5, 6]]\n\n    iex> Stream.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, :discard) |> Enum.to_list()\n    [[1, 2, 3], [3, 4, 5]]\n\n    iex> Stream.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, [7]) |> Enum.to_list()\n    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n\n    iex> Stream.chunk_every([1, 2, 3, 4, 5, 6], 3, 3, []) |> Enum.to_list()\n    [[1, 2, 3], [4, 5, 6]]\n\n    iex> Stream.chunk_every([1, 2, 3, 4], 3, 3, Stream.cycle([0])) |> Enum.to_list()\n    [[1, 2, 3], [4, 0, 0]]\n\n"}
{"completion":"","prompt":"Elixir.Stream.chunk_while(enum, acc, chunk_fun, after_fun): Chunks the `enum` with fine grained control when every chunk is emitted.\n\n`chunk_fun` receives the current element and the accumulator and\nmust return `{:cont, element, acc}` to emit the given chunk and\ncontinue with accumulator or `{:cont, acc}` to not emit any chunk\nand continue with the return accumulator.\n\n`after_fun` is invoked when iteration is done and must also return\n`{:cont, element, acc}` or `{:cont, acc}`.\n\n## Examples\n\n    iex> chunk_fun = fn element, acc ->\n    ...>   if rem(element, 2) == 0 do\n    ...>     {:cont, Enum.reverse([element | acc]), []}\n    ...>   else\n    ...>     {:cont, [element | acc]}\n    ...>   end\n    ...> end\n    iex> after_fun = fn\n    ...>   [] -> {:cont, []}\n    ...>   acc -> {:cont, Enum.reverse(acc), []}\n    ...> end\n    iex> stream = Stream.chunk_while(1..10, [], chunk_fun, after_fun)\n    iex> Enum.to_list(stream)\n    [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]\n\n"}
{"completion":"","prompt":"Elixir.Stream.concat(enumerables): Creates a stream that enumerates each enumerable in an enumerable.\n\n## Examples\n\n    iex> stream = Stream.concat([1..3, 4..6, 7..9])\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n"}
{"completion":"","prompt":"Elixir.Stream.concat(first, second): Creates a stream that enumerates the first argument, followed by the second.\n\n## Examples\n\n    iex> stream = Stream.concat(1..3, 4..6)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5, 6]\n\n    iex> stream1 = Stream.cycle([1, 2, 3])\n    iex> stream2 = Stream.cycle([4, 5, 6])\n    iex> stream = Stream.concat(stream1, stream2)\n    iex> Enum.take(stream, 6)\n    [1, 2, 3, 1, 2, 3]\n\n"}
{"completion":"","prompt":"Elixir.Stream.cycle(enumerable): Creates a stream that cycles through the given enumerable,\ninfinitely.\n\n## Examples\n\n    iex> stream = Stream.cycle([1, 2, 3])\n    iex> Enum.take(stream, 5)\n    [1, 2, 3, 1, 2]\n\n"}
{"completion":"","prompt":"Elixir.Stream.dedup(enum): Creates a stream that only emits elements if they are different from the last emitted element.\n\nThis function only ever needs to store the last emitted element.\n\nElements are compared using `===/2`.\n\n## Examples\n\n    iex> Stream.dedup([1, 2, 3, 3, 2, 1]) |> Enum.to_list()\n    [1, 2, 3, 2, 1]\n\n"}
{"completion":"","prompt":"Elixir.Stream.dedup_by(enum, fun): Creates a stream that only emits elements if the result of calling `fun` on the element is\ndifferent from the (stored) result of calling `fun` on the last emitted element.\n\n## Examples\n\n    iex> Stream.dedup_by([{1, :x}, {2, :y}, {2, :z}, {1, :x}], fn {x, _} -> x end) |> Enum.to_list()\n    [{1, :x}, {2, :y}, {1, :x}]\n\n"}
{"completion":"","prompt":"Elixir.Stream.drop(enum, n): Lazily drops the next `n` elements from the enumerable.\n\nIf a negative `n` is given, it will drop the last `n` elements from\nthe collection. Note that the mechanism by which this is implemented\nwill delay the emission of any element until `n` additional elements have\nbeen emitted by the enum.\n\n## Examples\n\n    iex> stream = Stream.drop(1..10, 5)\n    iex> Enum.to_list(stream)\n    [6, 7, 8, 9, 10]\n\n    iex> stream = Stream.drop(1..10, -5)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]\n\n"}
{"completion":"","prompt":"Elixir.Stream.drop_every(enum, nth): Creates a stream that drops every `nth` element from the enumerable.\n\nThe first element is always dropped, unless `nth` is 0.\n\n`nth` must be a non-negative integer.\n\n## Examples\n\n    iex> stream = Stream.drop_every(1..10, 2)\n    iex> Enum.to_list(stream)\n    [2, 4, 6, 8, 10]\n\n    iex> stream = Stream.drop_every(1..1000, 1)\n    iex> Enum.to_list(stream)\n    []\n\n    iex> stream = Stream.drop_every([1, 2, 3, 4, 5], 0)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]\n\n"}
{"completion":"","prompt":"Elixir.Stream.drop_while(enum, fun): Lazily drops elements of the enumerable while the given\nfunction returns a truthy value.\n\n## Examples\n\n    iex> stream = Stream.drop_while(1..10, &(&1 <= 5))\n    iex> Enum.to_list(stream)\n    [6, 7, 8, 9, 10]\n\n"}
{"completion":"","prompt":"Elixir.Stream.duplicate(value, n): Duplicates the given element `n` times in a stream.\n\n`n` is an integer greater than or equal to `0`.\n\nIf `n` is `0`, an empty stream is returned.\n\n## Examples\n\n    iex> stream = Stream.duplicate(\"hello\", 0)\n    iex> Enum.to_list(stream)\n    []\n\n    iex> stream = Stream.duplicate(\"hi\", 1)\n    iex> Enum.to_list(stream)\n    [\"hi\"]\n\n    iex> stream = Stream.duplicate(\"bye\", 2)\n    iex> Enum.to_list(stream)\n    [\"bye\", \"bye\"]\n\n    iex> stream = Stream.duplicate([1, 2], 3)\n    iex> Enum.to_list(stream)\n    [[1, 2], [1, 2], [1, 2]]\n"}
{"completion":"","prompt":"Elixir.Stream.each(enum, fun): Executes the given function for each element.\n\nThe values in the stream do not change, therefore this\nfunction is useful for adding side effects (like printing)\nto a stream. See `map/2` if producing a different stream\nis desired.\n\n## Examples\n\n    iex> stream = Stream.each([1, 2, 3], fn x -> send(self(), x) end)\n    iex> Enum.to_list(stream)\n    iex> receive do: (x when is_integer(x) -> x)\n    1\n    iex> receive do: (x when is_integer(x) -> x)\n    2\n    iex> receive do: (x when is_integer(x) -> x)\n    3\n\n"}
{"completion":"","prompt":"Elixir.Stream.filter(enum, fun): Creates a stream that filters elements according to\nthe given function on enumeration.\n\n## Examples\n\n    iex> stream = Stream.filter([1, 2, 3], fn x -> rem(x, 2) == 0 end)\n    iex> Enum.to_list(stream)\n    [2]\n\n"}
{"completion":"","prompt":"Elixir.Stream.flat_map(enum, mapper): Maps the given `fun` over `enumerable` and flattens the result.\n\nThis function returns a new stream built by appending the result of invoking `fun`\non each element of `enumerable` together.\n\n## Examples\n\n    iex> stream = Stream.flat_map([1, 2, 3], fn x -> [x, x * 2] end)\n    iex> Enum.to_list(stream)\n    [1, 2, 2, 4, 3, 6]\n\n    iex> stream = Stream.flat_map([1, 2, 3], fn x -> [[x]] end)\n    iex> Enum.to_list(stream)\n    [[1], [2], [3]]\n\n"}
{"completion":"","prompt":"Elixir.Stream.intersperse(enumerable, intersperse_element): Lazily intersperses `intersperse_element` between each element of the enumeration.\n\n## Examples\n\n    iex> Stream.intersperse([1, 2, 3], 0) |> Enum.to_list()\n    [1, 0, 2, 0, 3]\n\n    iex> Stream.intersperse([1], 0) |> Enum.to_list()\n    [1]\n\n    iex> Stream.intersperse([], 0) |> Enum.to_list()\n    []\n\n"}
{"completion":"","prompt":"Elixir.Stream.interval(n): Creates a stream that emits a value after the given period `n`\nin milliseconds.\n\nThe values emitted are an increasing counter starting at `0`.\nThis operation will block the caller by the given interval\nevery time a new element is streamed.\n\nDo not use this function to generate a sequence of numbers.\nIf blocking the caller process is not necessary, use\n`Stream.iterate(0, & &1 + 1)` instead.\n\n## Examples\n\n    iex> Stream.interval(10) |> Enum.take(10)\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n"}
{"completion":"","prompt":"Elixir.Stream.into(enum, collectable, transform \\\\ fn x -> x end): Injects the stream values into the given collectable as a side-effect.\n\nThis function is often used with `run/1` since any evaluation\nis delayed until the stream is executed. See `run/1` for an example.\n"}
{"completion":"","prompt":"Elixir.Stream.iterate(start_value, next_fun): Emits a sequence of values, starting with `start_value`. Successive\nvalues are generated by calling `next_fun` on the previous value.\n\n## Examples\n\n    iex> Stream.iterate(0, &(&1 + 1)) |> Enum.take(5)\n    [0, 1, 2, 3, 4]\n\n"}
{"completion":"","prompt":"Elixir.Stream.map(enum, fun): Creates a stream that will apply the given function on\nenumeration.\n\n## Examples\n\n    iex> stream = Stream.map([1, 2, 3], fn x -> x * 2 end)\n    iex> Enum.to_list(stream)\n    [2, 4, 6]\n\n"}
{"completion":"","prompt":"Elixir.Stream.map_every(enum, nth, fun): Creates a stream that will apply the given function on\nevery `nth` element from the enumerable.\n\nThe first element is always passed to the given function.\n\n`nth` must be a non-negative integer.\n\n## Examples\n\n    iex> stream = Stream.map_every(1..10, 2, fn x -> x * 2 end)\n    iex> Enum.to_list(stream)\n    [2, 2, 6, 4, 10, 6, 14, 8, 18, 10]\n\n    iex> stream = Stream.map_every([1, 2, 3, 4, 5], 1, fn x -> x * 2 end)\n    iex> Enum.to_list(stream)\n    [2, 4, 6, 8, 10]\n\n    iex> stream = Stream.map_every(1..5, 0, fn x -> x * 2 end)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]\n\n"}
{"completion":"","prompt":"Elixir.Stream.reject(enum, fun): Creates a stream that will reject elements according to\nthe given function on enumeration.\n\n## Examples\n\n    iex> stream = Stream.reject([1, 2, 3], fn x -> rem(x, 2) == 0 end)\n    iex> Enum.to_list(stream)\n    [1, 3]\n\n"}
{"completion":"","prompt":"Elixir.Stream.repeatedly(generator_fun): Returns a stream generated by calling `generator_fun` repeatedly.\n\n## Examples\n\n    # Although not necessary, let's seed the random algorithm\n    iex> :rand.seed(:exsss, {1, 2, 3})\n    iex> Stream.repeatedly(&:rand.uniform/0) |> Enum.take(3)\n    [0.5455598952593053, 0.6039309974353404, 0.6684893034823949]\n\n"}
{"completion":"","prompt":"Elixir.Stream.resource(start_fun, next_fun, after_fun): Emits a sequence of values for the given resource.\n\nSimilar to `transform/3` but the initial accumulated value is\ncomputed lazily via `start_fun` and executes an `after_fun` at\nthe end of enumeration (both in cases of success and failure).\n\nSuccessive values are generated by calling `next_fun` with the\nprevious accumulator (the initial value being the result returned\nby `start_fun`) and it must return a tuple containing a list\nof elements to be emitted and the next accumulator. The enumeration\nfinishes if it returns `{:halt, acc}`.\n\nAs the name says, this function is useful to stream values from\nresources.\n\n## Examples\n\n    Stream.resource(\n      fn -> File.open!(\"sample\") end,\n      fn file ->\n        case IO.read(file, :line) do\n          data when is_binary(data) -> {[data], file}\n          _ -> {:halt, file}\n        end\n      end,\n      fn file -> File.close(file) end\n    )\n\n    iex> Stream.resource(\n    ...>  fn ->\n    ...>    {:ok, pid} = StringIO.open(\"string\")\n    ...>    pid\n    ...>  end,\n    ...>  fn pid ->\n    ...>    case IO.getn(pid, \"\", 1) do\n    ...>      :eof -> {:halt, pid}\n    ...>      char -> {[char], pid}\n    ...>    end\n    ...>  end,\n    ...>  fn pid -> StringIO.close(pid) end\n    ...> ) |> Enum.to_list()\n    [\"s\", \"t\", \"r\", \"i\", \"n\", \"g\"]\n\n"}
{"completion":"","prompt":"Elixir.Stream.run(stream): Runs the given stream.\n\nThis is useful when a stream needs to be run, for side effects,\nand there is no interest in its return result.\n\n## Examples\n\nOpen up a file, replace all `#` by `%` and stream to another file\nwithout loading the whole file in memory:\n\n    File.stream!(\"/path/to/file\")\n    |> Stream.map(&String.replace(&1, \"#\", \"%\"))\n    |> Stream.into(File.stream!(\"/path/to/other/file\"))\n    |> Stream.run()\n\nNo computation will be done until we call one of the `Enum` functions\nor `run/1`.\n"}
{"completion":"","prompt":"Elixir.Stream.scan(enum, fun): Creates a stream that applies the given function to each\nelement, emits the result and uses the same result as the accumulator\nfor the next computation. Uses the first element in the enumerable\nas the starting value.\n\n## Examples\n\n    iex> stream = Stream.scan(1..5, &(&1 + &2))\n    iex> Enum.to_list(stream)\n    [1, 3, 6, 10, 15]\n\n"}
{"completion":"","prompt":"Elixir.Stream.scan(enum, acc, fun): Creates a stream that applies the given function to each\nelement, emits the result and uses the same result as the accumulator\nfor the next computation. Uses the given `acc` as the starting value.\n\n## Examples\n\n    iex> stream = Stream.scan(1..5, 0, &(&1 + &2))\n    iex> Enum.to_list(stream)\n    [1, 3, 6, 10, 15]\n\n"}
{"completion":"","prompt":"Elixir.Stream.take(enum, count): Lazily takes the next `count` elements from the enumerable and stops\nenumeration.\n\nIf a negative `count` is given, the last `count` values will be taken.\nFor such, the collection is fully enumerated keeping up to `2 * count`\nelements in memory. Once the end of the collection is reached,\nthe last `count` elements will be executed. Therefore, using\na negative `count` on an infinite collection will never return.\n\n## Examples\n\n    iex> stream = Stream.take(1..100, 5)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]\n\n    iex> stream = Stream.take(1..100, -5)\n    iex> Enum.to_list(stream)\n    [96, 97, 98, 99, 100]\n\n    iex> stream = Stream.cycle([1, 2, 3]) |> Stream.take(5)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 1, 2]\n\n"}
{"completion":"","prompt":"Elixir.Stream.take_every(enum, nth): Creates a stream that takes every `nth` element from the enumerable.\n\nThe first element is always included, unless `nth` is 0.\n\n`nth` must be a non-negative integer.\n\n## Examples\n\n    iex> stream = Stream.take_every(1..10, 2)\n    iex> Enum.to_list(stream)\n    [1, 3, 5, 7, 9]\n\n    iex> stream = Stream.take_every([1, 2, 3, 4, 5], 1)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]\n\n    iex> stream = Stream.take_every(1..1000, 0)\n    iex> Enum.to_list(stream)\n    []\n\n"}
{"completion":"","prompt":"Elixir.Stream.take_while(enum, fun): Lazily takes elements of the enumerable while the given\nfunction returns a truthy value.\n\n## Examples\n\n    iex> stream = Stream.take_while(1..100, &(&1 <= 5))\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]\n\n"}
{"completion":"","prompt":"Elixir.Stream.timer(n): Creates a stream that emits a single value after `n` milliseconds.\n\nThe value emitted is `0`. This operation will block the caller by\nthe given time until the element is streamed.\n\n## Examples\n\n    iex> Stream.timer(10) |> Enum.to_list()\n    [0]\n\n"}
{"completion":"","prompt":"Elixir.Stream.transform(enum, acc, reducer): Transforms an existing stream.\n\nIt expects an accumulator and a function that receives two arguments,\nthe stream element and the updated accumulator. It must return a tuple,\nwhere the first element is a new stream (often a list) or the atom `:halt`,\nand the second element is the accumulator to be used by the next element.\n\nNote: this function is equivalent to `Enum.flat_map_reduce/3`, except this\nfunction does not return the accumulator once the stream is processed.\n\n## Examples\n\n`Stream.transform/3` is useful as it can be used as the basis to implement\nmany of the functions defined in this module. For example, we can implement\n`Stream.take(enum, n)` as follows:\n\n    iex> enum = 1001..9999\n    iex> n = 3\n    iex> stream = Stream.transform(enum, 0, fn i, acc ->\n    ...>   if acc < n, do: {[i], acc + 1}, else: {:halt, acc}\n    ...> end)\n    iex> Enum.to_list(stream)\n    [1001, 1002, 1003]\n\n`Stream.transform/5` further generalizes this function to allow wrapping\naround resources.\n"}
{"completion":"","prompt":"Elixir.Stream.transform(enum, start_fun, reducer, after_fun): Similar to `Stream.transform/5`, except `last_fun` is not supplied.\n\nThis function can be seen as a combination of `Stream.resource/3` with\n`Stream.transform/3`.\n"}
{"completion":"","prompt":"Elixir.Stream.transform(enum, start_fun, reducer, last_fun, after_fun): Transforms an existing stream with function-based start, last, and after\ncallbacks.\n\nOnce transformation starts, `start_fun` is invoked to compute the initial\naccumulator. Then, for each element in the enumerable, the `reducer` function\nis invoked with the element and the accumulator, returning new elements and a\nnew accumulator, as in `transform/3`.\n\nOnce the collection is done, `last_fun` is invoked with the accumulator to\nemit any remaining items. Then `after_fun` is invoked, to close any resource,\nbut not emitting any new items. `last_fun` is only invoked if the given\nenumerable terminates successfully (either because it is done or it halted\nitself). `after_fun` is always invoked, therefore `after_fun` must be the\none used for closing resources.\n"}
{"completion":"","prompt":"Elixir.Stream.unfold(next_acc, next_fun): Emits a sequence of values for the given accumulator.\n\nSuccessive values are generated by calling `next_fun` with the previous\naccumulator and it must return a tuple with the current value and next\naccumulator. The enumeration finishes if it returns `nil`.\n\n## Examples\n\n    iex> Stream.unfold(5, fn\n    ...>   0 -> nil\n    ...>   n -> {n, n - 1}\n    ...> end) |> Enum.to_list()\n    [5, 4, 3, 2, 1]\n\n"}
{"completion":"","prompt":"Elixir.Stream.uniq(enum): Creates a stream that only emits elements if they are unique.\n\nKeep in mind that, in order to know if an element is unique\nor not, this function needs to store all unique values emitted\nby the stream. Therefore, if the stream is infinite, the number\nof elements stored will grow infinitely, never being garbage-collected.\n\n## Examples\n\n    iex> Stream.uniq([1, 2, 3, 3, 2, 1]) |> Enum.to_list()\n    [1, 2, 3]\n\n"}
{"completion":"","prompt":"Elixir.Stream.uniq_by(enum, fun): Creates a stream that only emits elements if they are unique, by removing the\nelements for which function `fun` returned duplicate elements.\n\nThe function `fun` maps every element to a term which is used to\ndetermine if two elements are duplicates.\n\nKeep in mind that, in order to know if an element is unique\nor not, this function needs to store all unique values emitted\nby the stream. Therefore, if the stream is infinite, the number\nof elements stored will grow infinitely, never being garbage-collected.\n\n## Example\n\n    iex> Stream.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end) |> Enum.to_list()\n    [{1, :x}, {2, :y}]\n\n    iex> Stream.uniq_by([a: {:tea, 2}, b: {:tea, 2}, c: {:coffee, 1}], fn {_, y} -> y end) |> Enum.to_list()\n    [a: {:tea, 2}, c: {:coffee, 1}]\n\n"}
{"completion":"","prompt":"Elixir.Stream.with_index(enum, offset \\\\ 0): Creates a stream where each element in the enumerable will\nbe wrapped in a tuple alongside its index.\n\nIf an `offset` is given, we will index from the given offset instead of from zero.\n\n## Examples\n\n    iex> stream = Stream.with_index([1, 2, 3])\n    iex> Enum.to_list(stream)\n    [{1, 0}, {2, 1}, {3, 2}]\n\n    iex> stream = Stream.with_index([1, 2, 3], 3)\n    iex> Enum.to_list(stream)\n    [{1, 3}, {2, 4}, {3, 5}]\n\n"}
{"completion":"","prompt":"Elixir.Stream.zip(enumerables): Zips corresponding elements from a finite collection of enumerables\ninto one stream of tuples.\n\nThe zipping finishes as soon as any enumerable in the given collection completes.\n\n## Examples\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> cycle = Stream.cycle([\"foo\", \"bar\", \"baz\"])\n    iex> Stream.zip([concat, [:a, :b, :c], cycle]) |> Enum.to_list()\n    [{1, :a, \"foo\"}, {2, :b, \"bar\"}, {3, :c, \"baz\"}]\n\n"}
{"completion":"","prompt":"Elixir.Stream.zip(enumerable1, enumerable2): Zips two enumerables together, lazily.\n\nThe zipping finishes as soon as either enumerable completes.\n\n## Examples\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> cycle = Stream.cycle([:a, :b, :c])\n    iex> Stream.zip(concat, cycle) |> Enum.to_list()\n    [{1, :a}, {2, :b}, {3, :c}, {4, :a}, {5, :b}, {6, :c}]\n\n"}
{"completion":"","prompt":"Elixir.Stream.zip_with(enumerables, zip_fun): Lazily zips corresponding elements from a finite collection of enumerables into a new\nenumerable, transforming them with the `zip_fun` function as it goes.\n\nThe first element from each of the enums in `enumerables` will be put into a list which is then passed to\nthe one-arity `zip_fun` function. Then, the second elements from each of the enums are put into a list and passed to\n`zip_fun`, and so on until any one of the enums in `enumerables` completes.\n\nReturns a new enumerable with the results of calling `zip_fun`.\n\n## Examples\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> Stream.zip_with([concat, concat], fn [a, b] -> a + b end) |> Enum.to_list()\n    [2, 4, 6, 8, 10, 12]\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> Stream.zip_with([concat, concat, 1..3], fn [a, b, c] -> a + b + c end) |> Enum.to_list()\n    [3, 6, 9]\n\n"}
{"completion":"","prompt":"Elixir.Stream.zip_with(enumerable1, enumerable2, zip_fun): Lazily zips corresponding elements from two enumerables into a new one, transforming them with\nthe `zip_fun` function as it goes.\n\nThe `zip_fun` will be called with the first element from `enumerable1` and the first\nelement from `enumerable2`, then with the second element from each, and so on until\neither one of the enumerables completes.\n\n## Examples\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> Stream.zip_with(concat, concat, fn a, b -> a + b end) |> Enum.to_list()\n    [2, 4, 6, 8, 10, 12]\n\n"}
{"completion":"","prompt":"Elixir.String.Chars.to_string(term): Converts `term` to a string.\n"}
{"completion":"","prompt":"Elixir.String.at(string, position): Returns the grapheme at the `position` of the given UTF-8 `string`.\nIf `position` is greater than `string` length, then it returns `nil`.\n\n## Examples\n\n    iex> String.at(\"elixir\", 0)\n    \"e\"\n\n    iex> String.at(\"elixir\", 1)\n    \"l\"\n\n    iex> String.at(\"elixir\", 10)\n    nil\n\n    iex> String.at(\"elixir\", -1)\n    \"r\"\n\n    iex> String.at(\"elixir\", -10)\n    nil\n\n"}
{"completion":"","prompt":"Elixir.String.bag_distance(string1, string2): Computes the bag distance between two strings.\n\nReturns a float value between 0 and 1 representing the bag\ndistance between `string1` and `string2`.\n\nThe bag distance is meant to be an efficient approximation\nof the distance between two strings to quickly rule out strings\nthat are largely different.\n\nThe algorithm is outlined in the \"String Matching with Metric\nTrees Using an Approximate Distance\" paper by Ilaria Bartolini,\nPaolo Ciaccia, and Marco Patella.\n\n## Examples\n\n    iex> String.bag_distance(\"abc\", \"\")\n    0.0\n    iex> String.bag_distance(\"abcd\", \"a\")\n    0.25\n    iex> String.bag_distance(\"abcd\", \"ab\")\n    0.5\n    iex> String.bag_distance(\"abcd\", \"abc\")\n    0.75\n    iex> String.bag_distance(\"abcd\", \"abcd\")\n    1.0\n\n"}
{"completion":"","prompt":"Elixir.String.capitalize(string, mode \\\\ :default): Converts the first character in the given string to\nuppercase and the remainder to lowercase according to `mode`.\n\n`mode` may be `:default`, `:ascii`, `:greek` or `:turkic`. The `:default` mode considers\nall non-conditional transformations outlined in the Unicode standard. `:ascii`\ncapitalizes only the letters A to Z. `:greek` includes the context sensitive\nmappings found in Greek. `:turkic` properly handles the letter i with the dotless variant.\n\n## Examples\n\n    iex> String.capitalize(\"abcd\")\n    \"Abcd\"\n\n    iex> String.capitalize(\"ï¬n\")\n    \"Fin\"\n\n    iex> String.capitalize(\"olÃ¡\")\n    \"OlÃ¡\"\n\n"}
{"completion":"","prompt":"Elixir.String.chunk(string, trait): Splits the string into chunks of characters that share a common trait.\n\nThe trait can be one of two options:\n\n  * `:valid` - the string is split into chunks of valid and invalid\n    character sequences\n\n  * `:printable` - the string is split into chunks of printable and\n    non-printable character sequences\n\nReturns a list of binaries each of which contains only one kind of\ncharacters.\n\nIf the given string is empty, an empty list is returned.\n\n## Examples\n\n    iex> String.chunk(<<?a, ?b, ?c, 0>>, :valid)\n    [\"abc\\0\"]\n\n    iex> String.chunk(<<?a, ?b, ?c, 0, 0xFFFF::utf16>>, :valid)\n    [\"abc\\0\", <<0xFFFF::utf16>>]\n\n    iex> String.chunk(<<?a, ?b, ?c, 0, 0x0FFFF::utf8>>, :printable)\n    [\"abc\", <<0, 0x0FFFF::utf8>>]\n\n"}
{"completion":"","prompt":"Elixir.String.codepoints(string): Returns a list of code points encoded as strings.\n\nTo retrieve code points in their natural integer\nrepresentation, see `to_charlist/1`. For details about\ncode points and graphemes, see the `String` module\ndocumentation.\n\n## Examples\n\n    iex> String.codepoints(\"olÃ¡\")\n    [\"o\", \"l\", \"Ã¡\"]\n\n    iex> String.codepoints(\"Ð¾Ð¿ÑÐ¸Ð¼Ð¸ Ð·Ð°ÑÐ¸Ð¸\")\n    [\"Ð¾\", \"Ð¿\", \"Ñ\", \"Ð¸\", \"Ð¼\", \"Ð¸\", \" \", \"Ð·\", \"Ð°\", \"Ñ\", \"Ð¸\", \"Ð¸\"]\n\n    iex> String.codepoints(\"á¼á¼ªá¿¼\")\n    [\"á¼\", \"á¼ª\", \"á¿¼\"]\n\n    iex> String.codepoints(\"\\u00e9\")\n    [\"Ã©\"]\n\n    iex> String.codepoints(\"\\u0065\\u0301\")\n    [\"e\", \"Ì\"]\n\n"}
{"completion":"","prompt":"Elixir.String.contains?(string, contents): Searches if `string` contains any of the given `contents`.\n\n`contents` can be either a string, a list of strings,\nor a compiled pattern. If `contents` is a list, this\nfunction will search if any of the strings in `contents`\nare part of `string`.\n\n> Note: if you want to check if `string` is listed in `contents`,\n> where `contents` is a list, use `Enum.member?(contents, string)`\n> instead.\n\n## Examples\n\n    iex> String.contains?(\"elixir of life\", \"of\")\n    true\n    iex> String.contains?(\"elixir of life\", [\"life\", \"death\"])\n    true\n    iex> String.contains?(\"elixir of life\", [\"death\", \"mercury\"])\n    false\n\nThe argument can also be a compiled pattern:\n\n    iex> pattern = :binary.compile_pattern([\"life\", \"death\"])\n    iex> String.contains?(\"elixir of life\", pattern)\n    true\n\nAn empty string will always match:\n\n    iex> String.contains?(\"elixir of life\", \"\")\n    true\n    iex> String.contains?(\"elixir of life\", [\"\", \"other\"])\n    true\n\nAn empty list will never match:\n\n    iex> String.contains?(\"elixir of life\", [])\n    false\n\n    iex> String.contains?(\"\", [])\n    false\n\nBe aware that this function can match within or across grapheme boundaries.\nFor example, take the grapheme \"Ã©\" which is made of the characters\n\"e\" and the acute accent. The following returns `true`:\n\n    iex> String.contains?(String.normalize(\"Ã©\", :nfd), \"e\")\n    true\n\nHowever, if \"Ã©\" is represented by the single character \"e with acute\"\naccent, then it will return `false`:\n\n    iex> String.contains?(String.normalize(\"Ã©\", :nfc), \"e\")\n    false\n\n"}
{"completion":"","prompt":"Elixir.String.downcase(string, mode \\\\ :default): Converts all characters in the given string to lowercase according to `mode`.\n\n`mode` may be `:default`, `:ascii`, `:greek` or `:turkic`. The `:default` mode considers\nall non-conditional transformations outlined in the Unicode standard. `:ascii`\nlowercases only the letters A to Z. `:greek` includes the context sensitive\nmappings found in Greek. `:turkic` properly handles the letter i with the dotless variant.\n\n## Examples\n\n    iex> String.downcase(\"ABCD\")\n    \"abcd\"\n\n    iex> String.downcase(\"AB 123 XPTO\")\n    \"ab 123 xpto\"\n\n    iex> String.downcase(\"OLÃ\")\n    \"olÃ¡\"\n\nThe `:ascii` mode ignores Unicode characters and provides a more\nperformant implementation when you know the string contains only\nASCII characters:\n\n    iex> String.downcase(\"OLÃ\", :ascii)\n    \"olÃ\"\n\nThe `:greek` mode properly handles the context sensitive sigma in Greek:\n\n    iex> String.downcase(\"Î£Î£\")\n    \"ÏÏ\"\n\n    iex> String.downcase(\"Î£Î£\", :greek)\n    \"ÏÏ\"\n\nAnd `:turkic` properly handles the letter i with the dotless variant:\n\n    iex> String.downcase(\"IÄ°\")\n    \"iiÌ\"\n\n    iex> String.downcase(\"IÄ°\", :turkic)\n    \"Ä±i\"\n\n"}
{"completion":"","prompt":"Elixir.String.duplicate(subject, n): Returns a string `subject` repeated `n` times.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.duplicate(\"abc\", 0)\n    \"\"\n\n    iex> String.duplicate(\"abc\", 1)\n    \"abc\"\n\n    iex> String.duplicate(\"abc\", 2)\n    \"abcabc\"\n\n"}
{"completion":"","prompt":"Elixir.String.ends_with?(string, suffix): Returns `true` if `string` ends with any of the suffixes given.\n\n`suffixes` can be either a single suffix or a list of suffixes.\n\n## Examples\n\n    iex> String.ends_with?(\"language\", \"age\")\n    true\n    iex> String.ends_with?(\"language\", [\"youth\", \"age\"])\n    true\n    iex> String.ends_with?(\"language\", [\"youth\", \"elixir\"])\n    false\n\nAn empty suffix will always match:\n\n    iex> String.ends_with?(\"language\", \"\")\n    true\n    iex> String.ends_with?(\"language\", [\"\", \"other\"])\n    true\n\n"}
{"completion":"","prompt":"Elixir.String.equivalent?(string1, string2): Returns `true` if `string1` is canonically equivalent to `string2`.\n\nIt performs Normalization Form Canonical Decomposition (NFD) on the\nstrings before comparing them. This function is equivalent to:\n\n    String.normalize(string1, :nfd) == String.normalize(string2, :nfd)\n\nIf you plan to compare multiple strings, multiple times in a row, you\nmay normalize them upfront and compare them directly to avoid multiple\nnormalization passes.\n\n## Examples\n\n    iex> String.equivalent?(\"abc\", \"abc\")\n    true\n\n    iex> String.equivalent?(\"man\\u0303ana\", \"maÃ±ana\")\n    true\n\n    iex> String.equivalent?(\"abc\", \"ABC\")\n    false\n\n    iex> String.equivalent?(\"nÃ¸\", \"nÃ³\")\n    false\n\n"}
{"completion":"","prompt":"Elixir.String.first(string): Returns the first grapheme from a UTF-8 string,\n`nil` if the string is empty.\n\n## Examples\n\n    iex> String.first(\"elixir\")\n    \"e\"\n\n    iex> String.first(\"Õ¥Õ¸Õ£Õ¬Õ«\")\n    \"Õ¥\"\n\n    iex> String.first(\"\")\n    nil\n\n"}
{"completion":"","prompt":"Elixir.String.graphemes(string): Returns Unicode graphemes in the string as per Extended Grapheme\nCluster algorithm.\n\nThe algorithm is outlined in the [Unicode Standard Annex #29,\nUnicode Text Segmentation](https://www.unicode.org/reports/tr29/).\n\nFor details about code points and graphemes, see the `String` module documentation.\n\n## Examples\n\n    iex> String.graphemes(\"ÅaÃ¯ve\")\n    [\"Å\", \"a\", \"Ã¯\", \"v\", \"e\"]\n\n    iex> String.graphemes(\"\\u00e9\")\n    [\"Ã©\"]\n\n    iex> String.graphemes(\"\\u0065\\u0301\")\n    [\"eÌ\"]\n\n"}
{"completion":"","prompt":"Elixir.String.jaro_distance(string1, string2): Computes the Jaro distance (similarity) between two strings.\n\nReturns a float value between `0.0` (equates to no similarity) and `1.0`\n(is an exact match) representing [Jaro](https://en.wikipedia.org/wiki/Jaro-Winkler_distance)\ndistance between `string1` and `string2`.\n\nThe Jaro distance metric is designed and best suited for short\nstrings such as person names. Elixir itself uses this function\nto provide the \"did you mean?\" functionality. For instance, when you\nare calling a function in a module and you have a typo in the\nfunction name, we attempt to suggest the most similar function\nname available, if any, based on the `jaro_distance/2` score.\n\n## Examples\n\n    iex> String.jaro_distance(\"Dwayne\", \"Duane\")\n    0.8222222222222223\n    iex> String.jaro_distance(\"even\", \"odd\")\n    0.0\n    iex> String.jaro_distance(\"same\", \"same\")\n    1.0\n\n"}
{"completion":"","prompt":"Elixir.String.last(string): Returns the last grapheme from a UTF-8 string,\n`nil` if the string is empty.\n\nIt traverses the whole string to find its last grapheme.\n\n## Examples\n\n    iex> String.last(\"\")\n    nil\n\n    iex> String.last(\"elixir\")\n    \"r\"\n\n    iex> String.last(\"Õ¥Õ¸Õ£Õ¬Õ«\")\n    \"Õ«\"\n\n"}
{"completion":"","prompt":"Elixir.String.length(string): Returns the number of Unicode graphemes in a UTF-8 string.\n\n## Examples\n\n    iex> String.length(\"elixir\")\n    6\n\n    iex> String.length(\"Õ¥Õ¸Õ£Õ¬Õ«\")\n    5\n\n"}
{"completion":"","prompt":"Elixir.String.match?(string, regex): Checks if `string` matches the given regular expression.\n\n## Examples\n\n    iex> String.match?(\"foo\", ~r/foo/)\n    true\n\n    iex> String.match?(\"bar\", ~r/foo/)\n    false\n\nElixir also provides text-based match operator `=~/2` and function `Regex.match?/2` as\nalternatives to test strings against regular expressions.\n"}
{"completion":"","prompt":"Elixir.String.myers_difference(string1, string2): Returns a keyword list that represents an edit script.\n\nCheck `List.myers_difference/2` for more information.\n\n## Examples\n\n    iex> string1 = \"fox hops over the dog\"\n    iex> string2 = \"fox jumps over the lazy cat\"\n    iex> String.myers_difference(string1, string2)\n    [eq: \"fox \", del: \"ho\", ins: \"jum\", eq: \"ps over the \", del: \"dog\", ins: \"lazy cat\"]\n\n"}
{"completion":"","prompt":"Elixir.String.next_codepoint(arg): Returns the next code point in a string.\n\nThe result is a tuple with the code point and the\nremainder of the string or `nil` in case\nthe string reached its end.\n\nAs with other functions in the `String` module, `next_codepoint/1`\nworks with binaries that are invalid UTF-8. If the string starts\nwith a sequence of bytes that is not valid in UTF-8 encoding, the\nfirst element of the returned tuple is a binary with the first byte.\n\n## Examples\n\n    iex> String.next_codepoint(\"olÃ¡\")\n    {\"o\", \"lÃ¡\"}\n\n    iex> invalid = \"\\x80\\x80OK\" # first two bytes are invalid in UTF-8\n    iex> {_, rest} = String.next_codepoint(invalid)\n    {<<128>>, <<128, 79, 75>>}\n    iex> String.next_codepoint(rest)\n    {<<128>>, \"OK\"}\n\n## Comparison with binary pattern matching\n\nBinary pattern matching provides a similar way to decompose\na string:\n\n    iex> <<codepoint::utf8, rest::binary>> = \"Elixir\"\n    \"Elixir\"\n    iex> codepoint\n    69\n    iex> rest\n    \"lixir\"\n\nthough not entirely equivalent because `codepoint` comes as\nan integer, and the pattern won't match invalid UTF-8.\n\nBinary pattern matching, however, is simpler and more efficient,\nso pick the option that better suits your use case.\n"}
{"completion":"","prompt":"Elixir.String.next_grapheme(string): Returns the next grapheme in a string.\n\nThe result is a tuple with the grapheme and the\nremainder of the string or `nil` in case\nthe String reached its end.\n\n## Examples\n\n    iex> String.next_grapheme(\"olÃ¡\")\n    {\"o\", \"lÃ¡\"}\n\n    iex> String.next_grapheme(\"\")\n    nil\n\n"}
{"completion":"","prompt":"Elixir.String.normalize(string, form): Converts all characters in `string` to Unicode normalization\nform identified by `form`.\n\nInvalid Unicode codepoints are skipped and the remaining of\nthe string is converted. If you want the algorithm to stop\nand return on invalid codepoint, use `:unicode.characters_to_nfd_binary/1`,\n`:unicode.characters_to_nfc_binary/1`, `:unicode.characters_to_nfkd_binary/1`,\nand `:unicode.characters_to_nfkc_binary/1` instead.\n\nNormalization forms `:nfkc` and `:nfkd` should not be blindly applied\nto arbitrary text. Because they erase many formatting distinctions,\nthey will prevent round-trip conversion to and from many legacy\ncharacter sets.\n\n## Forms\n\nThe supported forms are:\n\n  * `:nfd` - Normalization Form Canonical Decomposition.\n    Characters are decomposed by canonical equivalence, and\n    multiple combining characters are arranged in a specific\n    order.\n\n  * `:nfc` - Normalization Form Canonical Composition.\n    Characters are decomposed and then recomposed by canonical equivalence.\n\n  * `:nfkd` - Normalization Form Compatibility Decomposition.\n    Characters are decomposed by compatibility equivalence, and\n    multiple combining characters are arranged in a specific\n    order.\n\n  * `:nfkc` - Normalization Form Compatibility Composition.\n    Characters are decomposed and then recomposed by compatibility equivalence.\n\n## Examples\n\n    iex> String.normalize(\"yÃªsÌÌ£\", :nfd)\n    \"yeÌsÌ£Ì\"\n\n    iex> String.normalize(\"lenÌa\", :nfc)\n    \"leÃ±a\"\n\n    iex> String.normalize(\"ï¬\", :nfkd)\n    \"fi\"\n\n    iex> String.normalize(\"fi\", :nfkc)\n    \"fi\"\n\n"}
{"completion":"","prompt":"Elixir.String.pad_leading(string, count, padding \\\\ [\" \"]): Returns a new string padded with a leading filler\nwhich is made of elements from the `padding`.\n\nPassing a list of strings as `padding` will take one element of the list\nfor every missing entry. If the list is shorter than the number of inserts,\nthe filling will start again from the beginning of the list.\nPassing a string `padding` is equivalent to passing the list of graphemes in it.\nIf no `padding` is given, it defaults to whitespace.\n\nWhen `count` is less than or equal to the length of `string`,\ngiven `string` is returned.\n\nRaises `ArgumentError` if the given `padding` contains a non-string element.\n\n## Examples\n\n    iex> String.pad_leading(\"abc\", 5)\n    \"  abc\"\n\n    iex> String.pad_leading(\"abc\", 4, \"12\")\n    \"1abc\"\n\n    iex> String.pad_leading(\"abc\", 6, \"12\")\n    \"121abc\"\n\n    iex> String.pad_leading(\"abc\", 5, [\"1\", \"23\"])\n    \"123abc\"\n\n"}
{"completion":"","prompt":"Elixir.String.pad_trailing(string, count, padding \\\\ [\" \"]): Returns a new string padded with a trailing filler\nwhich is made of elements from the `padding`.\n\nPassing a list of strings as `padding` will take one element of the list\nfor every missing entry. If the list is shorter than the number of inserts,\nthe filling will start again from the beginning of the list.\nPassing a string `padding` is equivalent to passing the list of graphemes in it.\nIf no `padding` is given, it defaults to whitespace.\n\nWhen `count` is less than or equal to the length of `string`,\ngiven `string` is returned.\n\nRaises `ArgumentError` if the given `padding` contains a non-string element.\n\n## Examples\n\n    iex> String.pad_trailing(\"abc\", 5)\n    \"abc  \"\n\n    iex> String.pad_trailing(\"abc\", 4, \"12\")\n    \"abc1\"\n\n    iex> String.pad_trailing(\"abc\", 6, \"12\")\n    \"abc121\"\n\n    iex> String.pad_trailing(\"abc\", 5, [\"1\", \"23\"])\n    \"abc123\"\n\n"}
{"completion":"","prompt":"Elixir.String.printable?(string, character_limit \\\\ :infinity): Checks if a string contains only printable characters up to `character_limit`.\n\nTakes an optional `character_limit` as a second argument. If `character_limit` is `0`, this\nfunction will return `true`.\n\n## Examples\n\n    iex> String.printable?(\"abc\")\n    true\n\n    iex> String.printable?(\"abc\" <> <<0>>)\n    false\n\n    iex> String.printable?(\"abc\" <> <<0>>, 2)\n    true\n\n    iex> String.printable?(\"abc\" <> <<0>>, 0)\n    true\n\n"}
{"completion":"","prompt":"Elixir.String.replace(subject, pattern, replacement, options \\\\ []): Returns a new string created by replacing occurrences of `pattern` in\n`subject` with `replacement`.\n\nThe `subject` is always a string.\n\nThe `pattern` may be a string, a list of strings, a regular expression, or a\ncompiled pattern.\n\nThe `replacement` may be a string or a function that receives the matched\npattern and must return the replacement as a string or iodata.\n\nBy default it replaces all occurrences but this behaviour can be controlled\nthrough the `:global` option; see the \"Options\" section below.\n\n## Options\n\n  * `:global` - (boolean) if `true`, all occurrences of `pattern` are replaced\n    with `replacement`, otherwise only the first occurrence is\n    replaced. Defaults to `true`\n\n## Examples\n\n    iex> String.replace(\"a,b,c\", \",\", \"-\")\n    \"a-b-c\"\n\n    iex> String.replace(\"a,b,c\", \",\", \"-\", global: false)\n    \"a-b,c\"\n\nThe pattern may also be a list of strings and the replacement may also\nbe a function that receives the matches:\n\n    iex> String.replace(\"a,b,c\", [\"a\", \"c\"], fn <<char>> -> <<char + 1>> end)\n    \"b,b,d\"\n\nWhen the pattern is a regular expression, one can give `\\N` or\n`\\g{N}` in the `replacement` string to access a specific capture in the\nregular expression:\n\n    iex> String.replace(\"a,b,c\", ~r/,(.)/, \",\\\\1\\\\g{1}\")\n    \"a,bb,cc\"\n\nNote that we had to escape the backslash escape character (i.e., we used `\\\\N`\ninstead of just `\\N` to escape the backslash; same thing for `\\\\g{N}`). By\ngiving `\\0`, one can inject the whole match in the replacement string.\n\nA compiled pattern can also be given:\n\n    iex> pattern = :binary.compile_pattern(\",\")\n    iex> String.replace(\"a,b,c\", pattern, \"[]\")\n    \"a[]b[]c\"\n\nWhen an empty string is provided as a `pattern`, the function will treat it as\nan implicit empty string between each grapheme and the string will be\ninterspersed. If an empty string is provided as `replacement` the `subject`\nwill be returned:\n\n    iex> String.replace(\"ELIXIR\", \"\", \".\")\n    \".E.L.I.X.I.R.\"\n\n    iex> String.replace(\"ELIXIR\", \"\", \"\")\n    \"ELIXIR\"\n\nBe aware that this function can replace within or across grapheme boundaries.\nFor example, take the grapheme \"Ã©\" which is made of the characters\n\"e\" and the acute accent. The following will replace only the letter \"e\",\nmoving the accent to the letter \"o\":\n\n    iex> String.replace(String.normalize(\"Ã©\", :nfd), \"e\", \"o\")\n    \"oÌ\"\n\nHowever, if \"Ã©\" is represented by the single character \"e with acute\"\naccent, then it won't be replaced at all:\n\n    iex> String.replace(String.normalize(\"Ã©\", :nfc), \"e\", \"o\")\n    \"Ã©\"\n\n"}
{"completion":"","prompt":"Elixir.String.replace_leading(string, match, replacement): Replaces all leading occurrences of `match` by `replacement` of `match` in `string`.\n\nReturns the string untouched if there are no occurrences.\n\nIf `match` is `\"\"`, this function raises an `ArgumentError` exception: this\nhappens because this function replaces **all** the occurrences of `match` at\nthe beginning of `string`, and it's impossible to replace \"multiple\"\noccurrences of `\"\"`.\n\n## Examples\n\n    iex> String.replace_leading(\"hello world\", \"hello \", \"\")\n    \"world\"\n    iex> String.replace_leading(\"hello hello world\", \"hello \", \"\")\n    \"world\"\n\n    iex> String.replace_leading(\"hello world\", \"hello \", \"ola \")\n    \"ola world\"\n    iex> String.replace_leading(\"hello hello world\", \"hello \", \"ola \")\n    \"ola ola world\"\n\nThis function can replace across grapheme boundaries. See `replace/3`\nfor more information and examples.\n"}
{"completion":"","prompt":"Elixir.String.replace_prefix(string, match, replacement): Replaces prefix in `string` by `replacement` if it matches `match`.\n\nReturns the string untouched if there is no match. If `match` is an empty\nstring (`\"\"`), `replacement` is just prepended to `string`.\n\n## Examples\n\n    iex> String.replace_prefix(\"world\", \"hello \", \"\")\n    \"world\"\n    iex> String.replace_prefix(\"hello world\", \"hello \", \"\")\n    \"world\"\n    iex> String.replace_prefix(\"hello hello world\", \"hello \", \"\")\n    \"hello world\"\n\n    iex> String.replace_prefix(\"world\", \"hello \", \"ola \")\n    \"world\"\n    iex> String.replace_prefix(\"hello world\", \"hello \", \"ola \")\n    \"ola world\"\n    iex> String.replace_prefix(\"hello hello world\", \"hello \", \"ola \")\n    \"ola hello world\"\n\n    iex> String.replace_prefix(\"world\", \"\", \"hello \")\n    \"hello world\"\n\nThis function can replace across grapheme boundaries. See `replace/3`\nfor more information and examples.\n"}
{"completion":"","prompt":"Elixir.String.replace_suffix(string, match, replacement): Replaces suffix in `string` by `replacement` if it matches `match`.\n\nReturns the string untouched if there is no match. If `match` is an empty\nstring (`\"\"`), `replacement` is just appended to `string`.\n\n## Examples\n\n    iex> String.replace_suffix(\"hello\", \" world\", \"\")\n    \"hello\"\n    iex> String.replace_suffix(\"hello world\", \" world\", \"\")\n    \"hello\"\n    iex> String.replace_suffix(\"hello world world\", \" world\", \"\")\n    \"hello world\"\n\n    iex> String.replace_suffix(\"hello\", \" world\", \" mundo\")\n    \"hello\"\n    iex> String.replace_suffix(\"hello world\", \" world\", \" mundo\")\n    \"hello mundo\"\n    iex> String.replace_suffix(\"hello world world\", \" world\", \" mundo\")\n    \"hello world mundo\"\n\n    iex> String.replace_suffix(\"hello\", \"\", \" world\")\n    \"hello world\"\n\nThis function can replace across grapheme boundaries. See `replace/3`\nfor more information and examples.\n"}
{"completion":"","prompt":"Elixir.String.replace_trailing(string, match, replacement): Replaces all trailing occurrences of `match` by `replacement` in `string`.\n\nReturns the string untouched if there are no occurrences.\n\nIf `match` is `\"\"`, this function raises an `ArgumentError` exception: this\nhappens because this function replaces **all** the occurrences of `match` at\nthe end of `string`, and it's impossible to replace \"multiple\" occurrences of\n`\"\"`.\n\n## Examples\n\n    iex> String.replace_trailing(\"hello world\", \" world\", \"\")\n    \"hello\"\n    iex> String.replace_trailing(\"hello world world\", \" world\", \"\")\n    \"hello\"\n\n    iex> String.replace_trailing(\"hello world\", \" world\", \" mundo\")\n    \"hello mundo\"\n    iex> String.replace_trailing(\"hello world world\", \" world\", \" mundo\")\n    \"hello mundo mundo\"\n\nThis function can replace across grapheme boundaries. See `replace/3`\nfor more information and examples.\n"}
{"completion":"","prompt":"Elixir.String.reverse(string): Reverses the graphemes in given string.\n\n## Examples\n\n    iex> String.reverse(\"abcd\")\n    \"dcba\"\n\n    iex> String.reverse(\"hello world\")\n    \"dlrow olleh\"\n\n    iex> String.reverse(\"hello âog\")\n    \"goâ olleh\"\n\nKeep in mind reversing the same string twice does\nnot necessarily yield the original string:\n\n    iex> \"Ìe\"\n    \"Ìe\"\n    iex> String.reverse(\"Ìe\")\n    \"eÌ\"\n    iex> String.reverse(String.reverse(\"Ìe\"))\n    \"eÌ\"\n\nIn the first example the accent is before the vowel, so\nit is considered two graphemes. However, when you reverse\nit once, you have the vowel followed by the accent, which\nbecomes one grapheme. Reversing it again will keep it as\none single grapheme.\n"}
{"completion":"","prompt":"Elixir.String.slice(string, range): Returns a substring from the offset given by the start of the\nrange to the offset given by the end of the range.\n\nIf the start of the range is not a valid offset for the given\nstring or if the range is in reverse order, returns `\"\"`.\n\nIf the start or end of the range is negative, the whole string\nis traversed first in order to convert the negative indices into\npositive ones.\n\nRemember this function works with Unicode graphemes and considers\nthe slices to represent grapheme offsets. If you want to split\non raw bytes, check `Kernel.binary_part/3` or\n`Kernel.binary_slice/2` instead\n\n## Examples\n\n    iex> String.slice(\"elixir\", 1..3)\n    \"lix\"\n    iex> String.slice(\"elixir\", 1..10)\n    \"lixir\"\n\n    iex> String.slice(\"elixir\", -4..-1)\n    \"ixir\"\n    iex> String.slice(\"elixir\", -4..6)\n    \"ixir\"\n    iex> String.slice(\"elixir\", -100..100)\n    \"elixir\"\n\nFor ranges where `start > stop`, you need to explicitly\nmark them as increasing:\n\n    iex> String.slice(\"elixir\", 2..-1//1)\n    \"ixir\"\n    iex> String.slice(\"elixir\", 1..-2//1)\n    \"lixi\"\n\nYou can use `../0` as a shortcut for `0..-1//1`, which returns\nthe whole string as is:\n\n    iex> String.slice(\"elixir\", ..)\n    \"elixir\"\n\nThe step can be any positive number. For example, to\nget every 2 characters of the string:\n\n    iex> String.slice(\"elixir\", 0..-1//2)\n    \"eii\"\n\nIf the first position is after the string ends or after\nthe last position of the range, it returns an empty string:\n\n    iex> String.slice(\"elixir\", 10..3)\n    \"\"\n    iex> String.slice(\"a\", 1..1500)\n    \"\"\n\n"}
{"completion":"","prompt":"Elixir.String.slice(string, start, length): Returns a substring starting at the offset `start`, and of the given `length`.\n\nIf the offset is greater than string length, then it returns `\"\"`.\n\nRemember this function works with Unicode graphemes and considers\nthe slices to represent grapheme offsets. If you want to split\non raw bytes, check `Kernel.binary_part/3` or `Kernel.binary_slice/3`\ninstead.\n\n## Examples\n\n    iex> String.slice(\"elixir\", 1, 3)\n    \"lix\"\n\n    iex> String.slice(\"elixir\", 1, 10)\n    \"lixir\"\n\n    iex> String.slice(\"elixir\", 10, 3)\n    \"\"\n\nIf the start position is negative, it is normalized\nagainst the string length and clamped to 0:\n\n    iex> String.slice(\"elixir\", -4, 4)\n    \"ixir\"\n\n    iex> String.slice(\"elixir\", -10, 3)\n    \"eli\"\n\nIf start is more than the string length, an empty\nstring is returned:\n\n    iex> String.slice(\"elixir\", 10, 1500)\n    \"\"\n\n"}
{"completion":"","prompt":"Elixir.String.split(binary): Divides a string into substrings at each Unicode whitespace\noccurrence with leading and trailing whitespace ignored. Groups\nof whitespace are treated as a single occurrence. Divisions do\nnot occur on non-breaking whitespace.\n\n## Examples\n\n    iex> String.split(\"foo bar\")\n    [\"foo\", \"bar\"]\n\n    iex> String.split(\"foo\" <> <<194, 133>> <> \"bar\")\n    [\"foo\", \"bar\"]\n\n    iex> String.split(\" foo   bar \")\n    [\"foo\", \"bar\"]\n\n    iex> String.split(\"no\\u00a0break\")\n    [\"no\\u00a0break\"]\n\n"}
{"completion":"","prompt":"Elixir.String.split(string, pattern, options \\\\ []): Divides a string into parts based on a pattern.\n\nReturns a list of these parts.\n\nThe `pattern` may be a string, a list of strings, a regular expression, or a\ncompiled pattern.\n\nThe string is split into as many parts as possible by\ndefault, but can be controlled via the `:parts` option.\n\nEmpty strings are only removed from the result if the\n`:trim` option is set to `true`.\n\nWhen the pattern used is a regular expression, the string is\nsplit using `Regex.split/3`.\n\n## Options\n\n  * `:parts` (positive integer or `:infinity`) - the string\n    is split into at most as many parts as this option specifies.\n    If `:infinity`, the string will be split into all possible\n    parts. Defaults to `:infinity`.\n\n  * `:trim` (boolean) - if `true`, empty strings are removed from\n    the resulting list.\n\nThis function also accepts all options accepted by `Regex.split/3`\nif `pattern` is a regular expression.\n\n## Examples\n\nSplitting with a string pattern:\n\n    iex> String.split(\"a,b,c\", \",\")\n    [\"a\", \"b\", \"c\"]\n\n    iex> String.split(\"a,b,c\", \",\", parts: 2)\n    [\"a\", \"b,c\"]\n\n    iex> String.split(\" a b c \", \" \", trim: true)\n    [\"a\", \"b\", \"c\"]\n\nA list of patterns:\n\n    iex> String.split(\"1,2 3,4\", [\" \", \",\"])\n    [\"1\", \"2\", \"3\", \"4\"]\n\nA regular expression:\n\n    iex> String.split(\"a,b,c\", ~r{,})\n    [\"a\", \"b\", \"c\"]\n\n    iex> String.split(\"a,b,c\", ~r{,}, parts: 2)\n    [\"a\", \"b,c\"]\n\n    iex> String.split(\" a b c \", ~r{\\s}, trim: true)\n    [\"a\", \"b\", \"c\"]\n\n    iex> String.split(\"abc\", ~r{b}, include_captures: true)\n    [\"a\", \"b\", \"c\"]\n\nA compiled pattern:\n\n    iex> pattern = :binary.compile_pattern([\" \", \",\"])\n    iex> String.split(\"1,2 3,4\", pattern)\n    [\"1\", \"2\", \"3\", \"4\"]\n\nSplitting on empty string returns graphemes:\n\n    iex> String.split(\"abc\", \"\")\n    [\"\", \"a\", \"b\", \"c\", \"\"]\n\n    iex> String.split(\"abc\", \"\", trim: true)\n    [\"a\", \"b\", \"c\"]\n\n    iex> String.split(\"abc\", \"\", parts: 1)\n    [\"abc\"]\n\n    iex> String.split(\"abc\", \"\", parts: 3)\n    [\"\", \"a\", \"bc\"]\n\nBe aware that this function can split within or across grapheme boundaries.\nFor example, take the grapheme \"Ã©\" which is made of the characters\n\"e\" and the acute accent. The following will split the string into two parts:\n\n    iex> String.split(String.normalize(\"Ã©\", :nfd), \"e\")\n    [\"\", \"Ì\"]\n\nHowever, if \"Ã©\" is represented by the single character \"e with acute\"\naccent, then it will split the string into just one part:\n\n    iex> String.split(String.normalize(\"Ã©\", :nfc), \"e\")\n    [\"Ã©\"]\n\n"}
{"completion":"","prompt":"Elixir.String.split_at(string, position): Splits a string into two at the specified offset. When the offset given is\nnegative, location is counted from the end of the string.\n\nThe offset is capped to the length of the string. Returns a tuple with\ntwo elements.\n\nNote: keep in mind this function splits on graphemes and for such it\nhas to linearly traverse the string. If you want to split a string or\na binary based on the number of bytes, use `Kernel.binary_part/3`\ninstead.\n\n## Examples\n\n    iex> String.split_at(\"sweetelixir\", 5)\n    {\"sweet\", \"elixir\"}\n\n    iex> String.split_at(\"sweetelixir\", -6)\n    {\"sweet\", \"elixir\"}\n\n    iex> String.split_at(\"abc\", 0)\n    {\"\", \"abc\"}\n\n    iex> String.split_at(\"abc\", 1000)\n    {\"abc\", \"\"}\n\n    iex> String.split_at(\"abc\", -1000)\n    {\"\", \"abc\"}\n\n"}
{"completion":"","prompt":"Elixir.String.splitter(string, pattern, options \\\\ []): Returns an enumerable that splits a string on demand.\n\nThis is in contrast to `split/3` which splits the\nentire string upfront.\n\nThis function does not support regular expressions\nby design. When using regular expressions, it is often\nmore efficient to have the regular expressions traverse\nthe string at once than in parts, like this function does.\n\n## Options\n\n  * :trim - when `true`, does not emit empty patterns\n\n## Examples\n\n    iex> String.splitter(\"1,2 3,4 5,6 7,8,...,99999\", [\" \", \",\"]) |> Enum.take(4)\n    [\"1\", \"2\", \"3\", \"4\"]\n\n    iex> String.splitter(\"abcd\", \"\") |> Enum.take(10)\n    [\"\", \"a\", \"b\", \"c\", \"d\", \"\"]\n\n    iex> String.splitter(\"abcd\", \"\", trim: true) |> Enum.take(10)\n    [\"a\", \"b\", \"c\", \"d\"]\n\nA compiled pattern can also be given:\n\n    iex> pattern = :binary.compile_pattern([\" \", \",\"])\n    iex> String.splitter(\"1,2 3,4 5,6 7,8,...,99999\", pattern) |> Enum.take(4)\n    [\"1\", \"2\", \"3\", \"4\"]\n\n"}
{"completion":"","prompt":"Elixir.String.starts_with?(string, prefix): Returns `true` if `string` starts with any of the prefixes given.\n\n`prefix` can be either a string, a list of strings, or a compiled\npattern.\n\n## Examples\n\n    iex> String.starts_with?(\"elixir\", \"eli\")\n    true\n    iex> String.starts_with?(\"elixir\", [\"erlang\", \"elixir\"])\n    true\n    iex> String.starts_with?(\"elixir\", [\"erlang\", \"ruby\"])\n    false\n\nAn empty string will always match:\n\n    iex> String.starts_with?(\"elixir\", \"\")\n    true\n    iex> String.starts_with?(\"elixir\", [\"\", \"other\"])\n    true\n\nAn empty list will never match:\n\n    iex> String.starts_with?(\"elixir\", [])\n    false\n\n    iex> String.starts_with?(\"\", [])\n    false\n\n"}
{"completion":"","prompt":"Elixir.String.to_atom(string): Converts a string to an atom.\n\nWarning: this function creates atoms dynamically and atoms are\nnot garbage-collected. Therefore, `string` should not be an\nuntrusted value, such as input received from a socket or during\na web request. Consider using `to_existing_atom/1` instead.\n\nBy default, the maximum number of atoms is `1_048_576`. This limit\ncan be raised or lowered using the VM option `+t`.\n\nThe maximum atom size is of 255 Unicode code points.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.to_atom(\"my_atom\")\n    :my_atom\n\n"}
{"completion":"","prompt":"Elixir.String.to_charlist(string): Converts a string into a charlist.\n\nSpecifically, this function takes a UTF-8 encoded binary and returns a list of its integer\ncode points. It is similar to `codepoints/1` except that the latter returns a list of code points as\nstrings.\n\nIn case you need to work with bytes, take a look at the\n[`:binary` module](`:binary`).\n\n## Examples\n\n    iex> String.to_charlist(\"Ã¦Ã\")\n    'Ã¦Ã'\n\n"}
{"completion":"","prompt":"Elixir.String.to_existing_atom(string): Converts a string to an existing atom.\n\nThe maximum atom size is of 255 Unicode code points.\nRaises an `ArgumentError` if the atom does not exist.\n\nInlined by the compiler.\n\n> #### Atoms and modules {: .info}\n>\n> Since Elixir is a compiled language, the atoms defined in a module\n> will only exist after said module is loaded, which typically happens\n> whenever a function in the module is executed. Therefore, it is\n> generally recommended to call `String.to_existing_atom/1` only to\n> convert atoms defined within the module making the function call\n> to `to_existing_atom/1`.\n\n## Examples\n\n    iex> _ = :my_atom\n    iex> String.to_existing_atom(\"my_atom\")\n    :my_atom\n\n"}
{"completion":"","prompt":"Elixir.String.to_float(string): Returns a float whose text representation is `string`.\n\n`string` must be the string representation of a float including a decimal point.\nIn order to parse a string without decimal point as a float then `Float.parse/1`\nshould be used. Otherwise, an `ArgumentError` will be raised.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.to_float(\"2.2017764e+0\")\n    2.2017764\n\n    iex> String.to_float(\"3.0\")\n    3.0\n\n    String.to_float(\"3\")\n    ** (ArgumentError) argument error\n\n"}
{"completion":"","prompt":"Elixir.String.to_integer(string): Returns an integer whose text representation is `string`.\n\n`string` must be the string representation of an integer.\nOtherwise, an `ArgumentError` will be raised. If you want\nto parse a string that may contain an ill-formatted integer,\nuse `Integer.parse/1`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.to_integer(\"123\")\n    123\n\nPassing a string that does not represent an integer leads to an error:\n\n    String.to_integer(\"invalid data\")\n    ** (ArgumentError) argument error\n\n"}
{"completion":"","prompt":"Elixir.String.to_integer(string, base): Returns an integer whose text representation is `string` in base `base`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.to_integer(\"3FF\", 16)\n    1023\n\n"}
{"completion":"","prompt":"Elixir.String.trim(string): Returns a string where all leading and trailing Unicode whitespaces\nhave been removed.\n\n## Examples\n\n    iex> String.trim(\"\\n  abc\\n  \")\n    \"abc\"\n\n"}
{"completion":"","prompt":"Elixir.String.trim(string, to_trim): Returns a string where all leading and trailing `to_trim` characters have been\nremoved.\n\n## Examples\n\n    iex> String.trim(\"a  abc  a\", \"a\")\n    \"  abc  \"\n\n"}
{"completion":"","prompt":"Elixir.String.trim_leading(string): Returns a string where all leading Unicode whitespaces\nhave been removed.\n\n## Examples\n\n    iex> String.trim_leading(\"\\n  abc   \")\n    \"abc   \"\n\n"}
{"completion":"","prompt":"Elixir.String.trim_leading(string, to_trim): Returns a string where all leading `to_trim` characters have been removed.\n\n## Examples\n\n    iex> String.trim_leading(\"__ abc _\", \"_\")\n    \" abc _\"\n\n    iex> String.trim_leading(\"1 abc\", \"11\")\n    \"1 abc\"\n\n"}
{"completion":"","prompt":"Elixir.String.trim_trailing(string): Returns a string where all trailing Unicode whitespaces\nhas been removed.\n\n## Examples\n\n    iex> String.trim_trailing(\"   abc\\n  \")\n    \"   abc\"\n\n"}
{"completion":"","prompt":"Elixir.String.trim_trailing(string, to_trim): Returns a string where all trailing `to_trim` characters have been removed.\n\n## Examples\n\n    iex> String.trim_trailing(\"_ abc __\", \"_\")\n    \"_ abc \"\n\n    iex> String.trim_trailing(\"abc 1\", \"11\")\n    \"abc 1\"\n\n"}
{"completion":"","prompt":"Elixir.String.upcase(string, mode \\\\ :default): Converts all characters in the given string to uppercase according to `mode`.\n\n`mode` may be `:default`, `:ascii`, `:greek` or `:turkic`. The `:default` mode considers\nall non-conditional transformations outlined in the Unicode standard. `:ascii`\nuppercases only the letters a to z. `:greek` includes the context sensitive\nmappings found in Greek. `:turkic` properly handles the letter i with the dotless variant.\n\n## Examples\n\n    iex> String.upcase(\"abcd\")\n    \"ABCD\"\n\n    iex> String.upcase(\"ab 123 xpto\")\n    \"AB 123 XPTO\"\n\n    iex> String.upcase(\"olÃ¡\")\n    \"OLÃ\"\n\nThe `:ascii` mode ignores Unicode characters and provides a more\nperformant implementation when you know the string contains only\nASCII characters:\n\n    iex> String.upcase(\"olÃ¡\", :ascii)\n    \"OLÃ¡\"\n\nAnd `:turkic` properly handles the letter i with the dotless variant:\n\n    iex> String.upcase(\"Ä±i\")\n    \"II\"\n\n    iex> String.upcase(\"Ä±i\", :turkic)\n    \"IÄ°\"\n\n"}
{"completion":"","prompt":"Elixir.String.valid?(string): Checks whether `string` contains only valid characters.\n\n## Examples\n\n    iex> String.valid?(\"a\")\n    true\n\n    iex> String.valid?(\"Ã¸\")\n    true\n\n    iex> String.valid?(<<0xFFFF::16>>)\n    false\n\n    iex> String.valid?(<<0xEF, 0xB7, 0x90>>)\n    true\n\n    iex> String.valid?(\"asd\" <> <<0xFFFF::16>>)\n    false\n\n"}
{"completion":"","prompt":"Elixir.StringIO.close(pid): Stops the IO device and returns the remaining input/output\nbuffers.\n\n## Examples\n\n    iex> {:ok, pid} = StringIO.open(\"in\")\n    iex> IO.write(pid, \"out\")\n    iex> StringIO.close(pid)\n    {:ok, {\"in\", \"out\"}}\n\n"}
{"completion":"","prompt":"Elixir.StringIO.contents(pid): Returns the current input/output buffers for the given IO\ndevice.\n\n## Examples\n\n    iex> {:ok, pid} = StringIO.open(\"in\")\n    iex> IO.write(pid, \"out\")\n    iex> StringIO.contents(pid)\n    {\"in\", \"out\"}\n\n"}
{"completion":"","prompt":"Elixir.StringIO.flush(pid): Flushes the output buffer and returns its current contents.\n\n## Examples\n\n    iex> {:ok, pid} = StringIO.open(\"in\")\n    iex> IO.write(pid, \"out\")\n    iex> StringIO.flush(pid)\n    \"out\"\n    iex> StringIO.contents(pid)\n    {\"in\", \"\"}\n\n"}
{"completion":"","prompt":"Elixir.StringIO.open(string, options_or_function \\\\ []): Creates an IO device.\n\n`string` will be the initial input of the newly created\ndevice.\n\n`options_or_function` can be a keyword list of options or\na function.\n\nIf options are provided, the result will be `{:ok, pid}`, returning the\nIO device created. The option `:capture_prompt`, when set to `true`, causes\nprompts (which are specified as arguments to `IO.get*` functions) to be\nincluded in the device's output.\n\nIf a function is provided, the device will be created and sent to the\nfunction. When the function returns, the device will be closed. The final\nresult will be a tuple with `:ok` and the result of the function.\n\n## Examples\n\n    iex> {:ok, pid} = StringIO.open(\"foo\")\n    iex> IO.gets(pid, \">\")\n    \"foo\"\n    iex> StringIO.contents(pid)\n    {\"\", \"\"}\n\n    iex> {:ok, pid} = StringIO.open(\"foo\", capture_prompt: true)\n    iex> IO.gets(pid, \">\")\n    \"foo\"\n    iex> StringIO.contents(pid)\n    {\"\", \">\"}\n\n    iex> StringIO.open(\"foo\", fn pid ->\n    ...>   input = IO.gets(pid, \">\")\n    ...>   IO.write(pid, \"The input was #{input}\")\n    ...>   StringIO.contents(pid)\n    ...> end)\n    {:ok, {\"\", \"The input was foo\"}}\n\n"}
{"completion":"","prompt":"Elixir.StringIO.open(string, options, function): Creates an IO device.\n\n`string` will be the initial input of the newly created\ndevice.\n\nThe device will be created and sent to the function given.\nWhen the function returns, the device will be closed. The final\nresult will be a tuple with `:ok` and the result of the function.\n\n## Options\n\n  * `:capture_prompt` - if set to `true`, prompts (specified as\n    arguments to `IO.get*` functions) are captured in the output.\n    Defaults to `false`.\n\n  * `:encoding` (since v1.10.0) - encoding of the IO device. Allowed\n    values are `:unicode` (default) and `:latin1`.\n\n## Examples\n\n    iex> StringIO.open(\"foo\", [], fn pid ->\n    ...>   input = IO.gets(pid, \">\")\n    ...>   IO.write(pid, \"The input was #{input}\")\n    ...>   StringIO.contents(pid)\n    ...> end)\n    {:ok, {\"\", \"The input was foo\"}}\n\n    iex> StringIO.open(\"foo\", [capture_prompt: true], fn pid ->\n    ...>   input = IO.gets(pid, \">\")\n    ...>   IO.write(pid, \"The input was #{input}\")\n    ...>   StringIO.contents(pid)\n    ...> end)\n    {:ok, {\"\", \">The input was foo\"}}\n\n"}
{"completion":"","prompt":"Elixir.Supervisor.Spec.supervise(children, options): Receives a list of `children` (workers or supervisors) to\nsupervise and a set of `options`.\n\nReturns a tuple containing the supervisor specification. This tuple can be\nused as the return value of the `c:Supervisor.init/1` callback when implementing a\nmodule-based supervisor.\n\n## Examples\n\n    supervise(children, strategy: :one_for_one)\n\n## Options\n\n  * `:strategy` - the restart strategy option. It can be either\n    `:one_for_one`, `:rest_for_one`, `:one_for_all`, or\n    `:simple_one_for_one`. You can learn more about strategies\n    in the `Supervisor` module docs.\n\n  * `:max_restarts` - the maximum number of restarts allowed in\n    a time frame. Defaults to `3`.\n\n  * `:max_seconds` - the time frame in which `:max_restarts` applies.\n    Defaults to `5`.\n\nThe `:strategy` option is required and by default a maximum of 3 restarts is\nallowed within 5 seconds. Check the `Supervisor` module for a detailed\ndescription of the available strategies.\n"}
{"completion":"","prompt":"Elixir.Supervisor.Spec.supervisor(module, args, options \\\\ []): Defines the given `module` as a supervisor which will be started\nwith the given arguments.\n\n    supervisor(module, [], restart: :permanent)\n\nBy default, the function `start_link` is invoked on the given\nmodule. Overall, the default values for the options are:\n\n    [\n      id: module,\n      function: :start_link,\n      restart: :permanent,\n      shutdown: :infinity,\n      modules: [module]\n    ]\n\nSee the \"Supervisor and worker options\" section in the `Supervisor.Spec` module for more\ninformation on the available options.\n"}
{"completion":"","prompt":"Elixir.Supervisor.Spec.worker(module, args, options \\\\ []): Defines the given `module` as a worker which will be started\nwith the given arguments.\n\n    worker(ExUnit.Runner, [], restart: :permanent)\n\nBy default, the function `start_link` is invoked on the given\nmodule. Overall, the default values for the options are:\n\n    [\n      id: module,\n      function: :start_link,\n      restart: :permanent,\n      shutdown: 5000,\n      modules: [module]\n    ]\n\nSee the \"Supervisor and worker options\" section in the `Supervisor.Spec` module for more\ninformation on the available options.\n"}
{"completion":"","prompt":"Elixir.Supervisor.child_spec(module_or_map, overrides): Builds and overrides a child specification.\n\nSimilar to `start_link/2` and `init/2`, it expects a module, `{module, arg}`,\nor a [child specification](`t:child_spec/0`).\n\nIf a two-element tuple in the shape of `{module, arg}` is given,\nthe child specification is retrieved by calling `module.child_spec(arg)`.\n\nIf a module is given, the child specification is retrieved by calling\n`module.child_spec([])`.\n\nAfter the child specification is retrieved, the fields on `overrides`\nare directly applied on the child spec. If `overrides` has keys that\ndo not map to any child specification field, an error is raised.\n\nSee the \"Child specification\" section in the module documentation\nfor all of the available keys for overriding.\n\n## Examples\n\nThis function is often used to set an `:id` option when\nthe same module needs to be started multiple times in the\nsupervision tree:\n\n    Supervisor.child_spec({Agent, fn -> :ok end}, id: {Agent, 1})\n    #=> %{id: {Agent, 1},\n    #=>   start: {Agent, :start_link, [fn -> :ok end]}}\n\n"}
{"completion":"","prompt":"Elixir.Supervisor.count_children(supervisor): Returns a map containing count values for the given supervisor.\n\nThe map contains the following keys:\n\n  * `:specs` - the total count of children, dead or alive\n\n  * `:active` - the count of all actively running child processes managed by\n    this supervisor\n\n  * `:supervisors` - the count of all supervisors whether or not these\n    child supervisors are still alive\n\n  * `:workers` - the count of all workers, whether or not these child workers\n    are still alive\n\n"}
{"completion":"","prompt":"Elixir.Supervisor.delete_child(supervisor, child_id): Deletes the child specification identified by `child_id`.\n\nThe corresponding child process must not be running; use `terminate_child/2`\nto terminate it if it's running.\n\nIf successful, this function returns `:ok`. This function may return an error\nwith an appropriate error tuple if the `child_id` is not found, or if the\ncurrent process is running or being restarted.\n"}
{"completion":"","prompt":"Elixir.Supervisor.init(children, options): Receives a list of child specifications to initialize and a set of `options`.\n\nThis is typically invoked at the end of the `c:init/1` callback of\nmodule-based supervisors. See the sections \"Supervisor strategies and options\" and\n\"Module-based supervisors\" in the module documentation for more information.\n\nThis function returns a tuple containing the supervisor\nflags and child specifications.\n\n## Examples\n\n    def init(_init_arg) do\n      children = [\n        {Counter, 0}\n      ]\n\n      Supervisor.init(children, strategy: :one_for_one)\n    end\n\n## Options\n\n  * `:strategy` - the supervision strategy option. It can be either\n    `:one_for_one`, `:rest_for_one`, or `:one_for_all`\n\n  * `:max_restarts` - the maximum number of restarts allowed in\n    a time frame. Defaults to `3`.\n\n  * `:max_seconds` - the time frame in seconds in which `:max_restarts`\n    applies. Defaults to `5`.\n\nThe `:strategy` option is required and by default a maximum of 3 restarts\nis allowed within 5 seconds. Check the `Supervisor` module for a detailed\ndescription of the available strategies.\n"}
{"completion":"","prompt":"Elixir.Supervisor.restart_child(supervisor, child_id): Restarts a child process identified by `child_id`.\n\nThe child specification must exist and the corresponding child process must not\nbe running.\n\nNote that for temporary children, the child specification is automatically deleted\nwhen the child terminates, and thus it is not possible to restart such children.\n\nIf the child process start function returns `{:ok, child}` or `{:ok, child, info}`,\nthe PID is added to the supervisor and this function returns the same value.\n\nIf the child process start function returns `:ignore`, the PID remains set to\n`:undefined` and this function returns `{:ok, :undefined}`.\n\nThis function may return an error with an appropriate error tuple if the\n`child_id` is not found, or if the current process is running or being\nrestarted.\n\nIf the child process start function returns an error tuple or an erroneous value,\nor if it fails, this function returns `{:error, error}`.\n"}
{"completion":"","prompt":"Elixir.Supervisor.start_child(supervisor, child_spec): Adds a child specification to `supervisor` and starts that child.\n\n`child_spec` should be a valid child specification. The child process will\nbe started as defined in the child specification.\n\nIf a child specification with the specified ID already exists, `child_spec` is\ndiscarded and this function returns an error with `:already_started` or\n`:already_present` if the corresponding child process is running or not,\nrespectively.\n\nIf the child process start function returns `{:ok, child}` or `{:ok, child,\ninfo}`, then child specification and PID are added to the supervisor and\nthis function returns the same value.\n\nIf the child process start function returns `:ignore`, the child specification\nis added to the supervisor, the PID is set to `:undefined` and this function\nreturns `{:ok, :undefined}`.\n\nIf the child process start function returns an error tuple or an erroneous\nvalue, or if it fails, the child specification is discarded and this function\nreturns `{:error, error}` where `error` is a term containing information about\nthe error and child specification.\n"}
{"completion":"","prompt":"Elixir.Supervisor.start_link(children, options): Starts a supervisor with the given children.\n\n`children` is a list of the following forms:\n\n  * a [child specification](`t:child_spec/0`)\n\n  * a module, where `module.child_spec([])` will be invoked to retrieve\n    its child specification\n\n  * a two-element tuple in the shape of `{module, arg}`, where `module.child_spec(arg)`\n    will be invoked to retrieve its child specification\n\nA strategy is required to be provided through the `:strategy` option. See\n\"Supervisor strategies and options\" for examples and other options.\n\nThe options can also be used to register a supervisor name.\nThe supported values are described under the \"Name registration\"\nsection in the `GenServer` module docs.\n\nIf the supervisor and all child processes are successfully spawned\n(if the start function of each child process returns `{:ok, child}`,\n`{:ok, child, info}`, or `:ignore`), this function returns\n`{:ok, pid}`, where `pid` is the PID of the supervisor. If the supervisor\nis given a name and a process with the specified name already exists,\nthe function returns `{:error, {:already_started, pid}}`, where `pid`\nis the PID of that process.\n\nIf the start function of any of the child processes fails or returns an error\ntuple or an erroneous value, the supervisor first terminates with reason\n`:shutdown` all the child processes that have already been started, and then\nterminates itself and returns `{:error, {:shutdown, reason}}`.\n\nNote that a supervisor started with this function is linked to the parent\nprocess and exits not only on crashes but also if the parent process exits\nwith `:normal` reason.\n"}
{"completion":"","prompt":"Elixir.Supervisor.start_link(module, init_arg, options \\\\ []): Starts a module-based supervisor process with the given `module` and `init_arg`.\n\nTo start the supervisor, the `c:init/1` callback will be invoked in the given\n`module`, with `init_arg` as its argument. The `c:init/1` callback must return a\nsupervisor specification which can be created with the help of the `init/2`\nfunction.\n\nIf the `c:init/1` callback returns `:ignore`, this function returns\n`:ignore` as well and the supervisor terminates with reason `:normal`.\nIf it fails or returns an incorrect value, this function returns\n`{:error, term}` where `term` is a term with information about the\nerror, and the supervisor terminates with reason `term`.\n\nThe `:name` option can also be given in order to register a supervisor\nname, the supported values are described in the \"Name registration\"\nsection in the `GenServer` module docs.\n"}
{"completion":"","prompt":"Elixir.Supervisor.stop(supervisor, reason \\\\ :normal, timeout \\\\ :infinity): Synchronously stops the given supervisor with the given `reason`.\n\nIt returns `:ok` if the supervisor terminates with the given\nreason. If it terminates with another reason, the call exits.\n\nThis function keeps OTP semantics regarding error reporting.\nIf the reason is any other than `:normal`, `:shutdown` or\n`{:shutdown, _}`, an error report is logged.\n"}
{"completion":"","prompt":"Elixir.Supervisor.terminate_child(supervisor, child_id): Terminates the given child identified by `child_id`.\n\nThe process is terminated, if there's one. The child specification is\nkept unless the child is temporary.\n\nA non-temporary child process may later be restarted by the supervisor.\nThe child process can also be restarted explicitly by calling `restart_child/2`.\nUse `delete_child/2` to remove the child specification.\n\nIf successful, this function returns `:ok`. If there is no child\nspecification for the given child ID, this function returns\n`{:error, :not_found}`.\n"}
{"completion":"","prompt":"Elixir.Supervisor.which_children(supervisor): Returns a list with information about all children of the given supervisor.\n\nNote that calling this function when supervising a large number of children\nunder low memory conditions can cause an out of memory exception.\n\nThis function returns a list of `{id, child, type, modules}` tuples, where:\n\n  * `id` - as defined in the child specification\n\n  * `child` - the PID of the corresponding child process, `:restarting` if the\n    process is about to be restarted, or `:undefined` if there is no such\n    process\n\n  * `type` - `:worker` or `:supervisor`, as specified by the child specification\n\n  * `modules` - as specified by the child specification\n\n"}
{"completion":"","prompt":"Elixir.System.argv(): Lists command line arguments.\n\nReturns the list of command line arguments passed to the program.\n"}
{"completion":"","prompt":"Elixir.System.argv(args): Modifies command line arguments.\n\nChanges the list of command line arguments. Use it with caution,\nas it destroys any previous argv information.\n"}
{"completion":"","prompt":"Elixir.System.at_exit(fun): Registers a program exit handler function.\n\nRegisters a function that will be invoked at the end of an Elixir script.\nA script is typically started via the command line via the `elixir` and\n`mix` executables.\n\nThe handler always executes in a different process from the one it was\nregistered in. As a consequence, any resources managed by the calling process\n(ETS tables, open files, and others) won't be available by the time the handler\nfunction is invoked.\n\nThe function must receive the exit status code as an argument.\n\nIf the VM terminates programmatically, via `System.stop/1`, `System.halt/1`,\nor exit signals, the `at_exit/1` callbacks are not executed.\n"}
{"completion":"","prompt":"Elixir.System.build_info(): Elixir build information.\n\nReturns a map with the Elixir version, the Erlang/OTP release it was compiled\nwith, a short Git revision hash and the date and time it was built.\n\nEvery value in the map is a string, and these are:\n\n  * `:build` - the Elixir version, short Git revision hash and\n    Erlang/OTP release it was compiled with\n  * `:date` - a string representation of the ISO8601 date and time it was built\n  * `:otp_release` - OTP release it was compiled with\n  * `:revision` - short Git revision hash. If Git was not available at building\n    time, it is set to `\"\"`\n  * `:version` - the Elixir version\n\nOne should not rely on the specific formats returned by each of those fields.\nInstead one should use specialized functions, such as `version/0` to retrieve\nthe Elixir version and `otp_release/0` to retrieve the Erlang/OTP release.\n\n## Examples\n\n    iex> System.build_info()\n    %{\n      build: \"1.9.0-dev (772a00a0c) (compiled with Erlang/OTP 21)\",\n      date: \"2018-12-24T01:09:21Z\",\n      otp_release: \"21\",\n      revision: \"772a00a0c\",\n      version: \"1.9.0-dev\"\n    }\n\n"}
{"completion":"","prompt":"Elixir.System.cmd(command, args, opts \\\\ []): Executes the given `command` with `args`.\n\n`command` is expected to be an executable available in PATH\nunless an absolute path is given.\n\n`args` must be a list of binaries which the executable will receive\nas its arguments as is. This means that:\n\n  * environment variables will not be interpolated\n  * wildcard expansion will not happen (unless `Path.wildcard/2` is used\n    explicitly)\n  * arguments do not need to be escaped or quoted for shell safety\n\nThis function returns a tuple containing the collected result\nand the command exit status.\n\nInternally, this function uses a `Port` for interacting with the\noutside world. However, if you plan to run a long-running program,\nports guarantee stdin/stdout devices will be closed but it does not\nautomatically terminate the program. The documentation for the\n`Port` module describes this problem and possible solutions under\nthe \"Zombie processes\" section.\n\n## Examples\n\n    iex> System.cmd(\"echo\", [\"hello\"])\n    {\"hello\\n\", 0}\n\n    iex> System.cmd(\"echo\", [\"hello\"], env: [{\"MIX_ENV\", \"test\"}])\n    {\"hello\\n\", 0}\n\nIf you want to stream the output to Standard IO as it arrives:\n\n    iex> System.cmd(\"echo\", [\"hello\"], into: IO.stream())\n    hello\n    {%IO.Stream{}, 0}\n\n## Options\n\n  * `:into` - injects the result into the given collectable, defaults to `\"\"`\n  * `:cd` - the directory to run the command in\n  * `:env` - an enumerable of tuples containing environment key-value as\n    binary. The child process inherits all environment variables from its\n    parent process, the Elixir application, except those overwritten or\n    cleared using this option. Specify a value of `nil` to clear (unset) an\n    environment variable, which is useful for preventing credentials passed\n    to the application from leaking into child processes.\n  * `:arg0` - sets the command arg0\n  * `:stderr_to_stdout` - redirects stderr to stdout when `true`\n  * `:parallelism` - when `true`, the VM will schedule port tasks to improve\n    parallelism in the system. If set to `false`, the VM will try to perform\n    commands immediately, improving latency at the expense of parallelism.\n    The default can be set on system startup by passing the \"+spp\" argument\n    to `--erl`.\n\n## Error reasons\n\nIf invalid arguments are given, `ArgumentError` is raised by\n`System.cmd/3`. `System.cmd/3` also expects a strict set of\noptions and will raise if unknown or invalid options are given.\n\nFurthermore, `System.cmd/3` may fail with one of the POSIX reasons\ndetailed below:\n\n  * `:system_limit` - all available ports in the Erlang emulator are in use\n\n  * `:enomem` - there was not enough memory to create the port\n\n  * `:eagain` - there are no more available operating system processes\n\n  * `:enametoolong` - the external command given was too long\n\n  * `:emfile` - there are no more available file descriptors\n    (for the operating system process that the Erlang emulator runs in)\n\n  * `:enfile` - the file table is full (for the entire operating system)\n\n  * `:eacces` - the command does not point to an executable file\n\n  * `:enoent` - the command does not point to an existing file\n\n## Shell commands\n\nIf you desire to execute a trusted command inside a shell, with pipes,\nredirecting and so on, please check `shell/2`.\n"}
{"completion":"","prompt":"Elixir.System.compiled_endianness(): Returns the endianness the system was compiled with.\n"}
{"completion":"","prompt":"Elixir.System.convert_time_unit(time, from_unit, to_unit): Converts `time` from time unit `from_unit` to time unit `to_unit`.\n\nThe result is rounded via the floor function.\n\n`convert_time_unit/3` accepts an additional time unit (other than the\nones in the `t:time_unit/0` type) called `:native`. `:native` is the time\nunit used by the Erlang runtime system. It's determined when the runtime\nstarts and stays the same until the runtime is stopped, but could differ\nthe next time the runtime is started on the same machine. For this reason,\nyou should use this function to convert `:native` time units to a predictable\nunit before you display them to humans.\n\nTo determine how many seconds the `:native` unit represents in your current\nruntime, you can call this function to convert 1 second to the `:native`\ntime unit: `System.convert_time_unit(1, :second, :native)`.\n"}
{"completion":"","prompt":"Elixir.System.cwd(): Current working directory.\n\nReturns the current working directory or `nil` if one\nis not available.\n"}
{"completion":"","prompt":"Elixir.System.cwd!(): Current working directory, exception on error.\n\nReturns the current working directory or raises `RuntimeError`.\n"}
{"completion":"","prompt":"Elixir.System.delete_env(varname): Deletes an environment variable.\n\nRemoves the variable `varname` from the environment.\n"}
{"completion":"","prompt":"Elixir.System.endianness(): Returns the endianness.\n"}
{"completion":"","prompt":"Elixir.System.fetch_env(varname): Returns the value of the given environment variable or `:error` if not found.\n\nIf the environment variable `varname` is set, then `{:ok, value}` is returned\nwhere `value` is a string. If `varname` is not set, `:error` is returned.\n\n## Examples\n\n    iex> System.fetch_env(\"PORT\")\n    {:ok, \"4000\"}\n\n    iex> System.fetch_env(\"NOT_SET\")\n    :error\n\n"}
{"completion":"","prompt":"Elixir.System.fetch_env!(varname): Returns the value of the given environment variable or raises if not found.\n\nSame as `get_env/1` but raises instead of returning `nil` when the variable is\nnot set.\n\n## Examples\n\n    iex> System.fetch_env!(\"PORT\")\n    \"4000\"\n\n    iex> System.fetch_env!(\"NOT_SET\")\n    ** (ArgumentError) could not fetch environment variable \"NOT_SET\" because it is not set\n\n"}
{"completion":"","prompt":"Elixir.System.find_executable(program): Locates an executable on the system.\n\nThis function looks up an executable program given\nits name using the environment variable PATH on Windows and Unix-like\noperating systems. It also considers the proper executable\nextension for each operating system, so for Windows it will try to\nlookup files with `.com`, `.cmd` or similar extensions.\n"}
{"completion":"","prompt":"Elixir.System.get_env(): Returns all system environment variables.\n\nThe returned value is a map containing name-value pairs.\nVariable names and their values are strings.\n"}
{"completion":"","prompt":"Elixir.System.get_env(varname, default \\\\ nil): Returns the value of the given environment variable.\n\nThe returned value of the environment variable\n`varname` is a string. If the environment variable\nis not set, returns the string specified in `default` or\n`nil` if none is specified.\n\n## Examples\n\n    iex> System.get_env(\"PORT\")\n    \"4000\"\n\n    iex> System.get_env(\"NOT_SET\")\n    nil\n\n    iex> System.get_env(\"NOT_SET\", \"4001\")\n    \"4001\"\n\n"}
{"completion":"","prompt":"Elixir.System.get_pid(): Erlang VM process identifier.\n\nReturns the process identifier of the current Erlang emulator\nin the format most commonly used by the operating system environment.\n\nFor more information, see `:os.getpid/0`.\n"}
{"completion":"","prompt":"Elixir.System.halt(status \\\\ 0): Immediately halts the Erlang runtime system.\n\nTerminates the Erlang runtime system without properly shutting down\napplications and ports. Please see `stop/1` for a careful shutdown of the\nsystem.\n\n`status` must be a non-negative integer, the atom `:abort` or a binary.\n\n  * If an integer, the runtime system exits with the integer value which\n    is returned to the operating system.\n\n  * If `:abort`, the runtime system aborts producing a core dump, if that is\n    enabled in the operating system.\n\n  * If a string, an Erlang crash dump is produced with status as slogan,\n    and then the runtime system exits with status code 1.\n\nNote that on many platforms, only the status codes 0-255 are supported\nby the operating system.\n\nFor more information, see `:erlang.halt/1`.\n\n## Examples\n\n    System.halt(0)\n    System.halt(1)\n    System.halt(:abort)\n\n"}
{"completion":"","prompt":"Elixir.System.monotonic_time(): Returns the current monotonic time in the `:native` time unit.\n\nThis time is monotonically increasing and starts in an unspecified\npoint in time.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.System.monotonic_time(unit): Returns the current monotonic time in the given time unit.\n\nThis time is monotonically increasing and starts in an unspecified\npoint in time.\n"}
{"completion":"","prompt":"Elixir.System.no_halt(): Checks if the system will halt or not at the end of ARGV processing.\n"}
{"completion":"","prompt":"Elixir.System.no_halt(boolean): Marks if the system should halt or not at the end of ARGV processing.\n"}
{"completion":"","prompt":"Elixir.System.os_time(): Returns the current operating system (OS) time.\n\nThe result is returned in the `:native` time unit.\n\nThis time may be adjusted forwards or backwards in time\nwith no limitation and is not monotonic.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.System.os_time(unit): Returns the current operating system (OS) time in the given time `unit`.\n\nThis time may be adjusted forwards or backwards in time\nwith no limitation and is not monotonic.\n"}
{"completion":"","prompt":"Elixir.System.otp_release(): Returns the Erlang/OTP release number.\n"}
{"completion":"","prompt":"Elixir.System.pid(): Returns the operating system PID for the current Erlang runtime system instance.\n\nReturns a string containing the (usually) numerical identifier for a process.\nOn Unix-like operating systems, this is typically the return value of the `getpid()` system call.\nOn Windows, the process ID as returned by the `GetCurrentProcessId()` system\ncall is used.\n\n## Examples\n\n    System.pid()\n\n"}
{"completion":"","prompt":"Elixir.System.put_env(enum): Sets multiple environment variables.\n\nSets a new value for each environment variable corresponding\nto each `{key, value}` pair in `enum`. Keys are automatically\nconverted to strings, values are sent as is. `nil` values erase\nthe given keys.\n"}
{"completion":"","prompt":"Elixir.System.put_env(varname, value): Sets an environment variable value.\n\nSets a new `value` for the environment variable `varname`.\n"}
{"completion":"","prompt":"Elixir.System.restart(): Restarts all applications in the Erlang runtime system.\n\nAll applications are taken down smoothly, all code is unloaded, and all ports\nare closed before the system starts all applications once again.\n\n## Examples\n\n    System.restart()\n\n"}
{"completion":"","prompt":"Elixir.System.schedulers(): Returns the number of schedulers in the VM.\n"}
{"completion":"","prompt":"Elixir.System.schedulers_online(): Returns the number of schedulers online in the VM.\n"}
{"completion":"","prompt":"Elixir.System.shell(command, opts \\\\ []): Executes the given `command` in the OS shell.\n\nIt uses `sh` for Unix-like systems and `cmd` for Windows.\n\n> **Important:**: Use this function with care. In particular, **never\n> pass untrusted user input to this function**, as the user would be\n> able to perform \"command injection attacks\" by executing any code\n> directly on the machine. Generally speaking, prefer to use `cmd/3`\n> over this function.\n\n## Examples\n\n    iex> System.shell(\"echo hello\")\n    {\"hello\\n\", 0}\n\nIf you want to stream the output to Standard IO as it arrives:\n\n    iex> System.shell(\"echo hello\", into: IO.stream())\n    hello\n    {%IO.Stream{}, 0}\n\n## Options\n\nIt accepts the same options as `cmd/3` (except for `arg0`).\nIt also accepts the following exclusive options:\n\n  * `:close_stdin` (since v1.14.1) - if the stdin should be closed\n    on Unix systems, forcing any command that waits on stdin to\n    immediately terminate. Defaults to false.\n"}
{"completion":"","prompt":"Elixir.System.stacktrace(): Deprecated mechanism to retrieve the last exception stacktrace.\n\nIt always return an empty list.\n"}
{"completion":"","prompt":"Elixir.System.stop(status \\\\ 0): Carefully stops the Erlang runtime system.\n\nAll applications are taken down smoothly, all code is unloaded, and all ports\nare closed before the system terminates by calling `halt/1`.\n\n`status` must be a non-negative integer or a binary.\n\n  * If an integer, the runtime system exits with the integer value which is\n    returned to the operating system.\n\n  * If a binary, an Erlang crash dump is produced with status as slogan, and\n    then the runtime system exits with status code 1.\n\nNote that on many platforms, only the status codes 0-255 are supported\nby the operating system.\n\n## Examples\n\n    System.stop(0)\n    System.stop(1)\n\n"}
{"completion":"","prompt":"Elixir.System.system_time(): Returns the current system time in the `:native` time unit.\n\nIt is the VM view of the `os_time/0`. They may not match in\ncase of time warps although the VM works towards aligning\nthem. This time is not monotonic.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.System.system_time(unit): Returns the current system time in the given time unit.\n\nIt is the VM view of the `os_time/0`. They may not match in\ncase of time warps although the VM works towards aligning\nthem. This time is not monotonic.\n"}
{"completion":"","prompt":"Elixir.System.time_offset(): Returns the current time offset between the Erlang VM monotonic\ntime and the Erlang VM system time.\n\nThe result is returned in the `:native` time unit.\n\nSee `time_offset/1` for more information.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.System.time_offset(unit): Returns the current time offset between the Erlang VM monotonic\ntime and the Erlang VM system time.\n\nThe result is returned in the given time unit `unit`. The returned\noffset, added to an Erlang monotonic time (for instance, one obtained with\n`monotonic_time/1`), gives the Erlang system time that corresponds\nto that monotonic time.\n"}
{"completion":"","prompt":"Elixir.System.tmp_dir(): Writable temporary directory.\n\nReturns a writable temporary directory.\nSearches for directories in the following order:\n\n  1. the directory named by the TMPDIR environment variable\n  2. the directory named by the TEMP environment variable\n  3. the directory named by the TMP environment variable\n  4. `C:\\TMP` on Windows or `/tmp` on Unix-like operating systems\n  5. as a last resort, the current working directory\n\nReturns `nil` if none of the above are writable.\n"}
{"completion":"","prompt":"Elixir.System.tmp_dir!(): Writable temporary directory, exception on error.\n\nSame as `tmp_dir/0` but raises `RuntimeError`\ninstead of returning `nil` if no temp dir is set.\n"}
{"completion":"","prompt":"Elixir.System.trap_signal(signal, id \\\\ make_ref(), fun): Traps the given `signal` to execute the `fun`.\n\n> **Important**: Trapping signals may have strong implications\n> on how a system shuts down and behave in production and\n> therefore it is extremely discouraged for libraries to\n> set their own traps. Instead, they should redirect users\n> to configure them themselves. The only cases where it is\n> acceptable for libraries to set their own traps is when\n> using Elixir in script mode, such as in `.exs` files and\n> via Mix tasks.\n\nAn optional `id` that uniquely identifies the function\ncan be given, otherwise a unique one is automatically\ngenerated. If a previously registered `id` is given,\nthis function returns an error tuple. The `id` can be\nused to remove a registered signal by calling\n`untrap_signal/2`.\n\nThe given `fun` receives no arguments and it must return\n`:ok`.\n\nIt returns `{:ok, id}` in case of success,\n`{:error, :already_registered}` in case the id has already\nbeen registered for the given signal, or `{:error, :not_sup}`\nin case trapping exists is not supported by the current OS.\n\nThe first time a signal is trapped, it will override the\ndefault behaviour from the operating system. If the same\nsignal is trapped multiple times, subsequent functions\ngiven to `trap_signal` will execute *first*. In other\nwords, you can consider each function is prepended to\nthe signal handler.\n\nBy default, the Erlang VM register traps to the three\nsignals:\n\n  * `:sigstop` - gracefully shuts down the VM with `stop/0`\n  * `:sigquit` - halts the VM via `halt/0`\n  * `:sigusr1` - halts the VM via status code of 1\n\nTherefore, if you add traps to the signals above, the\ndefault behaviour above will be executed after all user\nsignals.\n\n## Implementation notes\n\nAll signals run from a single process. Therefore, blocking the\n`fun` will block subsequent traps. It is also not possible to add\nor remove traps from within a trap itself.\n\nInternally, this functionality is built on top of `:os.set_signal/2`.\nWhen you register a trap, Elixir automatically sets it to `:handle`\nand it reverts it back to `:default` once all traps are removed\n(except for `:sigquit`, `:sigterm`, and `:sigusr1` which are always\nhandled). If you or a library call `:os.set_signal/2` directly,\nit may disable Elixir traps (or Elixir may override your configuration).\n"}
{"completion":"","prompt":"Elixir.System.unique_integer(modifiers \\\\ []): Generates and returns an integer that is unique in the current runtime\ninstance.\n\n\"Unique\" means that this function, called with the same list of `modifiers`,\nwill never return the same integer more than once on the current runtime\ninstance.\n\nIf `modifiers` is `[]`, then a unique integer (that can be positive or negative) is returned.\nOther modifiers can be passed to change the properties of the returned integer:\n\n  * `:positive` - the returned integer is guaranteed to be positive.\n  * `:monotonic` - the returned integer is monotonically increasing. This\n    means that, on the same runtime instance (but even on different\n    processes), integers returned using the `:monotonic` modifier will always\n    be strictly less than integers returned by successive calls with the\n    `:monotonic` modifier.\n\nAll modifiers listed above can be combined; repeated modifiers in `modifiers`\nwill be ignored.\n\nInlined by the compiler.\n"}
{"completion":"","prompt":"Elixir.System.untrap_signal(signal, id): Removes a previously registered `signal` with `id`.\n"}
{"completion":"","prompt":"Elixir.System.user_home(): User home directory.\n\nReturns the user home directory (platform independent).\n"}
{"completion":"","prompt":"Elixir.System.user_home!(): User home directory, exception on error.\n\nSame as `user_home/0` but raises `RuntimeError`\ninstead of returning `nil` if no user home is set.\n"}
{"completion":"","prompt":"Elixir.System.version(): Elixir version information.\n\nReturns Elixir's version as binary.\n"}
{"completion":"","prompt":"Elixir.Task.Supervisor.async(supervisor, fun, options \\\\ []): Starts a task that can be awaited on.\n\nThe `supervisor` must be a reference as defined in `Supervisor`.\nThe task will still be linked to the caller, see `Task.async/3` for\nmore information and `async_nolink/3` for a non-linked variant.\n\nRaises an error if `supervisor` has reached the maximum number of\nchildren.\n\n## Options\n\n  * `:shutdown` - `:brutal_kill` if the tasks must be killed directly on shutdown\n    or an integer indicating the timeout value, defaults to 5000 milliseconds.\n\n"}
{"completion":"","prompt":"Elixir.Task.Supervisor.async(supervisor, module, fun, args, options \\\\ []): Starts a task that can be awaited on.\n\nThe `supervisor` must be a reference as defined in `Supervisor`.\nThe task will still be linked to the caller, see `Task.async/3` for\nmore information and `async_nolink/3` for a non-linked variant.\n\nRaises an error if `supervisor` has reached the maximum number of\nchildren.\n\n## Options\n\n  * `:shutdown` - `:brutal_kill` if the tasks must be killed directly on shutdown\n    or an integer indicating the timeout value, defaults to 5000 milliseconds.\n\n"}
{"completion":"","prompt":"Elixir.Task.Supervisor.async_nolink(supervisor, fun, options \\\\ []): Starts a task that can be awaited on.\n\nThe `supervisor` must be a reference as defined in `Supervisor`.\nThe task won't be linked to the caller, see `Task.async/3` for\nmore information.\n\nRaises an error if `supervisor` has reached the maximum number of\nchildren.\n\n## Options\n\n  * `:shutdown` - `:brutal_kill` if the tasks must be killed directly on shutdown\n    or an integer indicating the timeout value, defaults to 5000 milliseconds.\n\n## Compatibility with OTP behaviours\n\nIf you create a task using `async_nolink` inside an OTP behaviour\nlike `GenServer`, you should match on the message coming from the\ntask inside your `c:GenServer.handle_info/2` callback.\n\nThe reply sent by the task will be in the format `{ref, result}`,\nwhere `ref` is the monitor reference held by the task struct\nand `result` is the return value of the task function.\n\nKeep in mind that, regardless of how the task created with `async_nolink`\nterminates, the caller's process will always receive a `:DOWN` message\nwith the same `ref` value that is held by the task struct. If the task\nterminates normally, the reason in the `:DOWN` message will be `:normal`.\n\n## Examples\n\nTypically, you use `async_nolink/3` when there is a reasonable expectation that\nthe task may fail, and you don't want it to take down the caller. Let's see an\nexample where a `GenServer` is meant to run a single task and track its status:\n\n    defmodule MyApp.Server do\n      use GenServer\n\n      # ...\n\n      def start_task do\n        GenServer.call(__MODULE__, :start_task)\n      end\n\n      # In this case the task is already running, so we just return :ok.\n      def handle_call(:start_task, _from, %{ref: ref} = state) when is_reference(ref) do\n        {:reply, :ok, state}\n      end\n\n      # The task is not running yet, so let's start it.\n      def handle_call(:start_task, _from, %{ref: nil} = state) do\n        task =\n          Task.Supervisor.async_nolink(MyApp.TaskSupervisor, fn ->\n            ...\n          end)\n\n        # We return :ok and the server will continue running\n        {:reply, :ok, %{state | ref: task.ref}}\n      end\n\n      # The task completed successfully\n      def handle_info({ref, answer}, %{ref: ref} = state) do\n        # We don't care about the DOWN message now, so let's demonitor and flush it\n        Process.demonitor(ref, [:flush])\n        # Do something with the result and then return\n        {:noreply, %{state | ref: nil}}\n      end\n\n      # The task failed\n      def handle_info({:DOWN, ref, :process, _pid, _reason}, %{ref: ref} = state) do\n        # Log and possibly restart the task...\n        {:noreply, %{state | ref: nil}}\n      end\n    end\n\n"}
{"completion":"","prompt":"Elixir.Task.Supervisor.async_nolink(supervisor, module, fun, args, options \\\\ []): Starts a task that can be awaited on.\n\nThe `supervisor` must be a reference as defined in `Supervisor`.\nThe task won't be linked to the caller, see `Task.async/3` for\nmore information.\n\nRaises an error if `supervisor` has reached the maximum number of\nchildren.\n\nNote this function requires the task supervisor to have `:temporary`\nas the `:restart` option (the default), as `async_nolink/5` keeps a\ndirect reference to the task which is lost if the task is restarted.\n"}
{"completion":"","prompt":"Elixir.Task.Supervisor.async_stream(supervisor, enumerable, fun, options \\\\ []): Returns a stream that runs the given function `fun` concurrently\non each element in `enumerable`.\n\nEach element in `enumerable` is passed as argument to the given function `fun`\nand processed by its own task. The tasks will be spawned under the given\n`supervisor` and linked to the caller process, similarly to `async/3`.\n\nSee `async_stream/6` for discussion, options, and examples.\n"}
{"completion":"","prompt":"Elixir.Task.Supervisor.async_stream(supervisor, enumerable, module, function, args, options \\\\ []): Returns a stream where the given function (`module` and `function`)\nis mapped concurrently on each element in `enumerable`.\n\nEach element will be prepended to the given `args` and processed by its\nown task. The tasks will be spawned under the given `supervisor` and\nlinked to the caller process, similarly to `async/5`.\n\nWhen streamed, each task will emit `{:ok, value}` upon successful\ncompletion or `{:exit, reason}` if the caller is trapping exits.\nThe order of results depends on the value of the `:ordered` option.\n\nThe level of concurrency and the time tasks are allowed to run can\nbe controlled via options (see the \"Options\" section below).\n\nIf you find yourself trapping exits to handle exits inside\nthe async stream, consider using `async_stream_nolink/6` to start tasks\nthat are not linked to the calling process.\n\n## Options\n\n  * `:max_concurrency` - sets the maximum number of tasks to run\n    at the same time. Defaults to `System.schedulers_online/0`.\n\n  * `:ordered` - whether the results should be returned in the same order\n    as the input stream. This option is useful when you have large\n    streams and don't want to buffer results before they are delivered.\n    This is also useful when you're using the tasks for side effects.\n    Defaults to `true`.\n\n  * `:timeout` - the maximum amount of time to wait (in milliseconds)\n    without receiving a task reply (across all running tasks).\n    Defaults to `5000`.\n\n  * `:on_timeout` - what do to when a task times out. The possible\n    values are:\n    * `:exit` (default) - the process that spawned the tasks exits.\n    * `:kill_task` - the task that timed out is killed. The value\n      emitted for that task is `{:exit, :timeout}`.\n\n  * `:shutdown` - `:brutal_kill` if the tasks must be killed directly on shutdown\n    or an integer indicating the timeout value. Defaults to `5000` milliseconds.\n\n## Examples\n\nLet's build a stream and then enumerate it:\n\n    stream = Task.Supervisor.async_stream(MySupervisor, collection, Mod, :expensive_fun, [])\n    Enum.to_list(stream)\n\n"}
{"completion":"","prompt":"Elixir.Task.Supervisor.async_stream_nolink(supervisor, enumerable, fun, options \\\\ []): Returns a stream that runs the given `function` concurrently on each\nelement in `enumerable`.\n\nEach element in `enumerable` is passed as argument to the given function `fun`\nand processed by its own task. The tasks will be spawned under the given\n`supervisor` and will not be linked to the caller process, similarly\nto `async_nolink/3`.\n\nSee `async_stream/6` for discussion and examples.\n"}
{"completion":"","prompt":"Elixir.Task.Supervisor.async_stream_nolink(supervisor, enumerable, module, function, args, options \\\\ []): Returns a stream where the given function (`module` and `function`)\nis mapped concurrently on each element in `enumerable`.\n\nEach element in `enumerable` will be prepended to the given `args` and processed\nby its own task. The tasks will be spawned under the given `supervisor` and\nwill not be linked to the caller process, similarly to `async_nolink/5`.\n\nSee `async_stream/6` for discussion, options, and examples.\n"}
{"completion":"","prompt":"Elixir.Task.Supervisor.children(supervisor): Returns all children PIDs except those that are restarting.\n\nNote that calling this function when supervising a large number\nof children under low memory conditions can cause an out of memory\nexception.\n"}
{"completion":"","prompt":"Elixir.Task.Supervisor.start_child(supervisor, fun, options \\\\ []): Starts a task as a child of the given `supervisor`.\n\n    Task.Supervisor.start_child(MyTaskSupervisor, fn ->\n      IO.puts \"I am running in a task\"\n    end)\n\nNote that the spawned process is not linked to the caller, but\nonly to the supervisor. This command is useful in case the\ntask needs to perform side-effects (like I/O) and you have no\ninterest in its results nor if it completes successfully.\n\n## Options\n\n  * `:restart` - the restart strategy, may be `:temporary` (the default),\n    `:transient` or `:permanent`. `:temporary` means the task is never\n    restarted, `:transient` means it is restarted if the exit is not\n    `:normal`, `:shutdown` or `{:shutdown, reason}`. A `:permanent` restart\n    strategy means it is always restarted.\n\n  * `:shutdown` - `:brutal_kill` if the task must be killed directly on shutdown\n    or an integer indicating the timeout value, defaults to 5000 milliseconds.\n\n"}
{"completion":"","prompt":"Elixir.Task.Supervisor.start_child(supervisor, module, fun, args, options \\\\ []): Starts a task as a child of the given `supervisor`.\n\nSimilar to `start_child/3` except the task is specified\nby the given `module`, `fun` and `args`.\n"}
{"completion":"","prompt":"Elixir.Task.Supervisor.start_link(options \\\\ []): Starts a new supervisor.\n\n## Examples\n\nA task supervisor is typically started under a supervision tree using\nthe tuple format:\n\n    {Task.Supervisor, name: MyApp.TaskSupervisor}\n\nYou can also start it by calling `start_link/1` directly:\n\n    Task.Supervisor.start_link(name: MyApp.TaskSupervisor)\n\nBut this is recommended only for scripting and should be avoided in\nproduction code. Generally speaking, processes should always be started\ninside supervision trees.\n\n## Options\n\n  * `:name` - used to register a supervisor name, the supported values are\n    described under the `Name Registration` section in the `GenServer` module\n    docs;\n\n  * `:max_restarts`, `:max_seconds`, and `:max_children` - as specified in\n    `DynamicSupervisor`;\n\nThis function could also receive `:restart` and `:shutdown` as options\nbut those two options have been deprecated and it is now preferred to\ngive them directly to `start_child`.\n"}
{"completion":"","prompt":"Elixir.Task.Supervisor.terminate_child(supervisor, pid): Terminates the child with the given `pid`.\n"}
{"completion":"","prompt":"Elixir.Task.%Task{}: The Task struct.\n\nIt contains these fields:\n\n  * `:mfa` - a three-element tuple containing the module, function name,\n    and arity invoked to start the task in `async/1` and `async/3`\n\n  * `:owner` - the PID of the process that started the task\n\n  * `:pid` - the PID of the task process; `nil` if the task does\n    not use a task process\n\n  * `:ref` - the task monitor reference\n\n"}
{"completion":"","prompt":"Elixir.Task.async(fun): Starts a task that must be awaited on.\n\n`fun` must be a zero-arity anonymous function. This function\nspawns a process that is linked to and monitored by the caller\nprocess. A `Task` struct is returned containing the relevant\ninformation. Developers must eventually call `Task.await/2` or\n`Task.yield/2` followed by `Task.shutdown/2` on the returned task.\n\nRead the `Task` module documentation for more information about\nthe general usage of async tasks.\n\n## Linking\n\nThis function spawns a process that is linked to and monitored\nby the caller process. The linking part is important because it\naborts the task if the parent process dies. It also guarantees\nthe code before async/await has the same properties after you\nadd the async call. For example, imagine you have this:\n\n    x = heavy_fun()\n    y = some_fun()\n    x + y\n\nNow you want to make the `heavy_fun()` async:\n\n    x = Task.async(&heavy_fun/0)\n    y = some_fun()\n    Task.await(x) + y\n\nAs before, if `heavy_fun/0` fails, the whole computation will\nfail, including the caller process. If you don't want the task\nto fail then you must change the `heavy_fun/0` code in the\nsame way you would achieve it if you didn't have the async call.\nFor example, to either return `{:ok, val} | :error` results or,\nin more extreme cases, by using `try/rescue`. In other words,\nan asynchronous task should be thought of as an extension of the\ncaller process rather than a mechanism to isolate it from all errors.\n\nIf you don't want to link the caller to the task, then you\nmust use a supervised task with `Task.Supervisor` and call\n`Task.Supervisor.async_nolink/2`.\n\nIn any case, avoid any of the following:\n\n  * Setting `:trap_exit` to `true` - trapping exits should be\n    used only in special circumstances as it would make your\n    process immune to not only exits from the task but from\n    any other processes.\n\n    Moreover, even when trapping exits, calling `await` will\n    still exit if the task has terminated without sending its\n    result back.\n\n  * Unlinking the task process started with `async`/`await`.\n    If you unlink the processes and the task does not belong\n    to any supervisor, you may leave dangling tasks in case\n    the caller process dies.\n\n## Metadata\n\nThe task created with this function stores `:erlang.apply/2` in\nits `:mfa` metadata field, which is used internally to apply\nthe anonymous function. Use `async/3` if you want another function\nto be used as metadata.\n"}
{"completion":"","prompt":"Elixir.Task.async(module, function_name, args): Starts a task that must be awaited on.\n\nSimilar to `async/1` except the function to be started is\nspecified by the given `module`, `function_name`, and `args`.\nThe `module`, `function_name`, and its arity are stored as\na tuple in the `:mfa` field for reflection purposes.\n"}
{"completion":"","prompt":"Elixir.Task.async_stream(enumerable, fun, options \\\\ []): Returns a stream that runs the given function `fun` concurrently\non each element in `enumerable`.\n\nWorks the same as `async_stream/5` but with an anonymous function instead of a\nmodule-function-arguments tuple. `fun` must be a one-arity anonymous function.\n\nEach `enumerable` element is passed as argument to the given function `fun` and\nprocessed by its own task. The tasks will be linked to the caller process, similarly\nto `async/1`.\n\n## Example\n\nCount the code points in each string asynchronously, then add the counts together using reduce.\n\n    iex> strings = [\"long string\", \"longer string\", \"there are many of these\"]\n    iex> stream = Task.async_stream(strings, fn text -> text |> String.codepoints() |> Enum.count() end)\n    iex> Enum.reduce(stream, 0, fn {:ok, num}, acc -> num + acc end)\n    47\n\nSee `async_stream/5` for discussion, options, and more examples.\n"}
{"completion":"","prompt":"Elixir.Task.async_stream(enumerable, module, function_name, args, options \\\\ []): Returns a stream where the given function (`module` and `function_name`)\nis mapped concurrently on each element in `enumerable`.\n\nEach element of `enumerable` will be prepended to the given `args` and\nprocessed by its own task. Those tasks will be linked to an intermediate\nprocess that is then linked to the caller process. This means a failure\nin a task terminates the caller process and a failure in the caller\nprocess terminates all tasks.\n\nWhen streamed, each task will emit `{:ok, value}` upon successful\ncompletion or `{:exit, reason}` if the caller is trapping exits.\nIt's possible to have `{:exit, {element, reason}}` for exits\nusing the `:zip_input_on_exit` option. The order of results depends\non the value of the `:ordered` option.\n\nThe level of concurrency and the time tasks are allowed to run can\nbe controlled via options (see the \"Options\" section below).\n\nConsider using `Task.Supervisor.async_stream/6` to start tasks\nunder a supervisor. If you find yourself trapping exits to ensure\nerrors in the tasks do not terminate the caller process, consider\nusing `Task.Supervisor.async_stream_nolink/6` to start tasks that\nare not linked to the caller process.\n\n## Options\n\n  * `:max_concurrency` - sets the maximum number of tasks to run\n    at the same time. Defaults to `System.schedulers_online/0`.\n\n  * `:ordered` - whether the results should be returned in the same order\n    as the input stream. When the output is ordered, Elixir may need to\n    buffer results to emit them in the original order. Setting this option\n    to false disables the need to buffer at the cost of removing ordering.\n    This is also useful when you're using the tasks only for the side effects.\n    Note that regardless of what `:ordered` is set to, the tasks will\n    process asynchronously. If you need to process elements in order,\n    consider using `Enum.map/2` or `Enum.each/2` instead. Defaults to `true`.\n\n  * `:timeout` - the maximum amount of time (in milliseconds or `:infinity`)\n    each task is allowed to execute for. Defaults to `5000`.\n\n  * `:on_timeout` - what to do when a task times out. The possible\n    values are:\n    * `:exit` (default) - the caller (the process that spawned the tasks) exits.\n    * `:kill_task` - the task that timed out is killed. The value\n      emitted for that task is `{:exit, :timeout}`.\n\n  * `:zip_input_on_exit` - (since v1.14.0) adds the original\n    input to `:exit` tuples. The value emitted for that task is\n    `{:exit, {input, reason}}`, where `input` is the collection element\n    that caused an exited during processing. Defaults to `false`.\n\n## Example\n\nLet's build a stream and then enumerate it:\n\n    stream = Task.async_stream(collection, Mod, :expensive_fun, [])\n    Enum.to_list(stream)\n\nThe concurrency can be increased or decreased using the `:max_concurrency`\noption. For example, if the tasks are IO heavy, the value can be increased:\n\n    max_concurrency = System.schedulers_online() * 2\n    stream = Task.async_stream(collection, Mod, :expensive_fun, [], max_concurrency: max_concurrency)\n    Enum.to_list(stream)\n\nIf you do not care about the results of the computation, you can run\nthe stream with `Stream.run/1`. Also set `ordered: false`, as you don't\ncare about the order of the results either:\n\n    stream = Task.async_stream(collection, Mod, :expensive_fun, [], ordered: false)\n    Stream.run(stream)\n\n## First async tasks to complete\n\nYou can also use `async_stream/3` to execute M tasks and find the N tasks\nto complete. For example:\n\n    [\n      &heavy_call_1/0,\n      &heavy_call_2/0,\n      &heavy_call_3/0\n    ]\n    |> Task.async_stream(fn fun -> fun.() end, ordered: false, max_concurrency: 3)\n    |> Stream.filter(&match?({:ok, _}, &1))\n    |> Enum.take(2)\n\nIn the example above, we are executing three tasks and waiting for the\nfirst 2 to complete. We use `Stream.filter/2` to restrict ourselves only\nto successfully completed tasks, and then use `Enum.take/2` to retrieve\nN items. Note it is important to set both `ordered: false` and\n`max_concurrency: M`, where M is the number of tasks, to make sure all\ncalls execute concurrently.\n\n### Attention: unbound async + take\n\nIf you want to potentially process a high number of items and keep only\npart of the results, you may end-up processing more items than desired.\nLet's see an example:\n\n    1..100\n    |> Task.async_stream(fn i ->\n      Process.sleep(100)\n      IO.puts(to_string(i))\n    end)\n    |> Enum.take(10)\n\nRunning the example above in a machine with 8 cores will process 16 items,\neven though you want only 10 elements, since `async_stream/3` process items\nconcurrently. That's because it will process 8 elements at once. Then all 8\nelements complete at roughly the same time, causing 8 elements to be kicked\noff for processing. Out of these extra 8, only 2 will be used, and the rest\nwill be terminated.\n\nDepending on the problem, you can filter or limit the number of elements\nupfront:\n\n    1..100\n    |> Stream.take(10)\n    |> Task.async_stream(fn i ->\n      Process.sleep(100)\n      IO.puts(to_string(i))\n    end)\n    |> Enum.to_list()\n\nIn other cases, you likely want to tweak `:max_concurrency` to limit how\nmany elements may be over processed at the cost of reducing concurrency.\nYou can also set the number of elements to take to be a multiple of\n`:max_concurrency`. For instance, setting `max_concurrency: 5` in the\nexample above.\n"}
{"completion":"","prompt":"Elixir.Task.await(task, timeout \\\\ 5000): Awaits a task reply and returns it.\n\nIn case the task process dies, the caller process will exit with the same\nreason as the task.\n\nA timeout, in milliseconds or `:infinity`, can be given with a default value\nof `5000`. If the timeout is exceeded, then the caller process will exit.\nIf the task process is linked to the caller process which is the case when\na task is started with `async`, then the task process will also exit. If the\ntask process is trapping exits or not linked to the caller process, then it\nwill continue to run.\n\nThis function assumes the task's monitor is still active or the monitor's\n`:DOWN` message is in the message queue. If it has been demonitored, or the\nmessage already received, this function will wait for the duration of the\ntimeout awaiting the message.\n\nThis function can only be called once for any given task. If you want\nto be able to check multiple times if a long-running task has finished\nits computation, use `yield/2` instead.\n\n## Examples\n\n    iex> task = Task.async(fn -> 1 + 1 end)\n    iex> Task.await(task)\n    2\n\n## Compatibility with OTP behaviours\n\nIt is not recommended to `await` a long-running task inside an OTP\nbehaviour such as `GenServer`. Instead, you should match on the message\ncoming from a task inside your `c:GenServer.handle_info/2` callback.\n\nA GenServer will receive two messages on `handle_info/2`:\n\n  * `{ref, result}` - the reply message where `ref` is the monitor\n    reference returned by the `task.ref` and `result` is the task\n    result\n\n  * `{:DOWN, ref, :process, pid, reason}` - since all tasks are also\n    monitored, you will also receive the `:DOWN` message delivered by\n    `Process.monitor/1`. If you receive the `:DOWN` message without a\n    a reply, it means the task crashed\n\nAnother consideration to have in mind is that tasks started by `Task.async/1`\nare always linked to their callers and you may not want the GenServer to\ncrash if the task crashes. Therefore, it is preferable to instead use\n`Task.Supervisor.async_nolink/3` inside OTP behaviours. For completeness, here\nis an example of a GenServer that start tasks and handles their results:\n\n    defmodule GenServerTaskExample do\n      use GenServer\n\n      def start_link(opts) do\n        GenServer.start_link(__MODULE__, :ok, opts)\n      end\n\n      def init(_opts) do\n        # We will keep all running tasks in a map\n        {:ok, %{tasks: %{}}}\n      end\n\n      # Imagine we invoke a task from the GenServer to access a URL...\n      def handle_call(:some_message, _from, state) do\n        url = ...\n        task = Task.Supervisor.async_nolink(MyApp.TaskSupervisor, fn -> fetch_url(url) end)\n\n        # After we start the task, we store its reference and the url it is fetching\n        state = put_in(state.tasks[task.ref], url)\n\n        {:reply, :ok, state}\n      end\n\n      # If the task succeeds...\n      def handle_info({ref, result}, state) do\n        # The task succeed so we can cancel the monitoring and discard the DOWN message\n        Process.demonitor(ref, [:flush])\n\n        {url, state} = pop_in(state.tasks[ref])\n        IO.puts \"Got #{inspect(result)} for URL #{inspect url}\"\n        {:noreply, state}\n      end\n\n      # If the task fails...\n      def handle_info({:DOWN, ref, _, _, reason}, state) do\n        {url, state} = pop_in(state.tasks[ref])\n        IO.puts \"URL #{inspect url} failed with reason #{inspect(reason)}\"\n        {:noreply, state}\n      end\n    end\n\nWith the server defined, you will want to start the task supervisor\nabove and the GenServer in your supervision tree:\n\n    children = [\n      {Task.Supervisor, name: MyApp.TaskSupervisor},\n      {GenServerTaskExample, name: MyApp.GenServerTaskExample}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\n"}
{"completion":"","prompt":"Elixir.Task.await_many(tasks, timeout \\\\ 5000): Awaits replies from multiple tasks and returns them.\n\nThis function receives a list of tasks and waits for their replies in the\ngiven time interval. It returns a list of the results, in the same order as\nthe tasks supplied in the `tasks` input argument.\n\nIf any of the task processes dies, the caller process will exit with the same\nreason as that task.\n\nA timeout, in milliseconds or `:infinity`, can be given with a default value\nof `5000`. If the timeout is exceeded, then the caller process will exit.\nAny task processes that are linked to the caller process (which is the case\nwhen a task is started with `async`) will also exit. Any task processes that\nare trapping exits or not linked to the caller process will continue to run.\n\nThis function assumes the tasks' monitors are still active or the monitor's\n`:DOWN` message is in the message queue. If any tasks have been demonitored,\nor the message already received, this function will wait for the duration of\nthe timeout.\n\nThis function can only be called once for any given task. If you want to be\nable to check multiple times if a long-running task has finished its\ncomputation, use `yield_many/2` instead.\n\n## Compatibility with OTP behaviours\n\nIt is not recommended to `await` long-running tasks inside an OTP behaviour\nsuch as `GenServer`. See `await/2` for more information.\n\n## Examples\n\n    iex> tasks = [\n    ...>   Task.async(fn -> 1 + 1 end),\n    ...>   Task.async(fn -> 2 + 3 end)\n    ...> ]\n    iex> Task.await_many(tasks)\n    [2, 5]\n\n"}
{"completion":"","prompt":"Elixir.Task.child_spec(arg): Returns a specification to start a task under a supervisor.\n\n`arg` is passed as the argument to `Task.start_link/1` in the `:start` field\nof the spec.\n\nFor more information, see the `Supervisor` module,\nthe `Supervisor.child_spec/2` function and the `t:Supervisor.child_spec/0` type.\n"}
{"completion":"","prompt":"Elixir.Task.completed(result): Starts a task that immediately completes with the given `result`.\n\nUnlike `async/1`, this task does not spawn a linked process. It can\nbe awaited or yielded like any other task.\n\n## Usage\n\nIn some cases, it is useful to create a \"completed\" task that represents\na task that has already run and generated a result. For example, when\nprocessing data you may be able to determine that certain inputs are\ninvalid before dispatching them for further processing:\n\n    def process(data) do\n      tasks =\n        for entry <- data do\n          if invalid_input?(entry) do\n            Task.completed({:error, :invalid_input})\n          else\n            Task.async(fn -> further_process(entry) end)\n          end\n        end\n\n      Task.await_many(tasks)\n    end\n\nIn many cases, `Task.completed/1` may be avoided in favor of returning the\nresult directly.  You should generally only require this variant when working\nwith mixed asynchrony, when a group of inputs will be handled partially\nsynchronously and partially asynchronously.\n"}
{"completion":"","prompt":"Elixir.Task.ignore(task): Ignores an existing task.\n\nThis means the task will continue running, but it will be unlinked\nand you can no longer yield, await or shut it down.\n\nReturns `{:ok, reply}` if the reply is received before ignoring the task,\n`{:exit, reason}` if the task died before ignoring it, otherwise `nil`.\n\nImportant: avoid using [`Task.async/1,3`](`async/1`) and then immediately ignoring\nthe task. If you want to start tasks you don't care about their\nresults, use `Task.Supervisor.start_child/2` instead.\n\nRequires Erlang/OTP 24+.\n"}
{"completion":"","prompt":"Elixir.Task.shutdown(task, shutdown \\\\ 5000): Unlinks and shuts down the task, and then checks for a reply.\n\nReturns `{:ok, reply}` if the reply is received while shutting down the task,\n`{:exit, reason}` if the task died, otherwise `nil`. Once shut down,\nyou can no longer await or yield it.\n\nThe second argument is either a timeout or `:brutal_kill`. In case\nof a timeout, a `:shutdown` exit signal is sent to the task process\nand if it does not exit within the timeout, it is killed. With `:brutal_kill`\nthe task is killed straight away. In case the task terminates abnormally\n(possibly killed by another process), this function will exit with the same reason.\n\nIt is not required to call this function when terminating the caller, unless\nexiting with reason `:normal` or if the task is trapping exits. If the caller is\nexiting with a reason other than `:normal` and the task is not trapping exits, the\ncaller's exit signal will stop the task. The caller can exit with reason\n`:shutdown` to shut down all of its linked processes, including tasks, that\nare not trapping exits without generating any log messages.\n\nIf a task's monitor has already been demonitored or received and there is not\na response waiting in the message queue this function will return\n`{:exit, :noproc}` as the result or exit reason can not be determined.\n"}
{"completion":"","prompt":"Elixir.Task.start(fun): Starts a task.\n\n`fun` must be a zero-arity anonymous function.\n\nThis should only used when the task is used for side-effects\n(like I/O) and you have no interest on its results nor if it\ncompletes successfully.\n\nIf the current node is shutdown, the node will terminate even\nif the task was not completed. For this reason, we recommend\nto use `Task.Supervisor.start_child/2` instead, which allows\nyou to control the shutdown time via the `:shutdown` option.\n"}
{"completion":"","prompt":"Elixir.Task.start(module, function_name, args): Starts a task.\n\nThis should only used when the task is used for side-effects\n(like I/O) and you have no interest on its results nor if it\ncompletes successfully.\n\nIf the current node is shutdown, the node will terminate even\nif the task was not completed. For this reason, we recommend\nto use `Task.Supervisor.start_child/2` instead, which allows\nyou to control the shutdown time via the `:shutdown` option.\n"}
{"completion":"","prompt":"Elixir.Task.start_link(fun): Starts a task as part of a supervision tree with the given `fun`.\n\n`fun` must be a zero-arity anonymous function.\n\nThis is used to start a statically supervised task under a supervision tree.\n"}
{"completion":"","prompt":"Elixir.Task.start_link(module, function, args): Starts a task as part of a supervision tree with the given\n`module`, `function`, and `args`.\n\nThis is used to start a statically supervised task under a supervision tree.\n"}
{"completion":"","prompt":"Elixir.Task.yield(task, timeout \\\\ 5000): Temporarily blocks the caller process waiting for a task reply.\n\nReturns `{:ok, reply}` if the reply is received, `nil` if\nno reply has arrived, or `{:exit, reason}` if the task has already\nexited. Keep in mind that normally a task failure also causes\nthe process owning the task to exit. Therefore this function can\nreturn `{:exit, reason}` if at least one of the conditions below apply:\n\n  * the task process exited with the reason `:normal`\n  * the task isn't linked to the caller (the task was started\n    with `Task.Supervisor.async_nolink/2` or `Task.Supervisor.async_nolink/4`)\n  * the caller is trapping exits\n\nA timeout, in milliseconds or `:infinity`, can be given with a default value\nof `5000`. If the time runs out before a message from the task is received,\nthis function will return `nil` and the monitor will remain active. Therefore\n`yield/2` can be called multiple times on the same task.\n\nThis function assumes the task's monitor is still active or the\nmonitor's `:DOWN` message is in the message queue. If it has been\ndemonitored or the message already received, this function will wait\nfor the duration of the timeout awaiting the message.\n\nIf you intend to shut the task down if it has not responded within `timeout`\nmilliseconds, you should chain this together with `shutdown/1`, like so:\n\n    case Task.yield(task, timeout) || Task.shutdown(task) do\n      {:ok, result} ->\n        result\n\n      nil ->\n        Logger.warn(\"Failed to get a result in #{timeout}ms\")\n        nil\n    end\n\nIf you intend to check on the task but leave it running after the timeout,\nyou can chain this together with `ignore/1`, like so:\n\n    case Task.yield(task, timeout) || Task.ignore(task) do\n      {:ok, result} ->\n        result\n\n      nil ->\n        Logger.warn(\"Failed to get a result in #{timeout}ms\")\n        nil\n    end\n\nThat ensures that if the task completes after the `timeout` but before `shutdown/1`\nhas been called, you will still get the result, since `shutdown/1` is designed to\nhandle this case and return the result.\n"}
{"completion":"","prompt":"Elixir.Task.yield_many(tasks, timeout \\\\ 5000): Yields to multiple tasks in the given time interval.\n\nThis function receives a list of tasks and waits for their\nreplies in the given time interval. It returns a list\nof two-element tuples, with the task as the first element\nand the yielded result as the second. The tasks in the returned\nlist will be in the same order as the tasks supplied in the `tasks`\ninput argument.\n\nSimilarly to `yield/2`, each task's result will be\n\n  * `{:ok, term}` if the task has successfully reported its\n    result back in the given time interval\n  * `{:exit, reason}` if the task has died\n  * `nil` if the task keeps running past the timeout\n\nA timeout, in milliseconds or `:infinity`, can be given with a default value\nof `5000`.\n\nCheck `yield/2` for more information.\n\n## Example\n\n`Task.yield_many/2` allows developers to spawn multiple tasks\nand retrieve the results received in a given timeframe.\nIf we combine it with `Task.shutdown/2` (or `Task.ignore/1`),\nit allows us to gather those results and cancel (or ignore)\nthe tasks that have not replied in time.\n\nLet's see an example.\n\n    tasks =\n      for i <- 1..10 do\n        Task.async(fn ->\n          Process.sleep(i * 1000)\n          i\n        end)\n      end\n\n    tasks_with_results = Task.yield_many(tasks, 5000)\n\n    results =\n      Enum.map(tasks_with_results, fn {task, res} ->\n        # Shut down the tasks that did not reply nor exit\n        res || Task.shutdown(task, :brutal_kill)\n      end)\n\n    # Here we are matching only on {:ok, value} and\n    # ignoring {:exit, _} (crashed tasks) and `nil` (no replies)\n    for {:ok, value} <- results do\n      IO.inspect(value)\n    end\n\nIn the example above, we create tasks that sleep from 1\nup to 10 seconds and return the number of seconds they slept for.\nIf you execute the code all at once, you should see 1 up to 5\nprinted, as those were the tasks that have replied in the\ngiven time. All other tasks will have been shut down using\nthe `Task.shutdown/2` call.\n"}
{"completion":"","prompt":"Elixir.Time.add(time, amount_to_add, unit \\\\ :second): Adds the `amount_to_add` of `unit`s to the given `time`.\n\nAccepts an `amount_to_add` in any `unit`. `unit` can be `:day`,\n`:hour`, `:minute`, `:second` or any subsecond precision from\n`t:System.time_unit/0`. It defaults to `:second`. Negative values\nwill move backwards in time.\n\nThis function always consider the unit to be computed according\nto the `Calendar.ISO`.\n\nNote the result value represents the time of day, meaning that it is cyclic,\nfor instance, it will never go over 24 hours for the ISO calendar.\n\n## Examples\n\n    iex> Time.add(~T[10:00:00], 27000)\n    ~T[17:30:00]\n    iex> Time.add(~T[11:00:00.005], 2400)\n    ~T[11:40:00.005]\n    iex> Time.add(~T[00:00:00.000], 86_399_999, :millisecond)\n    ~T[23:59:59.999]\n\nNegative values are allowed:\n\n    iex> Time.add(~T[23:00:00], -60)\n    ~T[22:59:00]\n\nNote that the time is cyclic:\n\n    iex> Time.add(~T[17:10:05], 86400)\n    ~T[17:10:05]\n\nHours and minutes are also supported:\n\n    iex> Time.add(~T[17:10:05], 2, :hour)\n    ~T[19:10:05]\n    iex> Time.add(~T[17:10:05], 30, :minute)\n    ~T[17:40:05]\n\nThis operation merges the precision of the time with the given unit:\n\n    iex> result = Time.add(~T[00:29:10], 21, :millisecond)\n    ~T[00:29:10.021]\n    iex> result.microsecond\n    {21000, 3}\n\n"}
{"completion":"","prompt":"Elixir.Time.compare(time1, time2): Compares two time structs.\n\nReturns `:gt` if first time is later than the second\nand `:lt` for vice versa. If the two times are equal\n`:eq` is returned.\n\n## Examples\n\n    iex> Time.compare(~T[16:04:16], ~T[16:04:28])\n    :lt\n    iex> Time.compare(~T[16:04:16], ~T[16:04:16])\n    :eq\n    iex> Time.compare(~T[16:04:16.01], ~T[16:04:16.001])\n    :gt\n\nThis function can also be used to compare across more\ncomplex calendar types by considering only the time fields:\n\n    iex> Time.compare(~N[1900-01-01 16:04:16], ~N[2015-01-01 16:04:16])\n    :eq\n    iex> Time.compare(~N[2015-01-01 16:04:16], ~N[2015-01-01 16:04:28])\n    :lt\n    iex> Time.compare(~N[2015-01-01 16:04:16.01], ~N[2000-01-01 16:04:16.001])\n    :gt\n\n"}
{"completion":"","prompt":"Elixir.Time.convert(time, calendar): Converts given `time` to a different calendar.\n\nReturns `{:ok, time}` if the conversion was successful,\nor `{:error, reason}` if it was not, for some reason.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> Time.convert(~T[13:30:15], Calendar.Holocene)\n    {:ok, %Time{calendar: Calendar.Holocene, hour: 13, minute: 30, second: 15, microsecond: {0, 0}}}\n\n"}
{"completion":"","prompt":"Elixir.Time.convert!(time, calendar): Similar to `Time.convert/2`, but raises an `ArgumentError`\nif the conversion between the two calendars is not possible.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> Time.convert!(~T[13:30:15], Calendar.Holocene)\n    %Time{calendar: Calendar.Holocene, hour: 13, minute: 30, second: 15, microsecond: {0, 0}}\n\n"}
{"completion":"","prompt":"Elixir.Time.diff(time1, time2, unit \\\\ :second): Returns the difference between two times, considering only the hour, minute,\nsecond and microsecond.\n\nAs with the `compare/2` function both `Time` structs and other structures\ncontaining time can be used. If for instance a `NaiveDateTime` or `DateTime`\nis passed, only the hour, minute, second, and microsecond is considered. Any\nadditional information about a date or time zone is ignored when calculating\nthe difference.\n\nThe answer can be returned in any `:hour`, `:minute`, `:second` or any\nsubsecond `unit` available from `t:System.time_unit/0`. If the first time\nvalue is earlier than the second, a negative number is returned.\n\nThe unit is measured according to `Calendar.ISO` and defaults to `:second`.\nFractional results are not supported and are truncated.\n\n## Examples\n\n    iex> Time.diff(~T[00:29:12], ~T[00:29:10])\n    2\n\n    # When passing a `NaiveDateTime` the date part is ignored.\n    iex> Time.diff(~N[2017-01-01 00:29:12], ~T[00:29:10])\n    2\n\n    # Two `NaiveDateTime` structs could have big differences in the date\n    # but only the time part is considered.\n    iex> Time.diff(~N[2017-01-01 00:29:12], ~N[1900-02-03 00:29:10])\n    2\n\n    iex> Time.diff(~T[00:29:12], ~T[00:29:10], :microsecond)\n    2_000_000\n    iex> Time.diff(~T[00:29:10], ~T[00:29:12], :microsecond)\n    -2_000_000\n\n    iex> Time.diff(~T[02:29:10], ~T[00:29:10], :hour)\n    2\n    iex> Time.diff(~T[02:29:10], ~T[00:29:11], :hour)\n    1\n\n"}
{"completion":"","prompt":"Elixir.Time.from_erl(tuple, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO): Converts an Erlang time tuple to a `Time` struct.\n\n## Examples\n\n    iex> Time.from_erl({23, 30, 15}, {5000, 3})\n    {:ok, ~T[23:30:15.005]}\n    iex> Time.from_erl({24, 30, 15})\n    {:error, :invalid_time}\n\n"}
{"completion":"","prompt":"Elixir.Time.from_erl!(tuple, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO): Converts an Erlang time tuple to a `Time` struct.\n\n## Examples\n\n    iex> Time.from_erl!({23, 30, 15})\n    ~T[23:30:15]\n    iex> Time.from_erl!({23, 30, 15}, {5000, 3})\n    ~T[23:30:15.005]\n    iex> Time.from_erl!({24, 30, 15})\n    ** (ArgumentError) cannot convert {24, 30, 15} to time, reason: :invalid_time\n\n"}
{"completion":"","prompt":"Elixir.Time.from_iso8601(string, calendar \\\\ Calendar.ISO): Parses the extended \"Local time\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nTime zone offset may be included in the string but they will be\nsimply discarded as such information is not included in times.\n\nAs specified in the standard, the separator \"T\" may be omitted if\ndesired as there is no ambiguity within this function.\n\n## Examples\n\n    iex> Time.from_iso8601(\"23:50:07\")\n    {:ok, ~T[23:50:07]}\n    iex> Time.from_iso8601(\"23:50:07Z\")\n    {:ok, ~T[23:50:07]}\n    iex> Time.from_iso8601(\"T23:50:07Z\")\n    {:ok, ~T[23:50:07]}\n\n    iex> Time.from_iso8601(\"23:50:07,0123456\")\n    {:ok, ~T[23:50:07.012345]}\n    iex> Time.from_iso8601(\"23:50:07.0123456\")\n    {:ok, ~T[23:50:07.012345]}\n    iex> Time.from_iso8601(\"23:50:07.123Z\")\n    {:ok, ~T[23:50:07.123]}\n\n    iex> Time.from_iso8601(\"2015:01:23 23-50-07\")\n    {:error, :invalid_format}\n    iex> Time.from_iso8601(\"23:50:07A\")\n    {:error, :invalid_format}\n    iex> Time.from_iso8601(\"23:50:07.\")\n    {:error, :invalid_format}\n    iex> Time.from_iso8601(\"23:50:61\")\n    {:error, :invalid_time}\n\n"}
{"completion":"","prompt":"Elixir.Time.from_iso8601!(string, calendar \\\\ Calendar.ISO): Parses the extended \"Local time\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nRaises if the format is invalid.\n\n## Examples\n\n    iex> Time.from_iso8601!(\"23:50:07,123Z\")\n    ~T[23:50:07.123]\n    iex> Time.from_iso8601!(\"23:50:07.123Z\")\n    ~T[23:50:07.123]\n    iex> Time.from_iso8601!(\"2015:01:23 23-50-07\")\n    ** (ArgumentError) cannot parse \"2015:01:23 23-50-07\" as time, reason: :invalid_format\n\n"}
{"completion":"","prompt":"Elixir.Time.from_seconds_after_midnight(seconds, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO): Converts a number of seconds after midnight to a `Time` struct.\n\n## Examples\n\n    iex> Time.from_seconds_after_midnight(10_000)\n    ~T[02:46:40]\n    iex> Time.from_seconds_after_midnight(30_000, {5000, 3})\n    ~T[08:20:00.005]\n    iex> Time.from_seconds_after_midnight(-1)\n    ~T[23:59:59]\n    iex> Time.from_seconds_after_midnight(100_000)\n    ~T[03:46:40]\n\n"}
{"completion":"","prompt":"Elixir.Time.new(hour, minute, second, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO): Builds a new time.\n\nExpects all values to be integers. Returns `{:ok, time}` if each\nentry fits its appropriate range, returns `{:error, reason}` otherwise.\n\nMicroseconds can also be given with a precision, which must be an\ninteger between 0 and 6.\n\nThe built-in calendar does not support leap seconds.\n\n## Examples\n\n    iex> Time.new(0, 0, 0, 0)\n    {:ok, ~T[00:00:00.000000]}\n    iex> Time.new(23, 59, 59, 999_999)\n    {:ok, ~T[23:59:59.999999]}\n\n    iex> Time.new(24, 59, 59, 999_999)\n    {:error, :invalid_time}\n    iex> Time.new(23, 60, 59, 999_999)\n    {:error, :invalid_time}\n    iex> Time.new(23, 59, 60, 999_999)\n    {:error, :invalid_time}\n    iex> Time.new(23, 59, 59, 1_000_000)\n    {:error, :invalid_time}\n\n    # Invalid precision\n    Time.new(23, 59, 59, {999_999, 10})\n    {:error, :invalid_time}\n\n"}
{"completion":"","prompt":"Elixir.Time.new!(hour, minute, second, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO): Builds a new time.\n\nExpects all values to be integers. Returns `time` if each\nentry fits its appropriate range, raises if the time is invalid.\n\nMicroseconds can also be given with a precision, which must be an\ninteger between 0 and 6.\n\nThe built-in calendar does not support leap seconds.\n\n## Examples\n\n    iex> Time.new!(0, 0, 0, 0)\n    ~T[00:00:00.000000]\n    iex> Time.new!(23, 59, 59, 999_999)\n    ~T[23:59:59.999999]\n    iex> Time.new!(24, 59, 59, 999_999)\n    ** (ArgumentError) cannot build time, reason: :invalid_time\n"}
{"completion":"","prompt":"Elixir.Time.to_erl(time): Converts given `time` to an Erlang time tuple.\n\nWARNING: Loss of precision may occur, as Erlang time tuples\nonly contain hours/minutes/seconds.\n\n## Examples\n\n    iex> Time.to_erl(~T[23:30:15.999])\n    {23, 30, 15}\n\n    iex> Time.to_erl(~N[2010-04-17 23:30:15.999])\n    {23, 30, 15}\n\n"}
{"completion":"","prompt":"Elixir.Time.to_iso8601(time, format \\\\ :extended): Converts the given time to\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nBy default, `Time.to_iso8601/2` returns times formatted in the \"extended\"\nformat, for human readability. It also supports the \"basic\" format through\npassing the `:basic` option.\n\n### Examples\n\n    iex> Time.to_iso8601(~T[23:00:13])\n    \"23:00:13\"\n\n    iex> Time.to_iso8601(~T[23:00:13.001])\n    \"23:00:13.001\"\n\n    iex> Time.to_iso8601(~T[23:00:13.001], :basic)\n    \"230013.001\"\n\n    iex> Time.to_iso8601(~N[2010-04-17 23:00:13])\n    \"23:00:13\"\n\n"}
{"completion":"","prompt":"Elixir.Time.to_seconds_after_midnight(time): Converts a `Time` struct to a number of seconds after midnight.\n\nThe returned value is a two-element tuple with the number of seconds and microseconds.\n\n## Examples\n\n    iex> Time.to_seconds_after_midnight(~T[23:30:15])\n    {84615, 0}\n    iex> Time.to_seconds_after_midnight(~N[2010-04-17 23:30:15.999])\n    {84615, 999000}\n\n"}
{"completion":"","prompt":"Elixir.Time.to_string(time): Converts the given `time` to a string.\n\n### Examples\n\n    iex> Time.to_string(~T[23:00:00])\n    \"23:00:00\"\n    iex> Time.to_string(~T[23:00:00.001])\n    \"23:00:00.001\"\n    iex> Time.to_string(~T[23:00:00.123456])\n    \"23:00:00.123456\"\n\n    iex> Time.to_string(~N[2015-01-01 23:00:00.001])\n    \"23:00:00.001\"\n    iex> Time.to_string(~N[2015-01-01 23:00:00.123456])\n    \"23:00:00.123456\"\n\n"}
{"completion":"","prompt":"Elixir.Time.truncate(time, precision): Returns the given time with the microsecond field truncated to the given\nprecision (`:microsecond`, `millisecond` or `:second`).\n\nThe given time is returned unchanged if it already has lower precision than\nthe given precision.\n\n## Examples\n\n    iex> Time.truncate(~T[01:01:01.123456], :microsecond)\n    ~T[01:01:01.123456]\n\n    iex> Time.truncate(~T[01:01:01.123456], :millisecond)\n    ~T[01:01:01.123]\n\n    iex> Time.truncate(~T[01:01:01.123456], :second)\n    ~T[01:01:01]\n\n"}
{"completion":"","prompt":"Elixir.Time.utc_now(calendar \\\\ Calendar.ISO): Returns the current time in UTC.\n\n## Examples\n\n    iex> time = Time.utc_now()\n    iex> time.hour >= 0\n    true\n\n"}
{"completion":"","prompt":"Elixir.Tuple.append(tuple, value): Inserts an element at the end of a tuple.\n\nReturns a new tuple with the element appended at the end, and contains\nthe elements in `tuple` followed by `value` as the last element.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> tuple = {:foo, :bar}\n    iex> Tuple.append(tuple, :baz)\n    {:foo, :bar, :baz}\n\n"}
{"completion":"","prompt":"Elixir.Tuple.delete_at(tuple, index): Removes an element from a tuple.\n\nDeletes the element at the given `index` from `tuple`.\nRaises an `ArgumentError` if `index` is negative or greater than\nor equal to the length of `tuple`. Index is zero-based.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> tuple = {:foo, :bar, :baz}\n    iex> Tuple.delete_at(tuple, 0)\n    {:bar, :baz}\n\n"}
{"completion":"","prompt":"Elixir.Tuple.duplicate(data, size): Creates a new tuple.\n\nCreates a tuple of `size` containing the\ngiven `data` at every position.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Tuple.duplicate(:hello, 3)\n    {:hello, :hello, :hello}\n\n"}
{"completion":"","prompt":"Elixir.Tuple.insert_at(tuple, index, value): Inserts an element into a tuple.\n\nInserts `value` into `tuple` at the given `index`.\nRaises an `ArgumentError` if `index` is negative or greater than the\nlength of `tuple`. Index is zero-based.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> tuple = {:bar, :baz}\n    iex> Tuple.insert_at(tuple, 0, :foo)\n    {:foo, :bar, :baz}\n    iex> Tuple.insert_at(tuple, 2, :bong)\n    {:bar, :baz, :bong}\n\n"}
{"completion":"","prompt":"Elixir.Tuple.product(tuple): Computes a product of tuple elements.\n\n## Examples\n\n    iex> Tuple.product({255, 255})\n    65025\n    iex> Tuple.product({255, 1.0})\n    255.0\n    iex> Tuple.product({})\n    1\n"}
{"completion":"","prompt":"Elixir.Tuple.sum(tuple): Computes a sum of tuple elements.\n\n## Examples\n\n    iex> Tuple.sum({255, 255})\n    510\n    iex> Tuple.sum({255, 0.0})\n    255.0\n    iex> Tuple.sum({})\n    0\n"}
{"completion":"","prompt":"Elixir.Tuple.to_list(tuple): Converts a tuple to a list.\n\nReturns a new list with all the tuple elements.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> tuple = {:foo, :bar, :baz}\n    iex> Tuple.to_list(tuple)\n    [:foo, :bar, :baz]\n\n"}
{"completion":"","prompt":"Elixir.URI.%URI{}: The URI struct.\n\nThe fields are defined to match the following URI representation\n(with field names between brackets):\n\n    [scheme]://[userinfo]@[host]:[port][path]?[query]#[fragment]\n\n\nNote the `authority` field is deprecated. `parse/1` will still\npopulate it for backwards compatibility but you should generally\navoid setting or getting it.\n"}
{"completion":"","prompt":"Elixir.URI.append_query(uri, query): Appends `query` to the given `uri`.\n\nThe given `query` is not automatically encoded, use `encode/2` or `encode_www_form/1`.\n\n## Examples\n\n    iex> URI.append_query(URI.parse(\"http://example.com/\"), \"x=1\") |> URI.to_string()\n    \"http://example.com/?x=1\"\n\n    iex> URI.append_query(URI.parse(\"http://example.com/?x=1\"), \"y=2\") |> URI.to_string()\n    \"http://example.com/?x=1&y=2\"\n\n    iex> URI.append_query(URI.parse(\"http://example.com/?x=1\"), \"x=2\") |> URI.to_string()\n    \"http://example.com/?x=1&x=2\"\n"}
{"completion":"","prompt":"Elixir.URI.char_reserved?(character): Checks if `character` is a reserved one in a URI.\n\nAs specified in [RFC 3986, section 2.2](https://tools.ietf.org/html/rfc3986#section-2.2),\nthe following characters are reserved: `:`, `/`, `?`, `#`, `[`, `]`, `@`, `!`, `$`, `&`, `'`, `(`, `)`, `*`, `+`, `,`, `;`, `=`\n\n## Examples\n\n    iex> URI.char_reserved?(?+)\n    true\n\n"}
{"completion":"","prompt":"Elixir.URI.char_unescaped?(character): Checks if `character` is allowed unescaped in a URI.\n\nThis is the default used by `URI.encode/2` where both\n[reserved](`char_reserved?/1`) and [unreserved characters](`char_unreserved?/1`)\nare kept unescaped.\n\n## Examples\n\n    iex> URI.char_unescaped?(?{)\n    false\n\n"}
{"completion":"","prompt":"Elixir.URI.char_unreserved?(character): Checks if `character` is an unreserved one in a URI.\n\nAs specified in [RFC 3986, section 2.3](https://tools.ietf.org/html/rfc3986#section-2.3),\nthe following characters are unreserved:\n\n  * Alphanumeric characters: `A-Z`, `a-z`, `0-9`\n  * `~`, `_`, `-`, `.`\n\n## Examples\n\n    iex> URI.char_unreserved?(?_)\n    true\n\n"}
{"completion":"","prompt":"Elixir.URI.decode(uri): Percent-unescapes a URI.\n\n## Examples\n\n    iex> URI.decode(\"https%3A%2F%2Felixir-lang.org\")\n    \"https://elixir-lang.org\"\n\n"}
{"completion":"","prompt":"Elixir.URI.decode_query(query, map \\\\ %{}, encoding \\\\ :www_form): Decodes `query` into a map.\n\nGiven a query string in the form of `key1=value1&key2=value2...`, this\nfunction inserts each key-value pair in the query string as one entry in the\ngiven `map`. Keys and values in the resulting map will be binaries. Keys and\nvalues will be percent-unescaped.\n\nYou can specify one of the following `encoding` options:\n\n  * `:www_form` - (default, since v1.12.0) keys and values are decoded as per\n    `decode_www_form/1`. This is the format typically used by browsers on\n    query strings and form data. It decodes \"+\" as \" \".\n\n  * `:rfc3986` - (since v1.12.0) keys and values are decoded as per\n    `decode/1`. The result is the same as `:www_form` except for leaving \"+\"\n    as is in line with [RFC 3986](https://tools.ietf.org/html/rfc3986).\n\nEncoding defaults to `:www_form` for backward compatibility.\n\nUse `query_decoder/1` if you want to iterate over each value manually.\n\n## Examples\n\n    iex> URI.decode_query(\"foo=1&bar=2\")\n    %{\"bar\" => \"2\", \"foo\" => \"1\"}\n\n    iex> URI.decode_query(\"percent=oh+yes%21\", %{\"starting\" => \"map\"})\n    %{\"percent\" => \"oh yes!\", \"starting\" => \"map\"}\n\n    iex> URI.decode_query(\"percent=oh+yes%21\", %{}, :rfc3986)\n    %{\"percent\" => \"oh+yes!\"}\n\n"}
{"completion":"","prompt":"Elixir.URI.decode_www_form(string): Decodes `string` as \"x-www-form-urlencoded\".\n\nNote \"x-www-form-urlencoded\" is not specified as part of\nRFC 3986. However, it is a commonly used format to encode\nquery strings and form data by browsers.\n\n## Examples\n\n    iex> URI.decode_www_form(\"%3Call+in%2F\")\n    \"<all in/\"\n\n"}
{"completion":"","prompt":"Elixir.URI.default_port(scheme): Returns the default port for a given `scheme`.\n\nIf the scheme is unknown to the `URI` module, this function returns\n`nil`. The default port for any scheme can be configured globally\nvia `default_port/2`.\n\n## Examples\n\n    iex> URI.default_port(\"ftp\")\n    21\n\n    iex> URI.default_port(\"ponzi\")\n    nil\n\n"}
{"completion":"","prompt":"Elixir.URI.default_port(scheme, port): Registers the default `port` for the given `scheme`.\n\nAfter this function is called, `port` will be returned by\n`default_port/1` for the given scheme `scheme`. Note that this function\nchanges the default port for the given `scheme` *globally*, meaning for\nevery application.\n\nIt is recommended for this function to be invoked in your\napplication's start callback in case you want to register\nnew URIs.\n"}
{"completion":"","prompt":"Elixir.URI.encode(string, predicate \\\\ &char_unescaped?/1): Percent-escapes all characters that require escaping in `string`.\n\nThis means reserved characters, such as `:` and `/`, and the\nso-called unreserved characters, which have the same meaning both\nescaped and unescaped, won't be escaped by default.\n\nSee `encode_www_form/1` if you are interested in escaping reserved\ncharacters too.\n\nThis function also accepts a `predicate` function as an optional\nargument. If passed, this function will be called with each byte\nin `string` as its argument and should return a truthy value (anything other\nthan `false` or `nil`) if the given byte should be left as is, or return a\nfalsy value (`false` or `nil`) if the character should be escaped. Defaults\nto `URI.char_unescaped?/1`.\n\n## Examples\n\n    iex> URI.encode(\"ftp://s-ite.tld/?value=put it+Ð¹\")\n    \"ftp://s-ite.tld/?value=put%20it+%D0%B9\"\n\n    iex> URI.encode(\"a string\", &(&1 != ?i))\n    \"a str%69ng\"\n\n"}
{"completion":"","prompt":"Elixir.URI.encode_query(enumerable, encoding \\\\ :www_form): Encodes `enumerable` into a query string using `encoding`.\n\nTakes an enumerable that enumerates as a list of two-element\ntuples (for instance, a map or a keyword list) and returns a string\nin the form of `key1=value1&key2=value2...`.\n\nKeys and values can be any term that implements the `String.Chars`\nprotocol with the exception of lists, which are explicitly forbidden.\n\nYou can specify one of the following `encoding` strategies:\n\n  * `:www_form` - (default, since v1.12.0) keys and values are URL encoded as\n    per `encode_www_form/1`. This is the format typically used by browsers on\n    query strings and form data. It encodes \" \" as \"+\".\n\n  * `:rfc3986` - (since v1.12.0) the same as `:www_form` except it encodes\n    \" \" as \"%20\" according [RFC 3986](https://tools.ietf.org/html/rfc3986).\n    This is the best option if you are encoding in a non-browser situation,\n    since encoding spaces as \"+\" can be ambiguous to URI parsers. This can\n    inadvertently lead to spaces being interpreted as literal plus signs.\n\nEncoding defaults to `:www_form` for backward compatibility.\n\n## Examples\n\n    iex> query = %{\"foo\" => 1, \"bar\" => 2}\n    iex> URI.encode_query(query)\n    \"bar=2&foo=1\"\n\n    iex> query = %{\"key\" => \"value with spaces\"}\n    iex> URI.encode_query(query)\n    \"key=value+with+spaces\"\n\n    iex> query = %{\"key\" => \"value with spaces\"}\n    iex> URI.encode_query(query, :rfc3986)\n    \"key=value%20with%20spaces\"\n\n    iex> URI.encode_query(%{key: [:a, :list]})\n    ** (ArgumentError) encode_query/2 values cannot be lists, got: [:a, :list]\n\n"}
{"completion":"","prompt":"Elixir.URI.encode_www_form(string): Encodes `string` as \"x-www-form-urlencoded\".\n\nNote \"x-www-form-urlencoded\" is not specified as part of\nRFC 3986. However, it is a commonly used format to encode\nquery strings and form data by browsers.\n\n## Example\n\n    iex> URI.encode_www_form(\"put: it+Ð¹\")\n    \"put%3A+it%2B%D0%B9\"\n\n"}
{"completion":"","prompt":"Elixir.URI.merge(uri, rel): Merges two URIs.\n\nThis function merges two URIs as per\n[RFC 3986, section 5.2](https://tools.ietf.org/html/rfc3986#section-5.2).\n\n## Examples\n\n    iex> URI.merge(URI.parse(\"http://google.com\"), \"/query\") |> to_string()\n    \"http://google.com/query\"\n\n    iex> URI.merge(\"http://example.com\", \"http://google.com\") |> to_string()\n    \"http://google.com\"\n\n"}
{"completion":"","prompt":"Elixir.URI.new(uri): Creates a new URI struct from a URI or a string.\n\nIf a `%URI{}` struct is given, it returns `{:ok, uri}`. If a string is\ngiven, it will parse and validate it. If the string is valid, it returns\n`{:ok, uri}`, otherwise it returns `{:error, part}` with the invalid part\nof the URI. For parsing URIs without further validation, see `parse/1`.\n\nThis function can parse both absolute and relative URLs. You can check\nif a URI is absolute or relative by checking if the `scheme` field is\n`nil` or not.\n\nWhen a URI is given without a port, the value returned by `URI.default_port/1`\nfor the URI's scheme is used for the `:port` field. The scheme is also\nnormalized to lowercase.\n\n## Examples\n\n    iex> URI.new(\"https://elixir-lang.org/\")\n    {:ok, %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"//elixir-lang.org/\")\n    {:ok, %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"/foo/bar\")\n    {:ok, %URI{\n      fragment: nil,\n      host: nil,\n      path: \"/foo/bar\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"foo/bar\")\n    {:ok, %URI{\n      fragment: nil,\n      host: nil,\n      path: \"foo/bar\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"//[fe80::]/\")\n    {:ok, %URI{\n      fragment: nil,\n      host: \"fe80::\",\n      path: \"/\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"https:?query\")\n    {:ok, %URI{\n      fragment: nil,\n      host: nil,\n      path: nil,\n      port: 443,\n      query: \"query\",\n      scheme: \"https\",\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"/invalid_greater_than_in_path/>\")\n    {:error, \">\"}\n\nGiving an existing URI simply returns it wrapped in a tuple:\n\n    iex> {:ok, uri} = URI.new(\"https://elixir-lang.org/\")\n    iex> URI.new(uri)\n    {:ok, %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }}\n"}
{"completion":"","prompt":"Elixir.URI.new!(uri): Similar to `new/1` but raises `URI.Error` if an invalid string is given.\n\n## Examples\n\n    iex> URI.new!(\"https://elixir-lang.org/\")\n    %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }\n\n    iex> URI.new!(\"/invalid_greater_than_in_path/>\")\n    ** (URI.Error) cannot parse due to reason invalid_uri: \">\"\n\nGiving an existing URI simply returns it:\n\n    iex> uri = URI.new!(\"https://elixir-lang.org/\")\n    iex> URI.new!(uri)\n    %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }\n"}
{"completion":"","prompt":"Elixir.URI.parse(uri): Parses a URI into its components, without further validation.\n\nThis function can parse both absolute and relative URLs. You can check\nif a URI is absolute or relative by checking if the `scheme` field is\nnil or not. Furthermore, this function expects both absolute and\nrelative URIs to be well-formed and does not perform any validation.\nSee the \"Examples\" section below. Use `new/1` if you want to validate\nthe URI fields after parsing.\n\nWhen a URI is given without a port, the value returned by `URI.default_port/1`\nfor the URI's scheme is used for the `:port` field. The scheme is also\nnormalized to lowercase.\n\nIf a `%URI{}` struct is given to this function, this function returns it\nunmodified.\n\n> Note: this function sets the field :authority for backwards\n> compatibility reasons but it is deprecated.\n\n## Examples\n\n    iex> URI.parse(\"https://elixir-lang.org/\")\n    %URI{\n      authority: \"elixir-lang.org\",\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }\n\n    iex> URI.parse(\"//elixir-lang.org/\")\n    %URI{\n      authority: \"elixir-lang.org\",\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }\n\n    iex> URI.parse(\"/foo/bar\")\n    %URI{\n      fragment: nil,\n      host: nil,\n      path: \"/foo/bar\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }\n\n    iex> URI.parse(\"foo/bar\")\n    %URI{\n      fragment: nil,\n      host: nil,\n      path: \"foo/bar\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }\n\nIn contrast to `URI.new/1`, this function will parse poorly-formed\nURIs, for example:\n\n    iex> URI.parse(\"/invalid_greater_than_in_path/>\")\n    %URI{\n      fragment: nil,\n      host: nil,\n      path: \"/invalid_greater_than_in_path/>\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }\n\nAnother example is a URI with brackets in query strings. It is accepted\nby `parse/1`, it is commonly accepted by browsers, but it will be refused\nby `new/1`:\n\n    iex> URI.parse(\"/?foo[bar]=baz\")\n    %URI{\n      fragment: nil,\n      host: nil,\n      path: \"/\",\n      port: nil,\n      query: \"foo[bar]=baz\",\n      scheme: nil,\n      userinfo: nil\n    }\n\n"}
{"completion":"","prompt":"Elixir.URI.query_decoder(query, encoding \\\\ :www_form): Returns a stream of two-element tuples representing key-value pairs in the\ngiven `query`.\n\nKey and value in each tuple will be binaries and will be percent-unescaped.\n\nYou can specify one of the following `encoding` options:\n\n  * `:www_form` - (default, since v1.12.0) keys and values are decoded as per\n    `decode_www_form/1`. This is the format typically used by browsers on\n    query strings and form data. It decodes \"+\" as \" \".\n\n  * `:rfc3986` - (since v1.12.0) keys and values are decoded as per\n    `decode/1`. The result is the same as `:www_form` except for leaving \"+\"\n    as is in line with [RFC 3986](https://tools.ietf.org/html/rfc3986).\n\nEncoding defaults to `:www_form` for backward compatibility.\n\n## Examples\n\n    iex> URI.query_decoder(\"foo=1&bar=2\") |> Enum.to_list()\n    [{\"foo\", \"1\"}, {\"bar\", \"2\"}]\n\n    iex> URI.query_decoder(\"food=bread%26butter&drinks=tap%20water+please\") |> Enum.to_list()\n    [{\"food\", \"bread&butter\"}, {\"drinks\", \"tap water please\"}]\n\n    iex> URI.query_decoder(\"food=bread%26butter&drinks=tap%20water+please\", :rfc3986) |> Enum.to_list()\n    [{\"food\", \"bread&butter\"}, {\"drinks\", \"tap water+please\"}]\n\n"}
{"completion":"","prompt":"Elixir.URI.to_string(uri): Returns the string representation of the given [URI struct](`t:t/0`).\n\n## Examples\n\n    iex> uri = URI.parse(\"http://google.com\")\n    iex> URI.to_string(uri)\n    \"http://google.com\"\n\n    iex> uri = URI.parse(\"foo://bar.baz\")\n    iex> URI.to_string(uri)\n    \"foo://bar.baz\"\n\n"}
{"completion":"","prompt":"Elixir.Version.%Version{}: The Version struct.\n\nIt contains the fields `:major`, `:minor`, `:patch`, `:pre`, and\n`:build` according to SemVer 2.0, where `:pre` is a list.\n\nYou can read those fields but you should not create a new `Version`\ndirectly via the struct syntax. Instead use the functions in this\nmodule.\n"}
{"completion":"","prompt":"Elixir.Version.compare(version1, version2): Compares two versions.\n\nReturns `:gt` if the first version is greater than the second one, and `:lt`\nfor vice versa. If the two versions are equal, `:eq` is returned.\n\nPre-releases are strictly less than their corresponding release versions.\n\nPatch segments are compared lexicographically if they are alphanumeric, and\nnumerically otherwise.\n\nBuild segments are ignored: if two versions differ only in their build segment\nthey are considered to be equal.\n\nRaises a `Version.InvalidVersionError` exception if any of the two given\nversions are not parsable. If given an already parsed version this function\nwon't raise.\n\n## Examples\n\n    iex> Version.compare(\"2.0.1-alpha1\", \"2.0.0\")\n    :gt\n\n    iex> Version.compare(\"1.0.0-beta\", \"1.0.0-rc1\")\n    :lt\n\n    iex> Version.compare(\"1.0.0-10\", \"1.0.0-2\")\n    :gt\n\n    iex> Version.compare(\"2.0.1+build0\", \"2.0.1\")\n    :eq\n\n    iex> Version.compare(\"invalid\", \"2.0.1\")\n    ** (Version.InvalidVersionError) invalid version: \"invalid\"\n\n"}
{"completion":"","prompt":"Elixir.Version.compile_requirement(requirement): Compiles a requirement to an internal representation that may optimize matching.\n\nThe internal representation is opaque.\n"}
{"completion":"","prompt":"Elixir.Version.match?(version, requirement, opts \\\\ []): Checks if the given version matches the specification.\n\nReturns `true` if `version` satisfies `requirement`, `false` otherwise.\nRaises a `Version.InvalidRequirementError` exception if `requirement` is not\nparsable, or a `Version.InvalidVersionError` exception if `version` is not parsable.\nIf given an already parsed version and requirement this function won't\nraise.\n\n## Options\n\n  * `:allow_pre` (boolean) - when `false`, pre-release versions will not match\n    unless the operand is a pre-release version. Defaults to `true`.\n    For examples, please refer to the table above under the \"Requirements\" section.\n\n## Examples\n\n    iex> Version.match?(\"2.0.0\", \"> 1.0.0\")\n    true\n\n    iex> Version.match?(\"2.0.0\", \"== 1.0.0\")\n    false\n\n    iex> Version.match?(\"2.1.6-dev\", \"~> 2.1.2\")\n    true\n\n    iex> Version.match?(\"2.1.6-dev\", \"~> 2.1.2\", allow_pre: false)\n    false\n\n    iex> Version.match?(\"foo\", \"== 1.0.0\")\n    ** (Version.InvalidVersionError) invalid version: \"foo\"\n\n    iex> Version.match?(\"2.0.0\", \"== == 1.0.0\")\n    ** (Version.InvalidRequirementError) invalid requirement: \"== == 1.0.0\"\n\n"}
{"completion":"","prompt":"Elixir.Version.parse(string): Parses a version string into a `Version` struct.\n\n## Examples\n\n    iex> Version.parse(\"2.0.1-alpha1\")\n    {:ok, %Version{major: 2, minor: 0, patch: 1, pre: [\"alpha1\"]}}\n\n    iex> Version.parse(\"2.0-alpha1\")\n    :error\n\n"}
{"completion":"","prompt":"Elixir.Version.parse!(string): Parses a version string into a `Version`.\n\nIf `string` is an invalid version, a `Version.InvalidVersionError` is raised.\n\n## Examples\n\n    iex> Version.parse!(\"2.0.1-alpha1\")\n    %Version{major: 2, minor: 0, patch: 1, pre: [\"alpha1\"]}\n\n    iex> Version.parse!(\"2.0-alpha1\")\n    ** (Version.InvalidVersionError) invalid version: \"2.0-alpha1\"\n\n"}
{"completion":"","prompt":"Elixir.Version.parse_requirement(string): Parses a version requirement string into a `Version.Requirement` struct.\n\n## Examples\n\n    iex> {:ok, requirement} = Version.parse_requirement(\"== 2.0.1\")\n    iex> requirement\n    Version.parse_requirement!(\"== 2.0.1\")\n\n    iex> Version.parse_requirement(\"== == 2.0.1\")\n    :error\n\n"}
{"completion":"","prompt":"Elixir.Version.parse_requirement!(string): Parses a version requirement string into a `Version.Requirement` struct.\n\nIf `string` is an invalid requirement, a `Version.InvalidRequirementError` is raised.\n\n# Examples\n\n    iex> Version.parse_requirement!(\"== 2.0.1\")\n    Version.parse_requirement!(\"== 2.0.1\")\n\n    iex> Version.parse_requirement!(\"== == 2.0.1\")\n    ** (Version.InvalidRequirementError) invalid requirement: \"== == 2.0.1\"\n\n"}
{"completion":"","prompt":"Elixir.Version.to_string(version): Converts the given version to a string.\n\n### Examples\n\n    iex> Version.to_string(%Version{major: 1, minor: 2, patch: 3})\n    \"1.2.3\"\n    iex> Version.to_string(Version.parse!(\"1.14.0-rc.0+build0\"))\n    \"1.14.0-rc.0+build0\"\n"}
{"completion":"","prompt":"Elixir.ExUnit.after_suite(function): Sets a callback to be executed after the completion of a test suite.\n\nCallbacks set with `after_suite/1` must accept a single argument, which is a\nmap containing the results of the test suite's execution.\n\nIf `after_suite/1` is called multiple times, the callbacks will be called in\nreverse order. In other words, the last callback set will be the first to be\ncalled.\n"}
{"completion":"","prompt":"Elixir.ExUnit.async_run(): Starts tests asynchronously while test cases are still loading.\n\nIt returns a task that must be given to `await_run/0` when a result\nis desired.\n"}
{"completion":"","prompt":"Elixir.ExUnit.await_run(task): Awaits for a test suite that has been started with `async_run/0`.\n"}
{"completion":"","prompt":"Elixir.ExUnit.configuration(): Returns ExUnit configuration.\n\nFor the available configuration options, see `configure/1`.\n"}
{"completion":"","prompt":"Elixir.ExUnit.configure(options): Configures ExUnit.\n\n## Options\n\nExUnit supports the following options:\n\n  * `:assert_receive_timeout` - the timeout to be used on `assert_receive`\n    calls in milliseconds, defaults to `100`;\n\n  * `:autorun` - if ExUnit should run by default on exit. Defaults to `true`;\n\n  * `:capture_log` - if ExUnit should default to keeping track of log messages\n    and print them on test failure. Can be overridden for individual tests via\n    `@tag capture_log: false`. Defaults to `false`;\n\n  * `:colors` - a keyword list of color options to be used by some formatters:\n    * `:enabled` - boolean option to enable colors, defaults to `IO.ANSI.enabled?/0`;\n    * `:diff_insert` - color of the insertions on diffs, defaults to `:green`;\n    * `:diff_insert_whitespace` - color of the whitespace insertions on diffs,\n      defaults to `IO.ANSI.color_background(2, 0, 0)`;\n    * `:diff_delete` - color of the deletions on diffs, defaults to `:red`;\n    * `:diff_delete_whitespace` - color of the whitespace deletions on diffs,\n      defaults to `IO.ANSI.color_background(0, 2, 0)`;\n\n  * `:exclude` - specifies which tests are run by skipping tests that match the\n    filter. See the \"Filters\" section in the documentation for `ExUnit.Case`;\n\n  * `:exit_status` - specifies an alternate exit status to use when the test\n    suite fails. Defaults to 2;\n\n  * `:failures_manifest_file` - specifies a path to the file used to store failures\n    between runs;\n\n  * `:formatters` - the formatters that will print results,\n    defaults to `[ExUnit.CLIFormatter]`;\n\n  * `:include` - specifies which tests are run by skipping tests that do not\n    match the filter. Keep in mind that all tests are included by default, so unless they are\n    excluded first, the `:include` option has no effect. To only run the tests\n    that match the `:include` filter, exclude the `:test` tag first (see the\n    documentation for `ExUnit.Case` for more information on tags and filters);\n\n  * `:max_cases` - maximum number of tests to run in parallel. Only tests from\n    different modules run in parallel. It defaults to `System.schedulers_online * 2`\n    to optimize both CPU-bound and IO-bound tests;\n\n  * `:max_failures` - the suite stops evaluating tests when this number of test failures\n    is reached. All tests within a module that fail when using the\n    [`setup_all/1,2`](`ExUnit.Callbacks.setup_all/1`) callbacks\n    are counted as failures. Defaults to `:infinity`;\n\n  * `:only_test_ids` - a list of `{module_name, test_name}` tuples that limits\n    what tests get run. This is typically used by Mix to filter which tests\n    should run;\n\n  * `:refute_receive_timeout` - the timeout to be used on `refute_receive`\n    calls in milliseconds, defaults to `100`;\n\n  * `:seed` - an integer seed value to randomize the test suite. This seed\n    is also mixed with the test module and name to create a new unique seed\n    on every test, which is automatically fed into the `:rand` module. This\n    provides randomness between tests, but predictable and reproducible\n    results. A `:seed` of `0` will disable randomization and the tests in each\n    file will always run in the order that they were defined in;\n\n  * `:slowest` - prints timing information for the N slowest tests. Running\n    ExUnit with slow test reporting automatically runs in `trace` mode. It\n    is disabled by default;\n\n  * `:stacktrace_depth` - configures the stacktrace depth to be used\n    on formatting and reporters, defaults to `20`;\n\n  * `:timeout` - sets the timeout for the tests in milliseconds, defaults to `60_000`;\n\n  * `:trace` - sets ExUnit into trace mode, this sets `:max_cases` to `1` and\n    prints each test case and test while running. Note that in trace mode test\n    timeouts will be ignored as timeout is set to `:infinity`;\n\n  * `:test_location_relative_path` - the test location is the file:line information\n    printed by tests as a shortcut to run a given test. When this value is set,\n    the value is used as a prefix for the test itself. This is typically used by\n    Mix to properly set-up umbrella projects;\n\nAny arbitrary configuration can also be passed to `configure/1` or `start/1`,\nand these options can then be used in places such as custom formatters. These\nother options will be ignored by ExUnit itself.\n"}
{"completion":"","prompt":"Elixir.ExUnit.fetch_test_supervisor(): Fetches the test supervisor for the current test.\n\nReturns `{:ok, supervisor_pid}` or `:error` if not called from the test process.\n\nThis is the same supervisor as used by `ExUnit.Callbacks.start_supervised/2`\nand similar, see `ExUnit.Callbacks` module documentation for more information.\n"}
{"completion":"","prompt":"Elixir.ExUnit.plural_rule(word): Returns the pluralization for `word`.\n\nIf one is not registered, returns the word appended with an \"s\".\n"}
{"completion":"","prompt":"Elixir.ExUnit.plural_rule(word, pluralization): Registers a `pluralization` for `word`.\n\nIf one is already registered, it is replaced.\n"}
{"completion":"","prompt":"Elixir.ExUnit.run(additional_modules \\\\ []): Runs the tests. It is invoked automatically\nif ExUnit is started via `start/1`.\n\nFrom Elixir v1.14, it accepts an optional list of modules to run\nas part of the suite. This is often used to rerun modules already\nloaded in memory.\n\nReturns a map containing the total number of tests, the number\nof failures, the number of excluded tests and the number of skipped tests.\n"}
{"completion":"","prompt":"Elixir.ExUnit.start(options \\\\ []): Starts ExUnit and automatically runs tests right before the\nVM terminates.\n\nIt accepts a set of `options` to configure `ExUnit`\n(the same ones accepted by `configure/1`).\n\nIf you want to run tests manually, you can set the `:autorun` option\nto `false` and use `run/0` to run tests.\n"}
{"completion":"","prompt":"Elixir.ExUnit.AssertionError.no_value(): Indicates no meaningful value for a field.\n"}
{"completion":"","prompt":"Elixir.ExUnit.Assertions.assert(value, message): Asserts `value` is truthy, displaying the given `message` otherwise.\n\n## Examples\n\n    assert false, \"it will never be true\"\n\n    assert x == :foo, \"expected x to be foo\"\n\n    assert match?({:ok, _}, x), \"expected x to match {:ok, _}\"\n\n"}
{"completion":"","prompt":"Elixir.ExUnit.Assertions.assert_in_delta(value1, value2, delta, message \\\\ nil): Asserts that `value1` and `value2` differ by no more than `delta`.\n\nThis difference is inclusive, so the test will pass if the difference\nand the `delta` are equal.\n\n## Examples\n\n    assert_in_delta 1.1, 1.5, 0.2\n    assert_in_delta 10, 15, 2\n    assert_in_delta 10, 15, 5\n\n"}
{"completion":"","prompt":"Elixir.ExUnit.Assertions.assert_raise(exception, function): Asserts the `exception` is raised during `function` execution.\nReturns the rescued exception, fails otherwise.\n\n## Examples\n\n    assert_raise ArithmeticError, fn ->\n      1 + \"test\"\n    end\n\n"}
{"completion":"","prompt":"Elixir.ExUnit.Assertions.assert_raise(exception, message, function): Asserts the `exception` is raised during `function` execution with\nthe expected `message`, which can be a `Regex` or an exact `String`.\nReturns the rescued exception, fails otherwise.\n\n## Examples\n\n    assert_raise ArithmeticError, \"bad argument in arithmetic expression\", fn ->\n      1 + \"test\"\n    end\n\n    assert_raise RuntimeError, ~r/^today's lucky number is 0\\.\\d+!$/, fn ->\n      raise \"today's lucky number is #{:rand.uniform()}!\"\n    end\n\n"}
{"completion":"","prompt":"Elixir.ExUnit.Assertions.flunk(message \\\\ \"Flunked!\"): Fails with a message.\n\n## Examples\n\n    flunk(\"This should raise an error\")\n\n"}
{"completion":"","prompt":"Elixir.ExUnit.Assertions.refute(value, message): Asserts `value` is `nil` or `false` (that is, `value` is not truthy).\n\n## Examples\n\n    refute true, \"This will obviously fail\"\n\n"}
{"completion":"","prompt":"Elixir.ExUnit.Assertions.refute_in_delta(value1, value2, delta, message \\\\ nil): Asserts `value1` and `value2` are not within `delta`.\n\nThis difference is exclusive, so the test will fail if the difference\nand the delta are equal.\n\nIf you supply `message`, information about the values will\nautomatically be appended to it.\n\n## Examples\n\n    refute_in_delta 1.1, 1.2, 0.2\n    refute_in_delta 10, 11, 2\n\n"}
{"completion":"","prompt":"Elixir.ExUnit.CLIFormatter.child_spec(init_arg): Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.\n"}
{"completion":"","prompt":"Elixir.ExUnit.Callbacks.on_exit(name_or_ref \\\\ make_ref(), callback): Registers a callback that runs once the test exits.\n\n`callback` is a function that receives no arguments and\nruns in a separate process than the caller. Its return\nvalue is irrelevant and is discarded.\n\n`on_exit/2` is usually called from `setup/1` and `setup_all/1`\ncallbacks, often to undo the action performed during the setup.\n\nHowever, `on_exit/2` may also be called dynamically. An \"ID\" (the\n`name_or_ref` argument) can be used to guarantee that the callback\nwill be invoked only once. ExUnit uses this term to identify an\n`on_exit/2` handler: if you want to override a previous handler, for\nexample, use the same `name_or_ref` across multiple `on_exit/2`\ncalls.\n\nIf `on_exit/2` is called inside `setup/1` or inside a test, it's\nexecuted in a blocking fashion after the test exits and *before\nrunning the next test*. This means that no other test from the same\ntest case will be running while the `on_exit/2` callback for a\nprevious test is running. `on_exit/2` is executed in a different\nprocess than the test process. On the other hand, if `on_exit/2` is\ncalled inside a `setup_all/1` callback then `callback` is executed\nafter running *all tests* (see `setup_all/1` for more information).\n\n## Examples\n\n    setup do\n      File.write!(\"fixture.json\", \"{}\")\n      on_exit(fn -> File.rm!(\"fixture.json\") end)\n    end\n\nYou can use the same `name_or_ref` across multiple `on_exit/2` calls\nto \"override\" the registered handler:\n\n    setup do\n      on_exit(:drop_table, fn ->\n        Database.drop_table()\n      end)\n    end\n\n    test \"a test that shouldn't drop the table\" do\n      on_exit(:drop_table, fn -> :ok end)\n    end\n\nRelying too much on overriding callbacks like this can lead to test\ncases that are hard to understand and with too many layers of\nindirection. However, it can be useful in some cases or for library\nauthors, for example.\n"}
{"completion":"","prompt":"Elixir.ExUnit.Callbacks.start_link_supervised!(child_spec_or_module, opts \\\\ []): Same as `start_supervised!/2` but links the started process to the test process.\n\nIf the process that was started crashes, the crash is propagated to the test process,\nfailing the test and printing the cause of the crash.\n\nNote that if the started terminates before it is linked to the test process,\nthis function will exit with reason `:noproc`.\n"}
{"completion":"","prompt":"Elixir.ExUnit.Callbacks.start_supervised(child_spec_or_module, opts \\\\ []): Starts a child process under the test supervisor.\n\nIt expects a child specification or a module, similar to the ones\ngiven to `Supervisor.start_link/2`. For example, if your application\nstarts a supervision tree by running:\n\n    Supervisor.start_link([MyServer, {OtherSupervisor, ...}], ...)\n\nYou can start those processes under test in isolation by running:\n\n    start_supervised(MyServer)\n    start_supervised({OtherSupervisor, :initial_value})\n\nA keyword list can also be given if there is a need to change\nthe child specification for the given child process:\n\n    start_supervised({MyServer, :initial_value}, restart: :temporary)\n\nSee the `Supervisor` module for a discussion on child specifications\nand the available specification keys.\n\nThe advantage of starting a process under the test supervisor is that\nit is guaranteed to exit before the next test starts. Therefore, you\ndon't need to remove the process at the end of your tests via\n`stop_supervised/1`. You only need to use `stop_supervised/1 ` if you\nwant to remove a process from the supervision tree in the middle of a\ntest, as simply shutting down the process would cause it to be restarted\naccording to its `:restart` value.\n\nThe started process is not linked to the test process and a crash will\nnot necessarily fail the test. To start and link a process to guarantee\nthat any crash would also fail the test use `start_link_supervised!/2`.\n\nThis function returns `{:ok, pid}` in case of success, otherwise it\nreturns `{:error, reason}`.\n"}
{"completion":"","prompt":"Elixir.ExUnit.Callbacks.start_supervised!(child_spec_or_module, opts \\\\ []): Same as `start_supervised/2` but returns the PID on success and raises if\nnot started properly.\n"}
{"completion":"","prompt":"Elixir.ExUnit.Callbacks.stop_supervised(id): Stops a child process started via `start_supervised/2`.\n\nThis function expects the `id` in the child specification.\nFor example:\n\n    {:ok, _} = start_supervised(MyServer)\n    :ok = stop_supervised(MyServer)\n\nIt returns `:ok` if there is a supervised process with such\n`id`, `{:error, :not_found}` otherwise.\n"}
{"completion":"","prompt":"Elixir.ExUnit.Callbacks.stop_supervised!(id): Same as `stop_supervised/1` but raises if it cannot be stopped.\n"}
{"completion":"","prompt":"Elixir.ExUnit.CaptureIO.capture_io(fun): Captures IO generated when evaluating `fun`.\n\nReturns the binary which is the captured output.\n\nBy default, `capture_io` replaces the `group_leader` (`:stdio`)\nfor the current process. Capturing the group leader is done per\nprocess and therefore can be done concurrently.\n\nHowever, the capturing of any other named device, such as `:stderr`,\nhappens globally and persists until the function has ended. While this means\nit is safe to run your tests with `async: true` in many cases, captured output\nmay include output from a different test and care must be taken when using\n`capture_io` with a named process asynchronously.\n\nA developer can set a string as an input. The default input is an empty\nstring. If capturing a named device asynchronously, an input can only be given\nto the first capture. Any further capture that is given to a capture on that\ndevice will raise an exception and would indicate that the test should be run\nsynchronously.\n\nSimilarly, once a capture on a named device has begun, the encoding on that\ndevice cannot be changed in a subsequent concurrent capture. An error will\nbe raised in this case.\n\n## IO devices\n\nYou may capture the IO from any registered IO device. The device name given\nmust be an atom representing the name of a registered process. In addition,\nElixir provides two shortcuts:\n\n  * `:stdio` - a shortcut for `:standard_io`, which maps to\n    the current `Process.group_leader/0` in Erlang\n\n  * `:stderr` - a shortcut for the named process `:standard_error`\n    provided in Erlang\n\n## Options\n\n  * `:input` - An input to the IO device, defaults to `\"\"`.\n\n  * `:capture_prompt` - Define if prompts (specified as arguments to\n    `IO.get*` functions) should be captured. Defaults to `true`. For\n    IO devices other than `:stdio`, the option is ignored.\n\n  * `:encoding` (since v1.10.0) - encoding of the IO device. Allowed\n    values are `:unicode` (default) and `:latin1`.\n\n## Examples\n\n    iex> capture_io(fn -> IO.write(\"john\") end) == \"john\"\n    true\n\n    iex> capture_io(:stderr, fn -> IO.write(:stderr, \"john\") end) == \"john\"\n    true\n\n    iex> capture_io(:standard_error, fn -> IO.write(:stderr, \"john\") end) == \"john\"\n    true\n\n    iex> capture_io(\"this is input\", fn ->\n    ...>   input = IO.gets(\"> \")\n    ...>   IO.write(input)\n    ...> end) == \"> this is input\"\n    true\n\n    iex> capture_io([input: \"this is input\", capture_prompt: false], fn ->\n    ...>   input = IO.gets(\"> \")\n    ...>   IO.write(input)\n    ...> end) == \"this is input\"\n    true\n\n## Returning values\n\nAs seen in the examples above, `capture_io` returns the captured output.\nIf you want to also capture the result of the function executed,\nuse `with_io/2`.\n"}
{"completion":"","prompt":"Elixir.ExUnit.CaptureIO.capture_io(device_input_or_options, fun): Captures IO generated when evaluating `fun`.\n\nSee `capture_io/1` for more information.\n"}
{"completion":"","prompt":"Elixir.ExUnit.CaptureIO.capture_io(device, input_or_options, fun): Captures IO generated when evaluating `fun`.\n\nSee `capture_io/1` for more information.\n"}
{"completion":"","prompt":"Elixir.ExUnit.CaptureIO.with_io(fun): Invokes the given `fun` and returns the result and captured output.\n\nIt accepts the same arguments and options as `capture_io/1`.\n\n## Examples\n\n    {result, output} =\n      with_io(fn ->\n        IO.puts(\"a\")\n        IO.puts(\"b\")\n        2 + 2\n      end)\n\n    assert result == 4\n    assert output == \"a\\nb\\n\"\n"}
{"completion":"","prompt":"Elixir.ExUnit.CaptureIO.with_io(device_input_or_options, fun): Invokes the given `fun` and returns the result and captured output.\n\nSee `with_io/1` for more information.\n"}
{"completion":"","prompt":"Elixir.ExUnit.CaptureIO.with_io(device, input_or_options, fun): Invokes the given `fun` and returns the result and captured output.\n\nSee `with_io/1` for more information.\n"}
{"completion":"","prompt":"Elixir.ExUnit.CaptureLog.capture_log(opts \\\\ [], fun): Captures Logger messages generated when evaluating `fun`.\n\nReturns the binary which is the captured output.\n\nThis function mutes the `:console` backend and captures any log\nmessages sent to Logger from the calling processes. It is possible\nto ensure explicit log messages from other processes are captured\nby waiting for their exit or monitor signal.\n\nNote that when the `async` is set to `true`, the messages from another\ntest might be captured. This is OK as long you consider such cases in\nyour assertions.\n\nIt is possible to configure the level to capture with `:level`,\nwhich will set the capturing level for the duration of the\ncapture, for instance, if the log level is set to `:error`, then\nany message with the lower level will be ignored.\nThe default level is `nil`, which will capture all messages.\nNote this setting does not override the overall `Logger.level/0` value.\nTherefore, if `Logger.level/0` is set to a higher level than the one\nconfigured in this function, no message will be captured.\nThe behaviour is undetermined if async tests change Logger level.\n\nThe format, metadata and colors can be configured with `:format`,\n`:metadata` and `:colors` respectively. These three options\ndefaults to the `:console` backend configuration parameters.\n\nTo get the result of the evaluation along with the captured log,\nuse `with_log/2`.\n"}
{"completion":"","prompt":"Elixir.ExUnit.CaptureLog.with_log(opts \\\\ [], fun): Invokes the given `fun` and returns the result and captured log.\n\nIt accepts the same arguments and options as `capture_log/2`.\n\n## Examples\n\n    {result, log} =\n      with_log(fn ->\n        Logger.error(\"log msg\")\n        2 + 2\n      end)\n\n    assert result == 4\n    assert log =~ \"log msg\"\n"}
{"completion":"","prompt":"Elixir.ExUnit.CaptureServer.child_spec(init_arg): Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.\n"}
{"completion":"","prompt":"Elixir.ExUnit.Case.register_attribute(env, name, opts \\\\ []): Registers a new attribute to be used during `ExUnit.Case` tests.\n\nThe attribute values will be available through `context.registered`.\nRegistered values are cleared after each `test/3` similar\nto `@tag`.\n\nThis function takes the same options as `Module.register_attribute/3`.\n\n## Examples\n\n    defmodule MyTest do\n      use ExUnit.Case\n\n      ExUnit.Case.register_attribute(__MODULE__, :fixtures, accumulate: true)\n\n      @fixtures :user\n      @fixtures {:post, insert: false}\n      test \"using custom attribute\", context do\n        assert context.registered.fixtures == [{:post, insert: false}, :user]\n      end\n\n      test \"custom attributes are cleared per test\", context do\n        assert context.registered.fixtures == []\n      end\n    end\n\n"}
{"completion":"","prompt":"Elixir.ExUnit.Case.register_describe_attribute(env, name, opts \\\\ []): Registers a new describe attribute to be used during `ExUnit.Case` tests.\n\nThe attribute values will be available through `context.registered`.\nRegistered values are cleared after each `describe/2` similar\nto `@describetag`.\n\nThis function takes the same options as `Module.register_attribute/3`.\n\n## Examples\n\n    defmodule MyTest do\n      use ExUnit.Case\n\n      ExUnit.Case.register_describe_attribute(__MODULE__, :describe_fixtures, accumulate: true)\n\n      describe \"using custom attribute\" do\n        @describe_fixtures :user\n        @describe_fixtures {:post, insert: false}\n\n        test \"has attribute\", context do\n          assert context.registered.describe_fixtures == [{:post, insert: false}, :user]\n        end\n      end\n\n      describe \"custom attributes are cleared per describe\" do\n        test \"doesn't have attributes\", context do\n          assert context.registered.describe_fixtures == []\n        end\n      end\n    end\n\n"}
{"completion":"","prompt":"Elixir.ExUnit.Case.register_module_attribute(env, name, opts \\\\ []): Registers a new module attribute to be used during `ExUnit.Case` tests.\n\nThe attribute values will be available through `context.registered`.\n\nThis function takes the same options as `Module.register_attribute/3`.\n\n## Examples\n\n    defmodule MyTest do\n      use ExUnit.Case\n\n      ExUnit.Case.register_module_attribute(__MODULE__, :module_fixtures, accumulate: true)\n\n      @module_fixtures :user\n      @module_fixtures {:post, insert: false}\n\n      test \"using custom attribute\", context do\n        assert context.registered.module_fixtures == [{:post, insert: false}, :user]\n      end\n\n      test \"still using custom attribute\", context do\n        assert context.registered.module_fixtures == [{:post, insert: false}, :user]\n      end\n    end\n\n"}
{"completion":"","prompt":"Elixir.ExUnit.Case.register_test(map, test_type, name, tags): Registers a test with the given environment.\n\nThis function is deprecated in favor of `register_test/6` which performs\nbetter under tight loops by avoiding `__ENV__`.\n"}
{"completion":"","prompt":"Elixir.ExUnit.Case.register_test(mod, file, line, test_type, name, tags): Registers a function to run as part of this case.\n\nThis is used by third-party projects, like QuickCheck, to\nimplement macros like `property/3` that works like `test`\nbut instead defines a property. See `test/3` implementation\nfor an example of invoking this function.\n\nThe test type will be converted to a string and pluralized for\ndisplay. You can use `ExUnit.plural_rule/2` to set a custom\npluralization.\n"}
{"completion":"","prompt":"Elixir.ExUnit.Diff.compute(left, right, context): Returns the diff between `left` and `right` and env after the comparison.\n\nThe `left` side can be a literal or an AST, the `right` should always be a\nvalue. The `context` should be `{:match, pins}` for pattern matching and\n`==` and `===` for comparison cases.\n"}
{"completion":"","prompt":"Elixir.ExUnit.Diff.to_algebra(quoted, diff_wrapper): Converts a diff to an algebra document.\n"}
{"completion":"","prompt":"Elixir.ExUnit.EventManager.start_link(): Starts an event manager that publishes events during the suite run.\n\nThis is what power formatters as well as the\ninternal statistics server for ExUnit.\n"}
{"completion":"","prompt":"Elixir.ExUnit.Filters.eval(include, exclude, tags, collection): Evaluates the `include` and `exclude` filters against the given `tags` to\ndetermine if tests should be skipped or excluded.\n\nSome filters, like `:line`, may require the whole test `collection` to\nfind the closest line, that's why it must also be passed as an argument.\n\nFilters can either be a regular expression or any data structure\nthat implements the `String.Chars` protocol, which is invoked before comparing\nthe filter with the `:tag` value.\n\n## Precedence\n\nTests are first excluded, then included, and then skipped (if any left).\n\nIf a `:skip` tag is found in `tags`, `{:skipped, message}` is returned if the test\nhas been left after the `exclude` and `include` filters. Otherwise `{:exclude, message}`\nis returned.\n\nThe only exception to this rule is that `:skip` is found in the `include` filter,\n`:ok` is returned regardless of whether the test was excluded or not.\n\n## Examples\n\n    iex> ExUnit.Filters.eval([foo: \"bar\"], [:foo], %{foo: \"bar\"}, [])\n    :ok\n\n    iex> ExUnit.Filters.eval([foo: \"bar\"], [:foo], %{foo: \"baz\"}, [])\n    {:excluded, \"due to foo filter\"}\n\n"}
{"completion":"","prompt":"Elixir.ExUnit.Filters.failure_info(manifest_file): Returns a tuple containing useful information about test failures from the\nmanifest. The tuple contains:\n\n  * A set of files that contain tests that failed the last time they ran.\n    The paths are absolute paths.\n  * A set of test IDs that failed the last time they ran\n\n"}
{"completion":"","prompt":"Elixir.ExUnit.Filters.normalize(include, exclude): Normalizes `include` and `exclude` filters to remove duplicates\nand keep precedence.\n\n## Examples\n\n    iex> ExUnit.Filters.normalize(nil, nil)\n    {[], []}\n\n    iex> ExUnit.Filters.normalize([:foo, :bar, :bar], [:foo, :baz])\n    {[:foo, :bar], [:baz]}\n\n    iex> ExUnit.Filters.normalize([foo: \"true\"], [:foo])\n    {[foo: \"true\"], [:foo]}\n\n    iex> ExUnit.Filters.normalize([:foo], [foo: \"true\"])\n    {[:foo], []}\n\n    iex> ExUnit.Filters.normalize([foo: \"true\"], [foo: true])\n    {[foo: \"true\"], []}\n\n    iex> ExUnit.Filters.normalize([foo: true], [foo: \"true\"])\n    {[foo: true], []}\n\n    iex> ExUnit.Filters.normalize([foo: 1, foo: 1, foo: 2], [])\n    {[foo: 1, foo: 2], []}\n\n    iex> ExUnit.Filters.normalize([], [foo: 1, foo: 1, foo: 2])\n    {[], [foo: 1, foo: 2]}\n\n"}
{"completion":"","prompt":"Elixir.ExUnit.Filters.parse(filters): Parses the given filters, as one would receive from the command line.\n\n## Examples\n\n    iex> ExUnit.Filters.parse([\"foo:bar\", \"baz\", \"line:9\", \"bool:true\"])\n    [{:foo, \"bar\"}, :baz, {:line, \"9\"}, {:bool, \"true\"}]\n\n"}
{"completion":"","prompt":"Elixir.ExUnit.Filters.parse_path(file): Parses filters out of a path.\n\nDetermines whether a given file path (supplied to ExUnit/Mix as arguments\non the command line) includes a line number filter, and if so returns the\nappropriate ExUnit configuration options.\n"}
{"completion":"","prompt":"Elixir.ExUnit.Formatter.format_assertion_diff(assert_error, padding_size, width, formatter): Formats `ExUnit.AssertionError` diff.\n\nIt returns a keyword list with diffing information\nfrom the left and right side of the assertion, if\nany exists.\n\nIt expects the assertion error, the `padding_size`\nfor formatted content, the width (may be `:infinity`),\nand the formatter callback function.\n"}
{"completion":"","prompt":"Elixir.ExUnit.Formatter.format_filters(filters, type): Formats filters used to constrain cases to be run.\n\n## Examples\n\n    iex> format_filters([run: true, slow: false], :include)\n    \"Including tags: [run: true, slow: false]\"\n\n"}
{"completion":"","prompt":"Elixir.ExUnit.Formatter.format_test_all_failure(test_module, failures, counter, width, formatter): Receives a test module and formats its failure.\n"}
{"completion":"","prompt":"Elixir.ExUnit.Formatter.format_test_failure(test, failures, counter, width, formatter): Receives a test and formats its failure.\n"}
{"completion":"","prompt":"Elixir.ExUnit.Formatter.format_times(times): Formats time taken running the test suite.\n\n## Examples\n\n    iex> format_times(%{run: 10000, async: nil, load: nil})\n    \"Finished in 0.01 seconds (0.00s async, 0.01s sync)\"\n\n    iex> format_times(%{run: 10000, async: nil, load: 20000})\n    \"Finished in 0.03 seconds (0.02s on load, 0.00s async, 0.01s sync)\"\n\n    iex> format_times(%{run: 10000, async: nil, load: 200_000})\n    \"Finished in 0.2 seconds (0.2s on load, 0.00s async, 0.01s sync)\"\n\n    iex> format_times(%{run: 100_000, async: 50000, load: 200_000})\n    \"Finished in 0.3 seconds (0.2s on load, 0.05s async, 0.05s sync)\"\n\n"}
{"completion":"","prompt":"Elixir.ExUnit.OnExitHandler.child_spec(arg): Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.\n"}
{"completion":"","prompt":"Elixir.ExUnit.RunnerStats.child_spec(init_arg): Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.\n"}
{"completion":"","prompt":"Elixir.ExUnit.Server.child_spec(init_arg): Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.\n"}
{"completion":"","prompt":"Elixir.IEx.after_spawn(): Returns registered `after_spawn` callbacks.\n"}
{"completion":"","prompt":"Elixir.IEx.after_spawn(fun): Registers a function to be invoked after the IEx process is spawned.\n"}
{"completion":"","prompt":"Elixir.IEx.break!(module, function, arity, stops \\\\ 1): Sets up a breakpoint in `module`, `function` and `arity` with\nthe given number of `stops`.\n\nThis function will instrument the given module and load a new\nversion in memory with line by line breakpoints at the given\nfunction and arity. If the module is recompiled, all breakpoints\nare lost.\n\nWhen a breakpoint is reached, IEx will ask if you want to `pry`\nthe given function and arity. In other words, this works similar\nto `IEx.pry/0` as the running process becomes the evaluator of\nIEx commands and is temporarily changed to have a custom group\nleader. However, differently from `IEx.pry/0`, aliases and imports\nfrom the source code won't be available in the shell.\n\nIEx helpers includes many conveniences related to breakpoints.\nBelow they are listed with the full module, such as `IEx.Helpers.breaks/0`,\nbut remember it can be called directly as `breaks()` inside IEx.\nThey are:\n\n  * `IEx.Helpers.break!/2` - sets up a breakpoint for a given `Mod.fun/arity`\n  * `IEx.Helpers.break!/4` - sets up a breakpoint for the given module, function, arity\n  * `IEx.Helpers.breaks/0` - prints all breakpoints and their IDs\n  * `IEx.Helpers.continue/0` - continues until the next breakpoint in the same shell\n  * `IEx.Helpers.n/0` - goes to the next line of the current breakpoint\n  * `IEx.Helpers.next/0` - same as above\n  * `IEx.Helpers.open/0` - opens editor on the current breakpoint\n  * `IEx.Helpers.remove_breaks/0` - removes all breakpoints in all modules\n  * `IEx.Helpers.remove_breaks/1` - removes all breakpoints in a given module\n  * `IEx.Helpers.reset_break/1` - sets the number of stops on the given ID to zero\n  * `IEx.Helpers.reset_break/3` - sets the number of stops on the given module, function, arity to zero\n  * `IEx.Helpers.respawn/0` - starts a new shell (breakpoints will ask for permission once more)\n  * `IEx.Helpers.whereami/1` - shows the current location\n\nBy default, the number of stops in a breakpoint is 1. Any follow-up\ncall won't stop the code execution unless another breakpoint is set.\n\nAlternatively, the number of stops can be increased by passing the `stops`\nargument. `IEx.Helpers.reset_break/1` and `IEx.Helpers.reset_break/3`\ncan be used to reset the number back to zero. Note the module remains\n\"instrumented\" even after all stops on all breakpoints are consumed.\nYou can remove the instrumentation in a given module by calling\n`IEx.Helpers.remove_breaks/1` and on all modules by calling\n`IEx.Helpers.remove_breaks/0`.\n\nWithin a breakpoint, you can call `n` to jump to the next line.\nTo exit a breakpoint, you can either invoke `continue`, which will\nblock the shell until the next breakpoint is found or the process\nterminates, or invoke `respawn`, which starts a new IEx shell,\nfreeing up the pried one.\n\n## Examples\n\nThe examples below will use `break!`, assuming that you are setting\na breakpoint directly from your IEx shell. But you can set up a break\nfrom anywhere by using the fully qualified name `IEx.break!`.\n\nThe following sets up a breakpoint on `URI.parse/2`:\n\n    break! URI, :parse, 1\n\nThis call will setup a breakpoint that stops once.\nTo set a breakpoint that will stop 10 times:\n\n    break! URI, :parse, 1, 10\n\n`IEx.break!/2` is a convenience macro that allows breakpoints\nto be given in the `Mod.fun/arity` format:\n\n    break! URI.parse/1\n\nOr to set a breakpoint that will stop 10 times:\n\n    break! URI.parse/1, 10\n\nThis function returns the breakpoint ID and will raise if there\nis an error setting up the breakpoint.\n\n## Patterns and guards\n\n`IEx.break!/2` allows patterns to be given, triggering the\nbreakpoint only in some occasions. For example, to trigger\nthe breakpoint only when the first argument starts with the\n\"https\" string:\n\n    break! URI.parse(\"https\" <> _, _)\n\nOnly a single break point can be set per function. So if you call\n`IEx.break!` multiple times with different patterns, only the last\npattern is kept.\n\n## Macros\n\nWhile it is possible to set breakpoint in macros, remember that macros\nare generally expanded at compilation time, and therfore they may never\nbe invoked during runtime. Similarly, while patterns may be given to\nmacros, macros receive ASTs as arguments, and not values. For example,\nif you try to break on a macro with the following pattern:\n\n    break! MyModule.some_macro(pid) when pid == self()\n\nThis breakpoint will never be reached, because a macro never receives\na PID. Even if you call the macro as `MyModule.some_macro(self())`,\nthe macro will receive the AST representing the `self()` call, and not\nthe PID itself.\n\n## Breaks and `mix test`\n\nTo use `IEx.break!/4` during tests, you need to run `mix` inside\nthe `iex` command and pass the `--trace` to `mix test` to avoid running\ninto timeouts:\n\n    iex -S mix test --trace\n    iex -S mix test path/to/file:line --trace\n\n"}
{"completion":"","prompt":"Elixir.IEx.color(color, string): Returns `string` escaped using the specified `color`.\n\nANSI escapes in `string` are not processed in any way.\n"}
{"completion":"","prompt":"Elixir.IEx.configuration(): Returns IEx configuration.\n"}
{"completion":"","prompt":"Elixir.IEx.configure(options): Configures IEx.\n\nThe supported options are:\n\n  * `:colors`\n  * `:inspect`\n  * `:width`\n  * `:history_size`\n  * `:default_prompt`\n  * `:continuation_prompt`\n  * `:alive_prompt`\n  * `:alive_continuation_prompt`\n  * `:parser`\n\nThey are discussed individually in the sections below.\n\n## Colors\n\nA keyword list that encapsulates all color settings used by the\nshell. See documentation for the `IO.ANSI` module for the list of\nsupported colors and attributes.\n\nList of supported keys in the keyword list:\n\n  * `:enabled` - boolean value that allows for switching the coloring on and off\n  * `:eval_result` - color for an expression's resulting value\n  * `:eval_info` - ... various informational messages\n  * `:eval_error` - ... error messages\n  * `:eval_interrupt` - ... interrupt messages\n  * `:stack_info` - ... the stacktrace color\n  * `:blame_diff` - ... when blaming source with no match\n  * `:ls_directory` - ... for directory entries (ls helper)\n  * `:ls_device` - ... device entries (ls helper)\n\nWhen printing documentation, IEx will convert the Markdown\ndocumentation to ANSI as well. Colors for this can be configured\nvia:\n\n  * `:doc_code`        - the attributes for code blocks (cyan, bright)\n  * `:doc_inline_code` - inline code (cyan)\n  * `:doc_headings`    - h1 and h2 (yellow, bright)\n  * `:doc_title`       - the overall heading for the output (reverse, yellow, bright)\n  * `:doc_bold`        - (bright)\n  * `:doc_underline`   - (underline)\n\nIEx will also color inspected expressions using the `:syntax_colors`\noption. Such can be disabled with:\n\n    IEx.configure(colors: [syntax_colors: false])\n\nYou can also configure the syntax colors, however, as desired.\nThe below will format atoms in red and remove the coloring for\nall other data types:\n\n    IEx.configure(colors: [syntax_colors: [atom: :red]])\n\nThe default values can be found in `IO.ANSI.syntax_colors/0`.\n\n## Inspect\n\nA keyword list containing inspect options used by the shell\nwhen printing results of expression evaluation. Defaults to\npretty formatting with a limit of 50 entries.\n\nTo show all entries, configure the limit to `:infinity`:\n\n    IEx.configure(inspect: [limit: :infinity])\n\nSee `Inspect.Opts` for the full list of options.\n\n## Width\n\nAn integer indicating the maximum number of columns to use in output.\nThe default value is 80 columns. The actual output width is the minimum\nof this number and result of `:io.columns`. This way you can configure IEx\nto be your largest screen size and it should always take up the full width\nof your current terminal screen.\n\n## History size\n\nNumber of expressions and their results to keep in the history.\nThe value is an integer. When it is negative, the history is unlimited.\n\n## Prompt\n\nThis is an option determining the prompt displayed to the user\nwhen awaiting input.\n\nThe value is a keyword list with two possible keys representing prompt types:\n\n  * `:default_prompt` - used when `Node.alive?/0` returns `false`\n\n  * `:continuation_prompt` - used when `Node.alive?/0` returns `false`\n    and more input is expected\n\n  * `:alive_prompt` - used when `Node.alive?/0` returns `true`\n\n  * `:alive_continuation_prompt` - used when `Node.alive?/0` returns\n    `true` and more input is expected\n\nThe following values in the prompt string will be replaced appropriately:\n\n  * `%counter` - the index of the history\n  * `%prefix`  - a prefix given by `IEx.Server`\n  * `%node`    - the name of the local node\n\n## Parser\n\nThis is an option determining the parser to use for IEx.\n\nThe parser is a \"mfargs\", which is a tuple with three elements:\nthe module name, the function name, and extra arguments to\nbe appended. The parser receives at least three arguments, the\ncurrent input as a string, the parsing options as a keyword list,\nand the buffer as a string. It must return `{:ok, expr, buffer}`\nor `{:incomplete, buffer}`.\n\nIf the parser raises, the buffer is reset to an empty string.\n"}
{"completion":"","prompt":"Elixir.IEx.inspect_opts(): Returns the options used for inspecting.\n"}
{"completion":"","prompt":"Elixir.IEx.started?(): Returns `true` if IEx was started, `false` otherwise.\n"}
{"completion":"","prompt":"Elixir.IEx.width(): Returns the IEx width for printing.\n\nUsed by helpers and it has a default maximum cap of 80 chars.\n"}
{"completion":"","prompt":"Elixir.IEx.Autocomplete.expand(code, shell \\\\ IEx.Broker.shell()): The expansion logic.\n\nSome of the expansion has to be use the current shell\nenvironment, which is found via the broker.\n"}
{"completion":"","prompt":"Elixir.IEx.Autocomplete.remsh(node): Provides one helper function that is injected into connecting\nremote nodes to properly handle autocompletion.\n"}
{"completion":"","prompt":"Elixir.IEx.Broker.child_spec(init_arg): Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.\n"}
{"completion":"","prompt":"Elixir.IEx.Broker.evaluator(pid \\\\ shell()): Finds the evaluator and server running inside `:user_drv`, on this node exclusively.\n"}
{"completion":"","prompt":"Elixir.IEx.Broker.register(pid): Registers an IEx server in the broker.\n\nAll instances, except shell ones, are registered.\n"}
{"completion":"","prompt":"Elixir.IEx.Broker.respond(broker_pid, take_ref, bool): Client responds to a takeover request.\n\nThe broker's PID is needed to support remote shells.\n"}
{"completion":"","prompt":"Elixir.IEx.Broker.shell(): Finds the IEx server.\n"}
{"completion":"","prompt":"Elixir.IEx.Broker.take_over(location, whereami, opts): Client requests a takeover.\n"}
{"completion":"","prompt":"Elixir.IEx.CLI.start(): In order to work properly, IEx needs to be set as the\nproper `-user` when starting the Erlang VM and we do so\nby pointing exactly to this function.\n\nIf possible, Elixir will start a tty (smart terminal)\nwhich makes all control commands available in tty\navailable to the developer.\n\nIn case `tty` is not available (for example, Windows),\na dumb terminal version is started instead.\n"}
{"completion":"","prompt":"Elixir.IEx.Config.child_spec(arg): Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.\n"}
{"completion":"","prompt":"Elixir.IEx.Evaluator.fields_from_env(evaluator, server, fields): Returns the named fields from the current session environment.\n"}
{"completion":"","prompt":"Elixir.IEx.Evaluator.init(command, server, leader, opts): Eval loop for an IEx session. Its responsibilities include:\n\n  * loading of .iex files\n  * evaluating code\n  * trapping exceptions in the code being evaluated\n  * keeping expression history\n\n"}
{"completion":"","prompt":"Elixir.IEx.Evaluator.value_from_binding(evaluator, server, var_name, map_key_path): Gets a value out of the binding, using the provided\nvariable name and map key path.\n"}
{"completion":"","prompt":"Elixir.IEx.Evaluator.variables_from_binding(evaluator, server, variable_prefix): Gets a list of variables out of the binding that match the passed\nvariable prefix.\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.break!(module, function, arity, stops \\\\ 1): Sets up a breakpoint in `module`, `function` and `arity`\nwith the given number of `stops`.\n\nSee `IEx.break!/4` for a complete description of breakpoints\nin IEx.\n\n## Examples\n\n    break! URI, :decode_query, 2\n\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.breaks(): Prints all breakpoints to the terminal.\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.c(files, path \\\\ :in_memory): Compiles the given files.\n\nIt expects a list of files to compile and an optional path to write\nthe compiled code to. By default files are in-memory compiled.\nTo write compiled files to the current directory, an empty string\ncan be given.\n\nIt returns the names of the compiled modules.\n\nIf you want to recompile an existing module, check `r/1` instead.\n\n## Examples\n\nIn the example below, we pass a directory to where the `c/2` function will\nwrite the compiled `.beam` files to. This directory is typically named \"ebin\"\nin Erlang/Elixir systems:\n\n    iex> c([\"foo.ex\", \"bar.ex\"], \"ebin\")\n    [Foo, Bar]\n\nWhen compiling one file, there is no need to wrap it in a list:\n\n    iex> c(\"baz.ex\")\n    [Baz]\n\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.cd(directory): Changes the current working directory to the given path.\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.clear(): Clears the console screen.\n\nThis function only works if ANSI escape codes are enabled\non the shell, which means this function is by default\nunavailable on Windows machines.\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.continue(): Continues execution of the current process.\n\nThis is usually called by sessions started with `IEx.pry/0`\nor `IEx.break!/4`. This allows the current process to execute\nuntil the next breakpoint, which will automatically yield control\nback to IEx without requesting permission to pry.\n\nIf you simply want to move to the next line of the current breakpoint,\nuse `n/0` or `next/0` instead.\n\nIf the running process terminates, a new IEx session is\nstarted.\n\nWhile the process executes, the user will no longer have\ncontrol of the shell. If you would rather start a new shell,\nuse `respawn/0` instead.\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.exports(module \\\\ Kernel): Prints a list of all the functions and macros exported by the given module.\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.flush(): Clears out all messages sent to the shell's inbox and prints them out.\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.h(): Prints the documentation for `IEx.Helpers`.\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.i(term \\\\ v(-1)): Prints information about the data type of any given term.\n\nIf no argument is given, the value of the previous expression\nis used.\n\n## Examples\n\n    iex> i(1..5)\n\nWill print:\n\n    Term\n      1..5\n    Data type\n      Range\n    Description\n      This is a struct. Structs are maps with a __struct__ key.\n    Reference modules\n      Range, Map\n\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.l(module): Loads the given module's BEAM code (and ensures any previous\nold version was properly purged before).\n\nThis function is useful when you know the bytecode for module\nhas been updated in the file system and you want to tell the VM\nto load it.\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.ls(path \\\\ \".\"): Prints a list of the given directory's contents.\n\nIf `path` points to a file, prints its full path.\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.n(): A shortcut for `next/0`.\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.next(): Goes to the next line of the current breakpoint.\n\nThis is usually called by sessions started with `IEx.break!/4`.\nIf instead of the next line you want to move to the next breakpoint,\ncall `continue/0` instead.\n\nWhile the process executes, the user will no longer have\ncontrol of the shell. If you would rather start a new shell,\nuse `respawn/0` instead.\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.nl(nodes \\\\ Node.list(), module): Deploys a given module's BEAM code to a list of nodes.\n\nThis function is useful for development and debugging when you have code that\nhas been compiled or updated locally that you want to run on other nodes.\n\nThe node list defaults to a list of all connected nodes.\n\nReturns `{:error, :nofile}` if the object code (i.e. \".beam\" file) for the module\ncould not be found locally.\n\n## Examples\n\n    iex> nl(HelloWorld)\n    {:ok,\n     [\n       {:node1@easthost, :loaded, HelloWorld},\n       {:node1@westhost, :loaded, HelloWorld}\n     ]}\n\n    iex> nl(NoSuchModuleExists)\n    {:error, :nofile}\n\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.open(): Opens the current prying location.\n\nThis command only works inside a pry session started manually\nvia `IEx.pry/0` or a breakpoint set via `IEx.break!/4`. Calling\nthis function during a regular `IEx` session will print an error.\n\nKeep in mind the `open/0` location may not exist when prying\nprecompiled source code, such as Elixir itself.\n\nFor more information and to open any module or function, see\n`open/1`.\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.pid(string): Creates a PID from `string` or `atom`.\n\n## Examples\n\n    iex> pid(\"0.21.32\")\n    #PID<0.21.32>\n\n    iex> pid(:init)\n    #PID<0.0.0>\n\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.pid(x, y, z): Creates a PID with 3 non-negative integers passed as arguments\nto the function.\n\n## Examples\n\n    iex> pid(0, 21, 32)\n    #PID<0.21.32>\n    iex> pid(0, 64, 2048)\n    #PID<0.64.2048>\n\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.port(string): Creates a Port from `string`.\n\n## Examples\n\n    iex> port(\"0.4\")\n    #Port<0.4>\n\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.port(major, minor): Creates a Port from two non-negative integers.\n\n## Examples\n\n    iex> port(0, 8080)\n    #Port<0.8080>\n    iex> port(0, 443)\n    #Port<0.443>\n\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.pwd(): Prints the current working directory.\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.r(module_or_modules): Recompiles and reloads the given `module` or `modules`.\n\nPlease note that all the modules defined in the same file as\n`modules` are recompiled and reloaded. If you want to reload\nmultiple modules, it is best to reload them at the same time,\nsuch as in `r [Foo, Bar]`. This is important to avoid false\nwarnings, since the module is only reloaded in memory and its\nlatest information is not persisted to disk. See the \"In-memory\nreloading\" section below.\n\nThis function is meant to be used for development and\ndebugging purposes. Do not depend on it in production code.\n\n## In-memory reloading\n\nWhen we reload the module in IEx, we recompile the module source\ncode, updating its contents in memory. The original `.beam` file\nin disk, probably the one where the first definition of the module\ncame from, does not change at all.\n\nSince docs, typespecs, and exports information are loaded from the\n.beam file, they are not reloaded when you invoke this function.\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.recompile(options \\\\ []): Recompiles the current Mix project.\n\nThis helper only works when IEx is started with a Mix\nproject, for example, `iex -S mix`. Note this function\nsimply recompiles Elixir modules, without reloading\nconfiguration, recompiling dependencies, or restarting\napplications.\n\nTherefore, any long running process may crash on recompilation,\nas changed modules will be temporarily removed and recompiled,\nwithout going through the proper code change callback.\n\nIf you want to reload a single module, consider using\n`r(ModuleName)` instead.\n\nThis function is meant to be used for development and\ndebugging purposes. Do not depend on it in production code.\n\n## Options\n\n  * `:force` - when `true`, forces the application to recompile\n\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.ref(string): Creates a Reference from `string`.\n\n## Examples\n\n    iex> ref(\"0.1.2.3\")\n    #Reference<0.1.2.3>\n\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.ref(w, x, y, z): Creates a Reference from its 4 non-negative integers components.\n\n## Examples\n\n    iex> ref(0, 1, 2, 3)\n    #Reference<0.1.2.3>\n\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.remove_breaks(): Removes all breakpoints and instrumentation from all modules.\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.remove_breaks(module): Removes all breakpoints and instrumentation from `module`.\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.reset_break(id): Sets the number of pending stops in the breakpoint\nwith the given `id` to zero.\n\nReturns `:ok` if there is such breakpoint ID. `:not_found`\notherwise.\n\nNote the module remains \"instrumented\" on reset. If you would\nlike to effectively remove all breakpoints and instrumentation\ncode from a module, use `remove_breaks/1` instead.\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.reset_break(module, function, arity): Sets the number of pending stops in the given module,\nfunction and arity to zero.\n\nIf the module is not instrumented or if the given function\ndoes not have a breakpoint, it is a no-op and it returns\n`:not_found`. Otherwise it returns `:ok`.\n\nNote the module remains \"instrumented\" on reset. If you would\nlike to effectively remove all breakpoints and instrumentation\ncode from a module, use `remove_breaks/1` instead.\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.respawn(): Respawns the current shell by starting a new shell process.\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.runtime_info(): Prints VM/runtime information such as versions, memory usage and statistics.\n\nAdditional topics are available via `runtime_info/1`.\n\nFor more metrics, info, and debugging facilities, see the\n[Recon](https://github.com/ferd/recon) project.\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.runtime_info(topic): Just like `runtime_info/0`, except accepts topic or a list of topics.\n\nFor example, topic `:applications` will list the applications loaded.\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.v(n \\\\ -1): Returns the value of the `n`th expression in the history.\n\n`n` can be a negative value: if it is, the corresponding expression value\nrelative to the current one is returned. For example, `v(-2)` returns the\nvalue of the expression evaluated before the last evaluated expression. In\nparticular, `v(-1)` returns the result of the last evaluated expression and\n`v()` does the same.\n\n## Examples\n\n    iex(1)> \"hello\" <> \" world\"\n    \"hello world\"\n    iex(2)> 40 + 2\n    42\n    iex(3)> v(-2)\n    \"hello world\"\n    iex(4)> v(2)\n    42\n    iex(5)> v()\n    42\n\n"}
{"completion":"","prompt":"Elixir.IEx.Helpers.whereami(radius \\\\ 2): Prints the current location and stacktrace in a pry session.\n\nIt expects a `radius` which chooses how many lines before and after\nthe current line we should print. By default the `radius` is of two\nlines:\n\n    Location: lib/iex/lib/iex/helpers.ex:79\n\n    77:\n    78:   def recompile do\n    79:     require IEx; IEx.pry()\n    80:     if mix_started?() do\n    81:       config = Mix.Project.config\n\n    (IEx.Helpers) lib/iex/lib/iex/helpers.ex:78: IEx.Helpers.recompile/0\n\nThis command only works inside a pry session started manually\nvia `IEx.pry/0` or a breakpoint set via `IEx.break!/4`. Calling\nthis function during a regular `IEx` session will print an error.\n\nKeep in mind the `whereami/1` location may not exist when prying\nprecompiled source code, such as Elixir itself.\n"}
{"completion":"","prompt":"Elixir.IEx.History.append(state, entry, limit): Appends one entry to the history.\n"}
{"completion":"","prompt":"Elixir.IEx.History.each(state, fun): Enumerates over all items in the history starting from the oldest one and\napplies `fun` to each one in turn.\n"}
{"completion":"","prompt":"Elixir.IEx.History.init(): Initializes IEx history state.\n"}
{"completion":"","prompt":"Elixir.IEx.History.nth(history, n): Gets the nth item from the history.\n\nIf `n` < 0, the count starts from the most recent item and goes back in time.\n"}
{"completion":"","prompt":"Elixir.IEx.Info.info(term): Returns information for the given term.\n\nInformation should be returned as a list of `info_name`-`info` tuples,\nwhere `info_name` is a string-like value, such as an atom or a string\nitself, and `info` is a string. `info_name` should be short. `info` can\nbe arbitrarily long and contain newlines.\n\n`IEx.Helpers.i/1` will generate (and always display)\nthe 'Implemented protocols' and 'Term' sections in the result.\n\nAll other sections of information are added (and can be overridden)\nby customized implementations of this function.\n\nIt is recommended to at least include the following sections for a\ncustom implementation:\n\n  * `\"Data type\"`: Name of the data type. Usually the name of the module\n     defining the data type.\n  * `\"Description\"`: One or a few sentences describing what the data type represents.\n  * `\"Reference modules`: One or a few comma-separated module names that focus\n    on working with this datatype.\n\nOther recommended sections are:\n\n  * `\"Raw representation`: showing another way of writing the passed `term`.\n    This is mostly relevant for data-structures whose `String.Chars`-implementations\n    make use of sigils or other syntactic sugar.\n"}
{"completion":"","prompt":"Elixir.IEx.Introspection.b(mod): Prints the list of behaviour callbacks or a given callback.\n"}
{"completion":"","prompt":"Elixir.IEx.Introspection.decompose(term, context): Decomposes an introspection call into `{mod, fun, arity}`,\n`{mod, fun}` or `mod`.\n"}
{"completion":"","prompt":"Elixir.IEx.Introspection.h(module): Prints documentation.\n"}
{"completion":"","prompt":"Elixir.IEx.Introspection.open(module): Opens the given module, mfa, file/line, binary.\n"}
{"completion":"","prompt":"Elixir.IEx.Introspection.t(module): Prints the types for the given module and type documentation.\n"}
{"completion":"","prompt":"Elixir.IEx.Pry.break(module, function, arity, breaks \\\\ 1): Sets up a breakpoint on the given module/function/arity.\n"}
{"completion":"","prompt":"Elixir.IEx.Pry.break(module, function, args, guard, env, breaks \\\\ 1): Sets up a breakpoint on the given module/function/args with the given `guard`.\n\nIt requires an `env` to be given to make the expansion of the guards.\n"}
{"completion":"","prompt":"Elixir.IEx.Pry.break!(module, function, arity, breaks \\\\ 1): Raising variant of `break/4`.\n"}
{"completion":"","prompt":"Elixir.IEx.Pry.break!(module, function, args, guard, env, breaks \\\\ 1): Raising variant of `break/6`.\n"}
{"completion":"","prompt":"Elixir.IEx.Pry.breaks(): Returns all breakpoints.\n"}
{"completion":"","prompt":"Elixir.IEx.Pry.pry(binding, env): Callback for `IEx.pry/0`.\n\nYou can invoke this function directly when you are not able to invoke\n`IEx.pry/0` as a macro. This function expects the binding (from\n`binding/0`) and the environment (from `__ENV__/0`).\n"}
{"completion":"","prompt":"Elixir.IEx.Pry.remove_breaks(): Removes all breakpoints on all modules.\n\nThis effectively loads the non-instrumented version of\ncurrently instrumented modules into memory.\n"}
{"completion":"","prompt":"Elixir.IEx.Pry.remove_breaks(module): Removes breakpoints in the given module.\n\nThis effectively loads the non-instrumented version of\nthe module into memory.\n"}
{"completion":"","prompt":"Elixir.IEx.Pry.reset_break(id): Resets the breaks on a given breakpoint ID.\n"}
{"completion":"","prompt":"Elixir.IEx.Pry.reset_break(module, function, arity): Resets the breaks for the given `module`, `function` and `arity`.\n\nIf the `module` is not instrumented or if the given `function`\ndoes not have a breakpoint, it is a no-op and it returns\n`:not_found`. Otherwise it returns `:ok`.\n"}
{"completion":"","prompt":"Elixir.IEx.Pry.whereami(file, line, radius): Formats the location for `whereami/3` prying.\n\nIt receives the `file`, `line` and the snippet `radius` and\nreturns `{:ok, lines}`, where lines is a list of chardata\ncontaining each formatted line, or `:error`.\n\nThe actual line is especially formatted in bold.\n"}
{"completion":"","prompt":"Elixir.IEx.Server.run(opts): Starts a new IEx server session.\n\nThe accepted options are:\n\n  * `:prefix` - the IEx prefix\n  * `:env` - the `Macro.Env` used for the evaluator\n  * `:binding` - an initial set of variables for the evaluator\n  * `:on_eof` - if it should `:stop_evaluator` (default) or `:halt` the system\n\n"}
{"completion":"","prompt":"Elixir.Logger.add_backend(backend, opts \\\\ []): Adds a new backend.\n\nAdding a backend calls the `init/1` function in that backend\nwith the name of the backend as its argument. For example,\ncalling\n\n    Logger.add_backend(MyBackend)\n\nwill call `MyBackend.init(MyBackend)` to initialize the new\nbackend. If the backend's `init/1` callback returns `{:ok, _}`,\nthen this function returns `{:ok, pid}`. If the handler returns\n`{:error, :ignore}` from `init/1`, this function still returns\n`{:ok, pid}` but the handler is not started. If the handler\nreturns `{:error, reason}` from `init/1`, this function returns\n`{:error, {reason, info}}` where `info` is more information on\nthe backend that failed to start.\n\nBackends added by this function are not persisted. Therefore\nif the Logger application or supervision tree is restarted,\nthe backend won't be available. If you need this guarantee,\nthen configure the backend via the application environment:\n\n    config :logger, :backends, [MyBackend]\n\n## Options\n\n  * `:flush` - when `true`, guarantees all messages currently sent\n    to `Logger` are processed before the backend is added\n\n## Examples\n\n    {:ok, _pid} = Logger.add_backend(MyBackend, flush: true)\n\n"}
{"completion":"","prompt":"Elixir.Logger.add_translator(translator): Adds a new translator.\n"}
{"completion":"","prompt":"Elixir.Logger.bare_log(level, message_or_fun, metadata \\\\ []): Logs a message dynamically.\n\nOpposite to `log/3`, `debug/2`, `info/2`, and friends, the arguments\ngiven to `bare_log/3` are always evaluated. However, you can pass\nanonymous functions to `bare_log/3` and they will only be evaluated\nif there is something to be logged.\n"}
{"completion":"","prompt":"Elixir.Logger.compare_levels(left, right): Compares log levels.\n\nReceives two log levels and compares the `left` level\nagainst the `right` level and returns:\n\n  * `:lt` if `left` is less than `right`\n  * `:eq` if `left` and `right` are equal\n  * `:gt` if `left` is greater than `right`\n\n## Examples\n\n    iex> Logger.compare_levels(:debug, :warning)\n    :lt\n    iex> Logger.compare_levels(:error, :info)\n    :gt\n\n"}
{"completion":"","prompt":"Elixir.Logger.configure(options): Configures the logger.\n\nSee the \"Runtime Configuration\" section in the `Logger` module\ndocumentation for the available options. The changes done here\nare automatically persisted to the `:logger` application\nenvironment.\n"}
{"completion":"","prompt":"Elixir.Logger.configure_backend(backend, options): Configures the given backend.\n\nThe backend needs to be started and running in order to\nbe configured at runtime.\n"}
{"completion":"","prompt":"Elixir.Logger.delete_all_module_levels(): Resets the logging level for all modules to the primary level.\n"}
{"completion":"","prompt":"Elixir.Logger.delete_application_level(appname): Resets logging level for all modules in the given application to the primary level.\n\nEquivalent of:\n\n    appname |> Application.spec(:modules) |> Logger.delete_module_level()\n"}
{"completion":"","prompt":"Elixir.Logger.delete_module_level(module): Resets the logging level for a given module to the primary level.\n"}
{"completion":"","prompt":"Elixir.Logger.delete_process_level(pid): Resets logging level for the current process to the primary level.\n\nCurrently the only accepted PID is `self()`.\n"}
{"completion":"","prompt":"Elixir.Logger.disable(pid): Disables logging for the current process.\n\nCurrently the only accepted PID is `self()`.\n\nEquivalent of:\n\n    put_process_level(pid, :none)\n"}
{"completion":"","prompt":"Elixir.Logger.enable(pid): Enables logging for the current process.\n\nCurrently the only accepted PID is `self()`.\n\nEquivalent of:\n\n    delete_process_level(pid)\n"}
{"completion":"","prompt":"Elixir.Logger.enabled?(pid): Returns whether the logging is enabled for a given process.\n\nCurrently the only accepted PID is `self()`.\n"}
{"completion":"","prompt":"Elixir.Logger.flush(): Flushes the logger.\n\nThis guarantees all messages sent to `Logger` prior to this call will\nbe processed. This is useful for testing and it should not be called\nin production code.\n"}
{"completion":"","prompt":"Elixir.Logger.get_module_level(mod): Gets logging level for given module.\n\nThe returned value will be the effective value used. If no value\nwas set for a given module, then it will not be present in\nthe returned list.\n"}
{"completion":"","prompt":"Elixir.Logger.get_process_level(pid): Gets logging level for the current process.\n\nCurrently the only accepted PID is `self()`.\n\nThe returned value will be the effective value used. If no value\nwas set for a given process, then `nil` is returned.\n"}
{"completion":"","prompt":"Elixir.Logger.level(): Retrieves the `Logger` level.\n\nThe `Logger` level can be changed via `configure/1`.\n"}
{"completion":"","prompt":"Elixir.Logger.metadata(): Reads the current process metadata.\n"}
{"completion":"","prompt":"Elixir.Logger.metadata(keyword): Alters the current process metadata according to the given keyword list.\n\nThis function will merge the given keyword list into the existing metadata,\nwith the exception of setting a key to `nil`, which will remove that key\nfrom the metadata.\n"}
{"completion":"","prompt":"Elixir.Logger.put_application_level(appname, level): Puts logging level for modules in a given application.\n\nThis will take priority over the primary level set, so it can be\nused to increase or decrease verbosity of some parts of the project.\n\nEquivalent of:\n\n    appname |> Application.spec(:modules) |> Logger.put_module_level(level)\n"}
{"completion":"","prompt":"Elixir.Logger.put_module_level(mod, level): Puts logging level for given module.\n\nThis will take priority over the primary level set, so it can be\nused to increase or decrease verbosity of some parts of the project.\n\n## Example\n\n    defmodule Foo do\n      require Logger\n\n      def log, do: Logger.debug(\"foo\")\n    end\n\n    Logger.configure(level: :error)\n    Logger.put_module_level(Foo, :all)\n\n    Foo.log()\n    # This will print the message even if global level is :error\n\n"}
{"completion":"","prompt":"Elixir.Logger.put_process_level(pid, level): Puts logging level for the current process.\n\nCurrently the only accepted PID is `self()`.\n\nThis will take priority over the primary level set, so it can be\nused to increase or decrease verbosity of some parts of the running system.\n"}
{"completion":"","prompt":"Elixir.Logger.remove_backend(backend, opts \\\\ []): Removes a backend.\n\n## Options\n\n  * `:flush` - when `true`, guarantees all messages currently sent\n    to `Logger` are processed before the backend is removed\n\n"}
{"completion":"","prompt":"Elixir.Logger.remove_translator(translator): Removes a translator.\n"}
{"completion":"","prompt":"Elixir.Logger.reset_metadata(keyword \\\\ []): Resets the current process metadata to the given keyword list.\n"}
{"completion":"","prompt":"Elixir.Logger.App.stop(): Stops the application without sending messages to error logger.\n"}
{"completion":"","prompt":"Elixir.Logger.BackendSupervisor.child_spec(init_arg): Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.\n"}
{"completion":"","prompt":"Elixir.Logger.BackendSupervisor.start_link(_): Starts the backend supervisor.\n"}
{"completion":"","prompt":"Elixir.Logger.BackendSupervisor.translate_backend(other): Translates the shortcut backend name into its handler.\n"}
{"completion":"","prompt":"Elixir.Logger.BackendSupervisor.unwatch(backend): Removes the given `backend`.\n"}
{"completion":"","prompt":"Elixir.Logger.BackendSupervisor.watch(backend): Watches the given `backend`.\n"}
{"completion":"","prompt":"Elixir.Logger.Filter.filter_elixir_domain(map, extra): Filter messages logged via `Logger` module when not logging OTP reports.\n"}
{"completion":"","prompt":"Elixir.Logger.Filter.process_level(map, extra): Filter out logs if current process opted out of certain levels.\n"}
{"completion":"","prompt":"Elixir.Logger.Filter.silence_logger_exit(arg1, extra): A filter that waits until Logger exits and then removes itself.\n"}
{"completion":"","prompt":"Elixir.Logger.Formatter.compile(pattern): Compiles a format string into a data structure that `format/5` can handle.\n\nCheck the module doc for documentation on the valid parameters that\nwill be interpolated in the pattern. If you pass `nil` as the pattern,\nthe pattern defaults to:\n\n    \"\\n$time $metadata[$level] $message\\n\"\n\nIf you want to customize formatting through a custom formatter, you can\npass a `{module, function}` tuple as the `pattern`.\n\n    iex> Logger.Formatter.compile(\"$time $metadata [$level] $message\\n\")\n    [:time, \" \", :metadata, \" [\", :level, \"] \", :message, \"\\n\"]\n\n    iex> Logger.Formatter.compile({MyLoggerFormatter, :format})\n    {MyLoggerFormatter, :format}\n\n"}
{"completion":"","prompt":"Elixir.Logger.Formatter.format(pattern_or_function, level, message, timestamp, metadata): Takes a compiled format and injects the level, timestamp, message, and\nmetadata keyword list and returns a properly formatted string.\n\nIf `pattern_or_function` is a `{module, function_name}` tuple,\nthen `module.function_name(level, message, timestamp, metadata)` is\ninvoked to get the message. See `Logger.Backends.Console` for more\ninformation on this.\n\n## Examples\n\n    iex> pattern = Logger.Formatter.compile(\"[$level] $message\")\n    iex> timestamp = {{1977, 01, 28}, {13, 29, 00, 000}}\n    iex> formatted = Logger.Formatter.format(pattern, :info, \"hello\", timestamp, [])\n    iex> IO.chardata_to_string(formatted)\n    \"[info] hello\"\n\n"}
{"completion":"","prompt":"Elixir.Logger.Formatter.format_date(arg): Formats date as chardata.\n"}
{"completion":"","prompt":"Elixir.Logger.Formatter.format_time(arg): Formats time as chardata.\n"}
{"completion":"","prompt":"Elixir.Logger.Formatter.prune(binary): Prunes invalid Unicode code points from lists and invalid UTF-8 bytes.\n\nTypically called after formatting when the data cannot be printed.\n"}
{"completion":"","prompt":"Elixir.Logger.Translator.translate(min_level, level, kind, message): Built-in translation function.\n"}
{"completion":"","prompt":"Elixir.Logger.Utils.scan_inspect(format, args, truncate, opts \\\\ %Inspect.Opts{}): Receives a format string and arguments, scans them, and then replace `~p`,\n`~P`, `~w` and `~W` by its inspected variants.\n\nFor information about format scanning and how to consume them,\ncheck `:io_lib.scan_format/2`\n"}
{"completion":"","prompt":"Elixir.Logger.Utils.timestamp(timestamp \\\\ :os.system_time(:microsecond), utc_log?): Returns a timestamp that includes milliseconds.\n"}
{"completion":"","prompt":"Elixir.Logger.Utils.truncate(chardata, n): Truncates a `chardata` into `n` bytes.\n\nThere is a chance we truncate in the middle of a grapheme\ncluster but we never truncate in the middle of a binary\ncode point. For this reason, truncation is not exact.\n"}
{"completion":"","prompt":"Elixir.Logger.Watcher.child_spec(init_arg): Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.\n"}
{"completion":"","prompt":"Elixir.Logger.Watcher.start_link(tuple): Starts a watcher server.\n\nThis is useful when there is a need to start a handler\noutside of the handler supervision tree.\n"}
