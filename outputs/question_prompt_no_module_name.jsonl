{"completion":"Returns the default compilers used by Mix.\n\nIt can be used in your `mix.exs` to prepend or\nappend new compilers to Mix:\n\n    def project do\n      [compilers: Mix.compilers() ++ [:foo, :bar]]\n    end","prompt":"Can you write a docstring for the following Elixir function? compilers()"}
{"completion":"Sets Mix debug mode.","prompt":"Can you write a docstring for the following Elixir function? debug(debug)"}
{"completion":"Returns `true` if Mix is in debug mode, `false` otherwise.","prompt":"Can you write a docstring for the following Elixir function? debug?()"}
{"completion":"Returns the current Mix environment.\n\nThis function should not be used at runtime in application code (as opposed\nto infrastructure and build code like Mix tasks). Mix is a build tool and may\nnot be available after the code is compiled (for example in a release).\n\nTo differentiate the program behavior depending on the environment, it is\nrecommended to use application environment through `Application.get_env/3`.\nProper configuration can be set in config files, often per-environment\n(see the `Config` module for more information).","prompt":"Can you write a docstring for the following Elixir function? env()"}
{"completion":"Changes the current Mix environment to `env`.\n\nBe careful when invoking this function as any project\nconfiguration won't be reloaded.\n\nThis function should not be used at runtime in application code\n(see `env/0` for more information).","prompt":"Can you write a docstring for the following Elixir function? env(env)"}
{"completion":"Installs and starts dependencies.\n\nThe given `deps` should be in the same format as defined in a regular Mix\nproject. See `mix help deps` for more information. As a shortcut, an atom\ncan be given as dependency to mean the latest version. In other words,\nspecifying `:decimal` is the same as `{:decimal, \">= 0.0.0\"}`.\n\nAfter each successful installation, a given set of dependencies is cached\nso starting another VM and calling `Mix.install/2` with the same dependencies\nwill avoid unnecessary downloads and compilations. The location of the cache\ndirectory can be controlled using the `MIX_INSTALL_DIR` environment variable.\n\nThis function can only be called outside of a Mix project and only with the\nsame dependencies in the given VM.\n\n**Note:** this feature is currently experimental and it may change\nin future releases.\n\n## Options\n\n  * `:force` - if `true`, runs with empty install cache. This is useful when you want\n    to update your dependencies or your install got into an inconsistent state.\n    To use this option, you can also set the `MIX_INSTALL_FORCE` environment variable.\n    (Default: `false`)\n\n  * `:verbose` - if `true`, prints additional debugging information\n    (Default: `false`)\n\n  * `:consolidate_protocols` - if `true`, runs protocol\n    consolidation via the `mix compile.protocols` task (Default: `true`)\n\n  * `:elixir` - if set, ensures the current Elixir version matches the given\n    version requirement (Default: `nil`)\n\n  * `:system_env` (since v1.13.0) - a list or a map of system environment variable\n    names with respective values as binaries. The system environment is made part\n    of the `Mix.install/2` cache, so different configurations will lead to different apps\n\n  * `:config` (since v1.13.0) - a keyword list of keyword lists with application\n    configuration to be set before the apps loaded. The configuration is part of\n    the `Mix.install/2` cache, so different configurations will lead to different\n    apps\n\n  * `:config_path` (since v1.14.0) - path to a configuration file. If a `runtime.exs`\n    file exists in the same directory as the given path, it is loaded too.\n\n  * `:lockfile` (since v1.14.0) - path to a lockfile to be used as a basis of\n    dependency resolution.\n\n## Examples\n\nInstalling `:decimal` and `:jason`:\n\n    Mix.install([\n      :decimal,\n      {:jason, \"~> 1.0\"}\n    ])\n\nInstalling `:nx` & `:exla`, and configuring the underlying applications\nand environment variables:\n\n    Mix.install(\n      [:nx, :exla],\n      config: [\n        nx: [default_backend: EXLA]\n      ],\n      system_env: [\n        XLA_TARGET: \"cuda111\"\n      ]\n    )\n\nInstalling a Mix project as a path dependency along with its configuration\nand deps:\n\n    # $ git clone https://github.com/hexpm/hexpm /tmp/hexpm\n    # $ cd /tmp/hexpm && mix setup\n\n    Mix.install(\n      [\n        {:hexpm, path: \"/tmp/hexpm\", env: :dev},\n      ],\n      config_path: \"/tmp/hexpm/config/config.exs\",\n      lockfile: \"/tmp/hexpm/mix.lock\"\n    )\n\n    Hexpm.Repo.query!(\"SELECT COUNT(1) from packages\")\n    #=> ...\n\nThe example above can be simplified by passing the application\nname as an atom for `:config_path` and `:lockfile`:\n\n    Mix.install(\n      [\n        {:hexpm, path: \"/tmp/hexpm\", env: :dev},\n      ],\n      config_path: :hexpm,\n      lockfile: :hexpm\n    )\n\n## Limitations\n\nThere is one limitation to `Mix.install/2`, which is actually an Elixir\nbehaviour. If you are installing a dependency that defines a struct or\nmacro, you cannot use the struct or macro immediately after the install\ncall. For example, this won't work:\n\n    Mix.install([:decimal])\n    %Decimal{} = Decimal.new(42)\n\nThat's because Elixir first expands all structs and all macros, and then\nit executes the code. This means that, by the time Elixir tries to expand\nthe `%Decimal{}` struct, the dependency has not been installed yet.\n\nLuckily this has a straightforward solution, which is move the code to\ninside a module:\n\n    Mix.install([:decimal])\n\n    defmodule Script do\n      def run do\n        %Decimal{} = Decimal.new(42)\n      end\n    end\n\n    Script.run()\n\nThe contents inside `defmodule` will only be expanded and executed\nafter `Mix.install/2` runs, which means that any struct, macros,\nand imports will be correctly handled.","prompt":"Can you write a docstring for the following Elixir function? install(deps, opts \\\\ [])"}
{"completion":"Returns whether `Mix.install/2` was called in the current node.","prompt":"Can you write a docstring for the following Elixir function? installed?()"}
{"completion":"The path for local archives or escripts.","prompt":"Can you write a docstring for the following Elixir function? path_for(atom)"}
{"completion":"Raises a Mix error that is nicely formatted, defaulting to exit status `1`.","prompt":"Can you write a docstring for the following Elixir function? raise(message)"}
{"completion":"Raises a Mix error that is nicely formatted.\n\n## Options\n\n  * `:exit_status` - defines exit status, defaults to `1`","prompt":"Can you write a docstring for the following Elixir function? raise(message, opts)"}
{"completion":"Returns the current shell.\n\n`shell/0` can be used as a wrapper for the current shell. It contains\nconveniences for requesting information from the user, printing to the\nshell and so forth. The Mix shell is swappable (see `shell/1`), allowing\ndevelopers to use a test shell that simply sends messages to the current\nprocess instead of performing IO (see `Mix.Shell.Process`).\n\nBy default, this returns `Mix.Shell.IO`.\n\n## Examples\n\n    Mix.shell().info(\"Preparing to do something dangerous...\")\n\n    if Mix.shell().yes?(\"Are you sure?\") do\n      # do something dangerous\n    end","prompt":"Can you write a docstring for the following Elixir function? shell()"}
{"completion":"Sets the current shell.\n\nAs an argument you may pass `Mix.Shell.IO`, `Mix.Shell.Process`,\n`Mix.Shell.Quiet`, or any module that implements the `Mix.Shell`\nbehaviour.\n\nAfter calling this function, `shell` becomes the shell that is\nreturned by `shell/0`.\n\n## Examples\n\n    iex> Mix.shell(Mix.Shell.IO)\n    :ok\n\nYou can use `shell/0` and `shell/1` to temporarily switch shells,\nfor example, if you want to run a Mix Task that normally produces\na lot of output:\n\n    shell = Mix.shell()\n    Mix.shell(Mix.Shell.Quiet)\n\n    try do\n      Mix.Task.run(\"noisy.task\")\n    after\n      Mix.shell(shell)\n    end","prompt":"Can you write a docstring for the following Elixir function? shell(shell)"}
{"completion":"Returns the Mix target.","prompt":"Can you write a docstring for the following Elixir function? target()"}
{"completion":"Changes the current Mix target to `target`.\n\nBe careful when invoking this function as any project\nconfiguration won't be reloaded.","prompt":"Can you write a docstring for the following Elixir function? target(target)"}
{"completion":"Mix is a build tool that provides tasks for creating, compiling,\nand testing Elixir projects, managing its dependencies, and more.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix"}
{"completion":"Mix.Project\n\nThe foundation of Mix is a project. A project can be defined by using\n`Mix.Project` in a module, usually placed in a file named `mix.exs`:\n\n    defmodule MyApp.MixProject do\n      use Mix.Project\n\n      def project do\n        [\n          app: :my_app,\n          version: \"1.0.0\"\n        ]\n      end\n    end\n\nSee the `Mix.Project` module for detailed documentation on Mix projects.\n\nOnce the project is defined, a number of default Mix tasks can be run\ndirectly from the command line:\n\n  * `mix compile` - compiles the current project\n  * `mix test` - runs tests for the given project\n  * `mix run` - runs a particular command inside the project\n\nEach task has its own options and sometimes specific configuration\nto be defined in the `project/0` function. You can use `mix help`\nto list all available tasks and `mix help NAME` to show help for\na particular task.\n\nThe best way to get started with your first project is by calling\n`mix new my_project` from the command line.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix"}
{"completion":"Mix.Task\n\nTasks are what make Mix extensible.\n\nProjects can extend Mix behaviour by adding their own tasks. For\nexample, adding the task below inside your project will\nmake it available to everyone that uses your project:\n\n    defmodule Mix.Tasks.Hello do\n      use Mix.Task\n\n      def run(_) do\n        Mix.shell().info(\"Hello world\")\n      end\n    end\n\nThe task can now be invoked with `mix hello`.\n\nSee the `Mix.Task` behaviour for detailed documentation on Mix tasks.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix"}
{"completion":"Dependencies\n\nMix also manages your dependencies and integrates nicely with the [Hex package\nmanager](https://hex.pm).\n\nIn order to use dependencies, you need to add a `:deps` key\nto your project configuration. We often extract the list of dependencies\ninto its own function:\n\n    defmodule MyApp.MixProject do\n      use Mix.Project\n\n      def project do\n        [\n          app: :my_app,\n          version: \"1.0.0\",\n          deps: deps()\n        ]\n      end\n\n      defp deps do\n        [\n          {:ecto, \"~> 2.0\"},\n          {:plug, github: \"elixir-lang/plug\"}\n        ]\n      end\n    end\n\nYou can run `mix help deps` to learn more about dependencies in Mix.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix"}
{"completion":"Environments\n\nMix supports different environments. Environments allow developers\nto prepare and organize their project specifically for different\nscenarios. By default, Mix provides three environments:\n\n  * `:dev` - the default environment\n  * `:test` - the environment `mix test` runs on\n  * `:prod` - the environment your dependencies run on\n\nThe environment can be changed via the command line by setting\nthe `MIX_ENV` environment variable, for example:\n\n```bash\n$ MIX_ENV=prod mix run server.exs\n```\n\nYou can also specify that certain dependencies are available only for\ncertain environments:\n\n    {:some_test_dependency, \"~> 1.0\", only: :test}\n\nThe environment can be read via `Mix.env/0`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix"}
{"completion":"Targets\n\nBesides environments, Mix supports targets. Targets are useful when a\nproject needs to compile to different architectures and some of the\ndependencies are only available to some of them. By default, the target\nis `:host` but it can be set via the `MIX_TARGET` environment variable.\nThe target can be read via `Mix.target/0`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix"}
{"completion":"Configuration\n\nMix allows you configure the application environment of your application\nand of your dependencies. See the `Application` module to learn more about\nthe application environment. On this section, we will focus on how to configure\nit at two distinct moments: build-time and runtime.\n\n> Note: The application environment is discouraged for libraries. See Elixir's\n> [Library Guidelines](https://hexdocs.pm/elixir/library-guidelines.html) for\n> more information.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix"}
{"completion":"# Build-time configuration\n\nWhenever you invoke a `mix` command, Mix loads the configuration\nin `config/config.exs`, if said file exists. It is common for the\n`config/config.exs` file itself to import other configuration based\non the current `MIX_ENV`, such as `config/dev.exs`, `config/test.exs`,\nand `config/prod.exs`, by calling `Config.import_config/1`:\n\n    import Config\n    import_config \"#{config_env()}.exs\"\n\nWe say `config/config.exs` and all imported files are build-time\nconfiguration as they are evaluated whenever you compile your code.\nIn other words, if your configuration does something like:\n\n    import Config\n    config :my_app, :secret_key, System.fetch_env!(\"MY_APP_SECRET_KEY\")\n\nThe `:secret_key` key under `:my_app` will be computed on the host\nmachine before your code compiles. This can be an issue if the machine\ncompiling your code does not have access to all environment variables\nused to run your code, as loading the config above will fail due to the\nmissing environment variable. Luckily, Mix also provides runtime\nconfiguration, which should be preferred and we will see next.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix"}
{"completion":"# Runtime configuration\n\nTo enable runtime configuration in your release, all you need to do is\nto create a file named `config/runtime.exs`:\n\n    import Config\n    config :my_app, :secret_key, System.fetch_env!(\"MY_APP_SECRET_KEY\")\n\nThis file is executed whenever your project runs. If you assemble\na release with `mix release`, it also executes every time your release\nstarts.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix"}
{"completion":"Aliases\n\nAliases are shortcuts or tasks specific to the current project.\n\nIn the [Mix.Task section](#module-mix-task), we have defined a task that would be\navailable to everyone using our project as a dependency. What if\nwe wanted the task to only be available for our project? Just\ndefine an alias:\n\n    defmodule MyApp.MixProject do\n      use Mix.Project\n\n      def project do\n        [\n          app: :my_app,\n          version: \"1.0.0\",\n          aliases: aliases()\n        ]\n      end\n\n      defp aliases do\n        [\n          c: \"compile\",\n          hello: &hello/1\n        ]\n      end\n\n      defp hello(_) do\n        Mix.shell().info(\"Hello world\")\n      end\n    end\n\nIn the example above, we have defined two aliases. One is `mix c`\nwhich is a shortcut for `mix compile`. The other is named\n`mix hello`, which is the equivalent to the `Mix.Tasks.Hello`\nwe have defined in the [Mix.Task section](#module-mix-task).\n\nAliases may also be lists, specifying multiple tasks to be run\nconsecutively:\n\n    [all: [&hello/1, \"deps.get --only #{Mix.env()}\", \"compile\"]]\n\nIn the example above, we have defined an alias named `mix all`,\nthat prints \"Hello world\", then fetches dependencies specific\nto the current environment, and compiles the project.\n\nAliases can also be used to augment existing tasks. Let's suppose\nyou want to augment `mix clean` to clean another directory Mix does\nnot know about:\n\n    [clean: [\"clean\", &clean_extra/1]]\n\nWhere `&clean_extra/1` would be a function in your `mix.exs`\nwith extra cleanup logic.\n\nArguments given to the alias will be appended to the arguments of\nthe last task in the list. Except when overriding an existing task.\nIn this case, the arguments will be given to the original task,\nin order to preserve semantics. For example, in the `:clean` alias\nabove, the arguments given to the alias will be passed to \"clean\"\nand not to `clean_extra/1`.\n\nAliases defined in the current project do not affect its dependencies\nand aliases defined in dependencies are not accessible from the\ncurrent project.\n\nAliases can be used very powerfully to also run Elixir scripts and\nshell commands, for example:\n\n    # priv/hello1.exs\n    IO.puts(\"Hello One\")\n\n    # priv/hello2.exs\n    IO.puts(\"Hello Two\")\n\n    # priv/world.sh\n    #!/bin/sh\n    echo \"world!\"\n\n    # mix.exs\n    defp aliases do\n      [\n        some_alias: [\"hex.info\", \"run priv/hello1.exs\", \"cmd priv/world.sh\"]\n      ]\n    end\n\nIn the example above we have created the alias `some_alias` that will\nrun the task `mix hex.info`, then `mix run` to run an Elixir script,\nthen `mix cmd` to execute a command line shell script. This shows how\npowerful aliases mixed with Mix tasks can be.\n\nMix tasks are designed to run only once. This prevents the same task\nfrom being executed multiple times. For example, if there are several tasks\ndepending on `mix compile`, the code will be compiled once. Tasks can\nbe executed again if they are explicitly reenabled using `Mix.Task.reenable/1`:\n\n    another_alias: [\n      \"format --check-formatted priv/hello1.exs\",\n      \"cmd priv/world.sh\",\n      fn _ -> Mix.Task.reenable(\"format\") end,\n      \"format --check-formatted priv/hello2.exs\"\n    ]\n\nSome tasks are automatically reenabled though, as they are expected to\nbe invoked multiple times. They are: `mix cmd`, `mix do`, `mix loadconfig`,\n`mix profile.cprof`, `mix profile.eprof`, `mix profile.fprof`, `mix run`,\nand `mix xref`.\n\nIt is worth mentioning that some tasks, such as in the case of the\n`mix format` command in the example above, can accept multiple files so it\ncould be rewritten as:\n\n    another_alias: [\"format --check-formatted priv/hello1.exs priv/hello2.exs\"]","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix"}
{"completion":"Environment variables\n\nSeveral environment variables can be used to modify Mix's behaviour.\n\nMix responds to the following variables:\n\n  * `MIX_ARCHIVES` - specifies the directory into which the archives should be installed\n    (default: `~/.mix/archives`)\n  * `MIX_BUILD_ROOT` - sets the root directory where build artifacts\n    should be written to. For example, \"_build\". If `MIX_BUILD_PATH` is set, this\n    option is ignored.\n  * `MIX_BUILD_PATH` - sets the project `Mix.Project.build_path/0` config. This option\n    must always point to a subdirectory inside a temporary directory. For instance,\n    never \"/tmp\" or \"_build\" but \"_build/PROD\" or \"/tmp/PROD\", as required by Mix\n  * `MIX_DEPS_PATH` - sets the project `Mix.Project.deps_path/0` config for the current project (default: `deps`)\n  * `MIX_DEBUG` - outputs debug information about each task before running it\n  * `MIX_ENV` - specifies which environment should be used. See [Environments](#module-environments)\n  * `MIX_TARGET` - specifies which target should be used. See [Targets](#module-targets)\n  * `MIX_EXS` - changes the full path to the `mix.exs` file\n  * `MIX_HOME` - path to Mix's home directory, stores configuration files and scripts used by Mix\n    (default: `~/.mix`)\n  * `MIX_INSTALL_DIR` - (since v1.12.0) specifies directory where `Mix.install/2` keeps\n     install cache\n  * `MIX_INSTALL_FORCE` - (since v1.13.0) runs `Mix.install/2` with empty install cache\n  * `MIX_PATH` - appends extra code paths\n  * `MIX_QUIET` - does not print information messages to the terminal\n  * `MIX_REBAR3` - path to rebar3 command that overrides the one Mix installs\n    (default: `~/.mix/rebar3`)\n  * `MIX_XDG` - asks Mix to follow the [XDG Directory Specification](https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html)\n    for its home directory and configuration files. This behaviour needs to\n    be opt-in due to backwards compatibility. `MIX_HOME` has higher preference\n    than `MIX_XDG`. If none of the variables are set, the default directory\n    `~/.mix` will be used\n\nEnvironment variables that are not meant to hold a value (and act basically as\nflags) should be set to either `1` or `true`, for example:\n\n    $ MIX_DEBUG=1 mix compile","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix"}
{"completion":"Runs Mix according to the command line arguments.","prompt":"Can you write a docstring for the following Elixir function? main(args \\\\ System.argv())"}
{"completion":"Removes compiled files for the given `manifest`.","prompt":"Can you write a docstring for the following Elixir function? clean(manifest, compile_path)"}
{"completion":"Compiles stale Elixir files.\n\nIt expects a `manifest` file, the source directories, the destination\ndirectory, the cache key based on compiler configuration, external\nmanifests, and external modules, followed by opts.\n\nThe `manifest` is written down with information including dependencies\nbetween modules, which helps it recompile only the modules that\nhave changed at runtime.","prompt":"Can you write a docstring for the following Elixir function? compile(manifest, srcs, dest, new_cache_key, new_parent_manifests, new_parents, opts)"}
{"completion":"Returns protocols and implementations for the given `manifest`.","prompt":"Can you write a docstring for the following Elixir function? protocols_and_impls(manifest, compile_path)"}
{"completion":"Reads the manifest for external consumption.","prompt":"Can you write a docstring for the following Elixir function? read_manifest(manifest)"}
{"completion":"Asserts that the `:erlc_paths` configuration option that many Mix tasks\nrely on is valid.\n\nRaises a `Mix.Error` exception if the option is not valid, returns `:ok`\notherwise.","prompt":"Can you write a docstring for the following Elixir function? assert_valid_erlc_paths(erlc_paths)"}
{"completion":"Removes compiled files for the given `manifest`.","prompt":"Can you write a docstring for the following Elixir function? clean(manifest)"}
{"completion":"Compiles the given `mappings`.\n\n`mappings` should be a list of tuples in the form of `{src, dest}`.\n\nA `manifest` file and a `callback` to be invoked for each src/dest pair\nmust be given. A src/dest pair where destination is `nil` is considered\nto be up to date and won't be (re-)compiled.\n\n## Options\n\n  * `:force` - forces compilation regardless of modification times\n\n  * `:parallel` - a mapset of files to compile in parallel","prompt":"Can you write a docstring for the following Elixir function? compile(manifest, mappings, opts \\\\ [], callback)"}
{"completion":"Compiles the files in `mappings` with given extensions into\nthe destination, automatically invoking the callback for each\nstale input and output pair (or for all if `force` is `true`) and\nremoving files that no longer have a source, while keeping the\n`manifest` up to date.\n\n`mappings` should be a list of tuples in the form of `{src, dest}` paths.\n\n## Options\n\n  * `:force` - forces compilation regardless of modification times\n\n  * `:parallel` - a mapset of files to compile in parallel\n\n## Examples\n\nFor example, a simple compiler for Lisp Flavored Erlang\nwould be implemented like:\n\n    manifest = Path.join(Mix.Project.manifest_path(), \"compile.lfe\")\n    dest = Mix.Project.compile_path()\n\n    compile(manifest, [{\"src\", dest}], :lfe, :beam, opts, fn input, output ->\n      :lfe_comp.file(\n        to_erl_file(input),\n        [{:outdir, Path.dirname(output)}, :return, :report]\n      )\n    end)\n\nThe command above will:\n\n  1. look for files ending with the `lfe` extension in `src` path\n     and their `beam` counterpart in `ebin` path\n\n  2. for each stale file (or for all if `force` is `true`),\n     invoke the callback passing the calculated input\n     and output\n\n  3. update the manifest with the newly compiled outputs\n\n  4. remove any output in the manifest that does not\n     have an equivalent source\n\nThe callback must return `{:ok, term, warnings}` or\n`{:error, errors, warnings}` in case of error. This function returns\n`{status, diagnostics}` as specified in `Mix.Task.Compiler`.","prompt":"Can you write a docstring for the following Elixir function? compile(manifest, mappings, src_ext, dest_ext, opts, callback)"}
{"completion":"Ensures the native OTP application is available.","prompt":"Can you write a docstring for the following Elixir function? ensure_application!(app, input)"}
{"completion":"Returns the output paths in the manifest.","prompt":"Can you write a docstring for the following Elixir function? outputs(manifest)"}
{"completion":"Converts the given `file` to a format accepted by\nthe Erlang compilation tools.","prompt":"Can you write a docstring for the following Elixir function? to_erl_file(file)"}
{"completion":"Requires and runs test files.\n\nIt expects all of the test patterns, the test files that were matched for the\ntest patterns, the test paths, and the opts from the test task.","prompt":"Can you write a docstring for the following Elixir function? require_and_run(matched_test_files, test_paths, elixirc_opts, opts)"}
{"completion":"Configures the given `root_key`.\n\nKeyword lists are always deep merged.\n\n## Examples\n\nThe given `opts` are merged into the existing configuration\nfor the given `root_key`. Conflicting keys are overridden by the\nones specified in `opts`. For example, the application\nconfiguration below\n\n    config :logger,\n      level: :warn,\n      backends: [:console]\n\n    config :logger,\n      level: :info,\n      truncate: 1024\n\nwill have a final configuration for `:logger` of:\n\n    [level: :info, backends: [:console], truncate: 1024]","prompt":"Can you write a docstring for the following Elixir function? config(root_key, opts)"}
{"completion":"Configures the given `key` for the given `root_key`.\n\nKeyword lists are always deep merged.\n\n## Examples\n\nThe given `opts` are merged into the existing values for `key`\nin the given `root_key`. Conflicting keys are overridden by the\nones specified in `opts`. For example, the application\nconfiguration below\n\n    config :ecto, Repo,\n      log_level: :warn,\n      adapter: Ecto.Adapters.Postgres\n\n    config :ecto, Repo,\n      log_level: :info,\n      pool_size: 10\n\nwill have a final value of the configuration for the `Repo`\nkey in the `:ecto` application of:\n\n    [log_level: :info, pool_size: 10, adapter: Ecto.Adapters.Postgres]","prompt":"Can you write a docstring for the following Elixir function? config(root_key, key, opts)"}
{"completion":"Evaluates the given configuration file.\n\nIt accepts a list of `imported_paths` that should raise if attempted\nto be imported again (to avoid recursive imports).\n\nIt returns a tuple with the configuration and the imported paths.","prompt":"Can you write a docstring for the following Elixir function? eval!(file, imported_paths \\\\ [])"}
{"completion":"Merges two configurations.\n\nThe configurations are merged together with the values in\nthe second one having higher preference than the first in\ncase of conflicts. In case both values are set to keyword\nlists, it deep merges them.\n\n## Examples\n\n    iex> Mix.Config.merge([app: [k: :v1]], [app: [k: :v2]])\n    [app: [k: :v2]]\n\n    iex> Mix.Config.merge([app: [k: [v1: 1, v2: 2]]], [app: [k: [v2: :a, v3: :b]]])\n    [app: [k: [v1: 1, v2: :a, v3: :b]]]\n\n    iex> Mix.Config.merge([app1: []], [app2: []])\n    [app1: [], app2: []]","prompt":"Can you write a docstring for the following Elixir function? merge(config1, config2)"}
{"completion":"Persists the given configuration by modifying\nthe configured applications environment.\n\n`config` should be a list of `{app, app_config}` tuples or a\n`%{app => app_config}` map where `app` are the applications to\nbe configured and `app_config` are the configuration (as key-value\npairs) for each of those applications.\n\nReturns the configured applications.\n\n## Examples\n\n    Mix.Config.persist(logger: [level: :error], my_app: [my_config: 1])\n    #=> [:logger, :my_app]","prompt":"Can you write a docstring for the following Elixir function? persist(config)"}
{"completion":"Reads the configuration file.\n\nThe same as `eval!/2` but only returns the configuration\nin the given file, without returning the imported paths.\n\nIt exists for convenience purposes. For example, you could\ninvoke it inside your `mix.exs` to read some external data\nyou decided to move to a configuration file:\n\n    subsystem: Mix.Config.read!(\"rel/subsystem.exs\")","prompt":"Can you write a docstring for the following Elixir function? read!(file, imported_paths \\\\ [])"}
{"completion":"A simple configuration API and functions for managing config files.\n\nThis module is deprecated, use the modules `Config` and `Config.Reader`\nfrom Elixir's standard library instead.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Config"}
{"completion":"Setting configuration\n\nMost commonly, this module is used to define your own configuration:\n\n    use Mix.Config\n\n    config :root_key,\n      key1: \"value1\",\n      key2: \"value2\"\n\n    import_config \"#{Mix.env()}.exs\"\n\n`use Mix.Config` will import the functions `config/2`, `config/3`\nand `import_config/1` to help you manage your configuration.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Config"}
{"completion":"Evaluating configuration\n\nOnce a configuration is written to a file, the functions in this\nmodule can be used to read and merge said configuration. The `eval!/2`\nfunction allows you to evaluate a given configuration file and the `merge/2`\nfunction allows you to deep merge the results of multiple configurations. Those\nfunctions should not be invoked by users writing configurations but\nrather by library authors.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Config"}
{"completion":"Examples\n\nThe most common use of `Mix.Config` is to define application\nconfiguration so that `Application.get_env/3` and other `Application`\nfunctions can be used to retrieve or further change them.\n\nApplication config files are typically placed in the `config/`\ndirectory of your Mix projects. For example, the following config\n\n    # config/config.exs\n    config :my_app, :key, \"value\"\n\nwill be automatically loaded by Mix and persisted into the\n`:my_app`'s application environment, which can be accessed in\nits source code as follows:\n\n    \"value\" = Application.fetch_env!(:my_app, :key1)","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Config"}
{"completion":"The Mix.Dep struct keeps information about your project dependencies.\n\nIt contains:\n\n  * `scm` - a module representing the source code management tool (SCM)\n    operations\n\n  * `app` - the application name as an atom\n\n  * `requirement` - a binary or regular expression with the dependency's requirement\n\n  * `status` - the current status of the dependency, check\n    `Mix.Dep.format_status/1` for more information\n\n  * `opts` - the options given by the developer\n\n  * `deps` - dependencies of this dependency\n\n  * `top_level` - true if dependency was defined in the top-level project\n\n  * `manager` - the project management, possible values:\n    `:rebar3` | `:mix` | `:make` | `nil`\n\n  * `from` - path to the file where the dependency was defined\n\n  * `extra` - a slot for adding extra configuration based on the manager;\n    the information on this field is private to the manager and should not be\n    relied on\n\n  * `system_env` - an enumerable of key-value tuples of binaries to be set as environment variables\n    when loading or compiling the dependency\n\nA dependency is in two specific states: loaded and unloaded.\n\nWhen a dependency is unloaded, it means Mix only parsed its specification\nand made no attempt to actually load the dependency or validate its\nstatus. When the dependency is loaded, it means Mix attempted to fetch,\nload and validate it, the status is set in the status field.\n\nFurthermore, in the `opts` fields, Mix keeps some internal options, which\ncan be accessed by SCMs:\n\n  * `:app`   - the application name\n  * `:dest`  - the destination path for the dependency\n  * `:lock`  - the lock information retrieved from mix.lock\n  * `:build` - the build path for the dependency","prompt":"Can you write a docstring for the following Elixir function? %Mix.Dep{}"}
{"completion":"Checks if a dependency is available.\n\nAvailable dependencies are the ones that can be loaded.","prompt":"Can you write a docstring for the following Elixir function? available?(dep)"}
{"completion":"Returns loaded dependencies from the cache for the current environment.\n\nIf dependencies have not been cached yet, they are loaded\nand then cached.\n\nBecause the dependencies are cached during deps.loadpaths,\ntheir status may be outdated (for example, `:compile` did not\nyet become `:ok`). Therefore it is recommended to not rely\non their status, also given they haven't been checked\nagainst the lock.","prompt":"Can you write a docstring for the following Elixir function? cached()"}
{"completion":"Checks the lock for the given dependency and update its status accordingly.","prompt":"Can you write a docstring for the following Elixir function? check_lock(dep)"}
{"completion":"Clears loaded dependencies from the cache for the current environment.","prompt":"Can you write a docstring for the following Elixir function? clear_cached()"}
{"completion":"Returns `true` if the dependency is compilable.","prompt":"Can you write a docstring for the following Elixir function? compilable?(arg1)"}
{"completion":"Checks if a dependency has diverged.","prompt":"Can you write a docstring for the following Elixir function? diverged?(dep)"}
{"completion":"Filters the given dependencies by name.\n\nRaises if any of the names are missing.","prompt":"Can you write a docstring for the following Elixir function? filter_by_name(given, all_deps, opts \\\\ [])"}
{"completion":"Formats a dependency for printing.","prompt":"Can you write a docstring for the following Elixir function? format_dep(dep)"}
{"completion":"Formats the status of a dependency.","prompt":"Can you write a docstring for the following Elixir function? format_status(dep)"}
{"completion":"Runs the given `fun` inside the given dependency project by\nchanging the current working directory and loading the given\nproject onto the project stack.\n\nIt expects a loaded dependency as argument.","prompt":"Can you write a docstring for the following Elixir function? in_dependency(dep, post_config \\\\ [], fun)"}
{"completion":"Returns loaded dependencies recursively and caches it.\n\nThe result is cached for future `cached/0` calls.\n\n## Exceptions\n\nThis function raises an exception if any of the dependencies\nprovided in the project are in the wrong format.","prompt":"Can you write a docstring for the following Elixir function? load_and_cache()"}
{"completion":"Returns loaded dependencies recursively on the given environment.\n\nIf no environment is passed, dependencies are loaded across all\nenvironments. The result is not cached.\n\n## Exceptions\n\nThis function raises an exception if any of the dependencies\nprovided in the project are in the wrong format.","prompt":"Can you write a docstring for the following Elixir function? load_on_environment(opts)"}
{"completion":"Returns all load paths for the given dependency.\n\nAutomatically derived from source paths.","prompt":"Can you write a docstring for the following Elixir function? load_paths(dep)"}
{"completion":"Returns `true` if dependency is a Make project.","prompt":"Can you write a docstring for the following Elixir function? make?(dep)"}
{"completion":"Returns `true` if dependency is a Mix project.","prompt":"Can you write a docstring for the following Elixir function? mix?(dep)"}
{"completion":"Returns `true` if the dependency is ok.","prompt":"Can you write a docstring for the following Elixir function? ok?(dep)"}
{"completion":"Returns `true` if dependency is a Rebar project.","prompt":"Can you write a docstring for the following Elixir function? rebar?(dep)"}
{"completion":"Converges all dependencies from the current project,\nincluding nested dependencies.\n\nThere is a callback that is invoked for each dependency and\nmust return an updated dependency in case some processing\nis done.\n\nSee `Mix.Dep.Loader.children/1` for options.","prompt":"Can you write a docstring for the following Elixir function? converge(acc, lock, opts, callback)"}
{"completion":"A Depth-First Search to find where is the dependency graph cycle\nand then display the cyclic dependencies back to the developer.","prompt":"Can you write a docstring for the following Elixir function? find_cycle(graph)"}
{"completion":"Topologically sorts the given dependencies.","prompt":"Can you write a docstring for the following Elixir function? topological_sort(deps)"}
{"completion":"Fetches all dependencies.","prompt":"Can you write a docstring for the following Elixir function? all(old_lock, new_lock, opts)"}
{"completion":"Fetches the dependencies with the given names and their children recursively.","prompt":"Can you write a docstring for the following Elixir function? by_name(names, old_lock, new_lock, opts)"}
{"completion":"Gets all direct children of the current `Mix.Project`\nas a `Mix.Dep` struct. Umbrella project dependencies\nare included as children.\n\nBy default, it will filter all dependencies that does not match\ncurrent environment, behaviour can be overridden via options.","prompt":"Can you write a docstring for the following Elixir function? children()"}
{"completion":"Loads the given dependency information, including its\nlatest status and children.","prompt":"Can you write a docstring for the following Elixir function? load(dep, children)"}
{"completion":"Checks if a dependency must be skipped according to the environment.","prompt":"Can you write a docstring for the following Elixir function? skip?(dep, arg2)"}
{"completion":"Partitions loaded dependencies by environment.","prompt":"Can you write a docstring for the following Elixir function? split_by_env_and_target(deps, env_target)"}
{"completion":"Checks if a requirement from a dependency matches\nthe given version.","prompt":"Can you write a docstring for the following Elixir function? vsn_match(req, actual, app)"}
{"completion":"Reads the lockfile, returns a map containing\neach app name and its current lock information.","prompt":"Can you write a docstring for the following Elixir function? read(lockfile \\\\ lockfile())"}
{"completion":"Receives a map and writes it as the latest lock.","prompt":"Can you write a docstring for the following Elixir function? write(lockfile \\\\ lockfile(), map)"}
{"completion":"Gets all umbrella dependencies in the loaded format from cache (if available).","prompt":"Can you write a docstring for the following Elixir function? cached()"}
{"completion":"Gets all umbrella dependencies in the loaded format.","prompt":"Can you write a docstring for the following Elixir function? loaded()"}
{"completion":"Gets all umbrella dependencies in unloaded format.","prompt":"Can you write a docstring for the following Elixir function? unloaded()"}
{"completion":"Copies `source` to `target`.\n\nIf `target` already exists and the contents are not the same,\nit asks for user confirmation.\n\n## Options\n\n  * `:force` - forces copying without a shell prompt\n  * `:quiet` - does not log command output\n\n## Examples\n\n    iex> Mix.Generator.copy_file(\"source/gitignore\", \".gitignore\")\n    * creating .gitignore\n    true","prompt":"Can you write a docstring for the following Elixir function? copy_file(source, target, options \\\\ [])"}
{"completion":"Evaluates and copy templates at `source` to `target`.\n\nThe template in `source` is evaluated with the given `assigns`.\n\nIf `target` already exists and the contents are not the same,\nit asks for user confirmation.\n\n## Options\n\n  * `:force` - forces copying without a shell prompt\n  * `:quiet` - does not log command output\n\n## Examples\n\n    iex> assigns = [project_path: \"/Users/joe/newproject\"]\n    iex> Mix.Generator.copy_template(\"source/gitignore\", \".gitignore\", assigns)\n    * creating .gitignore\n    true","prompt":"Can you write a docstring for the following Elixir function? copy_template(source, target, assigns, options \\\\ [])"}
{"completion":"Creates a directory if one does not exist yet.\n\nThis function does nothing if the given directory already exists; in this\ncase, it still logs the directory creation.\n\n## Options\n\n  * `:quiet` - does not log command output\n\n## Examples\n\n    iex> Mix.Generator.create_directory(\"path/to/dir\")\n    * creating path/to/dir\n    true","prompt":"Can you write a docstring for the following Elixir function? create_directory(path, options \\\\ [])"}
{"completion":"Creates a file with the given contents.\n\nIf the file already exists and the contents are not the same,\nit asks for user confirmation.\n\n## Options\n\n  * `:force` - forces creation without a shell prompt\n  * `:quiet` - does not log command output\n\n## Examples\n\n    iex> Mix.Generator.create_file(\".gitignore\", \"_build\\ndeps\\n\")\n    * creating .gitignore\n    true","prompt":"Can you write a docstring for the following Elixir function? create_file(path, contents, opts \\\\ [])"}
{"completion":"Prompts the user to overwrite the file if it exists.\n\nReturns false if the file exists and the user forbade\nto override it. Returns true otherwise.","prompt":"Can you write a docstring for the following Elixir function? overwrite?(path)"}
{"completion":"Prompts the user to overwrite the file if it exists.\n\nThe contents are compared to avoid asking the user to\noverride if the contents did not change. Returns false\nif the file exists and the content is the same or the\nuser forbade to override it. Returns true otherwise.","prompt":"Can you write a docstring for the following Elixir function? overwrite?(path, contents)"}
{"completion":"Conveniences for working with paths and generating content.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Generator"}
{"completion":"Returns `true` if `Hex` is loaded or installed. Otherwise returns `false`.","prompt":"Can you write a docstring for the following Elixir function? ensure_installed?(app)"}
{"completion":"Returns `true` if it has the required `Hex`. If an update is performed, it then exits.\nOtherwise returns `false` without updating anything.","prompt":"Can you write a docstring for the following Elixir function? ensure_updated?()"}
{"completion":"Returns the URL to the Hex mirror.","prompt":"Can you write a docstring for the following Elixir function? mirror()"}
{"completion":"Ensures `Hex` is started.","prompt":"Can you write a docstring for the following Elixir function? start()"}
{"completion":"Appends archive paths to the Erlang code path.","prompt":"Can you write a docstring for the following Elixir function? append_archives()"}
{"completion":"Appends Mix paths to the Erlang code path.","prompt":"Can you write a docstring for the following Elixir function? append_paths()"}
{"completion":"Returns the ebin path of an archive.","prompt":"Can you write a docstring for the following Elixir function? archive_ebin(path)"}
{"completion":"Returns the name of an archive given a path.","prompt":"Can you write a docstring for the following Elixir function? archive_name(path)"}
{"completion":"Returns all tasks in local archives.","prompt":"Can you write a docstring for the following Elixir function? archives_tasks()"}
{"completion":"Checks Elixir version requirement stored in the ebin directory\nand print a warning if it is not satisfied.","prompt":"Can you write a docstring for the following Elixir function? check_elixir_version_in_ebin(ebin)"}
{"completion":"Fetches the given signed CSV files, verifies and returns the matching\nElixir version, artifact version and artifact's checksum.\n\nUsed to install both Rebar and Hex from S3.","prompt":"Can you write a docstring for the following Elixir function? find_matching_versions_from_signed_csv!(name, version, path)"}
{"completion":"Returns the name for an archive or an escript, based on the project config.\n\n## Examples\n\n    iex> Mix.Local.name_for(:archives, app: \"foo\", version: \"0.1.0\")\n    \"foo-0.1.0.ez\"\n\n    iex> Mix.Local.name_for(:escripts, escript: [name: \"foo\"])\n    \"foo\"","prompt":"Can you write a docstring for the following Elixir function? name_for(atom, project)"}
{"completion":"Removes archive paths from Erlang code path.","prompt":"Can you write a docstring for the following Elixir function? remove_archives()"}
{"completion":"Fetches `dep_spec` with `in_fetcher` and then runs `in_package`.\n\nGenerates a new Mix project in a temporary directory with the given `dep_spec`\nadded to a mix.exs. Then, `in_fetcher` is executed in the fetcher project. By\ndefault, this fetches the dependency, but you can provide an `in_fetcher`\nduring test or for other purposes. After the `in_fetcher` is executed,\n`in_package` is executed in the now (presumably) fetched package, with the\npackage's config overridden with the deps_path and lockfile of the fetcher\npackage. Also, the Mix env is set to :prod.","prompt":"Can you write a docstring for the following Elixir function? fetch(dep_spec, in_fetcher \\\\ &in_fetcher/1, in_package)"}
{"completion":"Common implementation of installation for archives and escripts.\n\nRelies on a few callbacks provided by respective callback modules\nfor customizing certain steps in the installation process.","prompt":"Can you write a docstring for the following Elixir function? install(module, argv, switches)"}
{"completion":"Receives `argv` and `opts` from options parsing and returns an `install_spec`.","prompt":"Can you write a docstring for the following Elixir function? parse_args(argv, opts)"}
{"completion":"A common implementation for uninstalling archives and scripts.","prompt":"Can you write a docstring for the following Elixir function? uninstall(root, listing, argv, switches)"}
{"completion":"Returns the application path inside the build.\n\nThe returned path will be expanded.\n\n## Examples\n\nIf your project defines the app `my_app`:\n\n    Mix.Project.app_path()\n    #=> \"/path/to/project/_build/shared/lib/my_app\"","prompt":"Can you write a docstring for the following Elixir function? app_path(config \\\\ config())"}
{"completion":"Returns a map with the umbrella child applications paths.\n\nThese paths are based on the `:apps_path` and `:apps` configurations.\n\nIf the given project configuration identifies an umbrella project, the return\nvalue is a map of `app => path` where `app` is a child app of the umbrella and\n`path` is its path relative to the root of the umbrella project.\n\nIf the given project configuration does not identify an umbrella project,\n`nil` is returned.\n\n## Examples\n\n    Mix.Project.apps_paths()\n    #=> %{my_app1: \"apps/my_app1\", my_app2: \"apps/my_app2\"}","prompt":"Can you write a docstring for the following Elixir function? apps_paths(config \\\\ config())"}
{"completion":"Returns the build path for the given project.\n\nIf no configuration is given, the one for the current project is used.\n\nThe returned path will be expanded.\n\n## Examples\n\n    Mix.Project.build_path()\n    #=> \"/path/to/project/_build/shared\"\n\nIf `:build_per_environment` is set to `true`, it will create a new build per\nenvironment:\n\n    Mix.env()\n    #=> :dev\n    Mix.Project.build_path()\n    #=> \"/path/to/project/_build/dev\"","prompt":"Can you write a docstring for the following Elixir function? build_path(config \\\\ config())"}
{"completion":"Builds the project structure for the given application.\n\n## Options\n\n  * `:symlink_ebin` - symlink ebin instead of copying it","prompt":"Can you write a docstring for the following Elixir function? build_structure(config \\\\ config(), opts \\\\ [])"}
{"completion":"Clears the dependency for the current environment.\n\nUseful when dependencies need to be reloaded due to change of global state.\n\nFor example, Nerves uses this function to force all dependencies to be\nreloaded after it updates the system environment. It goes roughly like\nthis:\n\n  1. Nerves fetches all dependencies and looks for the system specific deps\n  2. Once the system specific dep is found, it loads it alongside env vars\n  3. Nerves then clears the cache, forcing dependencies to be loaded again\n  4. Dependencies are loaded again, now with an updated env environment","prompt":"Can you write a docstring for the following Elixir function? clear_deps_cache()"}
{"completion":"Returns the paths the given project compiles to.\n\nIf no configuration is given, the one for the current project will be used.\n\nThe returned path will be expanded.\n\n## Examples\n\nIf your project defines the app `my_app`:\n\n    Mix.Project.compile_path()\n    #=> \"/path/to/project/_build/dev/lib/my_app/ebin\"","prompt":"Can you write a docstring for the following Elixir function? compile_path(config \\\\ config())"}
{"completion":"Returns the project configuration.\n\nIf there is no project defined, it still returns a keyword\nlist with default values. This allows many Mix tasks to work\nwithout the need for an underlying project.\n\nNote this configuration is cached once the project is\npushed onto the stack. Calling it multiple times won't\ncause it to be recomputed.\n\nDo not use `Mix.Project.config/0` to find the runtime configuration.\nUse it only to configure aspects of your project (like\ncompilation directories) and not your application runtime.","prompt":"Can you write a docstring for the following Elixir function? config()"}
{"completion":"Returns a list of project configuration files for this project.\n\nThis function is usually used in compilation tasks to trigger\na full recompilation whenever such configuration files change.\n\nIt returns the lock manifest, and all config files in the `config`\ndirectory that do not start with a leading period (for example,\n`.my_config.exs`).\n\nNote: before Elixir v1.13.0, the `mix.exs` file was also included\nas a config file, but since then it has been moved to its own\nfunction called `project_file/0`.","prompt":"Can you write a docstring for the following Elixir function? config_files()"}
{"completion":"Returns the latest modification time from config files.\n\nThis function is usually used in compilation tasks to trigger\na full recompilation whenever such configuration files change.\nFor this reason, the mtime is cached to avoid file system lookups.\n\nNote: before Elixir v1.13.0, the `mix.exs` file was also included\nin the mtimes, but not anymore. You can compute its modification\ndate by calling `project_file/0`.","prompt":"Can you write a docstring for the following Elixir function? config_mtime()"}
{"completion":"Returns the path where protocol consolidations are stored.\n\nThe returned path will be expanded.\n\n## Examples\n\nIf your project defines the app `my_app`:\n\n    Mix.Project.consolidation_path()\n    #=> \"/path/to/project/_build/dev/lib/my_app/consolidated\"\n\nInside umbrellas:\n\n    Mix.Project.consolidation_path()\n    #=> \"/path/to/project/_build/dev/consolidated\"","prompt":"Can you write a docstring for the following Elixir function? consolidation_path(config \\\\ config())"}
{"completion":"Returns all dependencies app names.\n\nThe order they are returned is guaranteed to be sorted\nfor proper dependency resolution. For example, if A\ndepends on B, then B will listed before A.","prompt":"Can you write a docstring for the following Elixir function? deps_apps()"}
{"completion":"Returns the path where dependencies are stored for the given project.\n\nIf no configuration is given, the one for the current project is used.\n\nThe returned path will be expanded.\n\n## Examples\n\n    Mix.Project.deps_path()\n    #=> \"/path/to/project/deps\"","prompt":"Can you write a docstring for the following Elixir function? deps_path(config \\\\ config())"}
{"completion":"Returns the full path of all dependencies as a map.\n\n## Options\n\n  * `:depth` - only returns dependencies to the depth level,\n    a depth of `1` will only return top-level dependencies\n  * `:parents` - starts the dependency traversal from the\n    given parents instead of the application root\n\n## Examples\n\n    Mix.Project.deps_paths()\n    #=> %{foo: \"deps/foo\", bar: \"custom/path/dep\"}","prompt":"Can you write a docstring for the following Elixir function? deps_paths(opts \\\\ [])"}
{"completion":"Returns the SCMs of all dependencies as a map.\n\nSee `Mix.SCM` module documentation to learn more about SCMs.\n\n## Options\n\n  * `:depth` - only returns dependencies to the depth level,\n    a depth of `1` will only return top-level dependencies\n  * `:parents` - starts the dependency traversal from the\n    given parents instead of the application root\n\n## Examples\n\n    Mix.Project.deps_scms()\n    #=> %{foo: Mix.SCM.Path, bar: Mix.SCM.Git}","prompt":"Can you write a docstring for the following Elixir function? deps_scms(opts \\\\ [])"}
{"completion":"Ensures the project structure for the given project exists.\n\nIn case it does exist, it is a no-op. Otherwise, it is built.\n\n`opts` are the same options that can be passed to `build_structure/2`.","prompt":"Can you write a docstring for the following Elixir function? ensure_structure(config \\\\ config(), opts \\\\ [])"}
{"completion":"Retrieves the current project if there is one.\n\nIf there is no current project, `nil` is returned. This\nmay happen in cases there is no `mix.exs` in the current\ndirectory.\n\nIf you expect a project to be defined, i.e., it is a\nrequirement of the current task, you should call\n`get!/0` instead.","prompt":"Can you write a docstring for the following Elixir function? get()"}
{"completion":"Same as `get/0`, but raises an exception if there is no current project.\n\nThis is usually called by tasks that need additional\nfunctions on the project to be defined. Since such\ntasks usually depend on a project being defined, this\nfunction raises a `Mix.NoProjectError` exception in\ncase no project is available.","prompt":"Can you write a docstring for the following Elixir function? get!()"}
{"completion":"Runs the given `fun` inside the given project.\n\nThis function changes the current working directory and\nloads the project at the given directory onto the project\nstack.\n\nA `post_config` can be passed that will be merged into\nthe project configuration.\n\n`fun` is called with the module name of the given `Mix.Project`.\nThe return value of this function is the return value of `fun`.\n\n## Examples\n\n    Mix.Project.in_project(:my_app, \"/path/to/my_app\", fn module ->\n      \"Mix project is: #{inspect(module)}\"\n    end)\n    #=> \"Mix project is: MyApp.MixProject\"","prompt":"Can you write a docstring for the following Elixir function? in_project(app, path, post_config \\\\ [], fun)"}
{"completion":"Returns the path where manifests are stored.\n\nBy default they are stored in the app path inside\nthe build directory. Umbrella applications have\nthe manifest path set to the root of the build directory.\nDirectories may be changed in future releases.\n\nThe returned path will be expanded.\n\n## Examples\n\nIf your project defines the app `my_app`:\n\n    Mix.Project.manifest_path()\n    #=> \"/path/to/project/_build/shared/lib/my_app/.mix\"","prompt":"Can you write a docstring for the following Elixir function? manifest_path(config \\\\ config())"}
{"completion":"Returns the path to the file that defines the current project.\n\nThe majority of the time, it will point to a `mix.exs` file.\nReturns `nil` if not inside a project.","prompt":"Can you write a docstring for the following Elixir function? project_file()"}
{"completion":"Returns `true` if `config` is the configuration for an umbrella project.\n\nWhen called with no arguments, tells whether the current project is\nan umbrella project.","prompt":"Can you write a docstring for the following Elixir function? umbrella?(config \\\\ config())"}
{"completion":"Defines and manipulates Mix projects.\n\nA Mix project is defined by calling `use Mix.Project` in a module, usually\nplaced in `mix.exs`:\n\n    defmodule MyApp.MixProject do\n      use Mix.Project\n\n      def project do\n        [\n          app: :my_app,\n          version: \"1.0.0\"\n        ]\n      end\n    end","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Project"}
{"completion":"Configuration\n\nIn order to configure Mix, the module that `use`s `Mix.Project` should export\na `project/0` function that returns a keyword list representing configuration\nfor the project.\n\nThis configuration can be read using `Mix.Project.config/0`. Note that\n`config/0` won't fail if a project is not defined; this allows many Mix tasks\nto work without a project.\n\nIf a task requires a project to be defined or needs to access a\nspecial function within the project, the task can call `Mix.Project.get!/0`\nwhich fails with `Mix.NoProjectError` in the case a project is not\ndefined.\n\nThere isn't a comprehensive list of all the options that can be returned by\n`project/0` since many Mix tasks define their own options that they read from\nthis configuration. For example, look at the \"Configuration\" section in the\ndocumentation for the `Mix.Tasks.Compile` task.\n\nThese are a few options that are not used by just one Mix task (and will thus\nbe documented here):\n\n  * `:build_per_environment` - if `true`, builds will be *per-environment*. If\n    `false`, builds will go in `_build/shared` regardless of the Mix\n    environment. Defaults to `true`.\n\n  * `:aliases` - a list of task aliases. For more information, check out the\n    \"Aliases\" section in the documentation for the `Mix` module. Defaults to\n    `[]`.\n\n  * `:config_path` - a string representing the path of the main config\n    file. See `config_files/0` for more information. Defaults to\n    `\"config/config.exs\"`.\n\n  * `:default_task` - a string representing the default task to be run by\n    `mix` when no task is specified. Defaults to `\"run\"`.\n\n  * `:deps` - a list of dependencies of this project. Refer to the\n    documentation for the `Mix.Tasks.Deps` task for more information. Defaults\n    to `[]`.\n\n  * `:deps_path` - directory where dependencies are stored. Also see\n    `deps_path/1`. Defaults to `\"deps\"`.\n\n  * `:lockfile` - the name of the lockfile used by the `mix deps.*` family of\n    tasks. Defaults to `\"mix.lock\"`.\n\n  * `:preferred_cli_env` - a keyword list of `{task, env}` tuples where `task`\n    is the task name as an atom (for example, `:\"deps.get\"`) and `env` is the\n    preferred environment (for example, `:test`). This option overrides what\n    is specified by the tasks with the `@preferred_cli_env` attribute (see the\n    docs for `Mix.Task`). Defaults to `[]`.\n\n  * `:preferred_cli_target` - a keyword list of `{task, target}` tuples where\n    `task` is the task name as an atom (for example, `:test`) and `target`\n    is the preferred target (for example, `:host`). Defaults to `[]`.\n\nFor more options, keep an eye on the documentation for single Mix tasks; good\nexamples are the `Mix.Tasks.Compile` task and all the specific compiler tasks\n(such as `Mix.Tasks.Compile.Elixir` or `Mix.Tasks.Compile.Erlang`).\n\nNote that sometimes the same configuration option is mentioned in the\ndocumentation for different tasks; this is just because it's common for many\ntasks to read and use the same configuration option (for example,\n`:erlc_paths` is used by `mix compile.erlang`, `mix compile.yecc`, and other\ntasks).","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Project"}
{"completion":"Erlang projects\n\nMix can be used to manage Erlang projects that don't have any Elixir code. To\nensure Mix tasks work correctly for an Erlang project, `language: :erlang` has\nto be part of the configuration returned by `project/0`. This setting also\nmakes sure Elixir is not added as a dependency to the generated `.app` file or\nto the escript generated with `mix escript.build`, and so on.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Project"}
{"completion":"Invoking this module\n\nThis module contains many functions that return project information and\nmetadata. However, since Mix is not included nor configured during releases,\nwe recommend using the functions in this module only inside Mix tasks.\nIf you need to configure your own app, consider using the application\nenvironment instead. For example, don't do this:\n\n    def some_config do\n      Mix.Project.config()[:some_config]\n    end\n\nNor this:\n\n    @some_config Mix.Project.config()[:some_config]\n\nInstead, do this:\n\n    def some_config do\n      Application.get_env(:my_app, :some_config)\n    end\n\nOr this:\n\n    @some_config Application.compile_env(:my_app, :some_config)","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Project"}
{"completion":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","prompt":"Can you write a docstring for the following Elixir function? child_spec(init_arg)"}
{"completion":"Decodes a public key and raises if the key is invalid.","prompt":"Can you write a docstring for the following Elixir function? decode!(id, key)"}
{"completion":"Returns all public keys as a list.","prompt":"Can you write a docstring for the following Elixir function? public_keys()"}
{"completion":"Returns the file system path for public keys.","prompt":"Can you write a docstring for the following Elixir function? public_keys_path()"}
{"completion":"Verifies the given binary has the proper signature using the system public keys.","prompt":"Can you write a docstring for the following Elixir function? verify(binary, hash, signature)"}
{"completion":"Applies the given overrides for app config.","prompt":"Can you write a docstring for the following Elixir function? apply_overrides(app, config, overrides)"}
{"completion":"Updates Rebar configuration to be more suitable for dependencies.","prompt":"Can you write a docstring for the following Elixir function? dependency_config(config)"}
{"completion":"Parses the dependencies in given `rebar.config` to Mix's dependency format.","prompt":"Can you write a docstring for the following Elixir function? deps(config)"}
{"completion":"Returns the path to the global copy of `rebar` defined by the\nenvironment variable `MIX_REBAR3`.","prompt":"Can you write a docstring for the following Elixir function? global_rebar_cmd(atom)"}
{"completion":"Loads `rebar.config` and evaluates `rebar.config.script` if it\nexists in the given directory.","prompt":"Can you write a docstring for the following Elixir function? load_config(dir)"}
{"completion":"Returns the path to the local copy of `rebar`, if one exists.","prompt":"Can you write a docstring for the following Elixir function? local_rebar_cmd(manager)"}
{"completion":"Returns the path supposed to host the local copy of `rebar`.\n\nThe rebar3 installation is specific to the Elixir version,\nin order to force updates when new Elixir versions come out.","prompt":"Can you write a docstring for the following Elixir function? local_rebar_path(atom)"}
{"completion":"Returns the path to the available `rebar` command.","prompt":"Can you write a docstring for the following Elixir function? rebar_cmd(manager)"}
{"completion":"Serializes a Rebar config to a term file.","prompt":"Can you write a docstring for the following Elixir function? serialize_config(config)"}
{"completion":"The Mix.Release struct has the following read-only fields:\n\n  * `:name` - the name of the release as an atom\n  * `:version` - the version of the release as a string\n  * `:path` - the path to the release root\n  * `:version_path` - the path to the release version inside the release\n  * `:applications` - a map of application with their definitions\n  * `:erts_source` - the ERTS source as a charlist (or nil)\n  * `:erts_version` - the ERTS version as a charlist\n\nThe following fields may be modified as long as they keep their defined types:\n\n  * `:boot_scripts` - a map of boot scripts with the boot script name\n    as key and a keyword list with **all** applications that are part of\n    it and their modes as value\n  * `:config_providers` - a list of `{config_provider, term}` tuples where the\n    first element is a module that implements the `Config.Provider` behaviour\n    and `term` is the value given to it on `c:Config.Provider.init/1`\n  * `:options` - a keyword list with all other user supplied release options\n  * `:overlays` - a list of extra files added to the release. If you have a custom\n    step adding extra files to a release, you can add these files to the `:overlays`\n    field so they are also considered on further commands, such as tar/zip. Each entry\n    in overlays is the relative path to the release root of each file\n  * `:steps` - a list of functions that receive the release and returns a release.\n    Must also contain the atom `:assemble` which is the internal assembling step.\n    May also contain the atom `:tar` to create a tarball of the release.","prompt":"Can you write a docstring for the following Elixir function? %Mix.Release{}"}
{"completion":"Copies the given application specification into the release.\n\nIt assumes the application exists in the release.","prompt":"Can you write a docstring for the following Elixir function? copy_app(release, app)"}
{"completion":"Copies the ebin directory at `source` to `target`\nrespecting release options such a `:strip_beams`.","prompt":"Can you write a docstring for the following Elixir function? copy_ebin(release, source, target)"}
{"completion":"Copies ERTS if the release is configured to do so.\n\nReturns true if the release was copied, false otherwise.","prompt":"Can you write a docstring for the following Elixir function? copy_erts(release)"}
{"completion":"Makes boot scripts.\n\nIt receives a path to the boot file, without extension, such as\n`releases/0.1.0/start` and this command will write `start.rel`,\n`start.boot`, and `start.script` to the given path, returning\n`{:ok, rel_path}` or `{:error, message}`.\n\nThe boot script uses the RELEASE_LIB environment variable, which must\nbe accordingly set with `--boot-var` and point to the release lib dir.","prompt":"Can you write a docstring for the following Elixir function? make_boot_script(release, path, modes, prepend_paths \\\\ [])"}
{"completion":"Copies the cookie to the given path.\n\nIf a cookie option was given, we compare it with\nthe contents of the file (if any), and ask the user\nif they want to override.\n\nIf there is no option, we generate a random one\nthe first time.","prompt":"Can you write a docstring for the following Elixir function? make_cookie(release, path)"}
{"completion":"Makes the start_erl.data file with the\nERTS version and release versions.","prompt":"Can you write a docstring for the following Elixir function? make_start_erl(release, path)"}
{"completion":"Makes the `sys.config` structure.\n\nIf there are config providers, then a value is injected into\nthe `:elixir` application configuration in `sys_config` to be\nread during boot and trigger the providers.\n\nIt uses the following release options to customize its behaviour:\n\n  * `:reboot_system_after_config`\n  * `:start_distribution_during_config`\n  * `:prune_runtime_sys_config_after_boot`\n\nIn case there are no config providers, it doesn't change `sys_config`.","prompt":"Can you write a docstring for the following Elixir function? make_sys_config(release, sys_config, config_provider_path)"}
{"completion":"Finds a template path for the release.","prompt":"Can you write a docstring for the following Elixir function? rel_templates_path(release, path)"}
{"completion":"Strips a beam file for a release.\n\nThis keeps only significant chunks necessary for the VM operation,\ndiscarding documentation, debug info, compile information and others.\n\nThe exact chunks that are kept are not documented and may change in\nfuture versions.","prompt":"Can you write a docstring for the following Elixir function? strip_beam(binary, options \\\\ [])"}
{"completion":"Defines the release structure and convenience for assembling releases.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Release"}
{"completion":"Gets registered remote converger.","prompt":"Can you write a docstring for the following Elixir function? get()"}
{"completion":"Registers a remote converger.","prompt":"Can you write a docstring for the following Elixir function? register(mod)"}
{"completion":"Appends the given SCM module to the list of available SCMs.","prompt":"Can you write a docstring for the following Elixir function? append(mod)"}
{"completion":"Returns all available SCMs. Each SCM is tried in order\nuntil a matching one is found.","prompt":"Can you write a docstring for the following Elixir function? available()"}
{"completion":"Prepends the given SCM module to the list of available SCMs.","prompt":"Can you write a docstring for the following Elixir function? prepend(mod)"}
{"completion":"This module provides helper functions and defines the\nbehaviour required by any source code manager (SCM) used by Mix.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.SCM"}
{"completion":"Executes the given `command` as a shell command and\ninvokes the `callback` for the streamed response.\n\nThis is most commonly used by shell implementations\nbut can also be invoked directly.\n\n## Options\n\n  * `:cd` - (since v1.11.0) the directory to run the command in\n\n  * `:stderr_to_stdout` - redirects stderr to stdout, defaults to true\n\n  * `:env` - a list of environment variables, defaults to `[]`\n\n  * `:quiet` - overrides the callback to no-op","prompt":"Can you write a docstring for the following Elixir function? cmd(command, options \\\\ [], callback)"}
{"completion":"Returns the printable app name.\n\nThis function returns the current application name,\nbut only if the application name should be printed.\n\nCalling this function automatically toggles its value\nto `false` until the current project is re-entered. The\ngoal is to avoid printing the application name\nmultiple times.","prompt":"Can you write a docstring for the following Elixir function? printable_app_name()"}
{"completion":"Defines `Mix.Shell` contract.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Shell"}
{"completion":"Executes the given command and prints its output\nto stdout as it comes.","prompt":"Can you write a docstring for the following Elixir function? cmd(command, opts \\\\ [])"}
{"completion":"Prints the given ANSI error to the shell followed by a newline.","prompt":"Can you write a docstring for the following Elixir function? error(message)"}
{"completion":"Prints the given ANSI message to the shell followed by a newline.","prompt":"Can you write a docstring for the following Elixir function? info(message)"}
{"completion":"Prints the current application to the shell if it\nwas not printed yet.","prompt":"Can you write a docstring for the following Elixir function? print_app()"}
{"completion":"Prints a message and prompts the user for input.\n\nInput will be consumed until Enter is pressed.","prompt":"Can you write a docstring for the following Elixir function? prompt(message)"}
{"completion":"Prints a message and asks the user to confirm if they\nwant to proceed. The user must type and submit one of\n\"y\", \"yes\", \"Y\", \"YES\" or \"Yes\".\n\nThe user may also press Enter; this can be configured\nto either accept or reject the prompt. The latter case\nmay be useful for a potentially dangerous operation that\nshould require explicit confirmation from the user.\n\n## Options\n\n  * `:default` - (:yes or :no) if `:yes` pressing Enter\n    accepts the prompt; if `:no` pressing Enter rejects\n    the prompt instead. Defaults to `:yes`.\n\n## Examples\n\n    if Mix.shell().yes?(\"Are you sure?\") do\n      # do something...\n    end","prompt":"Can you write a docstring for the following Elixir function? yes?(message, options \\\\ [])"}
{"completion":"This is Mix's default shell.\n\nIt simply prints messages to stdio and stderr.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Shell.IO"}
{"completion":"Executes the given command and forwards its messages to\nthe current process.","prompt":"Can you write a docstring for the following Elixir function? cmd(command, opts \\\\ [])"}
{"completion":"Forwards the error to the current process.","prompt":"Can you write a docstring for the following Elixir function? error(message)"}
{"completion":"Flushes all `:mix_shell` and `:mix_shell_input` messages from the current process.\n\nIf a callback is given, it is invoked for each received message.\n\n## Examples\n\n    flush(&IO.inspect/1)","prompt":"Can you write a docstring for the following Elixir function? flush(callback \\\\ fn x -> x end)"}
{"completion":"Forwards the message to the current process.","prompt":"Can you write a docstring for the following Elixir function? info(message)"}
{"completion":"Prints the current application if it\nwas not printed yet.","prompt":"Can you write a docstring for the following Elixir function? print_app()"}
{"completion":"Forwards the message to the current process.\n\nIt also checks the inbox for an input message matching:\n\n    {:mix_shell_input, :prompt, value}\n\nIf one does not exist, it will abort since there was no shell\nprocess inputs given. `value` must be a string.\n\n## Examples\n\nThe following will answer with `\"Meg\"` to the prompt\n`\"What's your name?\"`:\n\n    # The response is sent before calling prompt/1 so that prompt/1 can read it\n    send(self(), {:mix_shell_input, :prompt, \"Meg\"})\n    Mix.shell().prompt(\"What's your name?\")","prompt":"Can you write a docstring for the following Elixir function? prompt(message)"}
{"completion":"Forwards the message to the current process.\n\nIt also checks the inbox for an input message matching:\n\n    {:mix_shell_input, :yes?, value}\n\nIf one does not exist, it will abort since there was no shell\nprocess inputs given. `value` must be `true` or `false`.\n\n## Example\n\n    # Send the response to self() first so that yes?/2 will be able to read it\n    send(self(), {:mix_shell_input, :yes?, true})\n    Mix.shell().yes?(\"Are you sure you want to continue?\")","prompt":"Can you write a docstring for the following Elixir function? yes?(message, options \\\\ [])"}
{"completion":"Mix shell that uses the current process mailbox for communication.\n\nThis module provides a Mix shell implementation that uses\nthe current process mailbox for communication instead of IO.\n\nAs an example, when `Mix.shell().info(\"hello\")` is called,\nthe following message will be sent to the calling process:\n\n    {:mix_shell, :info, [\"hello\"]}\n\nThis is mainly useful in tests, allowing us to assert\nif given messages were received or not instead of performing\nchecks on some captured IO. Since we need to guarantee a clean\nslate between tests, there is also a `flush/1` function\nresponsible for flushing all `:mix_shell` related messages\nfrom the process inbox.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Shell.Process"}
{"completion":"Examples\n\n    Mix.shell().info(\"hello\")\n\n    receive do\n      {:mix_shell, :info, [msg]} -> msg\n    end\n    #=> \"hello\"\n\n    send(self(), {:mix_shell_input, :prompt, \"Pretty cool\"})\n    Mix.shell().prompt?(\"How cool was that?!\")\n    #=> \"Pretty cool\"","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Shell.Process"}
{"completion":"Executes the given command quietly without outputting anything.","prompt":"Can you write a docstring for the following Elixir function? cmd(command, opts \\\\ [])"}
{"completion":"Prints the error to the shell followed by a newline.","prompt":"Can you write a docstring for the following Elixir function? error(message)"}
{"completion":"Prints nothing to the shell.","prompt":"Can you write a docstring for the following Elixir function? info(message)"}
{"completion":"Prints the current application if it\nwas not printed yet.","prompt":"Can you write a docstring for the following Elixir function? print_app()"}
{"completion":"Prints a message and prompts the user for input.\n\nInput will be consumed until Enter is pressed.","prompt":"Can you write a docstring for the following Elixir function? prompt(message)"}
{"completion":"Prints a message and asks the user to confirm if they\nwant to proceed. The user must type and submit one of\n\"y\", \"yes\", \"Y\", \"YES\" or \"Yes\".\n\nThe user may also press Enter; this can be configured\nto either accept or reject the prompt. The latter case\nmay be useful for a potentially dangerous operation that\nshould require explicit confirmation from the user.\n\n## Options\n\n  * `:default` - (:yes or :no) if `:yes` pressing Enter\n    accepts the prompt; if `:no` pressing Enter rejects\n    the prompt instead. Defaults to `:yes`.","prompt":"Can you write a docstring for the following Elixir function? yes?(message, options \\\\ [])"}
{"completion":"This is Mix's default shell when the `MIX_QUIET` environment\nvariable is set.\n\nIt's just like `Mix.Shell.IO`, but prints far less.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Shell.Quiet"}
{"completion":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","prompt":"Can you write a docstring for the following Elixir function? child_spec(init_arg)"}
{"completion":"Checks if the given `task` name is an alias.\n\nReturns false if the given name is not an alias or if it is not a task.\n\nFor more information about task aliasing, take a look at the\n[\"Aliases\"](https://hexdocs.pm/mix/Mix.html#module-aliases) section in the\ndocs for `Mix`.","prompt":"Can you write a docstring for the following Elixir function? alias?(task)"}
{"completion":"Returns all loaded task modules.\n\nModules that are not yet loaded won't show up.\nCheck `load_all/0` if you want to preload all tasks.","prompt":"Can you write a docstring for the following Elixir function? all_modules()"}
{"completion":"Clears all invoked tasks, allowing them to be reinvoked.\n\nThis operation is not recursive.","prompt":"Can you write a docstring for the following Elixir function? clear()"}
{"completion":"Receives a task name and returns the corresponding task module if one exists.\n\nReturns `nil` if the module cannot be found, if it is an alias, or if it is\nnot a valid `Mix.Task`.","prompt":"Can you write a docstring for the following Elixir function? get(task)"}
{"completion":"Receives a task name and retrieves the corresponding task module.\n\n## Exceptions\n\n  * `Mix.NoTaskError`      - raised if the task could not be found\n  * `Mix.InvalidTaskError` - raised if the task is not a valid `Mix.Task`","prompt":"Can you write a docstring for the following Elixir function? get!(task)"}
{"completion":"Loads all tasks in all code paths.","prompt":"Can you write a docstring for the following Elixir function? load_all()"}
{"completion":"Loads all tasks in the given `paths`.","prompt":"Can you write a docstring for the following Elixir function? load_tasks(dirs)"}
{"completion":"Gets the moduledoc for the given task `module`.\n\nReturns the moduledoc or `nil`.","prompt":"Can you write a docstring for the following Elixir function? moduledoc(module)"}
{"completion":"Gets preferred CLI environment for the task.\n\nReturns environment (for example, `:test`, or `:prod`), or `nil`.","prompt":"Can you write a docstring for the following Elixir function? preferred_cli_env(task)"}
{"completion":"Indicates if the current task is recursing.\n\nThis returns true if a task is marked as recursive\nand it is being executed inside an umbrella project.","prompt":"Can you write a docstring for the following Elixir function? recursing?()"}
{"completion":"Checks if the task should be run recursively for all sub-apps in\numbrella projects.\n\nReturns `true` or `false`.","prompt":"Can you write a docstring for the following Elixir function? recursive(module)"}
{"completion":"Reenables a given task so it can be executed again down the stack.\n\nBoth alias and the regular stack are re-enabled when this function\nis called.\n\nIf an umbrella project reenables a task, it is re-enabled for all\nchild projects.","prompt":"Can you write a docstring for the following Elixir function? reenable(task)"}
{"completion":"Gets the list of requirements for the given task.\n\nReturns a list of strings, where the string is expected\nto be a task optionally followed by its arguments.","prompt":"Can you write a docstring for the following Elixir function? requirements(module)"}
{"completion":"Reruns `task` with the given arguments.\n\nThis function reruns the given task; to do that, it first re-enables the task\nand then runs it as normal.","prompt":"Can you write a docstring for the following Elixir function? rerun(task, args \\\\ [])"}
{"completion":"Conditionally runs the task (or alias) with the given `args`.\n\nIf there exists a task matching the given task name and it has not yet been\ninvoked, this will run the task with the given `args` and return the result.\n\nIf there is an [alias](https://hexdocs.pm/mix/Mix.html#module-aliases) defined\nfor the given task name, the alias will be invoked instead of the original\ntask.\n\nIf the task or alias has already been invoked, subsequent calls to `run/2`\nwill _abort_ without executing and return `:noop`.\n\nRemember: by default, tasks will only run _once_, even when called repeatedly!\nIf you need to run a task multiple times, you need to re-enable it via\n`reenable/1` or call it using `rerun/2`.\n\n`run/2` raises an exception if an alias or a task cannot be found or if the\ntask is invalid. See `get!/1` for more information.","prompt":"Can you write a docstring for the following Elixir function? run(task, args \\\\ [])"}
{"completion":"Runs recursive tasks in the specified list of children apps for umbrella projects.\n\nIf the task is not recursive (whose purpose is to be run in children\napplications), it runs at the project root level as usual. Calling\nthis function outside of an umbrella project root fails.","prompt":"Can you write a docstring for the following Elixir function? run_in_apps(task, apps, args \\\\ [])"}
{"completion":"Gets the shortdoc for the given task `module`.\n\nReturns the shortdoc or `nil`.","prompt":"Can you write a docstring for the following Elixir function? shortdoc(module)"}
{"completion":"Returns `true` if given module is a task.","prompt":"Can you write a docstring for the following Elixir function? task?(module)"}
{"completion":"Returns the task name for the given `module`.\n\n## Examples\n\n    iex> Mix.Task.task_name(Mix.Tasks.Test)\n    \"test\"","prompt":"Can you write a docstring for the following Elixir function? task_name(module)"}
{"completion":"Provides conveniences for creating, loading, and manipulating Mix tasks.\n\nA Mix task can be defined by using `Mix.Task` in a module whose name\nbegins with `Mix.Tasks.` and which defines the `run/1` function.\nTypically, task modules live inside the `lib/mix/tasks/` directory,\nand their file names use dot separators instead of underscores\n(e.g. `deps.clean.ex`) - although ultimately the file name is not\nrelevant.\n\nFor example:\n\n    # lib/mix/tasks/echo.ex\n    defmodule Mix.Tasks.Echo do\n      @moduledoc \"Printed when the user requests `mix help echo`\"\n      @shortdoc \"Echoes arguments\"\n\n      use Mix.Task\n\n      @impl Mix.Task\n      def run(args) do\n        Mix.shell().info(Enum.join(args, \" \"))\n      end\n    end\n\nThe command name will correspond to the portion of the module\nname following `Mix.Tasks.`. For example, a module name of\n`Mix.Tasks.Deps.Clean` corresponds to a task name of `deps.clean`.\n\nThe `run/1` function will receive a list of all command line\narguments passed, according to the user's terminal.\n\nFor example, if the `args` in the above `echo` task were\ninspected, you might see something like this:\n\n    mix echo 'A and B' C --test\n    [\"A and B\", \"C\", \"--test\"]\n\nDefine the `@shortdoc` attribute if you wish to make the task\npublicly visible on `mix help`. Omit this attribute if you do\nnot want your task to be listed via `mix help`.\nThe `@moduledoc` attribute may override `@shortdoc`. The task\nwill not appear in `mix help` if documentation for the entire\nmodule is hidden with `@moduledoc false`.\n\nIf a task has requirements, they can be listed using the\n`@requirements` attribute. For example:\n\n    @requirements [\"app.config\"]\n\nTasks typically depend on the `\"app.config\"` task, when they\nneed to access code from the current project with all apps\nalready configured, or the \"app.start\" task, when they also\nneed those apps to be already started:\n\n    @requirements [\"app.start\"]\n\nYou can also run tasks directly with `run/2`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Task"}
{"completion":"Attributes\n\nThere are a few attributes available in Mix tasks to\nconfigure them in Mix:\n\n  * `@shortdoc`  - makes the task public with a short description that appears\n    on `mix help`\n  * `@recursive` - runs the task recursively in umbrella projects\n  * `@requirements` - list of required tasks to be run before the task\n  * `@preferred_cli_env` - recommends an environment in which to run the task.\n    It is used only if `MIX_ENV` is not yet set. Note `@preferred_cli_env` is\n    not loaded from dependencies as we need to know the environment in order to\n    load the dependencies themselves. In those cases, you can set the\n    `preferred_cli_env` configuration under `def project` in your `mix.exs`","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Task"}
{"completion":"Documentation\n\nUsers can read the documentation for public Mix tasks by running `mix help my_task`.\nThe documentation that will be shown is the `@moduledoc` of the task's module.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Task"}
{"completion":"Adds a callback that runs after a given compiler.\n\nThe callback is invoked after the compiler runs and\nit receives a tuple with current status and the list\nof diagnostic. It must return the updated status and\ndiagnostics.\n\nIf the given compiler does not run (for instance,\nbecause an earlier compiler in the stack has aborted),\nthe callback will not be executed.","prompt":"Can you write a docstring for the following Elixir function? after_compiler(name, fun)"}
{"completion":"This module defines the behaviour for a Mix task that does compilation.\n\nA Mix compiler task can be defined by simply using `Mix.Task.Compiler`\nin a module whose name starts with `Mix.Tasks.Compile.` and defining\nthe [`run/1`](`c:run/1`) function:\n\n    defmodule Mix.Tasks.Compile.MyLanguage do\n      use Mix.Task.Compiler\n\n      def run(_args) do\n        :ok\n      end\n    end\n\nThe [`run/1`](`c:run/1`) function returns an atom indicating the status of the\ncompilation, and optionally can also return a list of \"diagnostics\"\nsuch as warnings or compilation errors. Doing this enables code\neditors to display issues inline without having to analyze the\ncommand-line output.\n\nIf the compiler uses manifest files to track stale sources, it should\ndefine `manifests/0`, and if it writes any output to disk it should\nalso define `clean/0`.\n\nA compiler supports the same attributes for configuration and\ndocumentation as a regular Mix task. See `Mix.Task` for more information.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Task.Compiler"}
{"completion":"Diagnostic information such as a warning or compilation error.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Task.Compiler.Diagnostic"}
{"completion":"Loads and configures all registered apps.\n\nThis is done by loading `config/runtime.exs` if one exists.\nThe application will be compiled if it was not compiled before.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.App.Config"}
{"completion":"Command line options\n\n  * `--force` - forces compilation regardless of compilation times\n  * `--temporary` - starts the application as temporary\n  * `--permanent` - starts the application as permanent\n  * `--preload-modules` - preloads all modules defined in applications\n  * `--no-archives-check` - does not check archives\n  * `--no-app-loading` - does not load .app resource file after compilation\n  * `--no-compile` - does not compile even if files require compilation\n  * `--no-deps-check` - does not check dependencies\n  * `--no-elixir-version-check` - does not check Elixir version\n  * `--no-validate-compile-env` - does not validate the application compile environment","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.App.Config"}
{"completion":"Starts all registered apps.\n\nFirst, this task guarantees that all dependencies are in place\nand that the current project has been compiled. Then, the current\napplication is started as a temporary application, unless\n`:start_permanent` is set to `true` in your project configuration\nor the `--permanent` option is given. Setting it to permanent\nguarantees the node will shut down if the application terminates\n(typically because its root supervisor has terminated).","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.App.Start"}
{"completion":"Configuration\n\n  * `:start_permanent` - the application and all of its children\n    applications are started in permanent mode. Defaults to `false`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.App.Start"}
{"completion":"Command line options\n\n  * `--force` - forces compilation regardless of compilation times\n  * `--temporary` - starts the application as temporary\n  * `--permanent` - starts the application as permanent\n  * `--preload-modules` - preloads all modules defined in applications\n  * `--no-archives-check` - does not check archives\n  * `--no-compile` - does not compile even if files require compilation\n  * `--no-deps-check` - does not check dependencies\n  * `--no-elixir-version-check` - does not check Elixir version\n  * `--no-start` - does not actually start applications, only compiles and loads code","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.App.Start"}
{"completion":"Prints the application tree.\n\n    mix app.tree --exclude logger --exclude elixir\n\nIf no application is given, it uses the current application defined\nin the `mix.exs` file.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.App.Tree"}
{"completion":"Command line options\n\n  * `--exclude` - exclude applications which you do not want to see printed.\n    `kernel`, `stdlib` and `compiler` are always excluded from the tree.\n\n  * `--format` - Can be set to one of either:\n\n    * `pretty` - uses Unicode code points for formatting the tree.\n      This is the default except on Windows.\n\n    * `plain` - does not use Unicode code points for formatting the tree.\n      This is the default on Windows.\n\n    * `dot` - produces a DOT graph description of the application tree\n      in `app_tree.dot` in the current directory.\n      Warning: this will overwrite any previously generated file.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.App.Tree"}
{"completion":"Lists all installed archives.\n\nArchives are typically installed at `~/.mix/archives`\nalthough the installation path can be customized by\nsetting the `MIX_ARCHIVES` environment variable.\n\nSince archives are specific to Elixir versions, it is\nexpected from build tools to swap the `MIX_ARCHIVES`\nvariable to different locations based on a particular\nElixir installation.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Archive"}
{"completion":"Builds an archive according to the specification of the\n[Erlang archive format](`:code`).\n\nArchives are meant to contain small projects, usually installed\nlocally. Archives may be installed into a Mix environment by\nrunning `mix archive.install`. Once installed, the archive is\navailable to all Mix projects. For this reason, the functionality\nbehind archives is limited. For instance, archives do not include\ndependencies, as those would conflict with any dependency in a\nMix project after the archive is installed. In general, we recommend\nthe usage of archives to be limited for extensions of Mix, such\nas custom SCMs, package managers, and the like. For general scripts to be\ndistributed to developers, please see `mix escript.build`.\n\nThe archive will be created in the current directory (which is\nexpected to be the project root), unless an argument `-o` is\nprovided with the file name.\n\nBy default, this command archives the current project but the `-i`\noption can be used to archive any directory. For example,\n`mix archive.build` with no options translates to:\n\n    mix archive.build -i _build/ENV/lib/APP -o APP-VERSION.ez","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Archive.Build"}
{"completion":"Command line options\n\n  * `-o` - specifies output file name.\n    If there is a `mix.exs`, defaults to \"APP-VERSION.ez\".\n\n  * `-i` - specifies the input directory to archive.\n    If there is a `mix.exs`, defaults to the current application build.\n\n  * `--no-compile` - skips compilation.\n    Only applies when `mix.exs` is available.\n\n  * `--include-dot-files` - adds dot files from priv directory to the archive.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Archive.Build"}
{"completion":"Checks all archives are available.\n\nMix projects can specify required archives using\nthe `:archives` option:\n\n    archives: [{:foo, \"~> 1.0.0\"}]\n\nThis task guarantees this option is respected.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Archive.Check"}
{"completion":"Installs an archive locally.\n\nIf no argument is supplied but there is an archive in the project's\nroot directory (created with `mix archive.build`), then the archive\nwill be installed locally. For example:\n\n    mix do archive.build + archive.install\n\nIf an argument is provided, it should be a local path to a\nprebuilt archive, a Git repository, a GitHub repository, or a Hex\npackage.\n\n    mix archive.install archive.ez\n    mix archive.install path/to/archive.ez\n    mix archive.install git https://path/to/git/repo\n    mix archive.install git https://path/to/git/repo branch git_branch\n    mix archive.install git https://path/to/git/repo tag git_tag\n    mix archive.install git https://path/to/git/repo ref git_ref\n    mix archive.install github user/project\n    mix archive.install github user/project branch git_branch\n    mix archive.install github user/project tag git_tag\n    mix archive.install github user/project ref git_ref\n    mix archive.install hex hex_package\n    mix archive.install hex hex_package 1.2.3\n\nAfter installation, the tasks in the archive are available locally:\n\n    mix some_task\n\nNote that installing via Git, GitHub, or Hex fetches the source\nof the archive and builds it, while using local path uses a pre-built archive.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Archive.Install"}
{"completion":"Command line options\n\n  * `--sha512` - checks the archive matches the given SHA-512 checksum. Only\n    applies to installations via a local path\n\n  * `--force` - forces installation without a shell prompt; primarily\n    intended for automation in build systems like Make\n\n  * `--submodules` - fetches repository submodules before building archive from\n    Git or GitHub\n\n  * `--app` - specifies a custom app name to be used for building the archive\n    from Git, GitHub, or Hex\n\n  * `--organization` - set this for Hex private packages belonging to an\n    organization\n\n  * `--repo` - set this for self-hosted Hex instances, defaults to `hexpm`","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Archive.Install"}
{"completion":"Uninstalls local archives.\n\n    mix archive.uninstall archive.ez","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Archive.Uninstall"}
{"completion":"Command line options\n  * `--force` - forces uninstallation without a shell prompt; primarily\n    intended for automation","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Archive.Uninstall"}
{"completion":"Deletes generated application files.\n\nThis command deletes all build artifacts for the current project.\nDependencies' sources and build files are cleaned only if the\n`--deps` option is given.\n\nBy default this task works across all environments, unless `--only`\nis given.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Clean"}
{"completion":"Executes the given command.\n\nFor example, you can invoke an external command such as make:\n\n    mix cmd make\n\nBy passing the `--cd` flag before the command, you can also force\nthe command to run in a specific directory:\n\n    mix cmd --cd \"third-party\" make\n\nThis task is also useful in umbrella applications to execute a command\non each child app:\n\n    mix cmd pwd\n\nYou can limit which apps the cmd runs in by using `mix do` with the `--app`\noption:\n\n    mix do --app app1 --app app2 cmd pwd\n\nThe tasks aborts whenenever a command exits with a non-zero status.\n\nThis task is automatically re-enabled, so it can be called multiple times\nwith different arguments.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Cmd"}
{"completion":"Command line options\n\n  * `--app` - limit running the command to the given app.\n    This option is currently deprecated in favor of `mix do --app`\n\n  * `--cd` - (since v1.10.4) the directory to run the command in","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Cmd"}
{"completion":"Zombie operating system processes\n\nBeware that the Erlang VM does not terminate child processes\nwhen it shuts down. Therefore, if you use `mix cmd` to start\nlong running processes and then shut down the VM, it is likely\nthat those child processes won't be terminated with the VM.\n\nA solution is to make sure the child processes listen to the\nstandard input and terminate when standard input is closed.\nWe discuss this topic at length in the \"Zombie operating system processes\"\nof the `Port` module documentation.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Cmd"}
{"completion":"Returns all compilers.","prompt":"Can you write a docstring for the following Elixir function? compilers(config \\\\ Mix.Project.config())"}
{"completion":"The main entry point to compile source files.\n\nIt simply runs the compilers registered in your project and returns\na tuple with the compilation status and a list of diagnostics.\n\nBefore compiling code, it loads the code in all dependencies and\nperform a series of checks to ensure the project is up to date.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Compile"}
{"completion":"Configuration\n\n  * `:compilers` - compilers to run, defaults to `Mix.compilers/0`,\n    which are `[:yecc, :leex, :erlang, :elixir, :app]`.\n\n  * `:consolidate_protocols` - when `true`, runs protocol\n    consolidation via the `mix compile.protocols` task. The default\n    value is `true`.\n\n  * `:build_embedded` - when `true`, embeds all code and priv\n    content in the `_build` directory instead of using symlinks.\n\n  * `:build_path` - the directory where build artifacts\n    should be written to. This option is intended only for\n    child apps within a larger umbrella application so that\n    each child app can use the common `_build` directory of\n    the parent umbrella. In a non-umbrella context, configuring\n    this has undesirable side-effects (such as skipping some\n    compiler checks) and should be avoided.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Compile"}
{"completion":"Compilers\n\nTo see documentation for each specific compiler, you must\ninvoke `help` directly for the compiler command:\n\n    mix help compile.elixir\n    mix help compile.erlang\n\nYou can get a list of all compilers by running:\n\n    mix compile --list","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Compile"}
{"completion":"Command line options\n\n  * `--all-warnings` - prints warnings even from files that do not need to be recompiled\n  * `--erl-config` - path to an Erlang term file that will be loaded as Mix config\n  * `--force` - forces compilation\n  * `--list` - lists all enabled compilers\n  * `--no-app-loading` - does not load .app resource file after compilation\n  * `--no-archives-check` - skips checking of archives\n  * `--no-compile` - does not actually compile, only loads code and perform checks\n  * `--no-deps-check` - skips checking of dependencies\n  * `--no-elixir-version-check` - does not check Elixir version\n  * `--no-optional-deps` - does not compile or load optional deps. Useful for testing\n    if a library still successfully compiles without optional dependencies (which is the\n    default case with dependencies)\n  * `--no-protocol-consolidation` - skips protocol consolidation\n  * `--no-validate-compile-env` - does not validate the application compile environment\n  * `--return-errors` - returns error status and diagnostics instead of exiting on error\n  * `--warnings-as-errors` - exit with non-zero status if compilation has one or more warnings","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Compile"}
{"completion":"Writes an .app file.\n\nAn `.app` file is a file containing Erlang terms that defines\nyour application. Mix automatically generates this file based on\nyour `mix.exs` configuration.\n\nIn order to generate the `.app` file, Mix expects your project\nto have both `:app` and `:version` keys. Furthermore, you can\nconfigure the generated application by defining an `application/0`\nfunction in your `mix.exs` that returns a keyword list.\n\nThe most commonly used keys are:\n\n  * `:extra_applications` - a list of OTP applications\n    your application depends on which are not included in `:deps`\n    (usually defined in `deps/0` in your `mix.exs`). For example,\n    here you can declare a dependency on applications that ship\n    with Erlang/OTP or Elixir, like `:crypto` or `:logger`.\n    Optional extra applications can be declared as a tuple, such\n    as `{:ex_unit, :optional}`. Mix guarantees all non-optional\n    applications are started before your application starts.\n\n  * `:registered` - the name of all registered processes in the\n    application. If your application defines a local GenServer\n    with name `MyServer`, it is recommended to add `MyServer`\n    to this list. It is most useful in detecting conflicts\n    between applications that register the same names.\n\n  * `:env` - the default values for the application environment.\n    The application environment is one of the most common ways\n    to configure applications. See the `Application` module for\n    mechanisms to read and write to the application environment.\n\nFor example:\n\n    def application do\n      [\n        extra_applications: [:logger, :crypto, ex_unit: :optional],\n        env: [key: :value],\n        registered: [MyServer]\n      ]\n    end\n\nOther options include:\n\n  * `:applications` - all applications your application depends\n    on at runtime. By default, this list is automatically inferred\n    from your dependencies. Mix and other tools use the application\n    list in order to start your dependencies before starting the\n    application itself.\n\n  * `:mod` - specifies a module to invoke when the application\n    is started. It must be in the format `{Mod, args}` where\n    args is often an empty list. The module specified must\n    implement the callbacks defined by the `Application`\n    module.\n\n  * `:start_phases` - specifies a list of phases and their arguments\n    to be called after the application is started. See the \"Phases\"\n    section below.\n\n  * `:included_applications` - specifies a list of applications\n    that will be included in the application. It is the responsibility of\n    the primary application to start the supervision tree of all included\n    applications, as only the primary application will be started. A process\n    in an included application considers itself belonging to the\n    primary application.\n\n  * `:maxT` - specifies the maximum time the application is allowed to run, in\n    milliseconds. Applications are stopped if `:maxT` is reached, and their\n    top-level supervisor terminated with reason `:normal`. This threshold is\n    technically valid in any resource file, but it is only effective for\n    applications with a callback module. Defaults to `:infinity`.\n\nBesides the options above, `.app` files also expect other options like\n`:modules` and `:vsn`, but these are automatically added by Mix.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Compile.App"}
{"completion":"Command line options\n\n  * `--force` - forces compilation regardless of modification times\n  * `--compile-path` - where to find `.beam` files and write the\n    resulting `.app` file, defaults to `Mix.Project.compile_path/0`","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Compile.App"}
{"completion":"Phases\n\nApplications provide a start phases mechanism which will be called,\nin order, for the application and all included applications. If a phase\nis not defined for an included application, that application is skipped.\n\nLet's see an example `MyApp.application/0` function:\n\n    def application do\n      [\n        start_phases: [init: [], go: [], finish: []],\n        included_applications: [:my_included_app]\n      ]\n    end\n\nAnd an example `:my_included_app` defines on its `mix.exs` the function:\n\n    def application do\n      [\n        mod: {MyIncludedApp, []},\n        start_phases: [go: []]\n      ]\n    end\n\nIn this example, the order that the application callbacks are called in is:\n\n    Application.start(MyApp)\n    MyApp.start(:normal, [])\n    MyApp.start_phase(:init, :normal, [])\n    MyApp.start_phase(:go, :normal, [])\n    MyIncludedApp.start_phase(:go, :normal, [])\n    MyApp.start_phase(:finish, :normal, [])","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Compile.App"}
{"completion":"Compiles Elixir source files.\n\nElixir is smart enough to recompile only files that have changed\nand their dependencies. This means if `lib/a.ex` is invoking\na function defined over `lib/b.ex`, whenever `lib/b.ex` changes,\n`lib/a.ex` is also recompiled.\n\nNote it is important to recompile a file's dependencies as\nthere are often compile time dependencies between them.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Compile.Elixir"}
{"completion":"`__mix_recompile__?/0`\n\nA module may export a `__mix_recompile__?/0` function that can\ncause the module to be recompiled using custom rules. For example,\n`@external_resource` already adds a compile-time dependency on an\nexternal file, however to depend on a _dynamic_ list of files we\ncan do:\n\n    defmodule MyModule do\n      paths = Path.wildcard(\"*.txt\")\n      @paths_hash :erlang.md5(paths)\n\n      for path <- paths do\n        @external_resource path\n      end\n\n      def __mix_recompile__?() do\n        Path.wildcard(\"*.txt\") |> :erlang.md5() != @paths_hash\n      end\n    end\n\nCompiler calls `__mix_recompile__?/0` for every module being\ncompiled (or previously compiled) and thus it is very important\nto do there as little work as possible to not slow down the\ncompilation.\n\nIf module has `@compile {:autoload, false}`, `__mix_recompile__?/0` will\nnot be used.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Compile.Elixir"}
{"completion":"Command line options\n\n  * `--verbose` - prints each file being compiled\n  * `--force` - forces compilation regardless of modification times\n  * `--docs` (`--no-docs`) - attaches (or not) documentation to compiled modules\n  * `--debug-info` (`--no-debug-info`) - attaches (or not) debug info to compiled modules\n  * `--ignore-module-conflict` - does not emit warnings if a module was previously defined\n  * `--warnings-as-errors` - treats warnings in the current project as errors and\n    return a non-zero exit status\n  * `--long-compilation-threshold N` - sets the \"long compilation\" threshold\n    (in seconds) to `N` (see the docs for `Kernel.ParallelCompiler.compile/2`)\n  * `--profile` - if set to `time`, outputs timing information of compilation steps\n  * `--tracer` - adds a compiler tracer in addition to any specified in the `mix.exs` file","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Compile.Elixir"}
{"completion":"Configuration\n\n  * `:elixirc_paths` - directories to find source files.\n    Defaults to `[\"lib\"]`.\n\n  * `:elixirc_options` - compilation options that apply to Elixir's compiler.\n    See `Code.put_compiler_option/2` for a complete list of options. These\n    options are often overridable from the command line using the switches\n    above.\n\n  * `[xref: [exclude: ...]]` - a list of `module` or `{module, function, arity}`\n    that should not be warned on in case on undefined modules or undefined\n    application warnings.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Compile.Elixir"}
{"completion":"Compiles Erlang source files.\n\nWhen this task runs, it will first check the modification times of\nall files to be compiled and if they haven't been changed since the\nlast compilation, it will not compile them. If any of them have changed,\nit compiles everything.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Compile.Erlang"}
{"completion":"Command line options\n\n  * `--force` - forces compilation regardless of modification times\n\n  * `--all-warnings` - prints warnings even from files that do not need to be\n    recompiled","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Compile.Erlang"}
{"completion":"Configuration\n\n  * `ERL_COMPILER_OPTIONS` - can be used to give default compile options.\n    The value must be a valid Erlang term. If the value is a list, it will\n    be used as is. If it is not a list, it will be put into a list.\n\n  * `:erlc_paths` - directories to find source files.\n    Defaults to `[\"src\"]`.\n\n  * `:erlc_include_path` - directory for adding include files.\n    Defaults to `\"include\"`.\n\n  * `:erlc_options` - compilation options that apply to Erlang's\n    compiler. Defaults to `[]`.\n\n    For a complete list of options, see `:compile.file/2`.\n    The option `:debug_info` is always added to the end of it.\n    You can disable that using:\n\n        erlc_options: [debug_info: false]","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Compile.Erlang"}
{"completion":"Compiles Leex source files.\n\nWhen this task runs, it will check the modification time of every file, and\nif it has changed, the file will be compiled. Files will be\ncompiled in the same source directory with a .erl extension.\nYou can force compilation regardless of modification times by passing\nthe `--force` option.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Compile.Leex"}
{"completion":"Command line options\n\n  * `--force` - forces compilation regardless of modification times\n\n  * `--all-warnings` - prints warnings even from files that do not need to be\n    recompiled","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Compile.Leex"}
{"completion":"Configuration\n\n  * `:erlc_paths` - directories to find source files. Defaults to `[\"src\"]`.\n\n  * `:leex_options` - compilation options that apply\n    to Leex's compiler.\n\n    For a complete list of options, see `:leex.file/2`.\n    Note that the `:report`, `:return_errors`, and `:return_warnings` options\n    are overridden by this compiler, thus setting them has no effect.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Compile.Leex"}
{"completion":"Returns if protocols have been consolidated at least once.","prompt":"Can you write a docstring for the following Elixir function? consolidated?()"}
{"completion":"Consolidates all protocols in all paths.\n\nThis task is automatically invoked unless the project\ndisables the `:consolidate_protocols` option in their\nconfiguration.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Compile.Protocols"}
{"completion":"Consolidation\n\nProtocol consolidation is useful in production when no\ndynamic code loading will happen, effectively optimizing\nprotocol dispatches by not accounting for code loading.\n\nThis task consolidates all protocols in the code path\nand outputs the new binary files to the given directory.\nDefaults to \"_build/MIX_ENV/lib/YOUR_APP/consolidated\"\nfor regular apps and \"_build/MIX_ENV/consolidated\" in\numbrella projects.\n\nIn case you are manually compiling protocols or building\nreleases, you need to take the generated protocols into\naccount. This can be done with:\n\n    $ elixir -pa _build/MIX_ENV/lib/YOUR_APP/consolidated -S mix run\n\nOr in umbrellas:\n\n    $ elixir -pa _build/MIX_ENV/consolidated -S mix run\n\nYou can verify a protocol is consolidated by checking\nits attributes:\n\n    iex> Protocol.consolidated?(Enumerable)\n    true","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Compile.Protocols"}
{"completion":"Compiles Yecc source files.\n\nWhen this task runs, it will check the modification time of every file, and\nif it has changed, the file will be compiled. Files will be\ncompiled in the same source directory with a .erl extension.\nYou can force compilation regardless of modification times by passing\nthe `--force` option.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Compile.Yecc"}
{"completion":"Command line options\n\n  * `--force` - forces compilation regardless of modification times\n\n  * `--all-warnings` - prints warnings even from files that do not need to be\n    recompiled","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Compile.Yecc"}
{"completion":"Configuration\n\n  * `:erlc_paths` - directories to find source files. Defaults to `[\"src\"]`.\n\n  * `:yecc_options` - compilation options that apply\n    to Yecc's compiler.\n\n    For a complete list of options, see `:yecc.file/1`.\n    Note that the `:report`, `:return_errors`, and `:return_warnings` options\n    are overridden by this compiler, thus setting them has no effect.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Compile.Yecc"}
{"completion":"Lists all dependencies and their status.\n\nDependencies must be specified in the `mix.exs` file in one of\nthe following formats:\n\n    {app, requirement}\n    {app, opts}\n    {app, requirement, opts}\n\nWhere:\n\n  * app is an atom\n  * requirement is a `Version` requirement or a regular expression\n  * opts is a keyword list of options\n\nFor example:\n\n    {:plug, \">= 0.4.0\"}\n    {:gettext, git: \"https://github.com/elixir-lang/gettext.git\", tag: \"0.1\"}\n    {:local_dependency, path: \"path/to/local_dependency\"}\n\nBy default, dependencies are fetched using the [Hex package manager](https://hex.pm/):\n\n    {:plug, \">= 0.4.0\"}\n\nBy specifying such dependencies, Mix will automatically install\nHex (if it wasn't previously installed) and download a package\nsuitable to your project. Note Hex expects the dependency\nrequirement to always be given and it will warn otherwise.\n\nMix also supports Git and path dependencies:\n\n    {:foobar, git: \"https://github.com/elixir-lang/foobar.git\", tag: \"0.1\"}\n    {:foobar, path: \"path/to/foobar\"}\n\nAnd also in umbrella dependencies:\n\n    {:my_app, in_umbrella: true}\n\nPath and in umbrella dependencies are automatically recompiled by\nthe parent project whenever they change. While fetchable dependencies,\nlike the ones using `:git`, are recompiled only when fetched/updated.\n\nThe dependencies' versions are expected to be formatted according to\nSemantic Versioning and the requirements must be specified as defined\nin the `Version` module.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Deps"}
{"completion":"Options\n\nBelow we provide a more detailed look into the available options.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Deps"}
{"completion":"# Dependency definition options\n\n  * `:app` - when set to `false`, does not read the app file for this\n    dependency. By default, the app file is read\n\n  * `:env` - the environment (as an atom) to run the dependency on; defaults to `:prod`\n\n  * `:compile` - a command (string) to compile the dependency; defaults to a `mix`,\n    `rebar` or `make` command\n\n  * `:optional` - marks the dependency as optional. In such cases, the\n    current project will always include the optional dependency but any\n    other project that depends on the current project won't be forced to\n    use the optional dependency. However, if the other project includes\n    the optional dependency on its own, the requirements and options\n    specified here will also be applied. Optional dependencies will _not_\n    be started by the application.\n\n  * `:only` - the dependency is made available only in the given environments,\n    useful when declaring dev- or test-only dependencies; by default the\n    dependency will be available in all environments. The value of this option\n    can either be a single environment (like `:dev`) or a list of environments\n    (like `[:dev, :test]`)\n\n  * `:targets` - the dependency is made available only for the given targets.\n    By default the dependency will be available in all environments. The value\n    of this option can either be a single target (like `:host`) or a list of\n    environments (like `[:host, :rpi3]`)\n\n  * `:override` - if set to `true` the dependency will override any other\n    definitions of itself by other dependencies\n\n  * `:manager` - Mix can also compile Rebar3 and makefile projects\n    and can fetch sub dependencies of Rebar3 projects. Mix will\n    try to infer the type of project but it can be overridden with this\n    option by setting it to `:mix`, `:rebar3`, or `:make`. In case\n    there are conflicting definitions, the first manager in the list above\n    will be picked up. For example, if a dependency is found with `:rebar3`\n    as a manager in different part of the trees, `:rebar3` will be automatically\n    picked. You can find the manager by running `mix deps` and override it by\n    setting the `:override` option in a top-level project.\n\n  * `:runtime` - whether the dependency is part of runtime applications.\n    If the `:applications` key is not provided in `def application` in your\n    `mix.exs` file, Mix will automatically include all dependencies as a runtime\n    application, except if `runtime: false` is given. Defaults to true.\n\n  * `:system_env` - an enumerable of key-value tuples of binaries to be set\n    as environment variables when loading or compiling the dependency","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Deps"}
{"completion":"# Git options (`:git`)\n\n  * `:git` - the Git repository URI\n  * `:github` - a shortcut for specifying Git repos from GitHub, uses `:git`\n  * `:ref` - the reference to checkout (may be a branch, a commit SHA or a tag)\n  * `:branch` - the Git branch to checkout\n  * `:tag` - the Git tag to checkout\n  * `:submodules` - when `true`, initialize submodules for the repo\n  * `:sparse` - checkout a single directory inside the Git repository and use it\n    as your Mix dependency. Search \"sparse Git checkouts\" for more information.\n  * `:subdir` - (since v1.13.0) search for the project in the given directory\n    relative to the git checkout. This is similar to `:sparse` option but instead\n    of a doing a sparse checkout it does a full checkout.\n\nIf your Git repository requires authentication, such as basic username:password\nHTTP authentication via URLs, it can be achieved via Git configuration, keeping\nthe access rules outside of source control.\n\n    git config --global url.\"https://YOUR_USER:YOUR_PASS@example.com/\".insteadOf \"https://example.com/\"\n\nFor more information, see the `git config` documentation:\nhttps://git-scm.com/docs/git-config#git-config-urlltbasegtinsteadOf","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Deps"}
{"completion":"# Path options (`:path`)\n\n  * `:path`        - the path for the dependency\n  * `:in_umbrella` - when `true`, sets a path dependency pointing to\n    \"../#{app}\", sharing the same environment as the current application","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Deps"}
{"completion":"# Hex options (`:hex`)\n\nSee the [Hex usage documentation](https://hex.pm/docs/usage) for Hex options.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Deps"}
{"completion":"Deps task\n\n`mix deps` task lists all dependencies in the following format:\n\n    APP VERSION (SCM) (MANAGER)\n    [locked at REF]\n    STATUS\n\nFor dependencies satisfied by Hex, `REF` is the package checksum.\n\nFor dependencies satisfied by git, `REF` is the commit object name,\nand may include branch or tag information.\n\nIt supports the following options:\n\n  * `--all` - lists all dependencies, regardless of specified environment","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Deps"}
{"completion":"Deletes the given dependencies' files, including build artifacts and fetched\nsources.\n\nSince this is a destructive action, cleaning of dependencies\nonly occurs when passing arguments/options:\n\n  * `dep1 dep2` - the names of dependencies to be deleted separated by a space\n  * `--unlock` - also unlocks the deleted dependencies\n  * `--build` - deletes only compiled files (keeps source files)\n  * `--all` - deletes all dependencies\n  * `--unused` - deletes only unused dependencies\n    (i.e. dependencies no longer mentioned in `mix.exs`)\n\nBy default this task works across all environments,\nunless `--only` is given which will clean all dependencies\nfor the chosen environment.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Deps.Clean"}
{"completion":"Compiles dependencies.\n\nBy default, this task attempts to compile all dependencies.\nA list of dependencies can be given to compile multiple\ndependencies in order.\n\nThis task attempts to detect if the project contains one of\nthe following files and act accordingly:\n\n  * `mix.exs` - invokes `mix compile`\n  * `rebar.config` - invokes `rebar compile`\n  * `Makefile.win`- invokes `nmake /F Makefile.win` (only on Windows)\n  * `Makefile` - invokes `gmake` on DragonFlyBSD, FreeBSD, NetBSD, and OpenBSD,\n    invokes `make` on any other operating system (except on Windows)\n\nThe compilation can be customized by passing a `compile` option\nin the dependency:\n\n    {:some_dependency, \"0.1.0\", compile: \"command to compile\"}\n\nIf a list of dependencies is given, Mix will attempt to compile\nthem as is. For example, if project `a` depends on `b`, calling\n`mix deps.compile a` will compile `a` even if `b` is out of\ndate. This is to allow parts of the dependency tree to be\nrecompiled without propagating those changes upstream. To ensure\n`b` is included in the compilation step, pass `--include-children`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Deps.Compile"}
{"completion":"Command line options\n\n  * `--force` - force compilation of deps\n  * `--skip-umbrella-children` - skips umbrella applications from compiling\n  * `--skip-local-deps` - skips non-remote dependencies, such as path deps, from compiling","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Deps.Compile"}
{"completion":"Gets all out of date dependencies, i.e. dependencies\nthat are not available or have an invalid lock.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Deps.Get"}
{"completion":"Command line options\n\n  * `--only` - only fetches dependencies for given environment\n  * `--no-archives-check` - does not check archives before fetching deps","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Deps.Get"}
{"completion":"Checks, compiles, and loads all dependencies along the way.\n\nIf there is an invalid dependency, its status is printed\nbefore aborting.\n\nAlthough this task does not show up in `mix help`, it is\npart of Mix public API and can be depended on.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Deps.Loadpaths"}
{"completion":"Command line options\n\n  * `--no-compile` - does not compile dependencies\n  * `--no-deps-check` - does not check or compile deps, only load available ones\n  * `--no-elixir-version-check` - does not check Elixir version\n  * `--no-load-deps` - does not add deps loadpaths to the code path\n  * `--no-optional-deps` - does not compile or load optional deps","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Deps.Loadpaths"}
{"completion":"Extension point for precompiling dependencies.\n\nThis is a task that can be aliased by projects\nthat need to execute certain tasks before\ncompiling dependencies:\n\n    aliases: [\"deps.precompile\": [\"nerves.precompile\", \"deps.precompile\"]]\n\nBy default, this task's single responsibility\nis to load all dependency paths. Dependency\nloading is deliberately ad-hoc, loading as much as\npossible without validating the files.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Deps.Precompile"}
{"completion":"Prints the dependency tree.\n\n    mix deps.tree\n\nIf no dependency is given, it uses the tree defined in the `mix.exs` file.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Deps.Tree"}
{"completion":"Command line options\n\n  * `--only` - the environment to show dependencies for\n\n  * `--target` - the target to show dependencies for\n\n  * `--exclude` - exclude dependencies which you do not want to see printed.\n\n  * `--format` - Can be set to one of either:\n\n    * `pretty` - uses Unicode code points for formatting the tree.\n      This is the default except on Windows.\n\n    * `plain` - does not use Unicode code points for formatting the tree.\n      This is the default on Windows.\n\n    * `dot` - produces a DOT graph description of the dependency tree\n      in `deps_tree.dot` in the current directory.\n      Warning: this will override any previously generated file.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Deps.Tree"}
{"completion":"Unlocks the given dependencies.\n\nSince this is a destructive action, unlocking dependencies\nonly occurs when passing arguments/options:\n\n  * `dep1 dep2` - the name of dependencies to be unlocked\n  * `--all` - unlocks all dependencies\n  * `--filter` - unlocks only deps matching the given name\n  * `--unused` - unlocks only unused dependencies (no longer mentioned\n    in the `mix.exs` file)\n  * `--check-unused` - checks that the `mix.lock` file has no unused\n    dependencies. This is useful in pre-commit hooks and CI scripts\n    if you want to reject contributions with extra dependencies","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Deps.Unlock"}
{"completion":"Updates the given dependencies.\n\nThe given dependencies and the projects they depend on will\nbe unlocked and updated to the latest version according to their\nversion requirements.\n\nSince this is a destructive action, updating all dependencies\nonly occurs when the `--all` command line option is passed.\n\nAll dependencies are automatically recompiled after update.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Deps.Update"}
{"completion":"mix deps.unlock + mix deps.get\n\nUpgrading a dependency often requires the projects it depends on\nto upgrade too. If you would rather update a single dependency and\nnot touch its children, you can explicitly unlock the single dependency\nand run `mix deps.get`:\n\n    $ mix deps.unlock some_dep\n    $ mix deps.get","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Deps.Update"}
{"completion":"Command line options\n\n  * `--all` - updates all dependencies\n  * `--only` - only fetches dependencies for given environment\n  * `--target` - only fetches dependencies for given target\n  * `--no-archives-check` - does not check archives before fetching deps","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Deps.Update"}
{"completion":"Executes the tasks separated by `+`:\n\n    mix do compile --list + deps\n\nThe plus should be followed by at least one space before and after.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Do"}
{"completion":"Examples\n\nThe example below prints the available compilers and\nthen the list of dependencies.\n\n    mix do compile --list + deps\n\nNote that the majority of Mix tasks are only executed once\nper invocation. So for example, the following command will\nonly compile once:\n\n    mix do compile + some_other_command + compile\n\nWhen `compile` is executed again, Mix will notice the task\nhas already ran, and skip it.\n\nInside umbrella projects, you can limit recursive tasks\n(the ones that run inside every app) by selecting the\ndesired application via the `--app` flag after `do` and\nbefore the first task:\n\n    mix do --app app1 --app app2 compile --list + deps\n\nElixir versions prior to v1.14 used the comma exclusively\nto separate commands:\n\n    mix do compile --list + deps\n\nSince then, the `+` operator has been introduced as a\nseparator for better support on Windows terminals.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Do"}
{"completion":"Command line options\n\n  * `--app` - limit recursive tasks to the given apps.\n    This option may be given multiple times and must come\n    before any of the tasks.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Do"}
{"completion":"Lists all installed escripts.\n\nEscripts are installed at `~/.mix/escripts`. Add that path to your `PATH` environment variable\nto be able to run installed escripts from any directory.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Escript"}
{"completion":"Builds an escript for the project.\n\nAn escript is an executable that can be invoked from the\ncommand line. An escript can run on any machine that has\nErlang/OTP installed and by default does not require Elixir to\nbe installed, as Elixir is embedded as part of the escript.\n\nThis task guarantees the project and its dependencies are\ncompiled and packages them inside an escript. Before invoking\n`mix escript.build`, it is only necessary to define a `:escript`\nkey with a `:main_module` option in your `mix.exs` file:\n\n    escript: [main_module: MyApp.CLI]\n\nEscripts should be used as a mechanism to share scripts between\ndevelopers and not as a deployment mechanism. For running live\nsystems, consider using `mix run` or building releases. See\nthe `Application` module for more information on systems\nlife-cycles.\n\nAll of the configuration defined in `config/config.exs` will\nbe included as part of the escript. `config/runtime.exs` is also\nincluded for Elixir escripts. Once the configuration is loaded,\nthis task starts the current application. If this is not desired,\nset the `:app` configuration to nil.\n\nThis task also removes documentation and debugging chunks from\nthe compiled `.beam` files to reduce the size of the escript.\nIf this is not desired, check the `:strip_beams` option.\n\n> Note: escripts do not support projects and dependencies\n> that need to store or read artifacts from the priv directory.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Escript.Build"}
{"completion":"Command line options\n\nExpects the same command line options as `mix compile`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Escript.Build"}
{"completion":"Configuration\n\nThe following option must be specified in your `mix.exs`\nunder the `:escript` key:\n\n  * `:main_module` - the module to be invoked once the escript starts.\n    The module must contain a function named `main/1` that will receive the\n    command line arguments. By default the arguments are given as a list of\n    binaries, but if project is configured with `language: :erlang` it will\n    be a list of charlists.\n\nThe remaining options can be specified to further customize the escript:\n\n  * `:name` - the name of the generated escript.\n    Defaults to app name.\n\n  * `:path` - the path to write the escript to.\n    Defaults to app name.\n\n  * `:app` - the app that starts with the escript.\n    Defaults to app name. Set it to `nil` if no application should\n    be started.\n\n  * `:strip_beams` - if `true` strips BEAM code in the escript to remove chunks\n    unnecessary at runtime, such as debug information and documentation.\n    Can be set to `[keep: [\"Docs\", \"Dbgi\"]]` to strip while keeping some chunks\n    that would otherwise be stripped, like docs, and debug info, for instance.\n    Defaults to `true`.\n\n  * `:embed_elixir` - if `true` embeds Elixir and its children apps\n    (`ex_unit`, `mix`, and the like) mentioned in the `:applications` list inside the\n    `application/0` function in `mix.exs`.\n\n    Defaults to `true` for Elixir projects, `false` for Erlang projects.\n\n    Note: if you set this to `false` for an Elixir project, you will have to add paths to Elixir's\n    `ebin` directories to `ERL_LIBS` environment variable when running the resulting escript, in\n    order for the code loader to be able to find `:elixir` application and its children\n    applications (if they are used).\n\n  * `:shebang` - shebang interpreter directive used to execute the escript.\n    Defaults to `\"#! /usr/bin/env escript\\n\"`.\n\n  * `:comment` - comment line to follow shebang directive in the escript.\n    Defaults to `\"\"`.\n\n  * `:emu_args` - emulator arguments to embed in the escript file.\n    Defaults to `\"\"`.\n\nThere is one project-level option that affects how the escript is generated:\n\n  * `language: :elixir | :erlang` - set it to `:erlang` for Erlang projects\n    managed by Mix. Doing so will ensure Elixir is not embedded by default.\n    Your app will still be started as part of escript loading, with the\n    config used during build.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Escript.Build"}
{"completion":"Example\n\n* `mix.exs`:\n\n      defmodule MyApp.MixProject do\n        use Mix.Project\n\n        def project do\n          [\n            app: :my_app,\n            version: \"0.0.1\",\n            escript: escript()\n          ]\n        end\n\n        def escript do\n          [main_module: MyApp.CLI]\n        end\n      end\n\n* `lib/cli.ex`:\n\n      defmodule MyApp.CLI do\n        def main(_args) do\n          IO.puts(\"Hello from MyApp!\")\n        end\n      end","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Escript.Build"}
{"completion":"Installs an escript locally.\n\nIf no argument is supplied but there is an escript in the project's root directory\n(created with `mix escript.build`), then the escript will be installed\nlocally. For example:\n\n    mix do escript.build + escript.install\n\nIf an argument is provided, it should be a local path to a prebuilt escript,\na Git repository, a GitHub repository, or a Hex package.\n\n    mix escript.install escript\n    mix escript.install path/to/escript\n    mix escript.install git https://path/to/git/repo\n    mix escript.install git https://path/to/git/repo branch git_branch\n    mix escript.install git https://path/to/git/repo tag git_tag\n    mix escript.install git https://path/to/git/repo ref git_ref\n    mix escript.install github user/project\n    mix escript.install github user/project branch git_branch\n    mix escript.install github user/project tag git_tag\n    mix escript.install github user/project ref git_ref\n    mix escript.install hex hex_package\n    mix escript.install hex hex_package 1.2.3\n\nAfter installation, the escript can be invoked as\n\n    ~/.mix/escripts/foo\n\nFor convenience, consider adding `~/.mix/escripts` directory to your\n`PATH` environment variable. For more information, check the wikipedia\narticle on PATH: https://en.wikipedia.org/wiki/PATH_(variable)","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Escript.Install"}
{"completion":"Command line options\n\n  * `--sha512` - checks the escript matches the given SHA-512 checksum. Only\n    applies to installations via a local path\n\n  * `--force` - forces installation without a shell prompt; primarily\n    intended for automation in build systems like Make\n\n  * `--submodules` - fetches repository submodules before building escript from\n    Git or GitHub\n\n  * `--app` - specifies a custom app name to be used for building the escript\n    from Git, GitHub, or Hex\n\n  * `--organization` - set this for Hex private packages belonging to an\n    organization\n\n  * `--repo` - set this for self-hosted Hex instances, defaults to `hexpm`","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Escript.Install"}
{"completion":"Uninstalls local escripts:\n\n    mix escript.uninstall escript_name","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Escript.Uninstall"}
{"completion":"Command line options\n  * `--force` - forces uninstallation without a shell prompt; primarily\n    intended for automation","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Escript.Uninstall"}
{"completion":"Evaluates the given code within a configured application.\n\n    mix eval \"IO.puts(1 + 2)\"\n\nThe given code is evaluated after the current application\nhas been configured, but without loading nor starting it.\nSee `mix run` for running your application and scripts within\na started application.\n\nThis task is designed to mirror the `bin/my_app eval` command\nin releases. It is typically used to invoke functions already\ndefined within your application. For example, you may have a\nmodule such as:\n\n    defmodule MyApp.ReleaseTasks do\n      def migrate_database do\n        Application.load(:my_app)\n        ...\n      end\n    end\n\nOnce defined, you can invoke this function either via `mix eval` or\nvia `bin/my_app eval` inside a release as follows:\n\n    $ mix eval MyApp.ReleaseTasks.migrate_database\n    $ bin/my_app eval MyApp.ReleaseTasks.migrate_database\n\nAs you can see, the current application has to be either explicitly\nloaded or started in your tasks, either by calling `Application.load/1`\nor `Application.ensure_all_started/1`. This gives you full control over\nthe application booting life-cycle. For more information, see the\n`Application` module.\n\nThis task is automatically re-enabled, so it can be called multiple\ntimes with different arguments.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Eval"}
{"completion":"Command-line options\n\n  * `--no-archives-check` - does not check archives\n  * `--no-compile` - does not compile even if files require compilation\n  * `--no-deps-check` - does not check dependencies\n  * `--no-elixir-version-check` - does not check the Elixir version from mix.exs\n  * `--no-mix-exs` - allows the command to run even if there is no mix.exs","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Eval"}
{"completion":"Returns a formatter function and the formatter options to\nbe used for the given file.\n\nThe function must be called with the contents of the file\nto be formatted. The options are returned for reflection\npurposes.","prompt":"Can you write a docstring for the following Elixir function? formatter_for_file(file, opts \\\\ [])"}
{"completion":"Returns formatter options to be used for the given file.","prompt":"Can you write a docstring for the following Elixir function? formatter_opts_for_file(file, opts \\\\ [])"}
{"completion":"Formats the given files and patterns.\n\n    mix format mix.exs \"lib/**/*.{ex,exs}\" \"test/**/*.{ex,exs}\"\n\nIf any of the files is `-`, then the input is read from stdin and the output\nis written to stdout.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Format"}
{"completion":"Formatting options\n\nThe formatter will read a `.formatter.exs` file in the current directory for\nformatter configuration. Evaluating this file should return a keyword list.\n\nHere is an example of a `.formatter.exs` file that works as a starting point:\n\n    [\n      inputs: [\"{mix,.formatter}.exs\", \"{config,lib,test}/**/*.{ex,exs}\"]\n    ]\n\nBesides the options listed in `Code.format_string!/2`, the `.formatter.exs`\nfile supports the following options:\n\n  * `:inputs` (a list of paths and patterns) - specifies the default inputs\n    to be used by this task. For example, `[\"mix.exs\", \"{config,lib,test}/**/*.{ex,exs}\"]`.\n    Patterns are expanded with `Path.wildcard/2`.\n\n  * `:plugins` (a list of modules) (since v1.13.0) - specifies a list of\n    modules to customize how the formatter works. See the \"Plugins\" section\n    below for more information.\n\n  * `:subdirectories` (a list of paths and patterns) - specifies subdirectories\n    that have their own formatting rules. Each subdirectory should have a\n    `.formatter.exs` that configures how entries in that subdirectory should be\n    formatted as. Configuration between `.formatter.exs` are not shared nor\n    inherited. If a `.formatter.exs` lists \"lib/app\" as a subdirectory, the rules\n    in `.formatter.exs` won't be available in `lib/app/.formatter.exs`.\n    Note that the parent `.formatter.exs` must not specify files inside the \"lib/app\"\n    subdirectory in its `:inputs` configuration. If this happens, the behaviour of\n    which formatter configuration will be picked is unspecified.\n\n  * `:import_deps` (a list of dependencies as atoms) - specifies a list\n     of dependencies whose formatter configuration will be imported.\n     See the \"Importing dependencies configuration\" section below for more\n     information.\n\n  * `:export` (a keyword list) - specifies formatter configuration to be exported.\n    See the \"Importing dependencies configuration\" section below.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Format"}
{"completion":"Task-specific options\n\n  * `--check-formatted` - checks that the file is already formatted.\n    This is useful in pre-commit hooks and CI scripts if you want to\n    reject contributions with unformatted code. If the check fails,\n    the formatted contents are not written to disk. Keep in mind\n    that the formatted output may differ between Elixir versions as\n    improvements and fixes are applied to the formatter.\n\n  * `--dry-run` - does not save files after formatting.\n\n  * `--dot-formatter` - path to the file with formatter configuration.\n    Defaults to `.formatter.exs` if one is available. See the\n    \"Formatting options\" section above for more information.\n\n  * `--stdin-filename` - path to the file being formatted on stdin.\n    This is useful if you are using plugins to support custom filetypes such\n    as `.heex`. Without passing this flag, it is assumed that the code being\n    passed via stdin is valid Elixir code. Defaults to \"stdin.exs\".","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Format"}
{"completion":"When to format code\n\nWe recommend developers to format code directly in their editors, either\nautomatically when saving a file or via an explicit command or key binding. If\nsuch option is not available in your editor of choice, adding the required\nintegration is usually a matter of invoking:\n\n    cd $project && mix format $file\n\nwhere `$file` refers to the current file and `$project` is the root of your\nproject.\n\nIt is also possible to format code across the whole project by passing a list\nof patterns and files to `mix format`, as shown at the top of this task\ndocumentation. This list can also be set in the `.formatter.exs` file under the\n`:inputs` key.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Format"}
{"completion":"Plugins\n\nIt is possible to customize how the formatter behaves. Plugins must implement\nthe `Mix.Tasks.Format` behaviour. For example, imagine that your project uses\nMarkdown in two distinct ways: via a custom `~M` sigil and via files with the\n`.md` and `.markdown` extensions. A custom plugin would look like this:\n\n    defmodule MixMarkdownFormatter do\n      @behaviour Mix.Tasks.Format\n\n      def features(_opts) do\n        [sigils: [:M], extensions: [\".md\", \".markdown\"]]\n      end\n\n      def format(contents, opts) do\n        # logic that formats markdown\n      end\n    end\n\nThe `opts` passed to `format/2` contains all the formatting options and either:\n\n  * `:sigil` (atom) - the sigil being formatted, e.g. `:M`.\n\n  * `:modifiers` (charlist) - list of sigil modifiers.\n\n  * `:extension` (string) - the extension of the file being formatted, e.g. `\".md\"`.\n\nNow any application can use your formatter as follows:\n\n    # .formatters.exs\n    [\n      # Define the desired plugins\n      plugins: [MixMarkdownFormatter],\n      # Remember to update the inputs list to include the new extensions\n      inputs: [\"{mix,.formatter}.exs\", \"{config,lib,test}/**/*.{ex,exs}\", \"posts/*.{md,markdown}\"]\n    ]\n\nRemember that, when running the formatter with plugins, you must make\nsure that your dependencies and your application have been compiled,\nso the relevant plugin code can be loaded. Otherwise a warning is logged.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Format"}
{"completion":"Importing dependencies configuration\n\nThis task supports importing formatter configuration from dependencies.\n\nA dependency that wants to export formatter configuration needs to have a\n`.formatter.exs` file at the root of the project. In this file, the dependency\ncan list an `:export` option with configuration to export. For now, only one\noption is supported under `:export`: `:locals_without_parens` (whose value has\nthe same shape as the value of the `:locals_without_parens` in `Code.format_string!/2`).\n\nThe functions listed under `:locals_without_parens` in the `:export` option of\na dependency can be imported in a project by listing that dependency in the\n`:import_deps` option of the formatter configuration file of the project.\n\nFor example, consider you have a project called `my_app` that depends on another one called `my_dep`.\n`my_dep` wants to export some configuration, so `my_dep/.formatter.exs`\nwould look like this:\n\n    # my_dep/.formatter.exs\n    [\n      # Regular formatter configuration for my_dep\n      # ...\n\n      export: [\n        locals_without_parens: [some_dsl_call: 2, some_dsl_call: 3]\n      ]\n    ]\n\nIn order to import configuration, `my_app`'s `.formatter.exs` would look like\nthis:\n\n    # my_app/.formatter.exs\n    [\n      import_deps: [:my_dep]\n    ]","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Format"}
{"completion":"Lists all tasks and aliases or prints the documentation for a given task or alias.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Help"}
{"completion":"Arguments\n\n    mix help                  - prints all aliases, tasks and their short descriptions\n    mix help ALIAS            - prints the definition for the given alias\n    mix help TASK             - prints full docs for the given task\n    mix help --search PATTERN - prints all tasks and aliases that contain PATTERN in the name\n    mix help --names          - prints all task names and aliases\n                                (useful for autocompleting)","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Help"}
{"completion":"Colors\n\nWhen possible, `mix help` is going to use coloring for formatting\nthe help information. The formatting can be customized by configuring\nthe Mix application either inside your project (in `config/config.exs`)\nor by using the local config (in `~/.mix/config.exs`).\n\nFor example, to disable color, one may use the configuration:\n\n    [mix: [colors: [enabled: false]]]\n\nThe available color options are:\n\n  * `:enabled`         - shows ANSI formatting (defaults to `IO.ANSI.enabled?/0`)\n  * `:doc_code`        - the attributes for code blocks (cyan, bright)\n  * `:doc_inline_code` - inline code (cyan)\n  * `:doc_headings`    - h1 and h2 (yellow, bright)\n  * `:doc_title`       - the overall heading for the output (reverse, yellow, bright)\n  * `:doc_bold`        - (bright)\n  * `:doc_underline`   - (underline)","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Help"}
{"completion":"A task that simply instructs users to run `iex -S mix`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Iex"}
{"completion":"Loads and persists the given configuration.\n\n    mix loadconfig path/to/config.exs\n\nAny configuration file loaded with `loadconfig` is treated\nas a compile-time configuration.\n\nNote that \"config/config.exs\" is always loaded automatically\nby the Mix CLI when it boots. \"config/runtime.exs\" is loaded\nautomatically by `mix app.config` before starting the current\napplication. Therefore there is no need to load those config\nfiles directly.\n\nThis task is automatically re-enabled, so it can be called\nmultiple times to load different configs.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Loadconfig"}
{"completion":"Loads the application and its dependencies paths.\n\nThis task is never directly invoked from the command line,\nbut it is rather used as building block by other tasks.\n\nDependencies are checked, compiled, and loaded. Each step\ncan be explicitly disabled with flags.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Loadpaths"}
{"completion":"Configuration\n\n  * `:elixir` - matches the current Elixir version against the\n    given requirement","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Loadpaths"}
{"completion":"Command line options\n\n  * `--no-archives-check` - does not check archives\n  * `--no-compile` - does not compile dependencies, only check and load them\n  * `--no-deps-check` - does not check dependencies, only load available ones\n  * `--no-elixir-version-check` - does not check Elixir version\n  * `--no-load-deps` - does not add deps loadpaths to the code path\n  * `--no-optional-deps` - does not compile or load optional deps","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Loadpaths"}
{"completion":"Lists local tasks.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Local"}
{"completion":"Installs Hex locally.\n\n    mix local.hex [VERSION]\n\nBy default the latest compatible version of Hex will be installed, unless\n`VERSION` is specified.\n\nIf installing a precompiled Hex does not work, you can compile and install\nHex directly with this command:\n\n    mix archive.install github hexpm/hex branch latest","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Local.Hex"}
{"completion":"Command line options\n\n  * `--force` - forces installation without a shell prompt; primarily\n    intended for automation in build systems like `make`\n\n  * `--if-missing` - performs installation only if Hex is not installed yet;\n    intended to avoid repeatedly reinstalling Hex in automation when a script\n    may be run multiple times\n\nIf both options are set, the shell prompt is skipped and Hex is not\nre-installed if it was already installed.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Local.Hex"}
{"completion":"Mirrors\n\nIf you want to change the [default mirror](https://repo.hex.pm)\nused for fetching Hex, set the `HEX_MIRROR` environment variable.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Local.Hex"}
{"completion":"Public keys are used by Mix to install packages like Rebar and Hex.\n\nMix by default ships with a public key but new ones can be added\non demand.\n\nTo list all available keys:\n\n    $ mix local.public_keys\n\nTo list all available keys showing the keys themselves:\n\n    $ mix local.public_keys --detailed\n\nTo add a new key:\n\n    $ mix local.public_keys local/path/to/key\n\nBe careful when adding new keys. Only add keys from sources you\ntrust.\n\nPublic keys are by default stored in your MIX_HOME under the\npublic_keys directory.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Local.PublicKeys"}
{"completion":"Command line options\n\n  * `--force` - forces installation without a shell prompt; primarily\n    intended for automation in build systems like `make`","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Local.PublicKeys"}
{"completion":"Fetches a copy of `rebar3` from the given path or URL.\n\nIt defaults to safely download a Rebar copy from Hex's CDN.\nHowever, a URL can be given as an argument, usually for an existing\nlocal copy of Rebar:\n\n    mix local.rebar rebar3 path/to/rebar\n\nThe local copy is stored in your `MIX_HOME` (defaults to `~/.mix`)\naccording to the current Elixir. The installed version of Rebar will\nbe used whenever required by `mix deps.compile`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Local.Rebar"}
{"completion":"Command line options\n\n  * `rebar3 PATH` - specifies a path for `rebar3`\n\n  * `--sha512` - checks the Rebar script matches the given SHA-512 checksum\n\n  * `--force` - forces installation without a shell prompt; primarily\n    intended for automation in build systems like `make`\n\n  * `--if-missing` - performs installation only if not installed yet;\n    intended to avoid repeatedly reinstalling in automation when a script\n    may be run multiple times","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Local.Rebar"}
{"completion":"Mirrors\n\nIf you want to change the [default mirror](https://repo.hex.pm)\nto use for fetching `rebar` please set the `HEX_MIRROR` environment variable.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Local.Rebar"}
{"completion":"Returns a list of reserved application names.","prompt":"Can you write a docstring for the following Elixir function? reserved_application_names()"}
{"completion":"Creates a new Elixir project.\nIt expects the path of the project as argument.\n\n    mix new PATH [--app APP] [--module MODULE] [--sup] [--umbrella]\n\nA project at the given PATH will be created. The\napplication name and module name will be retrieved\nfrom the path, unless `--module` or `--app` is given.\n\nAn `--app` option can be given in order to\nname the OTP application for the project.\n\nA `--module` option can be given in order\nto name the modules in the generated code skeleton.\n\nA `--sup` option can be given to generate an OTP application\nskeleton including a supervision tree. Normally an app is\ngenerated without a supervisor and without the app callback.\n\nAn `--umbrella` option can be given to generate an\numbrella project.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.New"}
{"completion":"Examples\n\n    mix new hello_world\n\nIs equivalent to:\n\n    mix new hello_world --module HelloWorld\n\nTo generate an app with a supervision tree and an application callback:\n\n    mix new hello_world --sup\n\nTo generate an umbrella application with sub applications:\n\n    mix new hello_world --umbrella\n    cd hello_world/apps\n    mix new child_app","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.New"}
{"completion":"Allows to programmatically run the `cprof` profiler on expression in `fun`.\n\nReturns the return value of `fun`.\n\n## Options\n\n  * `:matching` - only profile calls matching the given pattern in form of\n    `{module, function, arity}`, where each element may be replaced by `:_`\n    to allow any value\n  * `:limit` - filters out any results with a call count less than the limit\n  * `:module` - filters out any results not pertaining to the given module","prompt":"Can you write a docstring for the following Elixir function? profile(fun, opts \\\\ [])"}
{"completion":"Profiles the given file or expression using Erlang's `cprof` tool.\n\n`cprof` can be useful when you want to discover the bottlenecks related\nto function calls.\n\nBefore running the code, it invokes the `app.start` task which compiles\nand loads your project. After that, the target expression is profiled together\nwith all matching function calls, by setting breakpoints containing\ncounters. These can only be set on BEAM code so BIFs cannot be call\ncount traced.\n\nTo profile the code, you can use syntax similar to the `mix run` task:\n\n    mix profile.cprof -e Hello.world\n    mix profile.cprof -e \"[1, 2, 3] |> Enum.reverse |> Enum.map(&Integer.to_string/1)\"\n    mix profile.cprof my_script.exs arg1 arg2 arg3\n\nThis task is automatically re-enabled, so you can profile multiple times\nin the same Mix invocation.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Profile.Cprof"}
{"completion":"Command line options\n\n  * `--matching` - only profile calls matching the given `Module.function/arity` pattern\n  * `--limit` - filters out any results with a call count less than the limit\n  * `--module` - filters out any results not pertaining to the given module\n  * `--eval`, `-e` - evaluate the given code\n  * `--require`, `-r` - requires pattern before running the command\n  * `--parallel`, `-p` - makes all requires parallel\n  * `--no-compile` - does not compile even if files require compilation\n  * `--no-deps-check` - does not check dependencies\n  * `--no-archives-check` - does not check archives\n  * `--no-halt` - does not halt the system after running the command\n  * `--no-start` - does not start applications after compilation\n  * `--no-elixir-version-check` - does not check the Elixir version from mix.exs","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Profile.Cprof"}
{"completion":"Profile output\n\nExample output:\n                                                                         CNT\n    Total                                                                 15\n    Enum                                                                   6  <--\n      Enum.\"-map/2-lists^map/1-0-\"/2                                       4\n      Enum.reverse/1                                                       1\n      Enum.map/2                                                           1\n    :elixir_compiler                                                       4  <--\n      anonymous fn/1 in :elixir_compiler.__FILE__/1                        3\n      anonymous fn/0 in :elixir_compiler.__FILE__/1                        1\n    String.Chars.Integer                                                   3  <--\n      String.Chars.Integer.to_string/1                                     3\n    :erlang                                                                2  <--\n      :erlang.trace_pattern/3                                              2\n    Profile done over 20229 matching functions\n\nThe default output contains data gathered from all matching functions. The left\ncolumn structures each module and its total call count trace is presented on the right.\nEach module has its count discriminated by function below. The `<--` symbol is meant to\nhelp visualize where a new module call count begins.\n\nThe first row (Total) is the sum of all function calls. In the last row the number of\nmatching functions that were considered for profiling is presented.\n\nWhen `--matching` option is specified, call count tracing will be started only for\nthe functions matching the given pattern:\n\n    String.Chars.Integer                                                   3  <--\n      String.Chars.Integer.to_string/1                                     3\n    Profile done over 1 matching functions\n\nThe pattern can be a module name, such as `String` to count all calls to that module,\na call without arity, such as `String.split`, to count all calls to that function\nregardless of arity, or a call with arity, such as `String.split/3`, to count all\ncalls to that exact module, function and arity.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Profile.Cprof"}
{"completion":"Caveats\n\nYou should be aware the profiler is stopped as soon as the code has finished running. This\nmay need special attention, when:  running asynchronous code as function calls which were\ncalled before the profiler stopped will not be counted; running synchronous code as long\nrunning computations and a profiler without a proper MFA trace pattern or filter may\nlead to a result set which is difficult to comprehend.\n\nOther caveats are the impossibility to call count trace BIFs, since breakpoints can\nonly be set on BEAM code; functions calls performed by `:cprof` are not traced; the\nmaximum size of a call counter is equal to the host machine's word size\n(for example, 2147483647 in a 32-bit host).","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Profile.Cprof"}
{"completion":"Allows to programmatically run the `eprof` profiler on expression in `fun`.\n\nReturns the return value of `fun`.\n\n## Options\n\n  * `:matching` - only profile calls matching the given pattern in form of\n    `{module, function, arity}`, where each element may be replaced by `:_`\n    to allow any value\n  * `:calls` - filters out any results with a call count lower than this\n  * `:time` - filters out any results that took lower than specified (in s)\n  * `:sort` - sort the results by `:time` or `:calls` (default: `:time`)","prompt":"Can you write a docstring for the following Elixir function? profile(fun, opts \\\\ [])"}
{"completion":"Profiles the given file or expression using Erlang's `eprof` tool.\n\n`:eprof` provides time information of each function call and can be useful\nwhen you want to discover the bottlenecks related to this.\n\nBefore running the code, it invokes the `app.start` task which compiles\nand loads your project. After that, the target expression is profiled together\nwith all matching function calls using the Erlang trace BIFs. The tracing of\nthe function calls for that is enabled when the profiling is begun, and\ndisabled when profiling is stopped.\n\nTo profile the code, you can use syntax similar to the `mix run` task:\n\n    mix profile.eprof -e Hello.world\n    mix profile.eprof -e \"[1, 2, 3] |> Enum.reverse |> Enum.map(&Integer.to_string/1)\"\n    mix profile.eprof my_script.exs arg1 arg2 arg3\n\nThis task is automatically re-enabled, so you can profile multiple times\nin the same Mix invocation.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Profile.Eprof"}
{"completion":"Command line options\n\n  * `--matching` - only profile calls matching the given `Module.function/arity` pattern\n  * `--calls` - filters out any results with a call count lower than this\n  * `--time` - filters out any results that took lower than specified (in s)\n  * `--sort` - sorts the results by `time` or `calls` (default: `time`)\n  * `--eval`, `-e` - evaluates the given code\n  * `--require`, `-r` - requires pattern before running the command\n  * `--parallel`, `-p` - makes all requires parallel\n  * `--no-warmup` - skips the warmup step before profiling\n  * `--no-compile` - does not compile even if files require compilation\n  * `--no-deps-check` - does not check dependencies\n  * `--no-archives-check` - does not check archives\n  * `--no-halt` - does not halt the system after running the command\n  * `--no-start` - does not start applications after compilation\n  * `--no-elixir-version-check` - does not check the Elixir version from mix.exs","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Profile.Eprof"}
{"completion":"Profile output\n\nExample output:\n\n    #                                               CALLS     % TIME S/CALL\n    Total                                              24 100.0   26    1.08\n    Enum.reduce_range_inc/4                             5  3.85    1    0.20\n    :erlang.make_fun/3                                  1  7.69    2    2.00\n    Enum.each/2                                         1  7.69    2    2.00\n    anonymous fn/0 in :elixir_compiler_0.__FILE__/1     1  7.69    2    2.00\n    :erlang.integer_to_binary/1                         5 15.39    4    0.80\n    :erlang.apply/2                                     1 15.39    4    4.00\n    anonymous fn/3 in Enum.each/2                       5 19.23    5    1.00\n    String.Chars.Integer.to_string/1                    5 23.08    6    1.20\n\n    Profile done over 8 matching functions\n\nThe default output contains data gathered from all matching functions. The first\nrow after the header contains the sums of the partial results and the average time\nfor all the function calls listed. The following rows contain the function call,\nfollowed by the number of times that the function was called, then by the percentage\nof time that the call uses, then the total time for that function in microseconds,\nand, finally, the average time per call in microseconds.\n\nWhen `--matching` option is specified, call count tracing will be started only for\nthe functions matching the given pattern:\n\n    #                                               CALLS     % TIME S/CALL\n    Total                                               5 100.0    6    1.20\n    String.Chars.Integer.to_string/1                    5 100.0    6    1.20\n\n    Profile done over 1 matching functions\n\nThe pattern can be a module name, such as `String` to count all calls to that module,\na call without arity, such as `String.split`, to count all calls to that function\nregardless of arity, or a call with arity, such as `String.split/3`, to count all\ncalls to that exact module, function and arity.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Profile.Eprof"}
{"completion":"Caveats\n\nYou should be aware that the code being profiled is running in an anonymous\nfunction which is invoked by [`:eprof` module](https://www.erlang.org/doc/man/eprof.html).\nThus, you'll see some additional entries in your profile output. It is also\nimportant to note that the profiler is stopped as soon as the code has finished running,\nand this may need special attention, when: running asynchronous code as function calls which were\ncalled before the profiler stopped will not be counted; running synchronous code as long\nrunning computations and a profiler without a proper MFA trace pattern or filter may\nlead to a result set which is difficult to comprehend.\n\nYou should expect a slowdown in your code execution using this tool since `:eprof` has\nsome performance impact on the execution, but the impact is considerably lower than\n`Mix.Tasks.Profile.Fprof`. If you have a large system try to profile a limited\nscenario or focus on the main modules or processes. Another alternative is to use\n`Mix.Tasks.Profile.Cprof` that uses `:cprof` and has a low performance degradation effect.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Profile.Eprof"}
{"completion":"Allows to programmatically run the `fprof` profiler on expression in `fun`.\n\nReturns the return value of `fun`.\n\n## Options\n\n  * `:callers` - prints detailed information about immediate callers and called functions\n  * `:details` - includes profile data for each profiled process\n  * `:sort` - sorts the output by given key: `:acc` (default) or `:own`","prompt":"Can you write a docstring for the following Elixir function? profile(fun, opts \\\\ [])"}
{"completion":"Profiles the given file or expression using Erlang's `fprof` tool.\n\n`fprof` can be useful when you want to discover the bottlenecks of a\nsequential code.\n\nBefore running the code, it invokes the `app.start` task which compiles\nand loads your project. After that, the target expression is profiled, together\nwith all processes which are spawned by it. Other processes (for example, those\nresiding in the OTP application supervision tree) are not profiled.\n\nTo profile the code, you can use syntax similar to the `mix run` task:\n\n    mix profile.fprof -e Hello.world\n    mix profile.fprof my_script.exs arg1 arg2 arg3\n\nThis task is automatically re-enabled, so you can profile multiple times\nin the same Mix invocation.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Profile.Fprof"}
{"completion":"Command line options\n\n  * `--callers` - prints detailed information about immediate callers and called functions\n  * `--details` - includes profile data for each profiled process\n  * `--sort key` - sorts the output by given key: `acc` (default) or `own`\n  * `--eval`, `-e` - evaluates the given code\n  * `--require`, `-r` - requires pattern before running the command\n  * `--parallel`, `-p` - makes all requires parallel\n  * `--no-compile`    - does not compile even if files require compilation\n  * `--no-deps-check` - does not check dependencies\n  * `--no-archives-check` - does not check archives\n  * `--no-start` - does not start applications after compilation\n  * `--no-elixir-version-check` - does not check the Elixir version from mix.exs\n  * `--no-warmup` - does not execute code once before profiling","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Profile.Fprof"}
{"completion":"Profile output\n\nExample output:\n    #                                        CNT    ACC (ms)    OWN (ms)\n    Total                                 200279    1972.188    1964.579\n    :fprof.apply_start_stop/4                  0    1972.188       0.012\n    anonymous fn/0 in :elixir_compiler_2       1    1972.167       0.001\n    Test.run/0                                 1    1972.166       0.007\n    Test.do_something/1                        3    1972.131       0.040\n    Test.bottleneck/0                          1    1599.490       0.007\n    ...\n\nThe default output contains data gathered from all profiled processes.\nAll times are wall clock milliseconds. The columns have the following meaning:\n\n  * CNT - total number of invocations of the given function\n  * ACC - total time spent in the function\n  * OWN - time spent in the function, excluding the time of called functions\n\nThe first row (Total) is the sum of all functions executed in all profiled\nprocesses. For the given output, we had a total of 200279 function calls and spent\nabout 2 seconds running the code.\n\nMore detailed information is returned if you provide the `--callers` and\n`--details` options.\n\nWhen `--callers` option is specified, you'll see expanded function entries:\n\n    Mod.caller1/0                             3     200.000       0.017\n    Mod.caller2/0                             2     100.000       0.017\n      Mod.some_function/0                     5     300.000       0.017  <--\n        Mod.called1/0                         4     250.000       0.010\n        Mod.called2/0                         1      50.000       0.030\n\nHere, the arrow (`<--`) indicates the __marked__ function - the function\ndescribed by this paragraph. You also see its immediate callers (above) and\ncalled functions (below).\n\nAll the values of caller functions describe the marked function. For example,\nthe first row means that `Mod.caller1/0` invoked `Mod.some_function/0` 3 times.\n200ms of the total time spent in `Mod.some_function/0` was spent processing\ncalls from this particular caller.\n\nIn contrast, the values for the called functions describe those functions, but\nin the context of the marked function. For example, the last row means that\n`Mod.called2/0` was called once by `Mod.some_function/0`, and in that case\nthe total time spent in the function was 50ms.\n\nFor a detailed explanation it's worth reading the analysis in\n[Erlang/OTP documentation for fprof](https://www.erlang.org/doc/man/fprof.html#analysis).","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Profile.Fprof"}
{"completion":"Caveats\n\nYou should be aware that the code being profiled is running in an anonymous\nfunction which is invoked by [`:fprof` module](https://www.erlang.org/doc/man/fprof.html).\nThus, you'll see some additional entries in your profile output,\nsuch as `:fprof` calls, an anonymous\nfunction with high ACC time, or an `:undefined` function which represents\nthe outer caller (non-profiled code which started the profiler).\n\nAlso, keep in mind that profiling might significantly increase the running time\nof the profiled processes. This might skew your results if, for example, those\nprocesses perform some I/O operations, since running time of those operations\nwill remain unchanged, while CPU bound operations of the profiled processes\nmight take significantly longer. Thus, when profiling some intensive program,\ntry to reduce such dependencies, or be aware of the resulting bias.\n\nFinally, it's advised to profile your program with the `prod` environment, since\nthis should provide more realistic insights into bottlenecks.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Profile.Fprof"}
{"completion":"Assembles a self-contained release for the current project:\n\n    $ MIX_ENV=prod mix release\n    $ MIX_ENV=prod mix release NAME\n\nOnce a release is assembled, it can be packaged and deployed to a\ntarget, as long as the target runs on the same operating system (OS)\ndistribution and version as the machine running the `mix release`\ncommand.\n\nA release can be configured in your `mix.exs` file under the `:releases`\nkey inside `def project`:\n\n    def project do\n      [\n        releases: [\n          demo: [\n            include_executables_for: [:unix],\n            applications: [runtime_tools: :permanent]\n          ],\n\n          ...\n        ]\n      ]\n    end\n\nYou can specify multiple releases where the key is the release name\nand the value is a keyword list with the release configuration.\nReleasing a certain name is done with:\n\n    $ MIX_ENV=prod mix release demo\n\nIf the given name does not exist, an error is raised.\n\nIf `mix release`, without a name, is invoked and there are multiple names,\nan error will be raised unless you set `default_release: NAME` at the root\nof your project configuration.\n\nIf `mix release` is invoked and there are no names, a release using the\napplication name and default values is assembled.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Release"}
{"completion":"Why releases?\n\nReleases allow developers to precompile and package all of their code\nand the runtime into a single unit. The benefits of releases are:\n\n  * Code preloading. The VM has two mechanisms for loading code:\n    interactive and embedded. By default, it runs in the interactive\n    mode which dynamically loads modules when they are used for the\n    first time. The first time your application calls `Enum.map/2`,\n    the VM will find the `Enum` module and load it. There's a downside:\n    when you start a new server in production, it may need to load\n    many other modules, causing the first requests to have an unusual\n    spike in response time. With releases, the system is configured in\n    interactive mode and then it swaps to embedded mode, which preloads\n    all modules and guarantees your system is ready to handle requests\n    after booting.\n\n  * Configuration and customization. Releases give developers fine\n    grained control over system configuration and the VM flags used\n    to start the system.\n\n  * Self-contained. A release does not require the source code to be\n    included in your production artifacts. All of the code is precompiled\n    and packaged. Releases do not even require Erlang or Elixir in your\n    servers, as it includes the Erlang VM and its runtime by default.\n    Furthermore, both Erlang and Elixir standard libraries are stripped\n    to bring only the parts you are actually using.\n\n  * Multiple releases. You can assemble different releases with\n    different configuration per application or even with different\n    applications altogether.\n\n  * Management scripts. Releases come with scripts to start, restart,\n    connect to the running system remotely, execute RPC calls, run as\n    daemon, run as a Windows service, and more.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Release"}
{"completion":"Running the release\n\nOnce a release is assembled, you can start it by calling\n`bin/RELEASE_NAME start` inside the release. In production, you would do:\n\n    $ MIX_ENV=prod mix release\n    $ _build/prod/rel/my_app/bin/my_app start\n\n`bin/my_app start` will start the system connected to the current standard\ninput/output, where logs are also written to by default. This is the\npreferred way to run the system. Many tools, such as `systemd`, platforms\nas a service, such as Heroku, and many containers platforms, such as Docker,\nare capable of processing the standard input/output and redirecting\nthe log contents elsewhere. Those tools and platforms also take care\nof restarting the system in case it crashes.\n\nYou can also execute one-off commands, run the release as a daemon on\nUnix-like system, or install it as a service on Windows. We will take a\nlook at those next. You can also list all available commands by invoking\n`bin/RELEASE_NAME`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Release"}
{"completion":"# One-off commands (eval and rpc)\n\nIf you want to invoke specific modules and functions in your release,\nyou can do so in two ways: using `eval` or `rpc`.\n\n    $ bin/RELEASE_NAME eval \"IO.puts(:hello)\"\n    $ bin/RELEASE_NAME rpc \"IO.puts(:hello)\"\n\nThe `eval` command starts its own instance of the VM but without\nstarting any of the applications in the release and without starting\ndistribution. For example, if you need to do some prep work before\nrunning the actual system, like migrating your database, `eval` can\nbe a good fit. Just keep in mind any application you may use during\neval has to be explicitly loaded and/or started.\n\nYou can start an application by calling `Application.ensure_all_started/1`.\nHowever, if for some reason you cannot start an application, maybe\nbecause it will run other services you do not want, you must at least\nload the application by calling `Application.load/1`. If you don't\nload the application, any attempt at reading its environment or\nconfiguration may fail. Note that if you start an application,\nit is automatically loaded before started.\n\nAnother way to run commands is with `rpc`, which will connect to the\nsystem currently running and instruct it to execute the given\nexpression. This means you need to guarantee the system was already\nstarted and be careful with the instructions you are executing.\nYou can also use `remote` to connect a remote IEx session to the\nsystem.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Release"}
{"completion":"## Helper module\n\nAs you operate your system, you may find yourself running some piece of code\nas a one-off command quite often. You may consider creating a module to group\nthese tasks:\n\n    # lib/my_app/release_tasks.ex\n    defmodule MyApp.ReleaseTasks do\n      def eval_purge_stale_data() do\n        # Eval commands needs to start the app before\n        # Or Application.load(:my_app) if you can't start it\n        Application.ensure_all_started(:my_app)\n\n        # Code that purges stale data\n        ...\n      end\n\n      def rpc_print_connected_users() do\n        # Code that print users connected to the current running system\n        ...\n      end\n    end\n\nIn the example above, we prefixed the function names with the command\nname used to execute them, but that is entirely optional.\n\nAnd to run them:\n\n    $ bin/RELEASE_NAME eval \"MyApp.ReleaseTasks.eval_purge_stale_data()\"\n    $ bin/RELEASE_NAME rpc \"MyApp.ReleaseTasks.rpc_print_connected_users()\"","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Release"}
{"completion":"# Daemon mode (Unix-like)\n\nYou can run the release in daemon mode with the command:\n\n    $ bin/RELEASE_NAME daemon\n\nIn daemon mode, the system is started on the background via\n[`run_erl`](https://www.erlang.org/doc/man/run_erl.html). You may also\nwant to enable [`heart`](https://www.erlang.org/doc/man/heart.html)\nin daemon mode so it automatically restarts the system in case\nof crashes. See the generated `releases/RELEASE_VSN/env.sh` file.\n\nThe daemon will write all of its standard output to the \"tmp/log/\"\ndirectory in the release root. You can watch the log file by doing\n`tail -f tmp/log/erlang.log.1` or similar. Once files get too large,\nthe index suffix will be incremented. A developer can also attach\nto the standard input of the daemon by invoking \"to_erl tmp/pipe/\"\nfrom the release root. However, note that attaching to the system\nshould be done with extreme care, since the usual commands for\nexiting an Elixir system, such as hitting Ctrl+C twice or Ctrl+\\,\nwill actually shut down the daemon. Therefore, using\n`bin/RELEASE_NAME remote` should be preferred, even in daemon mode.\n\nYou can customize the tmp directory used both for logging and for\npiping in daemon mode by setting the `RELEASE_TMP` environment\nvariable. See the \"Customization\" section.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Release"}
{"completion":"# Services mode (Windows)\n\nWhile daemons are not available on Windows, it is possible to install a\nreleased system as a service on Windows with the help of\n[`erlsrv`](https://www.erlang.org/doc/man/erlsrv.html). This can be done by\nrunning:\n\n    $ bin/RELEASE_NAME install\n\nOnce installed, the service must be explicitly managed via the `erlsrv`\nexecutable, which is included in the `erts-VSN/bin` directory.\nThe service is not started automatically after installing.\n\nFor example, if you have a release named `demo`, you can install\nthe service and then start it from the release root as follows:\n\n    $ bin/demo install\n    $ erts-VSN/bin/erlsrv.exe start demo_demo\n\nThe name of the service is `demo_demo` because the name is built\nby concatenating the node name with the release name. Since Elixir\nautomatically uses the same name for both, the service will be\nreferenced as `demo_demo`.\n\nThe `install` command must be executed as an administrator.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Release"}
{"completion":"# `bin/RELEASE_NAME` commands\n\nThe following commands are supported by `bin/RELEASE_NAME`:\n\n```text\nstart        Starts the system\nstart_iex    Starts the system with IEx attached\ndaemon       Starts the system as a daemon (Unix-like only)\ndaemon_iex   Starts the system as a daemon with IEx attached (Unix-like only)\ninstall      Installs this system as a Windows service (Windows only)\neval \"EXPR\"  Executes the given expression on a new, non-booted system\nrpc \"EXPR\"   Executes the given expression remotely on the running system\nremote       Connects to the running system via a remote shell\nrestart      Restarts the running system via a remote command\nstop         Stops the running system via a remote command\npid          Prints the operating system PID of the running system via a remote command\nversion      Prints the release name and version to be booted\n```","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Release"}
{"completion":"Deployments","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Release"}
{"completion":"# Requirements\n\nA release is built on a **host**, a machine which contains Erlang, Elixir,\nand any other dependencies needed to compile your application. A release is\nthen deployed to a **target**, potentially the same machine as the host,\nbut usually separate, and often there are many targets (either multiple\ninstances, or the release is deployed to heterogeneous environments).\n\nTo deploy straight from a host to a separate target without cross-compilation,\nthe following must be the same between the host and the target:\n\n  * Target architecture (for example, x86_64 or ARM)\n  * Target vendor + operating system (for example, Windows, Linux, or Darwin/macOS)\n  * Target ABI (for example, musl or gnu)\n\nThis is often represented in the form of target triples, for example,\n`x86_64-unknown-linux-gnu`, `x86_64-unknown-linux-musl`, `x86_64-apple-darwin`.\n\nSo to be more precise, to deploy straight from a host to a separate target,\nthe Erlang Runtime System (ERTS), and any native dependencies (NIFs), must\nbe compiled for the same target triple. If you are building on a MacBook\n(`x86_64-apple-darwin`) and trying to deploy to a typical Ubuntu machine\n(`x86_64-unknown-linux-gnu`), the release will not work. Instead you should\nbuild the release on a `x86_64-unknown-linux-gnu` host. As we will see, this\ncan be done in multiple ways, such as releasing on the target itself, or by\nusing virtual machines or containers, usually as part of your release pipeline.\n\nIn addition to matching the target triple, it is also important that the\ntarget has all of the system packages that your application will need at\nruntime. A common one is the need for OpenSSL when building an application\nthat uses `:crypto` or `:ssl`, which is dynamically linked to ERTS. The other\ncommon source for native dependencies like this comes from dependencies\ncontaining NIFs (natively-implemented functions) which may expect to\ndynamically link to libraries they use.\n\nOf course, some operating systems and package managers can differ between\nversions, so if your goal is to have full compatibility between host and\ntarget, it is best to ensure the operating system and system package manager\nhave the same versions on host and target. This may even be a requirement in\nsome systems, especially so with package managers that try to create fully\nreproducible environments (Nix, Guix).\n\nSimilarly, when creating a stand-alone package and release for Windows, note\nthe Erlang Runtime System has a dependency to some Microsoft libraries\n(Visual C++ Redistributable Packages for Visual Studio 2013). These libraries\nare installed (if not present before) when Erlang is installed but it is not\npart of the standard Windows environment. Deploying a stand-alone release on\na computer without these libraries will result in a failure when trying to\nrun the release. One way to solve this is to download and install these\nMicrosoft libraries the first time a release is deployed (the Erlang installer\nversion 10.6 ships with Microsoft Visual C++ 2013 Redistributable - 12.0.30501).\n\nAlternatively, you can also bundle the compiled object files in the release,\nas long as they were compiled for the same target. If doing so, you need to\nupdate `LD_LIBRARY_PATH` environment variable with the paths containing the\nbundled objects on Unix-like systems or the `PATH` environment variable on\nWindows systems.\n\nCurrently, there is no official way to cross-compile a release from one\ntarget triple to another, due to the complexities involved in the process.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Release"}
{"completion":"# Techniques\n\nThere are a couple of ways to guarantee that a release is built on a host with\nthe same properties as the target. A simple option is to fetch the source,\ncompile the code and assemble the release on the target itself. It would\nbe something like this:\n\n    $ git clone remote://path/to/my_app.git my_app_source\n    $ cd my_app_source\n    $ mix deps.get --only prod\n    $ MIX_ENV=prod mix release\n    $ _build/prod/rel/my_app/bin/my_app start\n\nIf you prefer, you can also compile the release to a separate directory,\nso you can erase all source after the release is assembled:\n\n    $ git clone remote://path/to/my_app.git my_app_source\n    $ cd my_app_source\n    $ mix deps.get --only prod\n    $ MIX_ENV=prod mix release --path ../my_app_release\n    $ cd ../my_app_release\n    $ rm -rf ../my_app_source\n    $ bin/my_app start\n\nHowever, this option can be expensive if you have multiple production\nnodes or if the release assembling process is a long one, as each node\nneeds to individually assemble the release.\n\nYou can automate this process in a couple different ways. One option\nis to make it part of your Continuous Integration (CI) / Continuous\nDeployment (CD) pipeline. When you have a CI/CD pipeline, it is common\nthat the machines in your CI/CD pipeline run on the exact same target\ntriple as your production servers (if they don't, they should).\nIn this case, you can assemble the release at the end of your CI/CD\npipeline by calling `MIX_ENV=prod mix release` and push the artifact\nto S3 or any other network storage. To perform the deployment, your\nproduction machines can fetch the deployment from the network storage\nand run `bin/my_app start`.\n\nAnother mechanism to automate deployments is to use images, such as\nAmazon Machine Images, or container platforms, such as Docker.\nFor instance, you can use Docker to run locally a system with the\nexact same target triple as your production servers. Inside the\ncontainer, you can invoke `MIX_ENV=prod mix release` and build\na complete image and/or container with the operating system, all\ndependencies as well as the releases.\n\nIn other words, there are multiple ways systems can be deployed and\nreleases can be automated and incorporated into all of them as long\nas you remember to build the system in the same target triple.\n\nOnce a system is deployed, shutting down the system can be done by\nsending SIGINT/SIGTERM to the system, which is what most containers,\nplatforms and tools do, or by explicitly invoking `bin/RELEASE_NAME stop`.\nOnce the system receives the shutdown request, each application and\ntheir respective supervision trees will stop, one by one, in the\nopposite order that they were started.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Release"}
{"completion":"Customization\n\nThere are a couple ways in which developers can customize the generated\nartifacts inside a release.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Release"}
{"completion":"# Options\n\nThe following options can be set inside your `mix.exs` on each release definition:\n\n  * `:applications` - a keyword list with application names as keys and their\n    mode as value. By default `:applications` includes the current application and\n    all applications the current application depends on, recursively. You can include\n    new applications or change the mode of existing ones by listing them here.\n\n    The order of the applications given will be preserved as much as possible, with\n    only `:kernel`, `:stdlib`, `:sasl`, and `:elixir` listed before the given application\n    list. The supported values are:\n\n      * `:permanent` (default) - the application is started and the node shuts down\n        if the application terminates, regardless of reason\n      * `:transient` - the application is started and the node shuts down\n        if the application terminates abnormally\n      * `:temporary` - the application is started and the node does not\n        shut down if the application terminates\n      * `:load` - the application is only loaded\n      * `:none` - the application is part of the release but it is neither\n        loaded nor started\n\n    If you change the mode of an application, the mode will apply to all its child\n    applications. However, if an application has two parents, the mode of the parent\n    with highest priority wins (where `:permanent` has the highest priority, according\n    to the list above).\n\n  * `:strip_beams` - controls if BEAM files should have their debug information,\n    documentation chunks, and other non-essential metadata removed. Defaults to\n    `true`. May be set to `false` to disable stripping. Also accepts\n   `[keep: [\"Docs\", \"Dbgi\"]]` to keep certain chunks that are usually stripped.\n   You can also set the `:compress` option to true to enable individual\n   compression of BEAM files, although it is typically preferred to compress\n   the whole release instead.\n\n  * `:cookie` - a string representing the Erlang Distribution cookie. If this\n    option is not set, a random cookie is written to the `releases/COOKIE` file\n    when the first release is assembled. At runtime, we will first attempt\n    to fetch the cookie from the `RELEASE_COOKIE` environment variable and\n    then we'll read the `releases/COOKIE` file.\n\n    If you are setting this option manually, we recommend the cookie option\n    to be a long and randomly generated string, such as:\n    `Base.url_encode64(:crypto.strong_rand_bytes(40))`. We also recommend to restrict\n    the characters in the cookie to the subset returned by `Base.url_encode64/1`.\n\n  * `:validate_compile_env` - by default a release will match all runtime\n    configuration against any configuration that was marked at compile time\n    in your application of its dependencies via the `Application.compile_env/3`\n    function. If there is a mismatch between those, it means your system is\n    misconfigured and unable to boot. You can disable this check by setting\n    this option to false.\n\n  * `:path` - the path the release should be installed to.\n    Defaults to `\"_build/MIX_ENV/rel/RELEASE_NAME\"`.\n\n  * `:version` - the release version as a string or `{:from_app, app_name}`.\n    Defaults to the current application version. The `{:from_app, app_name}` format\n    can be used to easily reference the application version from another application.\n    This is particularly useful in umbrella applications.\n\n  * `:quiet` - a boolean that controls if releases should write steps to\n    the standard output. Defaults to `false`.\n\n  * `:include_erts` - a boolean, string, or anonymous function of arity zero.\n    If a boolean, it indicates whether the Erlang Runtime System (ERTS), which\n    includes the Erlang VM, should be included in the release. The default is\n    `true`, which is also the recommended value. If a string, it represents\n    the path to an existing ERTS installation. If an anonymous function of\n    arity zero, it's a function that returns any of the above (boolean or string).\n\n    You may also set this option to `false` if you desire to use the ERTS version installed\n    on the target. Note, however, that the ERTS version on the target must have **the\n    exact version** as the ERTS version used when the release is assembled. Setting it to\n    `false` also disables hot code upgrades. Therefore, `:include_erts` should be\n    set to `false` with caution and only if you are assembling the release on the\n    same server that runs it.\n\n  * `:include_executables_for` - a list of atoms detailing for which Operating\n    Systems executable files should be generated for. By default, it is set to\n    `[:unix, :windows]`. You can customize those as follows:\n\n        releases: [\n          demo: [\n            include_executables_for: [:unix] # Or [:windows] or []\n          ]\n        ]\n\n  * `:rel_templates_path` - the path to find template files that are copied to\n    the release, such as \"vm.args.eex\", \"remote.vm.args.eex\", \"env.sh.eex\"\n    (or \"env.bat.eex\"), and \"overlays\". Defaults to \"rel\" in the project root.\n\n  * `:overlays` - a list of directories with extra files to be copied\n    as is to the release. The \"overlays\" directory at `:rel_templates_path`\n    is always included in this list by default (typically at \"rel/overlays\").\n    See the \"Overlays\" section for more information.\n\n  * `:steps` - a list of steps to execute when assembling the release. See\n    the \"Steps\" section for more information.\n\n  * `:skip_mode_validation_for` - a list of application names\n    (atoms) specifying applications to skip strict validation of\n    \"unsafe\" modes. An \"unsafe\" case is when a parent application\n    mode is `:permanent` but one of the applications it depends on\n    is set to `:load`. Use this with care, as a release with\n    invalid modes may no longer boot without additional tweaks.\n    Defaults to `[]`.\n\nNote each release definition can be given as an anonymous function. This\nis useful if some release attributes are expensive to compute:\n\n    releases: [\n      demo: fn ->\n        [version: @version <> \"+\" <> git_ref()]\n      end\n    ]\n\nBesides the options above, it is possible to customize the generated\nrelease with custom files, by tweaking the release steps or by running\ncustom options and commands on boot. We will detail both approaches next.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Release"}
{"completion":"# Overlays\n\nOften it is necessary to copy extra files to the release root after\nthe release is assembled. This can be easily done by placing such\nfiles in the `rel/overlays` directory. Any file in there is copied\nas is to the release root. For example, if you have placed a\n\"rel/overlays/Dockerfile\" file, the \"Dockerfile\" will be copied as\nis to the release root.\n\nIf you want to specify extra overlay directories, you can do so\nwith the `:overlays` option. If you need to copy files dynamically,\nsee the \"Steps\" section.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Release"}
{"completion":"# Steps\n\nIt is possible to add one or more steps before and after the release is\nassembled. This can be done with the `:steps` option:\n\n    releases: [\n      demo: [\n        steps: [&set_configs/1, :assemble, &copy_extra_files/1]\n      ]\n    ]\n\nThe `:steps` option must be a list and it must always include the\natom `:assemble`, which does most of the release assembling. You\ncan pass anonymous functions before and after the `:assemble` to\ncustomize your release assembling pipeline. Those anonymous functions\nwill receive a `Mix.Release` struct and must return the same or\nan updated `Mix.Release` struct. It is also possible to build a tarball\nof the release by passing the `:tar` step anywhere after `:assemble`.\nIf the release `:path` is not configured, the tarball is created in\n`_build/MIX_ENV/RELEASE_NAME-RELEASE_VSN.tar.gz` Otherwise it is\ncreated inside the configured `:path`.\n\nSee `Mix.Release` for more documentation on the struct and which\nfields can be modified. Note that the `:steps` field itself can be\nmodified and it is updated every time a step is called. Therefore,\nif you need to execute a command before and after assembling the\nrelease, you only need to declare the first steps in your pipeline\nand then inject the last step into the release struct. The steps\nfield can also be used to verify if the step was set before or\nafter assembling the release.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Release"}
{"completion":"# vm.args and env.sh (env.bat)\n\nDevelopers may want to customize the VM flags and environment variables\ngiven when the release starts. The simplest way to customize those files\nis by running `mix release.init`. The Mix task will copy custom\n`rel/vm.args.eex`, `rel/remote.vm.args.eex`,  `rel/env.sh.eex`, and\n`rel/env.bat.eex` files to your project root. You can modify those files\nand they will be evaluated every time you perform a new release. Those\nfiles are regular EEx templates and they have a single assign, called\n`@release`, with the `Mix.Release` struct.\n\nThe `vm.args` and `remote.vm.args` files may contain any of the VM flags\naccepted by the [`erl` command](https://www.erlang.org/doc/man/erl.html).\n\nThe `env.sh` and `env.bat` is used to set environment variables.\nIn there, you can set vars such as `RELEASE_NODE`, `RELEASE_COOKIE`,\nand `RELEASE_TMP` to customize your node name, cookie and tmp\ndirectory respectively. Whenever `env.sh` or `env.bat` is invoked,\nthe variables `RELEASE_ROOT`, `RELEASE_NAME`, `RELEASE_VSN`, and\n`RELEASE_COMMAND` have already been set, so you can rely on them.\nSee the section on environment variables for more information.\n\nFurthermore, while the `vm.args` files are static, you can use\n`env.sh` and `env.bat` to dynamically set VM options. For example,\nif you want to make sure the Erlang Distribution listens only on\na given port known at runtime, you can set the following:\n\n```bash\ncase $RELEASE_COMMAND in\n  start*|daemon*)\n    ELIXIR_ERL_OPTIONS=\"-kernel inet_dist_listen_min $BEAM_PORT inet_dist_listen_max $BEAM_PORT\"\n    export ELIXIR_ERL_OPTIONS\n    ;;\n  *)\n    ;;\nesac\n```\n\nNote we only set the port on start/daemon commands. If you also limit\nthe port on other commands, such as `rpc`, then you will be unable\nto establish a remote connection as the port will already be in use\nby the node.\n\nOn Windows, your `env.bat` would look like this:\n\n```bash\nIF NOT %RELEASE_COMMAND:start=%==%RELEASE_COMMAND% (\n  set ELIXIR_ERL_OPTIONS=\"-kernel inet_dist_listen_min %BEAM_PORT% inet_dist_listen_max %BEAM_PORT%\"\n)\n```","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Release"}
{"completion":"Application configuration\n\nMix provides two mechanisms for configuring the application environment\nof your application and your dependencies: build-time and runtime. On this\nsection, we will learn how those mechanisms apply to releases. An introduction\nto this topic can be found in the \"Configuration\" section of the `Mix` module.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Release"}
{"completion":"# Build-time configuration\n\nWhenever you invoke a `mix` command, Mix loads the configuration in\n`config/config.exs`, if said file exists. We say that this configuration\nis a build-time configuration as it is evaluated whenever you compile your\ncode or whenever you assemble the release.\n\nIn other words, if your configuration does something like:\n\n    import Config\n    config :my_app, :secret_key, System.fetch_env!(\"MY_APP_SECRET_KEY\")\n\nThe `:secret_key` key under `:my_app` will be computed on the\nhost machine, whenever the release is built. Therefore if the machine\nassembling the release not have access to all environment variables used\nto run your code, loading the configuration will fail as the environment\nvariable is missing. Luckily, Mix also provides runtime configuration,\nwhich should be preferred and we will see next.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Release"}
{"completion":"# Runtime configuration\n\nTo enable runtime configuration in your release, all you need to do is\nto create a file named `config/runtime.exs`:\n\n    import Config\n    config :my_app, :secret_key, System.fetch_env!(\"MY_APP_SECRET_KEY\")\n\nThis file will be executed whenever your Mix project or your release\nstarts.\n\nYour `config/runtime.exs` file needs to follow three important rules:\n\n  * It MUST `import Config` at the top instead of the deprecated `use Mix.Config`\n  * It MUST NOT import any other configuration file via `import_config`\n  * It MUST NOT access `Mix` in any way, as `Mix` is a build tool and\n    it is not available inside releases\n\nIf a `config/runtime.exs` exists, it will be copied to your release\nand executed early in the boot process, when only Elixir and Erlang's\nmain applications have been started. Once the configuration is loaded,\nthe Erlang system will be restarted (within the same Operating System\nprocess) and the new configuration will take place.\n\nYou can change the path to the runtime configuration file by setting\n`:runtime_config_path` inside each release configuration. This path is\nresolved at build time as the given configuration file is always copied\nto inside the release:\n\n    releases: [\n      demo: [\n        runtime_config_path: ...\n      ]\n    ]\n\nBy setting `:runtime_config_path` to `false` it can be used to prevent\na runtime configuration file to be included in the release.\n\nFinally, in order for runtime configuration to work properly (as well\nas any other \"Config provider\" as defined next), it needs to be able\nto persist the newly computed configuration to disk. The computed config\nfile will be written to \"tmp\" directory inside the release every time\nthe system boots. You can configure the \"tmp\" directory by setting the\n`RELEASE_TMP` environment variable, either explicitly or inside your\n`releases/RELEASE_VSN/env.sh` (or `env.bat` on Windows).","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Release"}
{"completion":"# Config providers\n\nReleases also supports custom mechanisms, called config providers, to load\nany sort of runtime configuration to the system while it boots. For instance,\nif you need to access a vault or load configuration from a JSON file, it can\nbe achieved with config providers. The runtime configuration outlined in the\nprevious section is handled by the `Config.Reader` provider. See the\n`Config.Provider` module for more information and more examples.\n\nThe following options can be set inside your releases key in your `mix.exs`\nto control how config providers work:\n\n  * `:reboot_system_after_config` - every time your release is configured,\n    the system is rebooted to allow the new configuration to take place.\n    You can set this option to `false` to disable the rebooting for applications\n    that are sensitive to boot time but, in doing so, note you won't be able\n    to configure system applications, such as `:kernel` and `:stdlib`.\n    Defaults to `true` if using the deprecated `config/releases.exs`,\n    `false` otherwise.\n\n  * `:prune_runtime_sys_config_after_boot` - if `:reboot_system_after_config`\n    is set, every time your system boots, the release will write a config file\n    to your tmp directory. These configuration files are generally small.\n    But if you are concerned with disk space or if you have other restrictions,\n    you can ask the system to remove said config files after boot. The downside\n    is that you will no longer be able to restart the system internally (neither\n    via `System.restart/0` nor `bin/RELEASE_NAME restart`). If you need a restart,\n    you will have to terminate the Operating System process and start a new\n    one. Defaults to `false`.\n\n  * `:start_distribution_during_config` - if `:reboot_system_after_config` is\n    set, releases only start the Erlang VM distribution features after the config\n    files are evaluated. You can set it to `true` if you need distribution during\n    configuration. Defaults to `false`.\n\n  * `:config_providers` - a list of tuples with custom config providers.\n    See `Config.Provider` for more information. Defaults to `[]`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Release"}
{"completion":"# Customization and configuration summary\n\nGenerally speaking, the following files are available for customizing\nand configuring the running system:\n\n  * `config/config.exs` (and `config/prod.exs`) - provides build-time\n    application configuration, which are executed when the release is\n    assembled\n\n  * `config/runtime.exs` - provides runtime application configuration.\n    It is executed every time your Mix project or your release boots\n    and is further extensible via config providers. If you want to\n    detect you are inside a release, you can check for release specific\n    environment variables, such as `RELEASE_NODE` or `RELEASE_MODE`\n\n  * `rel/vm.args.eex` and `rel/remote.vm.args.eex` - template files that\n    are copied into every release and provides static configuration of the\n    Erlang Virtual Machine and other runtime flags. `vm.args` runs on\n    `start`, `daemon`, and `eval` commands. `remote.vm.args` configures\n    the VM for `remote` and `rpc` commands\n\n  * `rel/env.sh.eex` and `rel/env.bat.eex` - template files that are copied\n    into every release and are executed on every command to set up environment\n    variables, including specific ones to the VM, and the general environment","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Release"}
{"completion":"Directory structure\n\nA release is organized as follows:\n\n```text\nbin/\n  RELEASE_NAME\nerts-ERTS_VSN/\nlib/\n  APP_NAME-APP_VSN/\n    ebin/\n    include/\n    priv/\nreleases/\n  RELEASE_VSN/\n    consolidated/\n    elixir\n    elixir.bat\n    env.bat\n    env.sh\n    iex\n    iex.bat\n    remote.vm.args\n    runtime.exs\n    start.boot\n    start.script\n    start_clean.boot\n    start_clean.script\n    sys.config\n    vm.args\n  COOKIE\n  start_erl.data\ntmp/\n```\n\nWe document this structure for completeness. In practice, developers\nshould not modify any of those files after the release is assembled.\nInstead use env scripts, custom config provider, overlays, and all\nother mechanisms described in this guide to configure how your release\nworks.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Release"}
{"completion":"Environment variables\n\nThe system sets different environment variables. The following variables\nare set early on and can only be read by `env.sh` and `env.bat`:\n\n  * `RELEASE_ROOT` - points to the root of the release. If the system\n    includes ERTS, then it is the same as `:code.root_dir/0`. This\n    variable is always computed and it cannot be set to a custom value\n\n  * `RELEASE_COMMAND` - the command given to the release, such as `\"start\"`,\n    `\"remote\"`, `\"eval\"`, and so on. This is typically accessed inside `env.sh`\n    and `env.bat` to set different environment variables under different\n    conditions. Note, however, that `RELEASE_COMMAND` has not been\n    validated by the time `env.sh` and `env.bat` are called, so it may\n    be empty or contain invalid values. This variable is always computed\n    and it cannot be set to a custom value\n\n  * `RELEASE_NAME` - the name of the release. It can be set to a custom\n    value when invoking the release\n\n  * `RELEASE_VSN` - the version of the release, otherwise the latest\n    version is used. It can be set to a custom value when invoking the\n    release. The custom value must be an existing release version in\n    the `releases/` directory\n\n  * `RELEASE_PROG` - the command line executable used to start the release\n\nThe following variables can be set before you invoke the release or\ninside `env.sh` and `env.bat`:\n\n  * `RELEASE_COOKIE` - the release cookie. By default uses the value\n    in `releases/COOKIE`. It can be set to a custom value\n\n  * `RELEASE_NODE` - the release node name, in the format `name` or\n    optionally `name@host` if running in distributed mode. It can be\n    set to a custom value. The name part must be made only of letters,\n    digits, underscores, and hyphens\n\n  * `RELEASE_SYS_CONFIG` - the location of the sys.config file. It can\n    be set to a custom path and it must not include the `.config` extension\n\n  * `RELEASE_VM_ARGS` - the location of the vm.args file. It can be set\n    to a custom path\n\n  * `RELEASE_REMOTE_VM_ARGS` - the location of the remote.vm.args file.\n    It can be set to a custom path\n\n  * `RELEASE_TMP` - the directory in the release to write temporary\n    files to. It can be set to a custom directory. It defaults to\n    `$RELEASE_ROOT/tmp`\n\n  * `RELEASE_MODE` - if the release should load code on demand (interactive)\n    or preload it (embedded). Defaults to \"embedded\", which increases boot\n    time but it means the runtime will respond faster as it doesn't have to\n    load code. Choose interactive if you need to decrease boot time and reduce\n    memory usage on boot. It applies only to start/daemon/install commands\n\n  * `RELEASE_DISTRIBUTION` - how do we want to run the distribution.\n    May be `name` (long names), `sname` (short names) or `none`\n    (distribution is not started automatically). Defaults to\n    `sname` which allows access only within the current system.\n    `name` allows external connections\n\n  * `RELEASE_BOOT_SCRIPT` - the name of the boot script to use when starting\n    the release. This script is used when running commands such as `start` and\n    `daemon`. The boot script is expected to be located at the\n    path `releases/RELEASE_VSN/RELEASE_BOOT_SCRIPT.boot`. Defaults to `start`\n\n  * `RELEASE_BOOT_SCRIPT_CLEAN` - the name of the boot script used when\n    starting the release clean, without your application or its dependencies.\n    This script is used by commands such as `eval`, `rpc`, and `remote`.\n    The boot script is expected to be located at the path\n    `releases/RELEASE_VSN/RELEASE_BOOT_SCRIPT_CLEAN.boot`. Defaults\n    to `start_clean`","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Release"}
{"completion":"Umbrellas\n\nReleases are well integrated with umbrella projects, allowing you to\nrelease one or more subsets of your umbrella children. The only difference\nbetween performing a release in the umbrella project compared to a\nregular application is that umbrellas require you to explicitly list\nyour release and the starting point for each release. For example,\nimagine this umbrella applications:\n\n```text\nmy_app_umbrella/\n  apps/\n    my_app_core/\n    my_app_event_processing/\n    my_app_web/\n```\n\nwhere both `my_app_event_processing` and `my_app_web` depend on\n`my_app_core` but they do not depend on each other.\n\nInside your umbrella, you can define multiple releases:\n\n    releases: [\n      web_and_event_processing: [\n        applications: [\n          my_app_event_processing: :permanent,\n          my_app_web: :permanent\n        ]\n      ],\n\n      web_only: [\n        applications: [my_app_web: :permanent]\n      ],\n\n      event_processing_only: [\n        applications: [my_app_event_processing: :permanent]\n      ]\n    ]\n\nNote you don't need to define all applications in `:applications`,\nonly the entry points. Also remember that the recommended mode\nfor all applications in the system is `:permanent`.\n\nFinally, keep in mind it is not required for you to assemble the\nrelease from the umbrella root. You can also assemble the release\nfrom each child application individually. Doing it from the root,\nhowever, allows you to include two applications that do not depend\non each other as part of the same release.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Release"}
{"completion":"Hot Code Upgrades\n\nErlang and Elixir are sometimes known for the capability of upgrading\na node that is running in production without shutting down that node.\nHowever, this feature is not supported out of the box by Elixir releases.\n\nThe reason we don't provide hot code upgrades is because they are very\ncomplicated to perform in practice, as they require careful coding of\nyour processes and applications as well as extensive testing. Given most\nteams can use other techniques that are language agnostic to upgrade\ntheir systems, such as Blue/Green deployments, Canary deployments,\nRolling deployments, and others, hot upgrades are rarely a viable\noption. Let's understand why.\n\nIn a hot code upgrade, you want to update a node from version A to\nversion B. To do so, the first step is to write recipes for every application\nthat changed between those two releases, telling exactly how the application\nchanged between versions, those recipes are called `.appup` files.\nWhile some of the steps in building `.appup` files can be automated,\nnot all of them can. Furthermore, each process in the application needs\nto be explicitly coded with hot code upgrades in mind. Let's see an example.\nImagine your application has a counter process as a GenServer:\n\n    defmodule Counter do\n      use GenServer\n\n      def start_link(_) do\n        GenServer.start_link(__MODULE__, :ok, name: __MODULE__)\n      end\n\n      def bump do\n        GenServer.call(__MODULE__, :bump)\n      end\n\n      ## Callbacks\n\n      def init(:ok) do\n        {:ok, 0}\n      end\n\n      def handle_call(:bump, counter) do\n        {:reply, :ok, counter + 1}\n      end\n    end\n\nYou add this process as part of your supervision tree and ship version\n0.1.0 of your system. Now let's imagine that on version 0.2.0 you added\ntwo changes: instead of `bump/0`, that always increments the counter by\none, you introduce `bump/1` that passes the exact value to bump the\ncounter. You also change the state, because you want to store the maximum\nbump value:\n\n    defmodule Counter do\n      use GenServer\n\n      def start_link(_) do\n        GenServer.start_link(__MODULE__, :ok, name: __MODULE__)\n      end\n\n      def bump(by) do\n        GenServer.call(__MODULE__, {:bump, by})\n      end\n\n      ## Callbacks\n\n      def init(:ok) do\n        {:ok, {0, 0}}\n      end\n\n      def handle_call({:bump, by}, {counter, max}) do\n        {:reply, :ok, {counter + by, max(max, by)}}\n      end\n    end\n\nIf you were to perform a hot code upgrade in such an application, it would\ncrash, because in the initial version the state was just a counter\nbut in the new version the state is a tuple. Furthermore, you changed\nthe format of the `call` message from `:bump` to `{:bump, by}` and\nthe process may have both old and new messages temporarily mixed, so\nwe need to handle both. The final version would be:\n\n    defmodule Counter do\n      use GenServer\n\n      def start_link(_) do\n        GenServer.start_link(__MODULE__, :ok, name: __MODULE__)\n      end\n\n      def bump(by) do\n        GenServer.call(__MODULE__, {:bump, by})\n      end\n\n      ## Callbacks\n\n      def init(:ok) do\n        {:ok, {0, 0}}\n      end\n\n      def handle_call(:bump, {counter, max}) do\n        {:reply, :ok, {counter + 1, max(max, 1)}}\n      end\n\n      def handle_call({:bump, by}, {counter, max}) do\n        {:reply, :ok, {counter + by, max(max, by)}}\n      end\n\n      def code_change(_, counter, _) do\n        {:ok, {counter, 0}}\n      end\n    end\n\nNow you can proceed to list this process in the `.appup` file and\nhot code upgrade it. This is one of the many steps necessary\nto perform hot code upgrades and it must be taken into account by\nevery process and application being upgraded in the system.\nThe [`.appup` cookbook](https://www.erlang.org/doc/design_principles/appup_cookbook.html)\nprovides a good reference and more examples.\n\nOnce `.appup`s are created, the next step is to create a `.relup`\nfile with all instructions necessary to update the release itself.\nErlang documentation does provide a chapter on\n[Creating and upgrading a target system](https://www.erlang.org/doc/system_principles/create_target.html).\n[Learn You Some Erlang has a chapter on hot code upgrades](https://learnyousomeerlang.com/relups).\n\nOverall, there are many steps, complexities and assumptions made\nduring hot code upgrades, which is ultimately why they are not\nprovided by Elixir out of the box. However, hot code upgrades can\nstill be achieved by teams who desire to implement those steps\non top of `mix release` in their projects or as separate libraries.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Release"}
{"completion":"Command line options\n\n  * `--force` - forces recompilation\n  * `--no-archives-check` - does not check archive\n  * `--no-deps-check` - does not check dependencies\n  * `--no-elixir-version-check` - does not check Elixir version\n  * `--no-compile` - does not compile before assembling the release\n  * `--overwrite` - if there is an existing release version, overwrite it\n  * `--path` - the path of the release\n  * `--quiet` - does not write progress to the standard output\n  * `--version` - the version of the release","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Release"}
{"completion":"Generates sample files for releases.\n\n    $ mix release.init\n    * creating rel/vm.args.eex\n    * creating rel/remote.vm.args.eex\n    * creating rel/env.sh.eex\n    * creating rel/env.bat.eex","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Release.Init"}
{"completion":"Runs the current application.\n\n`mix run` starts the current application dependencies and the\napplication itself. The application will be compiled if it has\nnot been compiled yet or it is outdated.\n\n`mix run` may also run code in the application context through\nadditional options. For example, to run a script within the\ncurrent application, you may pass a filename as argument:\n\n    mix run my_app_script.exs arg1 arg2 arg3\n\nCode to be executed can also be passed inline with the `-e` option:\n\n    mix run -e \"DbUtils.delete_old_records()\" -- arg1 arg2 arg3\n\nIn both cases, the command-line arguments for the script or expression\nare available in `System.argv/0`. This mirror the command line interface\nin the `elixir` executable.\n\nFor starting long running systems, one typically passes the `--no-halt`\noption:\n\n    mix run --no-halt\n\nThe `--no-start` option can also be given and the current application,\nnor its dependencies will be started. Alternatively, you may use\n`mix eval` to evaluate a single expression without starting the current\napplication.\n\nIf you need to pass options to the Elixir executable at the same time\nyou use `mix run`, it can be done as follows:\n\n    elixir --sname hello -S mix run --no-halt\n\nThis task is automatically re-enabled, so it can be called multiple times\nwith different arguments.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Run"}
{"completion":"Command-line options\n\n  * `--eval`, `-e` - evaluates the given code\n  * `--require`, `-r` - executes the given pattern/file\n  * `--parallel`, `-p` - makes all requires parallel\n  * `--preload-modules` - preloads all modules defined in applications\n  * `--no-archives-check` - does not check archives\n  * `--no-compile` - does not compile even if files require compilation\n  * `--no-deps-check` - does not check dependencies\n  * `--no-elixir-version-check` - does not check the Elixir version from mix.exs\n  * `--no-halt` - does not halt the system after running the command\n  * `--no-mix-exs` - allows the command to run even if there is no mix.exs\n  * `--no-start` - does not start applications after compilation","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Run"}
{"completion":"Runs the tests for a project.\n\nThis task starts the current application, loads up\n`test/test_helper.exs` and then, requires all files matching the\n`test/**/*_test.exs` pattern in parallel.\n\nA list of files and/or directories can be given after the task\nname in order to select the files to run:\n\n    mix test test/some/particular/file_test.exs\n    mix test test/some/particular/dir\n\nTests in umbrella projects can be run from the root by specifying\nthe full suite path, including `apps/my_app/test`, in which case\nrecursive tests for other child apps will be skipped completely:\n\n    # To run all tests for my_app from the umbrella root\n    mix test apps/my_app/test\n\n    # To run a given test file on my_app from the umbrella root\n    mix test apps/my_app/test/some/particular/file_test.exs","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Test"}
{"completion":"Understanding test results\n\nWhen you run your test suite, it prints results as they run with\na summary at the end, as seen below:\n\n    $ mix test\n    ...\n\n      1) test greets the world (FooTest)\n         test/foo_test.exs:5\n         Assertion with == failed\n         code:  assert Foo.hello() == :world!\n         left:  :world\n         right: :world!\n         stacktrace:\n           test/foo_test.exs:6: (test)\n\n    ........\n\n    Finished in 0.05 seconds (0.00s async, 0.05s sync)\n    1 doctest, 11 tests, 1 failure\n\n    Randomized with seed 646219\n\nFor each test, the test suite will print a dot. Failed tests\nare printed immediately in the format described in the next\nsection.\n\nAfter all tests run, we print the suite summary. The first\nline contains the total time spent on the suite, followed\nby how much time was spent on async tests (defined with\n`use ExUnit.Case, async: true`) vs sync ones:\n\n    Finished in 0.05 seconds (0.00s async, 0.05s sync)\n\nDevelopers want to minimize the time spent on sync tests\nwhenever possible, as sync tests run serially and async\ntests run concurrently.\n\nFinally, how many tests we have run, how many of them\nfailed, how many were invalid, and so on.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Test"}
{"completion":"# Understanding test failures\n\nFirst, it contains the failure counter, followed by the test\nname and the module the test was defined:\n\n    1) test greets the world (FooTest)\n\nThe next line contains the exact location of the test in the\n`FILE:LINE` format:\n\n    test/foo_test.exs:5\n\nIf you want to re-run only this test, all you need to do is to\ncopy the line above and past it in front of `mix test`:\n\n    mix test test/foo_test.exs:5\n\nThen we show the error message, code snippet, and general information\nabout the failed test:\n\n    Assertion with == failed\n    code:  assert Foo.hello() == :world!\n    left:  :world\n    right: :world!\n\nIf your terminal supports coloring (see the  \"Coloring\" section below),\na diff is typically shown between `left` and `right` sides. Finally,\nwe print the stacktrace of the failure:\n\n    stacktrace:\n      test/foo_test.exs:6: (test)","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Test"}
{"completion":"Command line options\n\n  * `--all-warnings` - prints warnings even from files that do not need to be recompiled\n\n  * `--color` - enables color in the output\n\n  * `--cover` - runs coverage tool. See \"Coverage\" section below\n\n  * `--exclude` - excludes tests that match the filter\n\n  * `--exit-status` - use an alternate exit status to use when the test suite\n    fails (default is 2).\n\n  * `--export-coverage` - the name of the file to export coverage results to.\n    Only has an effect when used with `--cover`\n\n  * `--failed` - runs only tests that failed the last time they ran\n\n  * `--force` - forces compilation regardless of modification times\n\n  * `--formatter` - sets the formatter module that will print the results.\n    Defaults to ExUnit's built-in CLI formatter\n\n  * `--include` - includes tests that match the filter\n\n  * `--listen-on-stdin` - runs tests, and then listens on stdin. It will\n    re-run tests once a newline is received. See the \"File system watchers\"\n    section below\n\n  * `--max-cases` - sets the maximum number of tests running asynchronously. Only tests from\n    different modules run in parallel. Defaults to twice the number of cores\n\n  * `--max-failures` - the suite stops evaluating tests when this number of test\n    failures is reached. It runs all tests if omitted\n\n  * `--no-archives-check` - does not check archives\n\n  * `--no-color` - disables color in the output\n\n  * `--no-compile` - does not compile, even if files require compilation\n\n  * `--no-deps-check` - does not check dependencies\n\n  * `--no-elixir-version-check` - does not check the Elixir version from `mix.exs`\n\n  * `--no-start` - does not start applications after compilation\n\n  * `--only` - runs only tests that match the filter\n\n  * `--partitions` - sets the amount of partitions to split tests in. It must be\n    a number greater than zero. If set to one, it acts a no-op. If more than one,\n    then you must also set the `MIX_TEST_PARTITION` environment variable with the\n    partition to use in the current test run. See the \"Operating system process\n    partitioning\" section for more information\n\n  * `--preload-modules` - preloads all modules defined in applications\n\n  * `--profile-require` - profiles the time spent to require test files.\n    Used only for debugging. The test suite does not run.\n\n  * `--raise` - raises if the test suite failed\n\n  * `--seed` - seeds the random number generator used to randomize the order of tests;\n    `--seed 0` disables randomization so the tests in a single file will always be ran\n    in the same order they were defined in\n\n  * `--slowest` - prints timing information for the N slowest tests.\n    Automatically sets `--trace` and `--preload-modules`\n\n  * `--stale` - runs only tests which reference modules that changed since the\n    last time tests were ran with `--stale`. You can read more about this option\n    in the \"The --stale option\" section below\n\n  * `--timeout` - sets the timeout for the tests\n\n  * `--trace` - runs tests with detailed reporting. Automatically sets `--max-cases` to `1`.\n    Note that in trace mode test timeouts will be ignored as timeout is set to `:infinity`\n\n  * `--warnings-as-errors` - (since v1.12.0) treats warnings as errors and returns a non-zero\n    exit status. This option only applies to test files. To treat warnings as errors during\n    compilation and during tests, run:\n        MIX_ENV=test mix do compile --warnings-as-errors + test --warnings-as-errors","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Test"}
{"completion":"Configuration\n\nThese configurations can be set in the `def project` section of your `mix.exs`:\n\n  * `:test_coverage` - a set of options to be passed down to the coverage\n    mechanism. See the \"Coverage\" section for more information\n\n  * `:test_elixirc_options` - the compiler options to used when\n    loading/compiling test files. By default it disables the debug chunk\n    and docs chunk\n\n  * `:test_paths` - list of paths containing test files. Defaults to\n    `[\"test\"]` if the `test` directory exists; otherwise, it defaults to `[]`.\n    It is expected that all test paths contain a `test_helper.exs` file\n\n  * `:test_pattern` - a pattern to load test files. Defaults to `*_test.exs`\n\n  * `:warn_test_pattern` - a pattern to match potentially misnamed test files\n    and display a warning. Defaults to `*_test.ex`","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Test"}
{"completion":"Coloring\n\nColoring is enabled by default on most Unix terminals. They are also\navailable on Windows consoles from Windows 10, although it must be\nexplicitly enabled for the current user in the registry by running\nthe following command:\n\n    reg add HKCU\\Console /v VirtualTerminalLevel /t REG_DWORD /d 1\n\nAfter running the command above, you must restart your current console.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Test"}
{"completion":"Filters\n\nExUnit provides tags and filtering functionality that allow developers\nto select which tests to run. The most common functionality is to exclude\nsome particular tests from running by default in your test helper file:\n\n    # Exclude all external tests from running\n    ExUnit.configure(exclude: [external: true])\n\nThen, whenever desired, those tests could be included in the run via the\n`--include` option:\n\n    mix test --include external:true\n\nThe example above will run all tests that have the external option set to\n`true`. It is also possible to include all examples that have a given tag,\nregardless of its value:\n\n    mix test --include external\n\nNote that all tests are included by default, so unless they are excluded\nfirst (either in the test helper or via the `--exclude` option) the\n`--include` option has no effect.\n\nFor this reason, Mix also provides an `--only` option that excludes all\ntests and includes only the given ones:\n\n    mix test --only external\n\nWhich is similar to:\n\n    mix test --include external --exclude test\n\nIt differs in that the test suite will fail if no tests are executed when the `--only` option is used.\n\nIn case a single file is being tested, it is possible to pass one or more specific\nline numbers to run only those given tests:\n\n    mix test test/some/particular/file_test.exs:12\n\nWhich is equivalent to:\n\n    mix test --exclude test --include line:12 test/some/particular/file_test.exs\n\nOr:\n\n    mix test test/some/particular/file_test.exs:12:24\n\nWhich is equivalent to:\n\n    mix test --exclude test --include line:12 --include line:24 test/some/particular/file_test.exs\n\nIf a given line starts a `describe` block, that line filter runs all tests in it.\nOtherwise, it runs the closest test on or before the given line number.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Test"}
{"completion":"Coverage\n\nThe `:test_coverage` configures the coverage tool and reports generated\nby the `--cover` flag. It accepts the following options:\n\n  * `:output` - the output directory for cover results. Defaults to `\"cover\"`.\n\n  * `:tool` - a module specifying the coverage tool to use.\n\n  * `:summary` - at the end of each coverage run, a summary of each\n    module is printed, with results in red or green depending on whether\n    the percentage is below or above a given threshold. The task will\n    exit with status of 1 if the total coverage is below the threshold.\n    The `:summary` option allows you to customize the summary generation\n    and defaults to `[threshold: 90]`, but it may be set to `false` to\n    disable such reports.\n\n  * `:export` - a filename to export results to instead of generating\n    the coverage result on the fly. The `.coverdata` extension is\n    automatically added to the given file. This option is automatically\n    set via the `--export-coverage` option or when using process partitioning.\n    See `mix test.coverage` to compile a report from multiple exports.\n\n  * `:ignore_modules` - modules to ignore from generating reports and\n    in summaries. It is a list of module names as atoms and regular\n    expressions that are matched against the module names.\n\n  * `:local_only` - by default coverage only tracks local calls,\n    set this option to false if you plan to run coverage across nodes.\n\nBy default, a wrapper around OTP's `cover` is used as the default coverage\ntool. You can learn more about how it works in the docs for\n`mix test.coverage`. Your tool of choice can be given as follows:\n\n    def project() do\n      [\n        ...\n        test_coverage: [tool: CoverModule]\n        ...\n      ]\n    end\n\n`CoverModule` can be any module that exports `start/2`, receiving the\ncompilation path and the `test_coverage` options as arguments.\nIt must return either `nil` or an anonymous function of zero arity that\nwill run after the test suite is done.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Test"}
{"completion":"Operating system process partitioning\n\nWhile ExUnit supports the ability to run tests concurrently within the same\nElixir instance, it is not always possible to run all tests concurrently. For\nexample, some tests may rely on global resources.\n\nFor this reason, `mix test` supports partitioning the test files across\ndifferent Elixir instances. This is done by setting the `--partitions` option\nto an integer, with the number of partitions, and setting the `MIX_TEST_PARTITION`\nenvironment variable to control which test partition that particular instance\nis running. This can also be useful if you want to distribute testing across\nmultiple machines.\n\nFor example, to split a test suite into 4 partitions and run them, you would\nuse the following commands:\n\n    MIX_TEST_PARTITION=1 mix test --partitions 4\n    MIX_TEST_PARTITION=2 mix test --partitions 4\n    MIX_TEST_PARTITION=3 mix test --partitions 4\n    MIX_TEST_PARTITION=4 mix test --partitions 4\n\nThe test files are sorted upfront in a round-robin fashion. Note the partition\nitself is given as an environment variable so it can be accessed in config files\nand test scripts. For example, it can be used to setup a different database instance\nper partition in `config/test.exs`.\n\nIf partitioning is enabled and `--cover` is used, no cover reports are generated,\nas they only contain a subset of the coverage data. Instead, the coverage data\nis exported to files such as `cover/MIX_TEST_PARTITION.coverdata`. Once you have\nthe results of all partitions inside `cover/`, you can run `mix test.coverage` to\nget the unified report.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Test"}
{"completion":"The --stale option\n\nThe `--stale` command line option attempts to run only the test files which\nreference modules that have changed since the last time you ran this task with\n`--stale`.\n\nThe first time this task is run with `--stale`, all tests are run and a manifest\nis generated. On subsequent runs, a test file is marked \"stale\" if any modules it\nreferences (and any modules those modules reference, recursively) were modified\nsince the last run with `--stale`. A test file is also marked \"stale\" if it has\nbeen changed since the last run with `--stale`.\n\nThe `--stale` option is extremely useful for software iteration, allowing you to\nrun only the relevant tests as you perform changes to the codebase.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Test"}
{"completion":"File-system watchers\n\nYou can integrate `mix test` with filesystem watchers through the command line\nvia the `--listen-on-stdin` option. For example, you can use [fswatch](https://github.com/emcrisostomo/fswatch)\nor similar to emit newlines whenever there is a change, which will cause your test\nsuite to re-run:\n\n    fswatch lib test | mix test --listen-on-stdin\n\nThis can be combined with the `--stale` option to re-run only the test files that\nhave changed as well as the tests that have gone stale due to changes in `lib`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Test"}
{"completion":"Aborting the suite\n\nIt is possible to abort the test suite with `Ctrl+\\ `, which sends a SIGQUIT\nsignal to the Erlang VM. ExUnit will intercept this signal to show all tests\nthat have been aborted and print the results collected so far.\n\nThis can be useful in case the suite gets stuck and you don't want to wait\nuntil the timeout times passes (which defaults to 30 seconds).","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Test"}
{"completion":"Build reports from exported test coverage.\n\nIn this moduledoc, we will describe how the default test\ncoverage works in Elixir and also explore how it is capable\nof exporting coverage results to group reports from multiple\ntest runs.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Test.Coverage"}
{"completion":"Line coverage\n\nElixir uses Erlang's [`:cover`](https://www.erlang.org/doc/man/cover.html)\nfor its default test coverage. Erlang coverage is done by tracking\n*executable lines of code*. This implies blank lines, code comments,\nfunction signatures, and patterns are not necessarily executable and\ntherefore won't be tracked in coverage reports. Code in macros are\nalso often executed at compilation time, and therefore may not be covered.\nSimilarly, Elixir AST literals, such as atoms, are not executable either.\n\nLet's see an example:\n\n    if some_condition? do\n      do_this()\n    else\n      do_that()\n    end\n\nIn the example above, if your tests exercise both `some_condition? == true`\nand `some_condition? == false`, all branches will be covered, as they all\nhave executable code. However, the following code\n\n    if some_condition? do\n      do_this()\n    else\n      :default\n    end\n\nwon't ever mark the `:default` branch as covered, as there is no executable\ncode in the `else` branch. Note, however, this issue does not happen on `case`\nor `cond`, as Elixir is able to mark the clause operator `->` as executable in\nsuch corner cases:\n\n    case some_condition? do\n      true ->\n        do_this()\n\n      false ->\n        :default\n    end\n\nIf the code above is tested with both conditions, you should see entries\nin both branches marked as covered.\n\nFinally, it is worth discussing that line coverage by itself has its own\nlimitations. For example, take the following code:\n\n    do_this() || do_that()\n\nLine coverage is not capable of expressing that both `do_this()` and\n`do_that()` have been executed, since as soon as `do_this()` is executed,\nthe whole line is covered. Other techniques, such as branch coverage,\ncan help spot those cases, but they are not currently supported by the\ndefault coverage tool.\n\nOverall, code coverage can be a great tool for finding flaws in our\ncode (such as functions that haven't been covered) but it can also lead\nteams into a false sense of security since 100% coverage never means all\ndifferent executions flows have been asserted, even with the most advanced\ncoverage techniques. It is up to you and your team to specify how much\nemphasis you want to place on it.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Test.Coverage"}
{"completion":"Exporting coverage\n\nThis task can be used when you need to group the coverage\nacross multiple test runs. Let's see some examples.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Test.Coverage"}
{"completion":"# Example: aggregating partitioned runs\n\nIf you partition your tests across multiple runs,\nyou can unify the report as shown below:\n\n    MIX_TEST_PARTITION=1 mix test --partitions 2 --cover\n    MIX_TEST_PARTITION=2 mix test --partitions 2 --cover\n    mix test.coverage\n\nThis works because the `--partitions` option\nautomatically exports the coverage results.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Test.Coverage"}
{"completion":"# Example: aggregating coverage reports from all umbrella children\n\nIf you run `mix test.coverage` inside an umbrella,\nit will automatically gather exported cover results\nfrom all umbrella children - as long as the coverage\nresults have been exported, like this:\n\n    # from the umbrella root\n    mix test --cover --export-coverage default\n    mix test.coverage\n\nOf course, if you want to actually partition the tests,\nyou can also do:\n\n    # from the umbrella root\n    MIX_TEST_PARTITION=1 mix test --partitions 2 --cover\n    MIX_TEST_PARTITION=2 mix test --partitions 2 --cover\n    mix test.coverage\n\nOn the other hand, if you want partitioned tests but\nper-app reports, you can do:\n\n    # from the umbrella root\n    MIX_TEST_PARTITION=1 mix test --partitions 2 --cover\n    MIX_TEST_PARTITION=2 mix test --partitions 2 --cover\n    mix cmd mix test.coverage\n\nWhen running `test.coverage` from the umbrella root, it\nwill use the `:test_coverage` configuration from the umbrella\nroot.\n\nFinally, note the coverage itself is not measured across\nthe projects themselves. For example, if project B depends\non A, and if there is code in A that is only executed from\nproject B, those lines will not be marked as covered, which\nis important, as those projects should be developed and tested\nin isolation.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Test.Coverage"}
{"completion":"# Other scenarios\n\nThere may be other scenarios where you want to export coverage.\nFor example, you may have broken your test suite into two, one\nfor unit tests and another for integration tests. In such scenarios,\nyou can explicitly use the `--export-coverage` command line option,\nor the `:export` option under `:test_coverage` in your `mix.exs` file.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Test.Coverage"}
{"completion":"Annotates the current project will recompile.","prompt":"Can you write a docstring for the following Elixir function? run(_)"}
{"completion":"Returns a list of information of all the runtime function calls in the project.\n\nEach item in the list is a map with the following keys:\n\n  * `:callee` - a tuple containing the module, function, and arity of the call\n  * `:line` - an integer representing the line where the function is called\n  * `:file` - a binary representing the file where the function is called\n  * `:caller_module` - the module where the function is called\n\nThis function returns an empty list when used at the root of an umbrella\nproject because there is no compile manifest to extract the function call\ninformation from. To get the function calls of each child in an umbrella,\nexecute the function at the root of each individual application.","prompt":"Can you write a docstring for the following Elixir function? calls(opts \\\\ [])"}
{"completion":"Prints cross reference information between modules.\n\nThe `xref` task expects a mode as first argument:\n\n    $ mix xref MODE\n\nAll available modes are discussed below.\n\nThis task is automatically re-enabled, so you can print\ninformation multiple times in the same Mix invocation.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Xref"}
{"completion":"mix xref callers MODULE\n\nPrints all callers of the given `MODULE`. Example:\n\n    $ mix xref callers MyMod","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Xref"}
{"completion":"mix xref trace FILE\n\nCompiles the given file listing all dependencies within the same app.\nIt includes the type and line for each one. Example:\n\n    $ mix xref trace lib/my_app/router.ex\n\nThe `--label` option may be given to keep only certain traces\n(compile, runtime or export):\n\n    $ mix xref trace lib/my_app/router.ex --label compile\n\nIf you have an umbrella application, we also recommend using the\n`--include-siblings` flag to see the dependencies on other\numbrella applications.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Xref"}
{"completion":"# Example\n\nImagine the given file lib/b.ex:\n\n    defmodule B do\n      import A\n      A.macro()\n      macro()\n      A.fun()\n      fun()\n      def calls_macro, do: A.macro()\n      def calls_fun, do: A.fun()\n      def calls_struct, do: %A{}\n    end\n\n`mix xref trace` will print:\n\n    lib/b.ex:2: require A (export)\n    lib/b.ex:3: call A.macro/0 (compile)\n    lib/b.ex:4: import A.macro/0 (compile)\n    lib/b.ex:5: call A.fun/0 (compile)\n    lib/b.ex:6: call A.fun/0 (compile)\n    lib/b.ex:6: import A.fun/0 (compile)\n    lib/b.ex:7: call A.macro/0 (compile)\n    lib/b.ex:8: call A.fun/0 (runtime)\n    lib/b.ex:9: struct A (export)","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Xref"}
{"completion":"mix xref graph\n\nPrints a file dependency graph where an edge from `A` to `B` indicates\nthat `A` (source) depends on `B` (sink).\n\n    $ mix xref graph --format stats\n\nThe following options are accepted:\n\n  * `--exclude` - path to exclude. Can be repeated to exclude multiple paths.\n\n  * `--label` - only shows relationships with the given label.\n    The labels are \"compile\", \"export\" and \"runtime\". By default,\n    the `--label` option simply filters the printed graph to show\n    only relationships with the given label. You can pass `--only-direct`\n    to trim the graph to only the nodes that have the direct\n    relationship given by label. There is also a special label\n    called \"compile-connected\" that keeps only compile-time files\n    with at least one transitive dependency. See \"Dependencies types\"\n    section below.\n\n  * `--group` - provide comma-separated paths to consider as a group. Dependencies\n    from and into multiple files of the group are considered a single dependency.\n    Dependencies between the group elements are ignored. This is useful when you\n    are computing compile and compile-connected dependencies and you want a\n    series of files to be treated as one. The group is printed using the first path,\n    with a `+` suffix. Can be repeated to create multiple groups.\n\n  * `--only-direct` - keeps only files with the direct relationship\n    given by `--label`\n\n  * `--only-nodes` - only shows the node names (no edges).\n    Generally useful with the `--sink` flag\n\n  * `--source` - displays all files that the given source file\n    references (directly or indirectly). Can be repeated to display\n    references from multiple sources.\n\n  * `--sink` - displays all files that reference the given file\n    (directly or indirectly). Can be repeated.\n\n  * `--min-cycle-size` - controls the minimum cycle size on formats\n    like `stats` and `cycles`\n\n  * `--format` - can be set to one of:\n\n    * `pretty` - prints the graph to the terminal using Unicode characters.\n      Each prints each file followed by the files it depends on. This is the\n      default except on Windows;\n\n    * `plain` - the same as pretty except ASCII characters are used instead of\n      Unicode characters. This is the default on Windows;\n\n    * `stats` - prints general statistics about the graph;\n\n    * `cycles` - prints all cycles in the graph;\n\n    * `dot` - produces a DOT graph description in `xref_graph.dot` in the\n      current directory. Warning: this will override any previously generated file\n\nThe `--source` and `--sink` options are particularly useful when trying to understand\nhow the modules in a particular file interact with the whole system. You can combine\nthose options with `--label` and `--only-nodes` to get all files that exhibit a certain\nproperty, for example:\n\n    # To show all compile-time relationships\n    mix xref graph --label compile\n\n    # To get the tree that depend on lib/foo.ex at compile time\n    mix xref graph --label compile --sink lib/foo.ex\n\n    # To get all files that depend on lib/foo.ex at compile time\n    mix xref graph --label compile --sink lib/foo.ex --only-nodes\n\n    # To get all paths between two files\n    mix xref graph --source lib/foo.ex --sink lib/bar.ex\n\n    # To show general statistics about the graph\n    mix xref graph --format stats","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Xref"}
{"completion":"# Understanding the printed graph\n\nWhen `mix xref graph` runs, it will print a tree of the following\nformat. Imagine the following code:\n\n    # lib/a.ex\n    defmodule A do\n      IO.puts B.hello()\n    end\n\n    # lib/b.ex\n    defmodule B do\n      def hello, do: C.world()\n    end\n\n    # lib/c.ex\n    defmodule C do\n      def world, do: \"hello world\"\n    end\n\nIt will print:\n\n    $ mix xref graph\n    lib/a.ex\n     lib/b.ex (compile)\n    lib/b.ex\n     lib/c.ex\n    lib/c.ex\n\nThis tree means that `lib/a.ex` depends on `lib/b.ex` at compile\ntime. And `lib/b.ex` depends on `lib/c.ex` at runtime. This is often\nproblematic because if `lib/c.ex` changes, `lib/a.ex` also has to\nrecompile due to this indirect compile time dependency. When you pass\n`--label compile`, the graph shows only the compile-time dependencies:\n\n    $ mix xref graph --label compile\n    lib/a.ex\n     lib/b.ex (compile)\n\nThe `--label compile` flag removes all non-compile dependencies. However,\nthis can be misleading because having direct compile time dependencies is\nnot necessarily an issue. The biggest concern, as mentioned above, are the\ntransitive compile time dependencies. You can get all compile time\ndependencies that cause transitive compile time dependencies by using\n`--label compile-connected`:\n\n    $ mix xref graph --label compile-connected\n    lib/a.ex\n     lib/b.ex (compile)\n\nThe above says `lib/a.ex` depends on `lib/b.ex` and that causes transitive\ncompile time dependencies - as we know, `lib/a.ex` also depends on `lib/c.ex`.\nWe can retrieve those transitive dependencies by passing `lib/b.ex` as\n`--source` to `mix xref graph`:\n\n    $ mix xref graph --source lib/b.ex\n    lib/b.ex\n     lib/c.ex\n\nSimilarly, you can use the `--label compile` and the `--sink` flag to find\nall compile time dependencies that will recompile once the sink changes:\n\n    $ mix xref graph --label compile --sink lib/c.ex\n    lib/a.ex\n     lib/b.ex (compile)","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Xref"}
{"completion":"# Dependencies types\n\nElixir tracks three types of dependencies between modules: compile,\nexports, and runtime. If a module has a compile time dependency on\nanother module, the caller module has to be recompiled whenever the\ncallee changes. Compile-time dependencies are typically added when\nusing macros or when invoking functions in the module body (outside\nof functions). You can list all dependencies in a file by running\n`mix xref trace path/to/file.ex`.\n\nExports dependencies are compile time dependencies on the module API,\nnamely structs and its public definitions. For example, if you import\na module but only use its functions, it is an export dependency. If\nyou use a struct, it is an export dependency too. Export dependencies\nare only recompiled if the module API changes. Note, however, that compile\ntime dependencies have higher precedence than exports. Therefore if\nyou import a module and use its macros, it is a compile time dependency.\n\nRuntime dependencies are added whenever you invoke another module\ninside a function. Modules with runtime dependencies do not have\nto be compiled when the callee changes, unless there is a transitive\ncompile or an outdated export time dependency between them. The option\n`--label compile-connected` can be used to find the first case.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Xref"}
{"completion":"Shared options\n\nThose options are shared across all modes:\n\n  * `--fail-above` - generates a failure if the relevant metric is above the\n    given threshold. Applies to all modes except `mix xref graph --format stats`.\n\n  * `--include-siblings` - includes dependencies that have `:in_umbrella` set\n    to true in the current project in the reports. This can be used to find\n    callers or to analyze graphs between projects\n\n  * `--no-compile` - does not compile even if files require compilation\n\n  * `--no-deps-check` - does not check dependencies\n\n  * `--no-archives-check` - does not check archives\n\n  * `--no-elixir-version-check` - does not check the Elixir version from mix.exs","prompt":"Can you write a docstring for the following Elixir function? Elixir.Mix.Tasks.Xref"}
{"completion":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","prompt":"Can you write a docstring for the following Elixir function? child_spec(arg)"}
{"completion":"Takes a `command` name and attempts to load a module\nwith the command name converted to a module name\nin the given `at` scope.\n\nReturns `{:module, module}` in case a module\nexists and is loaded, `{:error, reason}` otherwise.\n\n## Examples\n\n    iex> Mix.Utils.command_to_module(\"compile\", Mix.Tasks)\n    {:module, Mix.Tasks.Compile}","prompt":"Can you write a docstring for the following Elixir function? command_to_module(command, at \\\\ Elixir)"}
{"completion":"Takes a command and converts it to the module name format.\n\n## Examples\n\n    iex> Mix.Utils.command_to_module_name(\"compile.elixir\")\n    \"Compile.Elixir\"","prompt":"Can you write a docstring for the following Elixir function? command_to_module_name(command)"}
{"completion":"Prints n files are being compiled with the given extension.","prompt":"Can you write a docstring for the following Elixir function? compiling_n(n, ext)"}
{"completion":"Extracts files from a list of paths.\n\n`exts_or_pattern` may be a list of extensions or a\n`Path.wildcard/1` pattern.\n\nIf the path in `paths` is a file, it is included in\nthe return result. If it is a directory, it is searched\nrecursively for files with the given extensions or matching\nthe given patterns.","prompt":"Can you write a docstring for the following Elixir function? extract_files(paths, exts_or_pattern)"}
{"completion":"Extracts all stale `sources` compared to the given `targets`.","prompt":"Can you write a docstring for the following Elixir function? extract_stale(sources, targets)"}
{"completion":"Returns the date the given path was last modified in posix time.\n\nIf the path does not exist, it returns the Unix epoch\n(1970-01-01 00:00:00).","prompt":"Can you write a docstring for the following Elixir function? last_modified(path)"}
{"completion":"Returns the date the given path was last modified in posix time\nand the size.\n\nIf the path does not exist, it returns the Unix epoch\n(1970-01-01 00:00:00).","prompt":"Can you write a docstring for the following Elixir function? last_modified_and_size(path)"}
{"completion":"Gets possible location of Mix cache.\n\nPossible locations:\n\n * `XDG_CACHE_HOME/mix` (if `MIX_XDG` is set)\n * `:filename.basedir(:user_cache, \"mix\")`","prompt":"Can you write a docstring for the following Elixir function? mix_cache()"}
{"completion":"Gets possible location of global Mix configuration.\n\nPossible locations:\n\n   * `MIX_HOME`\n   * `XDG_CONFIG_HOME/mix` (if `MIX_XDG` is set)\n   * `~/.mix`","prompt":"Can you write a docstring for the following Elixir function? mix_config()"}
{"completion":"Gets the Mix home.\n\nIt uses the the locations `MIX_HOME`, `XDG_DATA_HOME/mix`,\n`~/.mix` with decreasing priority.\n\nDevelopers should only store entries in the\n`MIX_HOME` directory which are guaranteed to\nwork across multiple Elixir versions, as it is\nnot recommended to swap the `MIX_HOME` directory\nas configuration and other important data may be\nstored there.","prompt":"Can you write a docstring for the following Elixir function? mix_home()"}
{"completion":"Takes a module and converts it to a command.\n\nThe nesting argument can be given in order to remove\nthe nesting of a module.\n\n## Examples\n\n    iex> Mix.Utils.module_name_to_command(Mix.Tasks.Compile, 2)\n    \"compile\"\n\n    iex> Mix.Utils.module_name_to_command(\"Mix.Tasks.Compile.Elixir\", 2)\n    \"compile.elixir\"","prompt":"Can you write a docstring for the following Elixir function? module_name_to_command(module, nesting \\\\ 0)"}
{"completion":"Parses a string into module, function and arity.\n\nIt returns `{:ok, mfa_list}`, where a `mfa_list` is\n`[module, function, arity]`, `[module, function]` or `[module]`,\nor the atom `:error`.\n\n    iex> Mix.Utils.parse_mfa(\"Foo.bar/1\")\n    {:ok, [Foo, :bar, 1]}\n    iex> Mix.Utils.parse_mfa(\":foo.bar/1\")\n    {:ok, [:foo, :bar, 1]}\n    iex> Mix.Utils.parse_mfa(\":foo.bar\")\n    {:ok, [:foo, :bar]}\n    iex> Mix.Utils.parse_mfa(\":foo\")\n    {:ok, [:foo]}\n    iex> Mix.Utils.parse_mfa(\"Foo\")\n    {:ok, [Foo]}\n\n    iex> Mix.Utils.parse_mfa(\"Foo.\")\n    :error\n    iex> Mix.Utils.parse_mfa(\"Foo.bar.baz\")\n    :error\n    iex> Mix.Utils.parse_mfa(\"Foo.bar/2/2\")\n    :error","prompt":"Can you write a docstring for the following Elixir function? parse_mfa(mfa)"}
{"completion":"Prints the given tree according to the callback.\n\nThe callback will be invoked for each node and it\nmust return a `{printed, children}` tuple.","prompt":"Can you write a docstring for the following Elixir function? print_tree(nodes, callback, opts \\\\ [])"}
{"completion":"Opens and reads content from either a URL or a local file system path.\n\nReturns the contents as a `{:ok, binary}`, `:badpath` for invalid\npaths or `{:local, message}` for local errors and `{:remote, message}`\nfor remote ones.\n\n## Options\n\n  * `:sha512` - checks against the given SHA-512 checksum. Returns\n    `{:checksum, message}` in case it fails. This option is required\n    for URLs unless the `:unsafe_uri` is given (WHICH IS NOT RECOMMENDED\n    unless another security mechanism is in place, such as private keys)\n\n  * `:timeout` - times out the request after the given milliseconds.\n    Returns `{:remote, timeout_message}` if it fails. Defaults to 60\n    seconds","prompt":"Can you write a docstring for the following Elixir function? read_path(path, opts \\\\ [])"}
{"completion":"Returns `true` if any of the `sources` are stale\ncompared to the given `targets`.","prompt":"Can you write a docstring for the following Elixir function? stale?(sources, targets)"}
{"completion":"Symlinks directory `source` to `target` or copies it recursively\nin case symlink fails.\n\nIn case of conflicts, it copies files only if they have been\nrecently touched.\n\nExpects source and target to be absolute paths as it generates\na relative symlink.","prompt":"Can you write a docstring for the following Elixir function? symlink_or_copy(source, target)"}
{"completion":"Symlinks or copy with the option to force a hard copy.\nSee `symlink_or_copy/2`.","prompt":"Can you write a docstring for the following Elixir function? symlink_or_copy(hard_copy?, source, target)"}
{"completion":"Outputs the given tree according to the callback as a DOT graph.\n\nThe callback will be invoked for each node and it\nmust return a `{printed, children}` tuple.","prompt":"Can you write a docstring for the following Elixir function? write_dot_graph!(path, title, nodes, callback, opts \\\\ [])"}
{"completion":"Returns a function that accesses all the elements in a list.\n\nThe returned function is typically passed as an accessor to `Kernel.get_in/2`,\n`Kernel.get_and_update_in/3`, and friends.\n\n## Examples\n\n    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n    iex> get_in(list, [Access.all(), :name])\n    [\"john\", \"mary\"]\n    iex> get_and_update_in(list, [Access.all(), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {[\"john\", \"mary\"], [%{name: \"JOHN\"}, %{name: \"MARY\"}]}\n    iex> pop_in(list, [Access.all(), :name])\n    {[\"john\", \"mary\"], [%{}, %{}]}\n\nHere is an example that traverses the list dropping even\nnumbers and multiplying odd numbers by 2:\n\n    iex> require Integer\n    iex> get_and_update_in([1, 2, 3, 4, 5], [Access.all()], fn num ->\n    ...>   if Integer.is_even(num), do: :pop, else: {num, num * 2}\n    ...> end)\n    {[1, 2, 3, 4, 5], [2, 6, 10]}\n\nAn error is raised if the accessed structure is not a list:\n\n    iex> get_in(%{}, [Access.all()])\n    ** (RuntimeError) Access.all/0 expected a list, got: %{}","prompt":"Can you write a docstring for the following Elixir function? all()"}
{"completion":"Returns a function that accesses the element at `index` (zero based) of a list.\n\nThe returned function is typically passed as an accessor to `Kernel.get_in/2`,\n`Kernel.get_and_update_in/3`, and friends.\n\n## Examples\n\n    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n    iex> get_in(list, [Access.at(1), :name])\n    \"mary\"\n    iex> get_in(list, [Access.at(-1), :name])\n    \"mary\"\n    iex> get_and_update_in(list, [Access.at(0), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {\"john\", [%{name: \"JOHN\"}, %{name: \"mary\"}]}\n    iex> get_and_update_in(list, [Access.at(-1), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {\"mary\", [%{name: \"john\"}, %{name: \"MARY\"}]}\n\n`at/1` can also be used to pop elements out of a list or\na key inside of a list:\n\n    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n    iex> pop_in(list, [Access.at(0)])\n    {%{name: \"john\"}, [%{name: \"mary\"}]}\n    iex> pop_in(list, [Access.at(0), :name])\n    {\"john\", [%{}, %{name: \"mary\"}]}\n\nWhen the index is out of bounds, `nil` is returned and the update function is never called:\n\n    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n    iex> get_in(list, [Access.at(10), :name])\n    nil\n    iex> get_and_update_in(list, [Access.at(10), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {nil, [%{name: \"john\"}, %{name: \"mary\"}]}\n\nAn error is raised if the accessed structure is not a list:\n\n    iex> get_in(%{}, [Access.at(1)])\n    ** (RuntimeError) Access.at/1 expected a list, got: %{}","prompt":"Can you write a docstring for the following Elixir function? at(index)"}
{"completion":"Same as `at/1` except that it raises `Enum.OutOfBoundsError`\nif the given index is out of bounds.\n\n## Examples\n\n    iex> get_in([:a, :b, :c], [Access.at!(2)])\n    :c\n    iex> get_in([:a, :b, :c], [Access.at!(3)])\n    ** (Enum.OutOfBoundsError) out of bounds error","prompt":"Can you write a docstring for the following Elixir function? at!(index)"}
{"completion":"Returns a function that accesses the element at the given index in a tuple.\n\nThe returned function is typically passed as an accessor to `Kernel.get_in/2`,\n`Kernel.get_and_update_in/3`, and friends.\n\nThe returned function raises if `index` is out of bounds.\n\nNote that popping elements out of tuples is not possible and raises an\nerror.\n\n## Examples\n\n    iex> map = %{user: {\"john\", 27}}\n    iex> get_in(map, [:user, Access.elem(0)])\n    \"john\"\n    iex> get_and_update_in(map, [:user, Access.elem(0)], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {\"john\", %{user: {\"JOHN\", 27}}}\n    iex> pop_in(map, [:user, Access.elem(0)])\n    ** (RuntimeError) cannot pop data from a tuple\n\nAn error is raised if the accessed structure is not a tuple:\n\n    iex> get_in(%{}, [Access.elem(0)])\n    ** (RuntimeError) Access.elem/1 expected a tuple, got: %{}","prompt":"Can you write a docstring for the following Elixir function? elem(index)"}
{"completion":"Fetches the value for the given key in a container (a map, keyword\nlist, or struct that implements the `Access` behaviour).\n\nReturns `{:ok, value}` where `value` is the value under `key` if there is such\na key, or `:error` if `key` is not found.\n\n## Examples\n\n    iex> Access.fetch(%{name: \"meg\", age: 26}, :name)\n    {:ok, \"meg\"}\n\n    iex> Access.fetch([ordered: true, on_timeout: :exit], :timeout)\n    :error","prompt":"Can you write a docstring for the following Elixir function? fetch(container, key)"}
{"completion":"Same as `fetch/2` but returns the value directly,\nor raises a `KeyError` exception if `key` is not found.\n\n## Examples\n\n    iex> Access.fetch!(%{name: \"meg\", age: 26}, :name)\n    \"meg\"","prompt":"Can you write a docstring for the following Elixir function? fetch!(container, key)"}
{"completion":"Returns a function that accesses all elements of a list that match the provided predicate.\n\nThe returned function is typically passed as an accessor to `Kernel.get_in/2`,\n`Kernel.get_and_update_in/3`, and friends.\n\n## Examples\n\n    iex> list = [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}]\n    iex> get_in(list, [Access.filter(&(&1.salary > 20)), :name])\n    [\"francine\"]\n    iex> get_and_update_in(list, [Access.filter(&(&1.salary <= 20)), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {[\"john\"], [%{name: \"JOHN\", salary: 10}, %{name: \"francine\", salary: 30}]}\n\n`filter/1` can also be used to pop elements out of a list or\na key inside of a list:\n\n    iex> list = [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}]\n    iex> pop_in(list, [Access.filter(&(&1.salary >= 20))])\n    {[%{name: \"francine\", salary: 30}], [%{name: \"john\", salary: 10}]}\n    iex> pop_in(list, [Access.filter(&(&1.salary >= 20)), :name])\n    {[\"francine\"], [%{name: \"john\", salary: 10}, %{salary: 30}]}\n\nWhen no match is found, an empty list is returned and the update function is never called\n\n    iex> list = [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}]\n    iex> get_in(list, [Access.filter(&(&1.salary >= 50)), :name])\n    []\n    iex> get_and_update_in(list, [Access.filter(&(&1.salary >= 50)), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {[], [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}]}\n\nAn error is raised if the predicate is not a function or is of the incorrect arity:\n\n    iex> get_in([], [Access.filter(5)])\n    ** (FunctionClauseError) no function clause matching in Access.filter/1\n\nAn error is raised if the accessed structure is not a list:\n\n    iex> get_in(%{}, [Access.filter(fn a -> a == 10 end)])\n    ** (RuntimeError) Access.filter/1 expected a list, got: %{}","prompt":"Can you write a docstring for the following Elixir function? filter(func)"}
{"completion":"Gets the value for the given key in a container (a map, keyword\nlist, or struct that implements the `Access` behaviour).\n\nReturns the value under `key` if there is such a key, or `default` if `key` is\nnot found.\n\n## Examples\n\n    iex> Access.get(%{name: \"john\"}, :name, \"default name\")\n    \"john\"\n    iex> Access.get(%{name: \"john\"}, :age, 25)\n    25\n\n    iex> Access.get([ordered: true], :timeout)\n    nil","prompt":"Can you write a docstring for the following Elixir function? get(container, key, default \\\\ nil)"}
{"completion":"Gets and updates the given key in a `container` (a map, a keyword list,\na struct that implements the `Access` behaviour).\n\nThe `fun` argument receives the value of `key` (or `nil` if `key` is not\npresent in `container`) and must return a two-element tuple `{current_value, new_value}`:\nthe \"get\" value `current_value` (the retrieved value, which can be operated on before\nbeing returned) and the new value to be stored under `key` (`new_value`).\n`fun` may also return `:pop`, which means the current value\nshould be removed from the container and returned.\n\nThe returned value is a two-element tuple with the \"get\" value returned by\n`fun` and a new container with the updated value under `key`.\n\n## Examples\n\n    iex> Access.get_and_update([a: 1], :a, fn current_value ->\n    ...>   {current_value, current_value + 1}\n    ...> end)\n    {1, [a: 2]}","prompt":"Can you write a docstring for the following Elixir function? get_and_update(container, key, fun)"}
{"completion":"Returns a function that accesses the given key in a map/struct.\n\nThe returned function is typically passed as an accessor to `Kernel.get_in/2`,\n`Kernel.get_and_update_in/3`, and friends.\n\nThe returned function uses the default value if the key does not exist.\nThis can be used to specify defaults and safely traverse missing keys:\n\n    iex> get_in(%{}, [Access.key(:user, %{}), Access.key(:name, \"meg\")])\n    \"meg\"\n\nSuch is also useful when using update functions, allowing us to introduce\nvalues as we traverse the data structure for updates:\n\n    iex> put_in(%{}, [Access.key(:user, %{}), Access.key(:name)], \"Mary\")\n    %{user: %{name: \"Mary\"}}\n\n## Examples\n\n    iex> map = %{user: %{name: \"john\"}}\n    iex> get_in(map, [Access.key(:unknown, %{}), Access.key(:name, \"john\")])\n    \"john\"\n    iex> get_and_update_in(map, [Access.key(:user), Access.key(:name)], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {\"john\", %{user: %{name: \"JOHN\"}}}\n    iex> pop_in(map, [Access.key(:user), Access.key(:name)])\n    {\"john\", %{user: %{}}}\n\nAn error is raised if the accessed structure is not a map or a struct:\n\n    iex> get_in([], [Access.key(:foo)])\n    ** (BadMapError) expected a map, got: []","prompt":"Can you write a docstring for the following Elixir function? key(key, default \\\\ nil)"}
{"completion":"Returns a function that accesses the given key in a map/struct.\n\nThe returned function is typically passed as an accessor to `Kernel.get_in/2`,\n`Kernel.get_and_update_in/3`, and friends.\n\nSimilar to `key/2`, but the returned function raises if the key does not exist.\n\n## Examples\n\n    iex> map = %{user: %{name: \"john\"}}\n    iex> get_in(map, [Access.key!(:user), Access.key!(:name)])\n    \"john\"\n    iex> get_and_update_in(map, [Access.key!(:user), Access.key!(:name)], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {\"john\", %{user: %{name: \"JOHN\"}}}\n    iex> pop_in(map, [Access.key!(:user), Access.key!(:name)])\n    {\"john\", %{user: %{}}}\n    iex> get_in(map, [Access.key!(:user), Access.key!(:unknown)])\n    ** (KeyError) key :unknown not found in: %{name: \"john\"}\n\nAn error is raised if the accessed structure is not a map/struct:\n\n    iex> get_in([], [Access.key!(:foo)])\n    ** (RuntimeError) Access.key!/1 expected a map/struct, got: []","prompt":"Can you write a docstring for the following Elixir function? key!(key)"}
{"completion":"Removes the entry with a given key from a container (a map, keyword\nlist, or struct that implements the `Access` behaviour).\n\nReturns a tuple containing the value associated with the key and the\nupdated container. `nil` is returned for the value if the key isn't\nin the container.\n\n## Examples\n\nWith a map:\n\n    iex> Access.pop(%{name: \"Elixir\", creator: \"Valim\"}, :name)\n    {\"Elixir\", %{creator: \"Valim\"}}\n\nA keyword list:\n\n    iex> Access.pop([name: \"Elixir\", creator: \"Valim\"], :name)\n    {\"Elixir\", [creator: \"Valim\"]}\n\nAn unknown key:\n\n    iex> Access.pop(%{name: \"Elixir\", creator: \"Valim\"}, :year)\n    {nil, %{creator: \"Valim\", name: \"Elixir\"}}","prompt":"Can you write a docstring for the following Elixir function? pop(container, key)"}
{"completion":"Returns a function that accesses all items of a list that are within the provided range.\n\nThe range will be normalized following the same rules from `Enum.slice/2`.\n\nThe returned function is typically passed as an accessor to `Kernel.get_in/2`,\n`Kernel.get_and_update_in/3`, and friends.\n\n## Examples\n\n    iex> list = [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}, %{name: \"vitor\", salary: 25}]\n    iex> get_in(list, [Access.slice(1..2), :name])\n    [\"francine\", \"vitor\"]\n    iex> get_and_update_in(list, [Access.slice(1..3//2), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {[\"francine\"], [%{name: \"john\", salary: 10}, %{name: \"FRANCINE\", salary: 30}, %{name: \"vitor\", salary: 25}]}\n\n`slice/1` can also be used to pop elements out of a list or\na key inside of a list:\n\n    iex> list = [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}, %{name: \"vitor\", salary: 25}]\n    iex> pop_in(list, [Access.slice(-2..-1)])\n    {[%{name: \"francine\", salary: 30}, %{name: \"vitor\", salary: 25}], [%{name: \"john\", salary: 10}]}\n    iex> pop_in(list, [Access.slice(-2..-1), :name])\n    {[\"francine\", \"vitor\"], [%{name: \"john\", salary: 10}, %{salary: 30}, %{salary: 25}]}\n\nWhen no match is found, an empty list is returned and the update function is never called\n\n    iex> list = [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}, %{name: \"vitor\", salary: 25}]\n    iex> get_in(list, [Access.slice(5..10//2), :name])\n    []\n    iex> get_and_update_in(list, [Access.slice(5..10//2), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {[], [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}, %{name: \"vitor\", salary: 25}]}\n\nAn error is raised if the accessed structure is not a list:\n\n    iex> get_in(%{}, [Access.slice(2..10//3)])\n    ** (ArgumentError) Access.slice/1 expected a list, got: %{}\n\nAn error is raised if the step of the range is negative:\n\n    iex> get_in([], [Access.slice(2..10//-1)])\n    ** (ArgumentError) Access.slice/1 does not accept ranges with negative steps, got: 2..10//-1","prompt":"Can you write a docstring for the following Elixir function? slice(range)"}
{"completion":"Key-based access to data structures.\n\nThe `Access` module defines a behaviour for dynamically accessing\nkeys of any type in a data structure via the `data[key]` syntax.\n\n`Access` supports keyword lists (`Keyword`) and maps (`Map`) out\nof the box. Keywords supports only atoms keys, keys for maps can\nbe of any type. Both return `nil` if the key does not exist:\n\n    iex> keywords = [a: 1, b: 2]\n    iex> keywords[:a]\n    1\n    iex> keywords[:c]\n    nil\n\n    iex> map = %{a: 1, b: 2}\n    iex> map[:a]\n    1\n\n    iex> star_ratings = %{1.0 => \"\", 1.5 => \"\", 2.0 => \"\"}\n    iex> star_ratings[1.5]\n    \"\"\n\nThis syntax is very convenient as it can be nested arbitrarily:\n\n    iex> keywords = [a: 1, b: 2]\n    iex> keywords[:c][:unknown]\n    nil\n\nThis works because accessing anything on a `nil` value, returns\n`nil` itself:\n\n    iex> nil[:a]\n    nil\n\nThe access syntax can also be used with the `Kernel.put_in/2`,\n`Kernel.update_in/2` and `Kernel.get_and_update_in/2` macros\nto allow values to be set in nested data structures:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> put_in(users[\"john\"][:age], 28)\n    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n\n> Attention! While the access syntax is allowed in maps via\n> `map[key]`, if your map is made of predefined atom keys,\n> you should prefer to access those atom keys with `map.key`\n> instead of `map[key]`, as `map.key` will raise if the key\n> is missing (which is not supposed to happen if the keys are\n> predefined). Similarly, since structs are maps and structs\n> have predefined keys, they only allow the `struct.key`\n> syntax and they do not allow the `struct[key]` access syntax.\n> See the `Map` module for more information.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Access"}
{"completion":"Nested data structures\n\nBoth key-based access syntaxes can be used with the nested update\nfunctions and macros in `Kernel`, such as `Kernel.get_in/2`,\n`Kernel.put_in/3`, `Kernel.update_in/3`, `Kernel.pop_in/2`, and\n`Kernel.get_and_update_in/3`.\n\nFor example, to update a map inside another map:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> put_in(users[\"john\"].age, 28)\n    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n\nThis module provides convenience functions for traversing other\nstructures, like tuples and lists. These functions can be used\nin all the `Access`-related functions and macros in `Kernel`.\n\nFor instance, given a user map with the `:name` and `:languages`\nkeys, here is how to deeply traverse the map and convert all\nlanguage names to uppercase:\n\n    iex> languages = [\n    ...>   %{name: \"elixir\", type: :functional},\n    ...>   %{name: \"c\", type: :procedural}\n    ...> ]\n    iex> user = %{name: \"john\", languages: languages}\n    iex> update_in(user, [:languages, Access.all(), :name], &String.upcase/1)\n    %{\n      name: \"john\",\n      languages: [\n        %{name: \"ELIXIR\", type: :functional},\n        %{name: \"C\", type: :procedural}\n      ]\n    }\n\nSee the functions `key/1`, `key!/1`, `elem/1`, and `all/0` for\nsome of the available accessors.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Access"}
{"completion":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","prompt":"Can you write a docstring for the following Elixir function? child_spec(init_arg)"}
{"completion":"Performs a cast (*fire and forget*) operation on the agent state.\n\nThe function `fun` is sent to the `agent` which invokes the function\npassing the agent state. The return value of `fun` becomes the new\nstate of the agent.\n\nNote that `cast` returns `:ok` immediately, regardless of whether `agent` (or\nthe node it should live on) exists.\n\n## Examples\n\n    iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.cast(pid, fn state -> state + 1 end)\n    :ok\n    iex> Agent.get(pid, fn state -> state end)\n    43","prompt":"Can you write a docstring for the following Elixir function? cast(agent, fun)"}
{"completion":"Performs a cast (*fire and forget*) operation on the agent state.\n\nSame as `cast/2` but a module, function, and arguments are expected\ninstead of an anonymous function. The state is added as first\nargument to the given list of arguments.\n\n## Examples\n\n    iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.cast(pid, Kernel, :+, [12])\n    :ok\n    iex> Agent.get(pid, fn state -> state end)\n    54","prompt":"Can you write a docstring for the following Elixir function? cast(agent, module, fun, args)"}
{"completion":"Returns a specification to start an agent under a supervisor.\n\nSee the \"Child specification\" section in the `Supervisor` module for more detailed information.","prompt":"Can you write a docstring for the following Elixir function? child_spec(arg)"}
{"completion":"Gets an agent value via the given anonymous function.\n\nThe function `fun` is sent to the `agent` which invokes the function\npassing the agent state. The result of the function invocation is\nreturned from this function.\n\n`timeout` is an integer greater than zero which specifies how many\nmilliseconds are allowed before the agent executes the function and returns\nthe result value, or the atom `:infinity` to wait indefinitely. If no result\nis received within the specified time, the function call fails and the caller\nexits.\n\n## Examples\n\n    iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.get(pid, fn state -> state end)\n    42","prompt":"Can you write a docstring for the following Elixir function? get(agent, fun, timeout \\\\ 5000)"}
{"completion":"Gets an agent value via the given function.\n\nSame as `get/3` but a module, function, and arguments are expected\ninstead of an anonymous function. The state is added as first\nargument to the given list of arguments.","prompt":"Can you write a docstring for the following Elixir function? get(agent, module, fun, args, timeout \\\\ 5000)"}
{"completion":"Gets and updates the agent state in one operation via the given anonymous\nfunction.\n\nThe function `fun` is sent to the `agent` which invokes the function\npassing the agent state. The function must return a tuple with two\nelements, the first being the value to return (that is, the \"get\" value)\nand the second one being the new state of the agent.\n\n`timeout` is an integer greater than zero which specifies how many\nmilliseconds are allowed before the agent executes the function and returns\nthe result value, or the atom `:infinity` to wait indefinitely. If no result\nis received within the specified time, the function call fails and the caller\nexits.\n\n## Examples\n\n    iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.get_and_update(pid, fn state -> {state, state + 1} end)\n    42\n    iex> Agent.get(pid, fn state -> state end)\n    43","prompt":"Can you write a docstring for the following Elixir function? get_and_update(agent, fun, timeout \\\\ 5000)"}
{"completion":"Gets and updates the agent state in one operation via the given function.\n\nSame as `get_and_update/3` but a module, function, and arguments are expected\ninstead of an anonymous function. The state is added as first\nargument to the given list of arguments.","prompt":"Can you write a docstring for the following Elixir function? get_and_update(agent, module, fun, args, timeout \\\\ 5000)"}
{"completion":"Starts an agent process without links (outside of a supervision tree).\n\nSee `start_link/2` for more information.\n\n## Examples\n\n    iex> {:ok, pid} = Agent.start(fn -> 42 end)\n    iex> Agent.get(pid, fn state -> state end)\n    42","prompt":"Can you write a docstring for the following Elixir function? start(fun, options \\\\ [])"}
{"completion":"Starts an agent without links with the given module, function, and arguments.\n\nSee `start_link/4` for more information.","prompt":"Can you write a docstring for the following Elixir function? start(module, fun, args, options \\\\ [])"}
{"completion":"Starts an agent linked to the current process with the given function.\n\nThis is often used to start the agent as part of a supervision tree.\n\nOnce the agent is spawned, the given function `fun` is invoked in the server\nprocess, and should return the initial agent state. Note that `start_link/2`\ndoes not return until the given function has returned.\n\n## Options\n\nThe `:name` option is used for registration as described in the module\ndocumentation.\n\nIf the `:timeout` option is present, the agent is allowed to spend at most\nthe given number of milliseconds on initialization or it will be terminated\nand the start function will return `{:error, :timeout}`.\n\nIf the `:debug` option is present, the corresponding function in the\n[`:sys` module](`:sys`) will be invoked.\n\nIf the `:spawn_opt` option is present, its value will be passed as options\nto the underlying process as in `Process.spawn/4`.\n\n## Return values\n\nIf the server is successfully created and initialized, the function returns\n`{:ok, pid}`, where `pid` is the PID of the server. If an agent with the\nspecified name already exists, the function returns\n`{:error, {:already_started, pid}}` with the PID of that process.\n\nIf the given function callback fails, the function returns `{:error, reason}`.\n\n## Examples\n\n    iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.get(pid, fn state -> state end)\n    42\n\n    iex> {:error, {exception, _stacktrace}} = Agent.start(fn -> raise \"oops\" end)\n    iex> exception\n    %RuntimeError{message: \"oops\"}","prompt":"Can you write a docstring for the following Elixir function? start_link(fun, options \\\\ [])"}
{"completion":"Starts an agent linked to the current process.\n\nSame as `start_link/2` but a module, function, and arguments are expected\ninstead of an anonymous function; `fun` in `module` will be called with the\ngiven arguments `args` to initialize the state.","prompt":"Can you write a docstring for the following Elixir function? start_link(module, fun, args, options \\\\ [])"}
{"completion":"Synchronously stops the agent with the given `reason`.\n\nIt returns `:ok` if the agent terminates with the given\nreason. If the agent terminates with another reason, the call will\nexit.\n\nThis function keeps OTP semantics regarding error reporting.\nIf the reason is any other than `:normal`, `:shutdown` or\n`{:shutdown, _}`, an error report will be logged.\n\n## Examples\n\n    iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.stop(pid)\n    :ok","prompt":"Can you write a docstring for the following Elixir function? stop(agent, reason \\\\ :normal, timeout \\\\ :infinity)"}
{"completion":"Updates the agent state via the given anonymous function.\n\nThe function `fun` is sent to the `agent` which invokes the function\npassing the agent state. The return value of `fun` becomes the new\nstate of the agent.\n\nThis function always returns `:ok`.\n\n`timeout` is an integer greater than zero which specifies how many\nmilliseconds are allowed before the agent executes the function and returns\nthe result value, or the atom `:infinity` to wait indefinitely. If no result\nis received within the specified time, the function call fails and the caller\nexits.\n\n## Examples\n\n    iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.update(pid, fn state -> state + 1 end)\n    :ok\n    iex> Agent.get(pid, fn state -> state end)\n    43","prompt":"Can you write a docstring for the following Elixir function? update(agent, fun, timeout \\\\ 5000)"}
{"completion":"Updates the agent state via the given function.\n\nSame as `update/3` but a module, function, and arguments are expected\ninstead of an anonymous function. The state is added as first\nargument to the given list of arguments.\n\n## Examples\n\n    iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.update(pid, Kernel, :+, [12])\n    :ok\n    iex> Agent.get(pid, fn state -> state end)\n    54","prompt":"Can you write a docstring for the following Elixir function? update(agent, module, fun, args, timeout \\\\ 5000)"}
{"completion":"Agents are a simple abstraction around state.\n\nOften in Elixir there is a need to share or store state that\nmust be accessed from different processes or by the same process\nat different points in time.\n\nThe `Agent` module provides a basic server implementation that\nallows state to be retrieved and updated via a simple API.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Agent"}
{"completion":"Examples\n\nFor example, the following agent implements a counter:\n\n    defmodule Counter do\n      use Agent\n\n      def start_link(initial_value) do\n        Agent.start_link(fn -> initial_value end, name: __MODULE__)\n      end\n\n      def value do\n        Agent.get(__MODULE__, & &1)\n      end\n\n      def increment do\n        Agent.update(__MODULE__, &(&1 + 1))\n      end\n    end\n\nUsage would be:\n\n    Counter.start_link(0)\n    #=> {:ok, #PID<0.123.0>}\n\n    Counter.value()\n    #=> 0\n\n    Counter.increment()\n    #=> :ok\n\n    Counter.increment()\n    #=> :ok\n\n    Counter.value()\n    #=> 2\n\nThanks to the agent server process, the counter can be safely incremented\nconcurrently.\n\nAgents provide a segregation between the client and server APIs (similar to\n`GenServer`s). In particular, the functions passed as arguments to the calls to\n`Agent` functions are invoked inside the agent (the server). This distinction\nis important because you may want to avoid expensive operations inside the\nagent, as they will effectively block the agent until the request is\nfulfilled.\n\nConsider these two examples:\n\n    # Compute in the agent/server\n    def get_something(agent) do\n      Agent.get(agent, fn state -> do_something_expensive(state) end)\n    end\n\n    # Compute in the agent/client\n    def get_something(agent) do\n      Agent.get(agent, & &1) |> do_something_expensive()\n    end\n\nThe first function blocks the agent. The second function copies all the state\nto the client and then executes the operation in the client. One aspect to\nconsider is whether the data is large enough to require processing in the server,\nat least initially, or small enough to be sent to the client cheaply. Another\nfactor is whether the data needs to be processed atomically: getting the\nstate and calling `do_something_expensive(state)` outside of the agent means\nthat the agent's state can be updated in the meantime. This is specially\nimportant in case of updates as computing the new state in the client rather\nthan in the server can lead to race conditions if multiple clients are trying\nto update the same state to different values.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Agent"}
{"completion":"How to supervise\n\nAn `Agent` is most commonly started under a supervision tree.\nWhen we invoke `use Agent`, it automatically defines a `child_spec/1`\nfunction that allows us to start the agent directly under a supervisor.\nTo start an agent under a supervisor with an initial counter of 0,\none may do:\n\n    children = [\n      {Counter, 0}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_all)\n\nWhile one could also simply pass the `Counter` as a child to the supervisor,\nsuch as:\n\n    children = [\n      Counter # Same as {Counter, []}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_all)\n\nThe definition above wouldn't work for this particular example,\nas it would attempt to start the counter with an initial value\nof an empty list. However, this may be a viable option in your\nown agents. A common approach is to use a keyword list, as that\nwould allow setting the initial value and giving a name to the\ncounter process, for example:\n\n    def start_link(opts) do\n      {initial_value, opts} = Keyword.pop(opts, :initial_value, 0)\n      Agent.start_link(fn -> initial_value end, opts)\n    end\n\nand then you can use `Counter`, `{Counter, name: :my_counter}` or\neven `{Counter, initial_value: 0, name: :my_counter}` as a child\nspecification.\n\n`use Agent` also accepts a list of options which configures the\nchild specification and therefore how it runs under a supervisor.\nThe generated `child_spec/1` can be customized with the following options:\n\n  * `:id` - the child specification identifier, defaults to the current module\n  * `:restart` - when the child should be restarted, defaults to `:permanent`\n  * `:shutdown` - how to shut down the child, either immediately or by giving it time to shut down\n\nFor example:\n\n    use Agent, restart: :transient, shutdown: 10_000\n\nSee the \"Child specification\" section in the `Supervisor` module for more\ndetailed information. The `@doc` annotation immediately preceding\n`use Agent` will be attached to the generated `child_spec/1` function.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Agent"}
{"completion":"Name registration\n\nAn agent is bound to the same name registration rules as GenServers.\nRead more about it in the `GenServer` documentation.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Agent"}
{"completion":"A word on distributed agents\n\nIt is important to consider the limitations of distributed agents. Agents\nprovide two APIs, one that works with anonymous functions and another\nthat expects an explicit module, function, and arguments.\n\nIn a distributed setup with multiple nodes, the API that accepts anonymous\nfunctions only works if the caller (client) and the agent have the same\nversion of the caller module.\n\nKeep in mind this issue also shows up when performing \"rolling upgrades\"\nwith agents. By rolling upgrades we mean the following situation: you wish\nto deploy a new version of your software by *shutting down* some of your\nnodes and replacing them with nodes running a new version of the software.\nIn this setup, part of your environment will have one version of a given\nmodule and the other part another version (the newer one) of the same module.\n\nThe best solution is to simply use the explicit module, function, and arguments\nAPIs when working with distributed agents.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Agent"}
{"completion":"Hot code swapping\n\nAn agent can have its code hot swapped live by simply passing a module,\nfunction, and arguments tuple to the update instruction. For example, imagine\nyou have an agent named `:sample` and you want to convert its inner state\nfrom a keyword list to a map. It can be done with the following\ninstruction:\n\n    {:update, :sample, {:advanced, {Enum, :into, [%{}]}}}\n\nThe agent's state will be added to the given list of arguments (`[%{}]`) as\nthe first argument.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Agent"}
{"completion":"Gets the directory for app.\n\nThis information is returned based on the code path. Here is an\nexample:\n\n    File.mkdir_p!(\"foo/ebin\")\n    Code.prepend_path(\"foo/ebin\")\n    Application.app_dir(:foo)\n    #=> \"foo\"\n\nEven though the directory is empty and there is no `.app` file\nit is considered the application directory based on the name\n\"foo/ebin\". The name may contain a dash `-` which is considered\nto be the app version and it is removed for the lookup purposes:\n\n    File.mkdir_p!(\"bar-123/ebin\")\n    Code.prepend_path(\"bar-123/ebin\")\n    Application.app_dir(:bar)\n    #=> \"bar-123\"\n\nFor more information on code paths, check the `Code` module in\nElixir and also Erlang's [`:code` module](`:code`).","prompt":"Can you write a docstring for the following Elixir function? app_dir(app)"}
{"completion":"Returns the given path inside `app_dir/1`.\n\nIf `path` is a string, then it will be used as the path inside `app_dir/1`. If\n`path` is a list of strings, it will be joined (see `Path.join/1`) and the result\nwill be used as the path inside `app_dir/1`.\n\n## Examples\n\n    File.mkdir_p!(\"foo/ebin\")\n    Code.prepend_path(\"foo/ebin\")\n\n    Application.app_dir(:foo, \"my_path\")\n    #=> \"foo/my_path\"\n\n    Application.app_dir(:foo, [\"my\", \"nested\", \"path\"])\n    #=> \"foo/my/nested/path\"","prompt":"Can you write a docstring for the following Elixir function? app_dir(app, path)"}
{"completion":"Reads the application environment at compilation time from a macro.\n\nTypically, developers will use `compile_env/3`. This function must\nonly be invoked from macros which aim to read the compilation environment\ndynamically.\n\nIt expects a `Macro.Env` as first argument, where the `Macro.Env` is\ntypically the `__CALLER__` in a macro. It raises if `Macro.Env` comes\nfrom a function.","prompt":"Can you write a docstring for the following Elixir function? compile_env(env, app, key_or_path, default)"}
{"completion":"Reads the application environment at compilation time from a macro\nor raises.\n\nTypically, developers will use `compile_env!/2`. This function must\nonly be invoked from macros which aim to read the compilation environment\ndynamically.\n\nIt expects a `Macro.Env` as first argument, where the `Macro.Env` is\ntypically the `__CALLER__` in a macro. It raises if `Macro.Env` comes\nfrom a function.","prompt":"Can you write a docstring for the following Elixir function? compile_env!(env, app, key_or_path)"}
{"completion":"Deletes the `key` from the given `app` environment.\n\nIt receives the same options as `put_env/4`. Returns `:ok`.","prompt":"Can you write a docstring for the following Elixir function? delete_env(app, key, opts \\\\ [])"}
{"completion":"Ensures the given `app` and its applications are started.\n\nSame as `start/2` but also starts the applications listed under\n`:applications` in the `.app` file in case they were not previously\nstarted.","prompt":"Can you write a docstring for the following Elixir function? ensure_all_started(app, type \\\\ :temporary)"}
{"completion":"Ensures the given `app` is loaded.\n\nSame as `load/1` but returns `:ok` if the application was already\nloaded.","prompt":"Can you write a docstring for the following Elixir function? ensure_loaded(app)"}
{"completion":"Ensures the given `app` is started.\n\nSame as `start/2` but returns `:ok` if the application was already\nstarted. This is useful in scripts and in test setup, where test\napplications need to be explicitly started:\n\n    :ok = Application.ensure_started(:my_test_dep)","prompt":"Can you write a docstring for the following Elixir function? ensure_started(app, type \\\\ :temporary)"}
{"completion":"Returns the value for `key` in `app`'s environment in a tuple.\n\nIf the configuration parameter does not exist, the function returns `:error`.\n\n> **Important:** you must use this function to read only your own application\n> environment. Do not read the environment of other applications.\n\n> **Important:** if you are writing a library to be used by other developers,\n> it is generally recommended to avoid the application environment, as the\n> application environment is effectively a global storage. For more information,\n> read our [library guidelines](library-guidelines.md).","prompt":"Can you write a docstring for the following Elixir function? fetch_env(app, key)"}
{"completion":"Returns the value for `key` in `app`'s environment.\n\nIf the configuration parameter does not exist, raises `ArgumentError`.\n\n> **Important:** you must use this function to read only your own application\n> environment. Do not read the environment of other applications.\n\n> **Important:** if you are writing a library to be used by other developers,\n> it is generally recommended to avoid the application environment, as the\n> application environment is effectively a global storage. For more information,\n> read our [library guidelines](library-guidelines.md).","prompt":"Can you write a docstring for the following Elixir function? fetch_env!(app, key)"}
{"completion":"Formats the error reason returned by `start/2`,\n`ensure_started/2`, `stop/1`, `load/1` and `unload/1`,\nreturns a string.","prompt":"Can you write a docstring for the following Elixir function? format_error(reason)"}
{"completion":"Returns all key-value pairs for `app`.","prompt":"Can you write a docstring for the following Elixir function? get_all_env(app)"}
{"completion":"Gets the application for the given module.\n\nThe application is located by analyzing the spec\nof all loaded applications. Returns `nil` if\nthe module is not listed in any application spec.","prompt":"Can you write a docstring for the following Elixir function? get_application(module)"}
{"completion":"Returns the value for `key` in `app`'s environment.\n\nIf the configuration parameter does not exist, the function returns the\n`default` value.\n\n> **Important:** you must use this function to read only your own application\n> environment. Do not read the environment of other applications.\n\n> **Important:** if you are writing a library to be used by other developers,\n> it is generally recommended to avoid the application environment, as the\n> application environment is effectively a global storage. For more information,\n> read our [library guidelines](library-guidelines.md).\n\n## Examples\n\n`get_env/3` is commonly used to read the configuration of your OTP applications.\nSince Mix configurations are commonly used to configure applications, we will use\nthis as a point of illustration.\n\nConsider a new application `:my_app`. `:my_app` contains a database engine which\nsupports a pool of databases. The database engine needs to know the configuration for\neach of those databases, and that configuration is supplied by key-value pairs in\nenvironment of `:my_app`.\n\n    config :my_app, Databases.RepoOne,\n      # A database configuration\n      ip: \"localhost\",\n      port: 5433\n\n    config :my_app, Databases.RepoTwo,\n      # Another database configuration (for the same OTP app)\n      ip: \"localhost\",\n      port: 20717\n\n    config :my_app, my_app_databases: [Databases.RepoOne, Databases.RepoTwo]\n\nOur database engine used by `:my_app` needs to know what databases exist, and\nwhat the database configurations are. The database engine can make a call to\n`Application.get_env(:my_app, :my_app_databases, [])` to retrieve the list of\ndatabases (specified by module names).\n\nThe engine can then traverse each repository in the list and call\n`Application.get_env(:my_app, Databases.RepoOne)` and so forth to retrieve the\nconfiguration of each one. In this case, each configuration will be a keyword\nlist, so you can use the functions in the `Keyword` module or even the `Access`\nmodule to traverse it, for example:\n\n    config = Application.get_env(:my_app, Databases.RepoOne)\n    config[:ip]","prompt":"Can you write a docstring for the following Elixir function? get_env(app, key, default \\\\ nil)"}
{"completion":"Loads the given `app`.\n\nIn order to be loaded, an `.app` file must be in the load paths.\nAll `:included_applications` will also be loaded.\n\nLoading the application does not start it nor load its modules, but\nit does load its environment.","prompt":"Can you write a docstring for the following Elixir function? load(app)"}
{"completion":"Returns a list with information about the applications which have been loaded.","prompt":"Can you write a docstring for the following Elixir function? loaded_applications()"}
{"completion":"Puts the environment for multiple apps at the same time.\n\nThe given config should not:\n\n  * have the same application listed more than once\n  * have the same key inside the same application listed more than once\n\nIf those conditions are not met, it will raise.\n\nIt receives the same options as `put_env/4`. Returns `:ok`.","prompt":"Can you write a docstring for the following Elixir function? put_all_env(config, opts \\\\ [])"}
{"completion":"Puts the `value` in `key` for the given `app`.\n\n## Options\n\n  * `:timeout` - the timeout for the change (defaults to `5_000` milliseconds)\n  * `:persistent` - persists the given value on application load and reloads\n\nIf `put_env/4` is called before the application is loaded, the application\nenvironment values specified in the `.app` file will override the ones\npreviously set.\n\nThe `:persistent` option can be set to `true` when there is a need to guarantee\nparameters set with this function will not be overridden by the ones defined\nin the application resource file on load. This means persistent values will\nstick after the application is loaded and also on application reload.","prompt":"Can you write a docstring for the following Elixir function? put_env(app, key, value, opts \\\\ [])"}
{"completion":"Returns the spec for `app`.\n\nThe following keys are returned:\n\n  * `:description`\n  * `:id`\n  * `:vsn`\n  * `:modules`\n  * `:maxP`\n  * `:maxT`\n  * `:registered`\n  * `:included_applications`\n  * `:optional_applications`\n  * `:applications`\n  * `:mod`\n  * `:start_phases`\n\nNote the environment is not returned as it can be accessed via\n`fetch_env/2`. Returns `nil` if the application is not loaded.","prompt":"Can you write a docstring for the following Elixir function? spec(app)"}
{"completion":"Returns the value for `key` in `app`'s specification.\n\nSee `spec/1` for the supported keys. If the given\nspecification parameter does not exist, this function\nwill raise. Returns `nil` if the application is not loaded.","prompt":"Can you write a docstring for the following Elixir function? spec(app, key)"}
{"completion":"Starts the given `app`.\n\nIf the `app` is not loaded, the application will first be loaded using `load/1`.\nAny included application, defined in the `:included_applications` key of the\n`.app` file will also be loaded, but they won't be started.\n\nFurthermore, all applications listed in the `:applications` key must be explicitly\nstarted before this application is. If not, `{:error, {:not_started, app}}` is\nreturned, where `app` is the name of the missing application.\n\nIn case you want to automatically load **and start** all of `app`'s dependencies,\nsee `ensure_all_started/2`.\n\nThe `type` argument specifies the type of the application:\n\n  * `:permanent` - if `app` terminates, all other applications and the entire\n    node are also terminated.\n\n  * `:transient` - if `app` terminates with `:normal` reason, it is reported\n    but no other applications are terminated. If a transient application\n    terminates abnormally, all other applications and the entire node are\n    also terminated.\n\n  * `:temporary` - if `app` terminates, it is reported but no other\n    applications are terminated (the default).\n\nNote that it is always possible to stop an application explicitly by calling\n`stop/1`. Regardless of the type of the application, no other applications will\nbe affected.\n\nNote also that the `:transient` type is of little practical use, since when a\nsupervision tree terminates, the reason is set to `:shutdown`, not `:normal`.","prompt":"Can you write a docstring for the following Elixir function? start(app, type \\\\ :temporary)"}
{"completion":"Returns a list with information about the applications which are currently running.","prompt":"Can you write a docstring for the following Elixir function? started_applications(timeout \\\\ 5000)"}
{"completion":"Stops the given `app`.\n\nWhen stopped, the application is still loaded.","prompt":"Can you write a docstring for the following Elixir function? stop(app)"}
{"completion":"Unloads the given `app`.\n\nIt will also unload all `:included_applications`.\nNote that the function does not purge the application modules.","prompt":"Can you write a docstring for the following Elixir function? unload(app)"}
{"completion":"A module for working with applications and defining application callbacks.\n\nApplications are the idiomatic way to package software in Erlang/OTP. To get\nthe idea, they are similar to the \"library\" concept common in other\nprogramming languages, but with some additional characteristics.\n\nAn application is a component implementing some specific functionality, with a\nstandardized directory structure, configuration, and life cycle. Applications\nare *loaded*, *started*, and *stopped*. Each application also has its own\nenvironment, which provides a unified API for configuring each application.\n\nDevelopers typically interact with the application environment and its\ncallback module. Therefore those will be the topics we will cover first\nbefore jumping into details about the application resource file and life-cycle.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Application"}
{"completion":"The application environment\n\nEach application has its own environment. The environment is a keyword list\nthat maps atoms to terms. Note that this environment is unrelated to the\noperating system environment.\n\nBy default, the environment of an application is an empty list. In a Mix\nproject's `mix.exs` file, you can set the `:env` key in `application/0`:\n\n    def application do\n      [env: [db_host: \"localhost\"]]\n    end\n\nNow, in your application, you can read this environment by using functions\nsuch as `fetch_env!/2` and friends:\n\n    defmodule MyApp.DBClient do\n      def start_link() do\n        SomeLib.DBClient.start_link(host: db_host())\n      end\n\n      defp db_host do\n        Application.fetch_env!(:my_app, :db_host)\n      end\n    end\n\nIn Mix projects, the environment of the application and its dependencies can\nbe overridden via the `config/config.exs` and `config/runtime.exs` files. The\nformer is loaded at build-time, before your code compiles, and the latter at\nruntime, just before your app starts. For example, someone using your application\ncan override its `:db_host` environment variable as follows:\n\n    import Config\n    config :my_app, :db_host, \"db.local\"\n\nSee the \"Configuration\" section in the `Mix` module for more information.\nYou can also change the application environment dynamically by using functions\nsuch as `put_env/3` and `delete_env/2`.\n\n> Note: The config files `config/config.exs` and `config/runtime.exs`\n> are rarely used by libraries. Libraries typically define their environment\n> in the `def application` function of their `mix.exs`. Configuration files\n> are rather used by applications to configure their libraries.\n\n> Note: Each application is responsible for its own environment. Do not\n> use the functions in this module for directly accessing or modifying\n> the environment of other applications. Whenever you change the application\n> environment, Elixir's build tool will only recompile the files that\n> belong to that application. So if you read the application environment\n> of another application, there is a chance you will be depending on\n> outdated configuration, as your file won't be recompiled as it changes.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Application"}
{"completion":"Compile-time environment\n\nIn the previous example, we read the application environment at runtime:\n\n    defmodule MyApp.DBClient do\n      def start_link() do\n        SomeLib.DBClient.start_link(host: db_host())\n      end\n\n      defp db_host do\n        Application.fetch_env!(:my_app, :db_host)\n      end\n    end\n\nIn other words, the environment key `:db_host` for application `:my_app`\nwill only be read when `MyApp.DBClient` effectively starts. While reading\nthe application environment at runtime is the preferred approach, in some\nrare occasions you may want to use the application environment to configure\nthe compilation of a certain project. However, if you try to access\n`Application.fetch_env!/2` outside of a function:\n\n    defmodule MyApp.DBClient do\n      @db_host Application.fetch_env!(:my_app, :db_host)\n\n      def start_link() do\n        SomeLib.DBClient.start_link(host: @db_host)\n      end\n    end\n\nYou might see warnings and errors:\n\n    warning: Application.fetch_env!/2 is discouraged in the module body,\n    use Application.compile_env/3 instead\n      iex:3: MyApp.DBClient\n\n    ** (ArgumentError) could not fetch application environment :db_host\n    for application :my_app because the application was not loaded nor\n    configured\n\nThis happens because, when defining modules, the application environment\nis not yet available. Luckily, the warning tells us how to solve this\nissue, by using `Application.compile_env/3` instead:\n\n    defmodule MyApp.DBClient do\n      @db_host Application.compile_env(:my_app, :db_host, \"db.local\")\n\n      def start_link() do\n        SomeLib.DBClient.start_link(host: @db_host)\n      end\n    end\n\nThe difference here is that `compile_env` expects the default value to be\ngiven as an argument, instead of using the `def application` function of\nyour `mix.exs`. Furthermore, by using `compile_env/3`, tools like Mix will\nstore the values used during compilation and compare the compilation values\nwith the runtime values whenever your system starts, raising an error in\ncase they differ.\n\nIn any case, compile-time environments should be avoided. Whenever possible,\nreading the application environment at runtime should be the first choice.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Application"}
{"completion":"The application callback module\n\nApplications can be loaded, started, and stopped. Generally, build tools\nlike Mix take care of starting an application and all of its dependencies\nfor you, but you can also do it manually by calling:\n\n    {:ok, _} = Application.ensure_all_started(:some_app)\n\nWhen an application starts, developers may configure a callback module\nthat executes custom code. Developers use this callback to start the\napplication supervision tree.\n\nThe first step to do so is to add a `:mod` key to the `application/0`\ndefinition in your `mix.exs` file. It expects a tuple, with the application\ncallback module and start argument (commonly an empty list):\n\n    def application do\n      [mod: {MyApp, []}]\n    end\n\nThe `MyApp` module given to `:mod` needs to implement the `Application` behaviour.\nThis can be done by putting `use Application` in that module and implementing the\n`c:start/2` callback, for example:\n\n    defmodule MyApp do\n      use Application\n\n      def start(_type, _args) do\n        children = []\n        Supervisor.start_link(children, strategy: :one_for_one)\n      end\n    end\n\nThe `c:start/2` callback has to spawn and link a supervisor and return `{:ok,\npid}` or `{:ok, pid, state}`, where `pid` is the PID of the supervisor, and\n`state` is an optional application state. `args` is the second element of the\ntuple given to the `:mod` option.\n\nThe `type` argument passed to `c:start/2` is usually `:normal` unless in a\ndistributed setup where application takeovers and failovers are configured.\nDistributed applications are beyond the scope of this documentation.\n\nWhen an application is shutting down, its `c:stop/1` callback is called after\nthe supervision tree has been stopped by the runtime. This callback allows the\napplication to do any final cleanup. The argument is the state returned by\n`c:start/2`, if it did, or `[]` otherwise. The return value of `c:stop/1` is\nignored.\n\nBy using `Application`, modules get a default implementation of `c:stop/1`\nthat ignores its argument and returns `:ok`, but it can be overridden.\n\nApplication callback modules may also implement the optional callback\n`c:prep_stop/1`. If present, `c:prep_stop/1` is invoked before the supervision\ntree is terminated. Its argument is the state returned by `c:start/2`, if it did,\nor `[]` otherwise, and its return value is passed to `c:stop/1`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Application"}
{"completion":"The application resource file\n\nIn the sections above, we have configured an application in the\n`application/0` section of the `mix.exs` file. Ultimately, Mix will use\nthis configuration to create an [*application resource\nfile*](https://www.erlang.org/doc/man/application.html), which is a file called\n`APP_NAME.app`. For example, the application resource file of the OTP\napplication `ex_unit` is called `ex_unit.app`.\n\nYou can learn more about the generation of application resource files in\nthe documentation of `Mix.Tasks.Compile.App`, available as well by running\n`mix help compile.app`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Application"}
{"completion":"The application life cycle","prompt":"Can you write a docstring for the following Elixir function? Elixir.Application"}
{"completion":"# Loading applications\n\nApplications are *loaded*, which means that the runtime finds and processes\ntheir resource files:\n\n    Application.load(:ex_unit)\n    #=> :ok\n\nWhen an application is loaded, the environment specified in its resource file\nis merged with any overrides from config files.\n\nLoading an application *does not* load its modules.\n\nIn practice, you rarely load applications by hand because that is part of the\nstart process, explained next.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Application"}
{"completion":"# Starting applications\n\nApplications are also *started*:\n\n    Application.start(:ex_unit)\n    #=> :ok\n\nOnce your application is compiled, running your system is a matter of starting\nyour current application and its dependencies. Differently from other languages,\nElixir does not have a `main` procedure that is responsible for starting your\nsystem. Instead, you start one or more applications, each with their own\ninitialization and termination logic.\n\nWhen an application is started, the `Application.load/1` is automatically\ninvoked if it hasn't been done yet. Then, it checks if the dependencies listed\nin the `applications` key of the resource file are already started. Having at\nleast one dependency not started is an error condition. Functions like\n`ensure_all_started/1` takes care of starting an application and all of its\ndependencies for you.\n\nIf the application does not have a callback module configured, starting is\ndone at this point. Otherwise, its `c:start/2` callback is invoked. The PID of\nthe top-level supervisor returned by this function is stored by the runtime\nfor later use, and the returned application state is saved too, if any.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Application"}
{"completion":"# Stopping applications\n\nStarted applications are, finally, *stopped*:\n\n    Application.stop(:ex_unit)\n    #=> :ok\n\nStopping an application without a callback module is defined, but except for\nsome system tracing, it is in practice a no-op.\n\nStopping an application with a callback module has three steps:\n\n  1. If present, invoke the optional callback `c:prep_stop/1`.\n  2. Terminate the top-level supervisor.\n  3. Invoke the required callback `c:stop/1`.\n\nThe arguments passed to the callbacks are related to the state optionally\nreturned by `c:start/2`, and are documented in the section about the callback\nmodule above.\n\nIt is important to highlight that step 2 is a blocking one. Termination of a\nsupervisor triggers a recursive chain of children terminations, therefore\norderly shutting down all descendant processes. The `c:stop/1` callback is\ninvoked only after termination of the whole supervision tree.\n\nShutting down a live system cleanly can be done by calling `System.stop/1`. It\nwill shut down every application in the opposite order they had been started.\n\nBy default, a SIGTERM from the operating system will automatically translate to\n`System.stop/0`. You can also have more explicit control over operating system\nsignals via the `:os.set_signal/2` function.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Application"}
{"completion":"Tooling\n\nThe Mix build tool automates most of the application management tasks. For example,\n`mix test` automatically starts your application dependencies and your application\nitself before your test runs. `mix run --no-halt` boots your current project and\ncan be used to start a long running system. See `mix help run`.\n\nDevelopers can also use `mix release` to build **releases**. Releases are able to\npackage all of your source code as well as the Erlang VM into a single directory.\nReleases also give you explicit control over how each application is started and in\nwhich order. They also provide a more streamlined mechanism for starting and\nstopping systems, debugging, logging, as well as system monitoring.\n\nFinally, Elixir provides tools such as escripts and archives, which are\ndifferent mechanisms for packaging your application. Those are typically used\nwhen tools must be shared between developers and not as deployment options.\nSee `mix help archive.build` and `mix help escript.build` for more detail.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Application"}
{"completion":"Further information\n\nFor further details on applications please check the documentation of the\n[`:application` Erlang module](`:application`), and the\n[Applications](https://www.erlang.org/doc/design_principles/applications.html)\nsection of the [OTP Design Principles User's\nGuide](https://www.erlang.org/doc/design_principles/users_guide.html).","prompt":"Can you write a docstring for the following Elixir function? Elixir.Application"}
{"completion":"Converts an atom to a charlist.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Atom.to_charlist(:\"An atom\")\n    'An atom'","prompt":"Can you write a docstring for the following Elixir function? to_charlist(atom)"}
{"completion":"Converts an atom to a string.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Atom.to_string(:foo)\n    \"foo\"","prompt":"Can you write a docstring for the following Elixir function? to_string(atom)"}
{"completion":"Atoms are constants whose values are their own name.\n\nThey are often useful to enumerate over distinct values, such as:\n\n    iex> :apple\n    :apple\n    iex> :orange\n    :orange\n    iex> :watermelon\n    :watermelon\n\nAtoms are equal if their names are equal.\n\n    iex> :apple == :apple\n    true\n    iex> :apple == :orange\n    false\n\nOften they are used to express the state of an operation, by using\nvalues such as `:ok` and `:error`.\n\nThe booleans `true` and `false` are also atoms:\n\n    iex> true == :true\n    true\n    iex> is_atom(false)\n    true\n    iex> is_boolean(:false)\n    true\n\nElixir allows you to skip the leading `:` for the atoms `false`, `true`,\nand `nil`.\n\nAtoms must be composed of Unicode characters such as letters, numbers,\nunderscore, and `@`. If the keyword has a character that does not\nbelong to the category above, such as spaces, you can wrap it in\nquotes:\n\n    iex> :\"this is an atom with spaces\"\n    :\"this is an atom with spaces\"","prompt":"Can you write a docstring for the following Elixir function? Elixir.Atom"}
{"completion":"Decodes a base 16 encoded string into a binary string.\n\n## Options\n\nThe accepted options are:\n\n  * `:case` - specifies the character case to accept when decoding\n\nThe values for `:case` can be:\n\n  * `:upper` - only allows upper case characters (default)\n  * `:lower` - only allows lower case characters\n  * `:mixed` - allows mixed case characters\n\n## Examples\n\n    iex> Base.decode16(\"666F6F626172\")\n    {:ok, \"foobar\"}\n\n    iex> Base.decode16(\"666f6f626172\", case: :lower)\n    {:ok, \"foobar\"}\n\n    iex> Base.decode16(\"666f6F626172\", case: :mixed)\n    {:ok, \"foobar\"}","prompt":"Can you write a docstring for the following Elixir function? decode16(string, opts \\\\ [])"}
{"completion":"Decodes a base 16 encoded string into a binary string.\n\n## Options\n\nThe accepted options are:\n\n  * `:case` - specifies the character case to accept when decoding\n\nThe values for `:case` can be:\n\n  * `:upper` - only allows upper case characters (default)\n  * `:lower` - only allows lower case characters\n  * `:mixed` - allows mixed case characters\n\nAn `ArgumentError` exception is raised if the padding is incorrect or\na non-alphabet character is present in the string.\n\n## Examples\n\n    iex> Base.decode16!(\"666F6F626172\")\n    \"foobar\"\n\n    iex> Base.decode16!(\"666f6f626172\", case: :lower)\n    \"foobar\"\n\n    iex> Base.decode16!(\"666f6F626172\", case: :mixed)\n    \"foobar\"","prompt":"Can you write a docstring for the following Elixir function? decode16!(string, opts \\\\ [])"}
{"completion":"Decodes a base 32 encoded string into a binary string.\n\n## Options\n\nThe accepted options are:\n\n  * `:case` - specifies the character case to accept when decoding\n  * `:padding` - specifies whether to require padding\n\nThe values for `:case` can be:\n\n  * `:upper` - only allows  upper case characters (default)\n  * `:lower` - only allows lower case characters\n  * `:mixed` - allows mixed case characters\n\nThe values for `:padding` can be:\n\n  * `true` - requires the input string to be padded to the nearest multiple of 8 (default)\n  * `false` - ignores padding from the input string\n\n## Examples\n\n    iex> Base.decode32(\"MZXW6YTBOI======\")\n    {:ok, \"foobar\"}\n\n    iex> Base.decode32(\"mzxw6ytboi======\", case: :lower)\n    {:ok, \"foobar\"}\n\n    iex> Base.decode32(\"mzXW6ytBOi======\", case: :mixed)\n    {:ok, \"foobar\"}\n\n    iex> Base.decode32(\"MZXW6YTBOI\", padding: false)\n    {:ok, \"foobar\"}","prompt":"Can you write a docstring for the following Elixir function? decode32(string, opts \\\\ [])"}
{"completion":"Decodes a base 32 encoded string into a binary string.\n\nAn `ArgumentError` exception is raised if the padding is incorrect or\na non-alphabet character is present in the string.\n\n## Options\n\nThe accepted options are:\n\n  * `:case` - specifies the character case to accept when decoding\n  * `:padding` - specifies whether to require padding\n\nThe values for `:case` can be:\n\n  * `:upper` - only allows upper case characters (default)\n  * `:lower` - only allows lower case characters\n  * `:mixed` - allows mixed case characters\n\nThe values for `:padding` can be:\n\n  * `true` - requires the input string to be padded to the nearest multiple of 8 (default)\n  * `false` - ignores padding from the input string\n\n## Examples\n\n    iex> Base.decode32!(\"MZXW6YTBOI======\")\n    \"foobar\"\n\n    iex> Base.decode32!(\"mzxw6ytboi======\", case: :lower)\n    \"foobar\"\n\n    iex> Base.decode32!(\"mzXW6ytBOi======\", case: :mixed)\n    \"foobar\"\n\n    iex> Base.decode32!(\"MZXW6YTBOI\", padding: false)\n    \"foobar\"","prompt":"Can you write a docstring for the following Elixir function? decode32!(string, opts \\\\ [])"}
{"completion":"Decodes a base 64 encoded string into a binary string.\n\nAccepts `ignore: :whitespace` option which will ignore all the\nwhitespace characters in the input string.\n\nAccepts `padding: false` option which will ignore padding from\nthe input string.\n\n## Examples\n\n    iex> Base.decode64(\"Zm9vYmFy\")\n    {:ok, \"foobar\"}\n\n    iex> Base.decode64(\"Zm9vYmFy\\n\", ignore: :whitespace)\n    {:ok, \"foobar\"}\n\n    iex> Base.decode64(\"Zm9vYg==\")\n    {:ok, \"foob\"}\n\n    iex> Base.decode64(\"Zm9vYg\", padding: false)\n    {:ok, \"foob\"}","prompt":"Can you write a docstring for the following Elixir function? decode64(string, opts \\\\ [])"}
{"completion":"Decodes a base 64 encoded string into a binary string.\n\nAccepts `ignore: :whitespace` option which will ignore all the\nwhitespace characters in the input string.\n\nAccepts `padding: false` option which will ignore padding from\nthe input string.\n\nAn `ArgumentError` exception is raised if the padding is incorrect or\na non-alphabet character is present in the string.\n\n## Examples\n\n    iex> Base.decode64!(\"Zm9vYmFy\")\n    \"foobar\"\n\n    iex> Base.decode64!(\"Zm9vYmFy\\n\", ignore: :whitespace)\n    \"foobar\"\n\n    iex> Base.decode64!(\"Zm9vYg==\")\n    \"foob\"\n\n    iex> Base.decode64!(\"Zm9vYg\", padding: false)\n    \"foob\"","prompt":"Can you write a docstring for the following Elixir function? decode64!(string, opts \\\\ [])"}
{"completion":"Encodes a binary string into a base 16 encoded string.\n\n## Options\n\nThe accepted options are:\n\n  * `:case` - specifies the character case to use when encoding\n\nThe values for `:case` can be:\n\n  * `:upper` - uses upper case characters (default)\n  * `:lower` - uses lower case characters\n\n## Examples\n\n    iex> Base.encode16(\"foobar\")\n    \"666F6F626172\"\n\n    iex> Base.encode16(\"foobar\", case: :lower)\n    \"666f6f626172\"","prompt":"Can you write a docstring for the following Elixir function? encode16(data, opts \\\\ [])"}
{"completion":"Encodes a binary string into a base 32 encoded string.\n\n## Options\n\nThe accepted options are:\n\n  * `:case` - specifies the character case to use when encoding\n  * `:padding` - specifies whether to apply padding\n\nThe values for `:case` can be:\n\n  * `:upper` - uses upper case characters (default)\n  * `:lower` - uses lower case characters\n\nThe values for `:padding` can be:\n\n  * `true` - pad the output string to the nearest multiple of 8 (default)\n  * `false` - omit padding from the output string\n\n## Examples\n\n    iex> Base.encode32(\"foobar\")\n    \"MZXW6YTBOI======\"\n\n    iex> Base.encode32(\"foobar\", case: :lower)\n    \"mzxw6ytboi======\"\n\n    iex> Base.encode32(\"foobar\", padding: false)\n    \"MZXW6YTBOI\"","prompt":"Can you write a docstring for the following Elixir function? encode32(data, opts \\\\ [])"}
{"completion":"Encodes a binary string into a base 64 encoded string.\n\nAccepts `padding: false` option which will omit padding from\nthe output string.\n\n## Examples\n\n    iex> Base.encode64(\"foobar\")\n    \"Zm9vYmFy\"\n\n    iex> Base.encode64(\"foob\")\n    \"Zm9vYg==\"\n\n    iex> Base.encode64(\"foob\", padding: false)\n    \"Zm9vYg\"","prompt":"Can you write a docstring for the following Elixir function? encode64(data, opts \\\\ [])"}
{"completion":"Decodes a base 32 encoded string with extended hexadecimal alphabet\ninto a binary string.\n\n## Options\n\nThe accepted options are:\n\n  * `:case` - specifies the character case to accept when decoding\n  * `:padding` - specifies whether to require padding\n\nThe values for `:case` can be:\n\n  * `:upper` - only allows upper case characters (default)\n  * `:lower` - only allows lower case characters\n  * `:mixed` - allows mixed case characters\n\nThe values for `:padding` can be:\n\n  * `true` - requires the input string to be padded to the nearest multiple of 8 (default)\n  * `false` - ignores padding from the input string\n\n## Examples\n\n    iex> Base.hex_decode32(\"CPNMUOJ1E8======\")\n    {:ok, \"foobar\"}\n\n    iex> Base.hex_decode32(\"cpnmuoj1e8======\", case: :lower)\n    {:ok, \"foobar\"}\n\n    iex> Base.hex_decode32(\"cpnMuOJ1E8======\", case: :mixed)\n    {:ok, \"foobar\"}\n\n    iex> Base.hex_decode32(\"CPNMUOJ1E8\", padding: false)\n    {:ok, \"foobar\"}","prompt":"Can you write a docstring for the following Elixir function? hex_decode32(string, opts \\\\ [])"}
{"completion":"Decodes a base 32 encoded string with extended hexadecimal alphabet\ninto a binary string.\n\nAn `ArgumentError` exception is raised if the padding is incorrect or\na non-alphabet character is present in the string.\n\n## Options\n\nThe accepted options are:\n\n  * `:case` - specifies the character case to accept when decoding\n  * `:padding` - specifies whether to require padding\n\nThe values for `:case` can be:\n\n  * `:upper` - only allows upper case characters (default)\n  * `:lower` - only allows lower case characters\n  * `:mixed` - allows mixed case characters\n\nThe values for `:padding` can be:\n\n  * `true` - requires the input string to be padded to the nearest multiple of 8 (default)\n  * `false` - ignores padding from the input string\n\n## Examples\n\n    iex> Base.hex_decode32!(\"CPNMUOJ1E8======\")\n    \"foobar\"\n\n    iex> Base.hex_decode32!(\"cpnmuoj1e8======\", case: :lower)\n    \"foobar\"\n\n    iex> Base.hex_decode32!(\"cpnMuOJ1E8======\", case: :mixed)\n    \"foobar\"\n\n    iex> Base.hex_decode32!(\"CPNMUOJ1E8\", padding: false)\n    \"foobar\"","prompt":"Can you write a docstring for the following Elixir function? hex_decode32!(string, opts \\\\ [])"}
{"completion":"Encodes a binary string into a base 32 encoded string with an\nextended hexadecimal alphabet.\n\n## Options\n\nThe accepted options are:\n\n  * `:case` - specifies the character case to use when encoding\n  * `:padding` - specifies whether to apply padding\n\nThe values for `:case` can be:\n\n  * `:upper` - uses upper case characters (default)\n  * `:lower` - uses lower case characters\n\nThe values for `:padding` can be:\n\n  * `true` - pad the output string to the nearest multiple of 8 (default)\n  * `false` - omit padding from the output string\n\n## Examples\n\n    iex> Base.hex_encode32(\"foobar\")\n    \"CPNMUOJ1E8======\"\n\n    iex> Base.hex_encode32(\"foobar\", case: :lower)\n    \"cpnmuoj1e8======\"\n\n    iex> Base.hex_encode32(\"foobar\", padding: false)\n    \"CPNMUOJ1E8\"","prompt":"Can you write a docstring for the following Elixir function? hex_encode32(data, opts \\\\ [])"}
{"completion":"Decodes a base 64 encoded string with URL and filename safe alphabet\ninto a binary string.\n\nAccepts `ignore: :whitespace` option which will ignore all the\nwhitespace characters in the input string.\n\nAccepts `padding: false` option which will ignore padding from\nthe input string.\n\n## Examples\n\n    iex> Base.url_decode64(\"_3_-_A==\")\n    {:ok, <<255, 127, 254, 252>>}\n\n    iex> Base.url_decode64(\"_3_-_A==\\n\", ignore: :whitespace)\n    {:ok, <<255, 127, 254, 252>>}\n\n    iex> Base.url_decode64(\"_3_-_A\", padding: false)\n    {:ok, <<255, 127, 254, 252>>}","prompt":"Can you write a docstring for the following Elixir function? url_decode64(string, opts \\\\ [])"}
{"completion":"Decodes a base 64 encoded string with URL and filename safe alphabet\ninto a binary string.\n\nAccepts `ignore: :whitespace` option which will ignore all the\nwhitespace characters in the input string.\n\nAccepts `padding: false` option which will ignore padding from\nthe input string.\n\nAn `ArgumentError` exception is raised if the padding is incorrect or\na non-alphabet character is present in the string.\n\n## Examples\n\n    iex> Base.url_decode64!(\"_3_-_A==\")\n    <<255, 127, 254, 252>>\n\n    iex> Base.url_decode64!(\"_3_-_A==\\n\", ignore: :whitespace)\n    <<255, 127, 254, 252>>\n\n    iex> Base.url_decode64!(\"_3_-_A\", padding: false)\n    <<255, 127, 254, 252>>","prompt":"Can you write a docstring for the following Elixir function? url_decode64!(string, opts \\\\ [])"}
{"completion":"Encodes a binary string into a base 64 encoded string with URL and filename\nsafe alphabet.\n\nAccepts `padding: false` option which will omit padding from\nthe output string.\n\n## Examples\n\n    iex> Base.url_encode64(<<255, 127, 254, 252>>)\n    \"_3_-_A==\"\n\n    iex> Base.url_encode64(<<255, 127, 254, 252>>, padding: false)\n    \"_3_-_A\"","prompt":"Can you write a docstring for the following Elixir function? url_encode64(data, opts \\\\ [])"}
{"completion":"This module provides data encoding and decoding functions\naccording to [RFC 4648](https://tools.ietf.org/html/rfc4648).\n\nThis document defines the commonly used base 16, base 32, and base\n64 encoding schemes.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Base"}
{"completion":"Base 16 alphabet\n\n| Value | Encoding | Value | Encoding | Value | Encoding | Value | Encoding |\n|------:|:---------|------:|:---------|------:|:---------|------:|:---------|\n|     0 | 0        |     4 | 4        |     8 | 8        |    12 | C        |\n|     1 | 1        |     5 | 5        |     9 | 9        |    13 | D        |\n|     2 | 2        |     6 | 6        |    10 | A        |    14 | E        |\n|     3 | 3        |     7 | 7        |    11 | B        |    15 | F        |","prompt":"Can you write a docstring for the following Elixir function? Elixir.Base"}
{"completion":"Base 32 alphabet\n\n| Value | Encoding | Value | Encoding | Value | Encoding | Value | Encoding |\n|------:|:---------|------:|:---------|------:|:---------|------:|:---------|\n|     0 | A        |     9 | J        |    18 | S        |    27 | 3        |\n|     1 | B        |    10 | K        |    19 | T        |    28 | 4        |\n|     2 | C        |    11 | L        |    20 | U        |    29 | 5        |\n|     3 | D        |    12 | M        |    21 | V        |    30 | 6        |\n|     4 | E        |    13 | N        |    22 | W        |    31 | 7        |\n|     5 | F        |    14 | O        |    23 | X        |       |          |\n|     6 | G        |    15 | P        |    24 | Y        | (pad) | =        |\n|     7 | H        |    16 | Q        |    25 | Z        |       |          |\n|     8 | I        |    17 | R        |    26 | 2        |       |          |","prompt":"Can you write a docstring for the following Elixir function? Elixir.Base"}
{"completion":"Base 32 (extended hex) alphabet\n\n| Value | Encoding | Value | Encoding | Value | Encoding | Value | Encoding |\n|------:|:---------|------:|:---------|------:|:---------|------:|:---------|\n|     0 | 0        |     9 | 9        |    18 | I        |    27 | R        |\n|     1 | 1        |    10 | A        |    19 | J        |    28 | S        |\n|     2 | 2        |    11 | B        |    20 | K        |    29 | T        |\n|     3 | 3        |    12 | C        |    21 | L        |    30 | U        |\n|     4 | 4        |    13 | D        |    22 | M        |    31 | V        |\n|     5 | 5        |    14 | E        |    23 | N        |       |          |\n|     6 | 6        |    15 | F        |    24 | O        | (pad) | =        |\n|     7 | 7        |    16 | G        |    25 | P        |       |          |\n|     8 | 8        |    17 | H        |    26 | Q        |       |          |","prompt":"Can you write a docstring for the following Elixir function? Elixir.Base"}
{"completion":"Base 64 alphabet\n\n| Value |  Encoding | Value | Encoding | Value | Encoding | Value | Encoding |\n|------:|:----------|------:|:---------|------:|:---------|------:|:---------|\n|     0 | A         |    17 | R        |    34 | i        |    51 | z        |\n|     1 | B         |    18 | S        |    35 | j        |    52 | 0        |\n|     2 | C         |    19 | T        |    36 | k        |    53 | 1        |\n|     3 | D         |    20 | U        |    37 | l        |    54 | 2        |\n|     4 | E         |    21 | V        |    38 | m        |    55 | 3        |\n|     5 | F         |    22 | W        |    39 | n        |    56 | 4        |\n|     6 | G         |    23 | X        |    40 | o        |    57 | 5        |\n|     7 | H         |    24 | Y        |    41 | p        |    58 | 6        |\n|     8 | I         |    25 | Z        |    42 | q        |    59 | 7        |\n|     9 | J         |    26 | a        |    43 | r        |    60 | 8        |\n|    10 | K         |    27 | b        |    44 | s        |    61 | 9        |\n|    11 | L         |    28 | c        |    45 | t        |    62 | +        |\n|    12 | M         |    29 | d        |    46 | u        |    63 | /        |\n|    13 | N         |    30 | e        |    47 | v        |       |          |\n|    14 | O         |    31 | f        |    48 | w        | (pad) | =        |\n|    15 | P         |    32 | g        |    49 | x        |       |          |\n|    16 | Q         |    33 | h        |    50 | y        |       |          |","prompt":"Can you write a docstring for the following Elixir function? Elixir.Base"}
{"completion":"Base 64 (URL and filename safe) alphabet\n\n| Value | Encoding | Value | Encoding | Value | Encoding | Value | Encoding |\n|------:|:---------|------:|:---------|------:|:---------|------:|:---------|\n|     0 | A        |    17 | R        |    34 | i        |    51 | z        |\n|     1 | B        |    18 | S        |    35 | j        |    52 | 0        |\n|     2 | C        |    19 | T        |    36 | k        |    53 | 1        |\n|     3 | D        |    20 | U        |    37 | l        |    54 | 2        |\n|     4 | E        |    21 | V        |    38 | m        |    55 | 3        |\n|     5 | F        |    22 | W        |    39 | n        |    56 | 4        |\n|     6 | G        |    23 | X        |    40 | o        |    57 | 5        |\n|     7 | H        |    24 | Y        |    41 | p        |    58 | 6        |\n|     8 | I        |    25 | Z        |    42 | q        |    59 | 7        |\n|     9 | J        |    26 | a        |    43 | r        |    60 | 8        |\n|    10 | K        |    27 | b        |    44 | s        |    61 | 9        |\n|    11 | L        |    28 | c        |    45 | t        |    62 | -        |\n|    12 | M        |    29 | d        |    46 | u        |    63 | _        |\n|    13 | N        |    30 | e        |    47 | v        |       |          |\n|    14 | O        |    31 | f        |    48 | w        | (pad) | =        |\n|    15 | P        |    32 | g        |    49 | x        |       |          |\n|    16 | Q        |    33 | h        |    50 | y        |       |          |","prompt":"Can you write a docstring for the following Elixir function? Elixir.Base"}
{"completion":"Mechanism for handling behaviours.\n\nThis module is deprecated. Instead of `defcallback/1` and\n`defmacrocallback/1`, the `@callback` and `@macrocallback`\nmodule attributes can be used respectively. See the\ndocumentation for `Module` for more information on these\nattributes.\n\nInstead of `MyModule.__behaviour__(:callbacks)`,\n`MyModule.behaviour_info(:callbacks)` can be used.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Behaviour"}
{"completion":"Bitwise AND operator.\n\nCalculates the bitwise AND of its arguments.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 9 &&& 3\n    1","prompt":"Can you write a docstring for the following Elixir function? left &&& right"}
{"completion":"Arithmetic left bitshift operator.\n\nCalculates the result of an arithmetic left bitshift.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 <<< 2\n    4\n\n    iex> 1 <<< -2\n    0\n\n    iex> -1 <<< 2\n    -4\n\n    iex> -1 <<< -2\n    -1","prompt":"Can you write a docstring for the following Elixir function? left <<< right"}
{"completion":"Arithmetic right bitshift operator.\n\nCalculates the result of an arithmetic right bitshift.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 >>> 2\n    0\n\n    iex> 1 >>> -2\n    4\n\n    iex> -1 >>> 2\n    -1\n\n    iex> -1 >>> -2\n    -4","prompt":"Can you write a docstring for the following Elixir function? left >>> right"}
{"completion":"Calculates the bitwise AND of its arguments.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> band(9, 3)\n    1","prompt":"Can you write a docstring for the following Elixir function? band(left, right)"}
{"completion":"Calculates the bitwise NOT of the argument.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> bnot(2)\n    -3\n\n    iex> bnot(2) &&& 3\n    1","prompt":"Can you write a docstring for the following Elixir function? bnot(expr)"}
{"completion":"Calculates the bitwise OR of its arguments.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> bor(9, 3)\n    11","prompt":"Can you write a docstring for the following Elixir function? bor(left, right)"}
{"completion":"Calculates the result of an arithmetic left bitshift.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> bsl(1, 2)\n    4\n\n    iex> bsl(1, -2)\n    0\n\n    iex> bsl(-1, 2)\n    -4\n\n    iex> bsl(-1, -2)\n    -1","prompt":"Can you write a docstring for the following Elixir function? bsl(left, right)"}
{"completion":"Calculates the result of an arithmetic right bitshift.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> bsr(1, 2)\n    0\n\n    iex> bsr(1, -2)\n    4\n\n    iex> bsr(-1, 2)\n    -1\n\n    iex> bsr(-1, -2)\n    -4","prompt":"Can you write a docstring for the following Elixir function? bsr(left, right)"}
{"completion":"Calculates the bitwise XOR of its arguments.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> bxor(9, 3)\n    10","prompt":"Can you write a docstring for the following Elixir function? bxor(left, right)"}
{"completion":"Bitwise OR operator.\n\nCalculates the bitwise OR of its arguments.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 9 ||| 3\n    11","prompt":"Can you write a docstring for the following Elixir function? left ||| right"}
{"completion":"A set of functions that perform calculations on bits.\n\nAll bitwise functions work only on integers; otherwise an\n`ArithmeticError` is raised. The functions `band/2`,\n`bor/2`, `bsl/2`, and `bsr/2` also have operators,\nrespectively: `&&&/2`, `|||/2`, `<<</2`, and `>>>/2`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Bitwise"}
{"completion":"Guards\n\nAll bitwise functions can be used in guards:\n\n    iex> odd? = fn\n    ...>   int when Bitwise.band(int, 1) == 1 -> true\n    ...>   _ -> false\n    ...> end\n    iex> odd?.(1)\n    true\n\nAll functions in this module are inlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Bitwise"}
{"completion":"Converts the given date into a string.\n\nBy default, returns dates formatted in the \"extended\" format,\nfor human readability. It also supports the \"basic\" format\nby passing the `:basic` option.\n\n## Examples\n\n    iex> Calendar.ISO.date_to_string(2015, 2, 28)\n    \"2015-02-28\"\n    iex> Calendar.ISO.date_to_string(2017, 8, 1)\n    \"2017-08-01\"\n    iex> Calendar.ISO.date_to_string(-99, 1, 31)\n    \"-0099-01-31\"\n\n    iex> Calendar.ISO.date_to_string(2015, 2, 28, :basic)\n    \"20150228\"\n    iex> Calendar.ISO.date_to_string(-99, 1, 31, :basic)\n    \"-00990131\"","prompt":"Can you write a docstring for the following Elixir function? date_to_string(year, month, day, format \\\\ :extended)"}
{"completion":"Converts the datetime (with time zone) into a string.\n\nBy default, returns datetimes formatted in the \"extended\" format,\nfor human readability. It also supports the \"basic\" format\nby passing the `:basic` option.\n\n## Examples\n\n    iex> time_zone = \"Etc/UTC\"\n    iex> Calendar.ISO.datetime_to_string(2017, 8, 1, 1, 2, 3, {4, 5}, time_zone, \"UTC\", 0, 0)\n    \"2017-08-01 01:02:03.00000Z\"\n    iex> Calendar.ISO.datetime_to_string(2017, 8, 1, 1, 2, 3, {4, 5}, time_zone, \"UTC\", 3600, 0)\n    \"2017-08-01 01:02:03.00000+01:00\"\n    iex> Calendar.ISO.datetime_to_string(2017, 8, 1, 1, 2, 3, {4, 5}, time_zone, \"UTC\", 3600, 3600)\n    \"2017-08-01 01:02:03.00000+02:00\"\n\n    iex> time_zone = \"Europe/Berlin\"\n    iex> Calendar.ISO.datetime_to_string(2017, 8, 1, 1, 2, 3, {4, 5}, time_zone, \"CET\", 3600, 0)\n    \"2017-08-01 01:02:03.00000+01:00 CET Europe/Berlin\"\n    iex> Calendar.ISO.datetime_to_string(2017, 8, 1, 1, 2, 3, {4, 5}, time_zone, \"CDT\", 3600, 3600)\n    \"2017-08-01 01:02:03.00000+02:00 CDT Europe/Berlin\"\n\n    iex> time_zone = \"America/Los_Angeles\"\n    iex> Calendar.ISO.datetime_to_string(2015, 2, 28, 1, 2, 3, {4, 5}, time_zone, \"PST\", -28800, 0)\n    \"2015-02-28 01:02:03.00000-08:00 PST America/Los_Angeles\"\n    iex> Calendar.ISO.datetime_to_string(2015, 2, 28, 1, 2, 3, {4, 5}, time_zone, \"PDT\", -28800, 3600)\n    \"2015-02-28 01:02:03.00000-07:00 PDT America/Los_Angeles\"\n\n    iex> time_zone = \"Europe/Berlin\"\n    iex> Calendar.ISO.datetime_to_string(2017, 8, 1, 1, 2, 3, {4, 5}, time_zone, \"CET\", 3600, 0, :basic)\n    \"20170801 010203.00000+0100 CET Europe/Berlin\"","prompt":"Can you write a docstring for the following Elixir function? datetime_to_string(year, month, day, hour, minute, second, microsecond, time_zone, zone_abbr, utc_offset, std_offset, format \\\\ :extended)"}
{"completion":"Calculates the day and era from the given `year`, `month`, and `day`.\n\n## Examples\n\n    iex> Calendar.ISO.day_of_era(0, 1, 1)\n    {366, 0}\n    iex> Calendar.ISO.day_of_era(1, 1, 1)\n    {1, 1}\n    iex> Calendar.ISO.day_of_era(0, 12, 31)\n    {1, 0}\n    iex> Calendar.ISO.day_of_era(0, 12, 30)\n    {2, 0}\n    iex> Calendar.ISO.day_of_era(-1, 12, 31)\n    {367, 0}","prompt":"Can you write a docstring for the following Elixir function? day_of_era(year, month, day)"}
{"completion":"Calculates the day of the week from the given `year`, `month`, and `day`.\n\nIt is an integer from 1 to 7, where 1 is the given `starting_on` weekday.\nFor example, if `starting_on` is set to `:monday`, then 1 is Monday and\n7 is Sunday.\n\n`starting_on` can also be `:default`, which is equivalent to `:monday`.\n\n## Examples\n\n    iex> Calendar.ISO.day_of_week(2016, 10, 31, :monday)\n    {1, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 1, :monday)\n    {2, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 2, :monday)\n    {3, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 3, :monday)\n    {4, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 4, :monday)\n    {5, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 5, :monday)\n    {6, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 6, :monday)\n    {7, 1, 7}\n    iex> Calendar.ISO.day_of_week(-99, 1, 31, :monday)\n    {4, 1, 7}\n\n    iex> Calendar.ISO.day_of_week(2016, 10, 31, :sunday)\n    {2, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 1, :sunday)\n    {3, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 2, :sunday)\n    {4, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 3, :sunday)\n    {5, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 4, :sunday)\n    {6, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 5, :sunday)\n    {7, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 6, :sunday)\n    {1, 1, 7}\n    iex> Calendar.ISO.day_of_week(-99, 1, 31, :sunday)\n    {5, 1, 7}\n\n    iex> Calendar.ISO.day_of_week(2016, 10, 31, :saturday)\n    {3, 1, 7}","prompt":"Can you write a docstring for the following Elixir function? day_of_week(year, month, day, starting_on)"}
{"completion":"Calculates the day of the year from the given `year`, `month`, and `day`.\n\nIt is an integer from 1 to 366.\n\n## Examples\n\n    iex> Calendar.ISO.day_of_year(2016, 1, 31)\n    31\n    iex> Calendar.ISO.day_of_year(-99, 2, 1)\n    32\n    iex> Calendar.ISO.day_of_year(2018, 2, 28)\n    59","prompt":"Can you write a docstring for the following Elixir function? day_of_year(year, month, day)"}
{"completion":"See `c:Calendar.day_rollover_relative_to_midnight_utc/0` for documentation.","prompt":"Can you write a docstring for the following Elixir function? day_rollover_relative_to_midnight_utc()"}
{"completion":"Returns how many days there are in the given year-month.\n\n## Examples\n\n    iex> Calendar.ISO.days_in_month(1900, 1)\n    31\n    iex> Calendar.ISO.days_in_month(1900, 2)\n    28\n    iex> Calendar.ISO.days_in_month(2000, 2)\n    29\n    iex> Calendar.ISO.days_in_month(2001, 2)\n    28\n    iex> Calendar.ISO.days_in_month(2004, 2)\n    29\n    iex> Calendar.ISO.days_in_month(2004, 4)\n    30\n    iex> Calendar.ISO.days_in_month(-1, 5)\n    31","prompt":"Can you write a docstring for the following Elixir function? days_in_month(year, month)"}
{"completion":"Returns if the given year is a leap year.\n\n## Examples\n\n    iex> Calendar.ISO.leap_year?(2000)\n    true\n    iex> Calendar.ISO.leap_year?(2001)\n    false\n    iex> Calendar.ISO.leap_year?(2004)\n    true\n    iex> Calendar.ISO.leap_year?(1900)\n    false\n    iex> Calendar.ISO.leap_year?(-4)\n    true","prompt":"Can you write a docstring for the following Elixir function? leap_year?(year)"}
{"completion":"Returns how many months there are in the given year.\n\n## Example\n\n    iex> Calendar.ISO.months_in_year(2004)\n    12","prompt":"Can you write a docstring for the following Elixir function? months_in_year(year)"}
{"completion":"Converts the `t:Calendar.iso_days/0` format to the datetime format specified by this calendar.\n\n## Examples\n\n    iex> Calendar.ISO.naive_datetime_from_iso_days({0, {0, 86400}})\n    {0, 1, 1, 0, 0, 0, {0, 6}}\n    iex> Calendar.ISO.naive_datetime_from_iso_days({730_485, {0, 86400}})\n    {2000, 1, 1, 0, 0, 0, {0, 6}}\n    iex> Calendar.ISO.naive_datetime_from_iso_days({730_485, {43200, 86400}})\n    {2000, 1, 1, 12, 0, 0, {0, 6}}\n    iex> Calendar.ISO.naive_datetime_from_iso_days({-365, {0, 86400000000}})\n    {-1, 1, 1, 0, 0, 0, {0, 6}}","prompt":"Can you write a docstring for the following Elixir function? naive_datetime_from_iso_days(arg)"}
{"completion":"Returns the `t:Calendar.iso_days/0` format of the specified date.\n\n## Examples\n\n    iex> Calendar.ISO.naive_datetime_to_iso_days(0, 1, 1, 0, 0, 0, {0, 6})\n    {0, {0, 86400000000}}\n    iex> Calendar.ISO.naive_datetime_to_iso_days(2000, 1, 1, 12, 0, 0, {0, 6})\n    {730485, {43200000000, 86400000000}}\n    iex> Calendar.ISO.naive_datetime_to_iso_days(2000, 1, 1, 13, 0, 0, {0, 6})\n    {730485, {46800000000, 86400000000}}\n    iex> Calendar.ISO.naive_datetime_to_iso_days(-1, 1, 1, 0, 0, 0, {0, 6})\n    {-365, {0, 86400000000}}","prompt":"Can you write a docstring for the following Elixir function? naive_datetime_to_iso_days(year, month, day, hour, minute, second, microsecond)"}
{"completion":"Converts the datetime (without time zone) into a string.\n\nBy default, returns datetimes formatted in the \"extended\" format,\nfor human readability. It also supports the \"basic\" format\nby passing the `:basic` option.\n\n## Examples\n\n    iex> Calendar.ISO.naive_datetime_to_string(2015, 2, 28, 1, 2, 3, {4, 6})\n    \"2015-02-28 01:02:03.000004\"\n    iex> Calendar.ISO.naive_datetime_to_string(2017, 8, 1, 1, 2, 3, {4, 5})\n    \"2017-08-01 01:02:03.00000\"\n\n    iex> Calendar.ISO.naive_datetime_to_string(2015, 2, 28, 1, 2, 3, {4, 6}, :basic)\n    \"20150228 010203.000004\"","prompt":"Can you write a docstring for the following Elixir function? naive_datetime_to_string(year, month, day, hour, minute, second, microsecond, format \\\\ :extended)"}
{"completion":"Parses a date `string` in the `:extended` format.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).\n\n## Examples\n\n    iex> Calendar.ISO.parse_date(\"2015-01-23\")\n    {:ok, {2015, 1, 23}}\n\n    iex> Calendar.ISO.parse_date(\"2015:01:23\")\n    {:error, :invalid_format}\n    iex> Calendar.ISO.parse_date(\"2015-01-32\")\n    {:error, :invalid_date}","prompt":"Can you write a docstring for the following Elixir function? parse_date(string)"}
{"completion":"Parses a date `string` according to a given `format`.\n\nThe `format` can either be `:basic` or `:extended`.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).\n\n## Examples\n\n    iex> Calendar.ISO.parse_date(\"20150123\", :basic)\n    {:ok, {2015, 1, 23}}\n    iex> Calendar.ISO.parse_date(\"20150123\", :extended)\n    {:error, :invalid_format}","prompt":"Can you write a docstring for the following Elixir function? parse_date(string, format)"}
{"completion":"Parses a naive datetime `string` in the `:extended` format.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).\n\n## Examples\n\n    iex> Calendar.ISO.parse_naive_datetime(\"2015-01-23 23:50:07\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_naive_datetime(\"2015-01-23 23:50:07Z\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_naive_datetime(\"2015-01-23 23:50:07-02:30\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}}\n\n    iex> Calendar.ISO.parse_naive_datetime(\"2015-01-23 23:50:07.0\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 1}}}\n    iex> Calendar.ISO.parse_naive_datetime(\"2015-01-23 23:50:07,0123456\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {12345, 6}}}","prompt":"Can you write a docstring for the following Elixir function? parse_naive_datetime(string)"}
{"completion":"Parses a naive datetime `string` according to a given `format`.\n\nThe `format` can either be `:basic` or `:extended`.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).\n\n## Examples\n\n    iex> Calendar.ISO.parse_naive_datetime(\"20150123 235007\", :basic)\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_naive_datetime(\"20150123 235007\", :extended)\n    {:error, :invalid_format}","prompt":"Can you write a docstring for the following Elixir function? parse_naive_datetime(string, format)"}
{"completion":"Parses a time `string` in the `:extended` format.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).\n\n## Examples\n\n    iex> Calendar.ISO.parse_time(\"23:50:07\")\n    {:ok, {23, 50, 7, {0, 0}}}\n\n    iex> Calendar.ISO.parse_time(\"23:50:07Z\")\n    {:ok, {23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_time(\"T23:50:07Z\")\n    {:ok, {23, 50, 7, {0, 0}}}","prompt":"Can you write a docstring for the following Elixir function? parse_time(string)"}
{"completion":"Parses a time `string` according to a given `format`.\n\nThe `format` can either be `:basic` or `:extended`.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).\n\n## Examples\n\n    iex> Calendar.ISO.parse_time(\"235007\", :basic)\n    {:ok, {23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_time(\"235007\", :extended)\n    {:error, :invalid_format}","prompt":"Can you write a docstring for the following Elixir function? parse_time(string, format)"}
{"completion":"Parses a UTC datetime `string` in the `:extended` format.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).\n\n## Examples\n\n    iex> Calendar.ISO.parse_utc_datetime(\"2015-01-23 23:50:07Z\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}, 0}\n\n    iex> Calendar.ISO.parse_utc_datetime(\"2015-01-23 23:50:07+02:30\")\n    {:ok, {2015, 1, 23, 21, 20, 7, {0, 0}}, 9000}\n\n    iex> Calendar.ISO.parse_utc_datetime(\"2015-01-23 23:50:07\")\n    {:error, :missing_offset}","prompt":"Can you write a docstring for the following Elixir function? parse_utc_datetime(string)"}
{"completion":"Parses a UTC datetime `string` according to a given `format`.\n\nThe `format` can either be `:basic` or `:extended`.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).\n\n## Examples\n\n    iex> Calendar.ISO.parse_utc_datetime(\"20150123 235007Z\", :basic)\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}, 0}\n    iex> Calendar.ISO.parse_utc_datetime(\"20150123 235007Z\", :extended)\n    {:error, :invalid_format}","prompt":"Can you write a docstring for the following Elixir function? parse_utc_datetime(string, format)"}
{"completion":"Calculates the quarter of the year from the given `year`, `month`, and `day`.\n\nIt is an integer from 1 to 4.\n\n## Examples\n\n    iex> Calendar.ISO.quarter_of_year(2016, 1, 31)\n    1\n    iex> Calendar.ISO.quarter_of_year(2016, 4, 3)\n    2\n    iex> Calendar.ISO.quarter_of_year(-99, 9, 31)\n    3\n    iex> Calendar.ISO.quarter_of_year(2018, 12, 28)\n    4","prompt":"Can you write a docstring for the following Elixir function? quarter_of_year(year, month, day)"}
{"completion":"Converts a day fraction to this Calendar's representation of time.\n\n## Examples\n\n    iex> Calendar.ISO.time_from_day_fraction({1, 2})\n    {12, 0, 0, {0, 6}}\n    iex> Calendar.ISO.time_from_day_fraction({13, 24})\n    {13, 0, 0, {0, 6}}","prompt":"Can you write a docstring for the following Elixir function? time_from_day_fraction(arg)"}
{"completion":"Returns the normalized day fraction of the specified time.\n\n## Examples\n\n    iex> Calendar.ISO.time_to_day_fraction(0, 0, 0, {0, 6})\n    {0, 86400000000}\n    iex> Calendar.ISO.time_to_day_fraction(12, 34, 56, {123, 6})\n    {45296000123, 86400000000}","prompt":"Can you write a docstring for the following Elixir function? time_to_day_fraction(hour, minute, second, arg)"}
{"completion":"Converts the given time into a string.\n\nBy default, returns times formatted in the \"extended\" format,\nfor human readability. It also supports the \"basic\" format\nby passing the `:basic` option.\n\n## Examples\n\n    iex> Calendar.ISO.time_to_string(2, 2, 2, {2, 6})\n    \"02:02:02.000002\"\n    iex> Calendar.ISO.time_to_string(2, 2, 2, {2, 2})\n    \"02:02:02.00\"\n    iex> Calendar.ISO.time_to_string(2, 2, 2, {2, 0})\n    \"02:02:02\"\n\n    iex> Calendar.ISO.time_to_string(2, 2, 2, {2, 6}, :basic)\n    \"020202.000002\"\n    iex> Calendar.ISO.time_to_string(2, 2, 2, {2, 6}, :extended)\n    \"02:02:02.000002\"","prompt":"Can you write a docstring for the following Elixir function? time_to_string(hour, minute, second, microsecond, format \\\\ :extended)"}
{"completion":"Converts a `t:System.time_unit/0` to precision.\n\nInteger-based time units always get maximum precision.","prompt":"Can you write a docstring for the following Elixir function? time_unit_to_precision(arg1)"}
{"completion":"Determines if the date given is valid according to the proleptic Gregorian calendar.\n\n## Examples\n\n    iex> Calendar.ISO.valid_date?(2015, 2, 28)\n    true\n    iex> Calendar.ISO.valid_date?(2015, 2, 30)\n    false\n    iex> Calendar.ISO.valid_date?(-1, 12, 31)\n    true\n    iex> Calendar.ISO.valid_date?(-1, 12, 32)\n    false","prompt":"Can you write a docstring for the following Elixir function? valid_date?(year, month, day)"}
{"completion":"Determines if the date given is valid according to the proleptic Gregorian calendar.\n\nLeap seconds are not supported by the built-in Calendar.ISO.\n\n## Examples\n\n    iex> Calendar.ISO.valid_time?(10, 50, 25, {3006, 6})\n    true\n    iex> Calendar.ISO.valid_time?(23, 59, 60, {0, 0})\n    false\n    iex> Calendar.ISO.valid_time?(24, 0, 0, {0, 0})\n    false","prompt":"Can you write a docstring for the following Elixir function? valid_time?(hour, minute, second, microsecond)"}
{"completion":"Calculates the year and era from the given `year`.\n\nThe ISO calendar has two eras: the \"current era\" (CE) which\nstarts in year `1` and is defined as era `1`. And \"before the current\nera\" (BCE) for those years less than `1`, defined as era `0`.\n\n## Examples\n\n    iex> Calendar.ISO.year_of_era(1)\n    {1, 1}\n    iex> Calendar.ISO.year_of_era(2018)\n    {2018, 1}\n    iex> Calendar.ISO.year_of_era(0)\n    {1, 0}\n    iex> Calendar.ISO.year_of_era(-1)\n    {2, 0}","prompt":"Can you write a docstring for the following Elixir function? year_of_era(year)"}
{"completion":"Calendar callback to compute the year and era from the\ngiven `year`, `month` and `day`.\n\nIn the ISO calendar, the new year coincides with the new era,\nso the `month` and `day` arguments are discarded. If you only\nhave the year available, you can `year_of_era/1` instead.\n\n## Examples\n\n    iex> Calendar.ISO.year_of_era(1, 1, 1)\n    {1, 1}\n    iex> Calendar.ISO.year_of_era(2018, 12, 1)\n    {2018, 1}\n    iex> Calendar.ISO.year_of_era(0, 1, 1)\n    {1, 0}\n    iex> Calendar.ISO.year_of_era(-1, 12, 1)\n    {2, 0}","prompt":"Can you write a docstring for the following Elixir function? year_of_era(year, month, day)"}
{"completion":"The default calendar implementation, a Gregorian calendar following ISO 8601.\n\nThis calendar implements a proleptic Gregorian calendar and\nis therefore compatible with the calendar used in most countries\ntoday. The proleptic means the Gregorian rules for leap years are\napplied for all time, consequently the dates give different results\nbefore the year 1583 from when the Gregorian calendar was adopted.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Calendar.ISO"}
{"completion":"ISO 8601 compliance\n\nThe ISO 8601 specification is feature-rich, but allows applications\nto selectively implement most parts of it. The choices Elixir makes\nare catalogued below.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Calendar.ISO"}
{"completion":"# Features\n\nThe standard library supports a minimal set of possible ISO 8601 features.\nSpecifically, the parser only supports calendar dates and does not support\nordinal and week formats.\n\nBy default Elixir only parses extended-formatted date/times. You can opt-in\nto parse basic-formatted date/times.\n\n`NaiveDateTime.to_iso8601/2` and `DateTime.to_iso8601/2` allow you to produce\neither basic or extended formatted strings, and `Calendar.strftime/2` allows\nyou to format datetimes however else you desire.\n\nElixir does not support reduced accuracy formats (for example, a date without\nthe day component) nor decimal precisions in the lowest component (such as\n`10:01:25,5`). No functions exist to parse ISO 8601 durations or time intervals.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Calendar.ISO"}
{"completion":"## Examples\n\nElixir expects the extended format by default when parsing:\n\n    iex> Calendar.ISO.parse_naive_datetime(\"2015-01-23T23:50:07\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_naive_datetime(\"20150123T235007\")\n    {:error, :invalid_format}\n\nParsing can be restricted to basic if desired:\n\n    iex> Calendar.ISO.parse_naive_datetime(\"20150123T235007Z\", :basic)\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_naive_datetime(\"20150123T235007Z\", :extended)\n    {:error, :invalid_format}\n\nOnly calendar dates are supported in parsing; ordinal and week dates are not.\n\n    iex> Calendar.ISO.parse_date(\"2015-04-15\")\n    {:ok, {2015, 4, 15}}\n    iex> Calendar.ISO.parse_date(\"2015-105\")\n    {:error, :invalid_format}\n    iex> Calendar.ISO.parse_date(\"2015-W16\")\n    {:error, :invalid_format}\n    iex> Calendar.ISO.parse_date(\"2015-W016-3\")\n    {:error, :invalid_format}\n\nYears, months, days, hours, minutes, and seconds must be fully specified:\n\n    iex> Calendar.ISO.parse_date(\"2015-04-15\")\n    {:ok, {2015, 4, 15}}\n    iex> Calendar.ISO.parse_date(\"2015-04\")\n    {:error, :invalid_format}\n    iex> Calendar.ISO.parse_date(\"2015\")\n    {:error, :invalid_format}\n\n    iex> Calendar.ISO.parse_time(\"23:50:07.0123456\")\n    {:ok, {23, 50, 7, {12345, 6}}}\n    iex> Calendar.ISO.parse_time(\"23:50:07\")\n    {:ok, {23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_time(\"23:50\")\n    {:error, :invalid_format}\n    iex> Calendar.ISO.parse_time(\"23\")\n    {:error, :invalid_format}","prompt":"Can you write a docstring for the following Elixir function? Elixir.Calendar.ISO"}
{"completion":"# Extensions\n\nThe parser and formatter adopt one ISO 8601 extension: extended year notation.\n\nThis allows dates to be prefixed with a `+` or `-` sign, extending the range of\nexpressible years from the default (`0000..9999`) to `-9999..9999`. Elixir still\nrestricts years in this format to four digits.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Calendar.ISO"}
{"completion":"## Examples\n\n    iex> Calendar.ISO.parse_date(\"-2015-01-23\")\n    {:ok, {-2015, 1, 23}}\n    iex> Calendar.ISO.parse_date(\"+2015-01-23\")\n    {:ok, {2015, 1, 23}}\n\n    iex> Calendar.ISO.parse_naive_datetime(\"-2015-01-23 23:50:07\")\n    {:ok, {-2015, 1, 23, 23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_naive_datetime(\"+2015-01-23 23:50:07\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}}\n\n    iex> Calendar.ISO.parse_utc_datetime(\"-2015-01-23 23:50:07Z\")\n    {:ok, {-2015, 1, 23, 23, 50, 7, {0, 0}}, 0}\n    iex> Calendar.ISO.parse_utc_datetime(\"+2015-01-23 23:50:07Z\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}, 0}","prompt":"Can you write a docstring for the following Elixir function? Elixir.Calendar.ISO"}
{"completion":"# Additions\n\nISO 8601 does not allow a whitespace instead of `T` as a separator\nbetween date and times, both when parsing and formatting.\nThis is a common enough representation, Elixir allows it during parsing.\n\nThe formatting of dates in `NaiveDateTime.to_iso8601/1` and `DateTime.to_iso8601/1`\ndo produce specification-compliant string representations using the `T` separator.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Calendar.ISO"}
{"completion":"## Examples\n\n    iex> Calendar.ISO.parse_naive_datetime(\"2015-01-23 23:50:07.0123456\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {12345, 6}}}\n    iex> Calendar.ISO.parse_naive_datetime(\"2015-01-23T23:50:07.0123456\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {12345, 6}}}\n\n    iex> Calendar.ISO.parse_utc_datetime(\"2015-01-23 23:50:07.0123456Z\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {12345, 6}}, 0}\n    iex> Calendar.ISO.parse_utc_datetime(\"2015-01-23T23:50:07.0123456Z\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {12345, 6}}, 0}","prompt":"Can you write a docstring for the following Elixir function? Elixir.Calendar.ISO"}
{"completion":"This module defines a behaviour for providing time zone data.\n\nIANA provides time zone data that includes data about different\nUTC offsets and standard offsets for time zones.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Calendar.TimeZoneDatabase"}
{"completion":"Built-in time zone database that works only in Etc/UTC.\n\nFor all other time zones, it returns `{:error, :utc_only_time_zone_database}`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Calendar.UTCOnlyTimeZoneDatabase"}
{"completion":"Returns `true` if two calendars have the same moment of starting a new day,\n`false` otherwise.\n\nIf two calendars are not compatible, we can only convert datetimes and times\nbetween them. If they are compatible, this means that we can also convert\ndates as well as naive datetimes between them.","prompt":"Can you write a docstring for the following Elixir function? compatible_calendars?(calendar, calendar)"}
{"completion":"Gets the current time zone database.","prompt":"Can you write a docstring for the following Elixir function? get_time_zone_database()"}
{"completion":"Sets the current time zone database.","prompt":"Can you write a docstring for the following Elixir function? put_time_zone_database(database)"}
{"completion":"Formats received datetime into a string.\n\nThe datetime can be any of the Calendar types (`Time`, `Date`,\n`NaiveDateTime`, and `DateTime`) or any map, as long as they\ncontain all of the relevant fields necessary for formatting.\nFor example, if you use `%Y` to format the year, the datetime\nmust have the `:year` field. Therefore, if you pass a `Time`,\nor a map without the `:year` field to a format that expects `%Y`,\nan error will be raised.\n\n## Options\n\n  * `:preferred_datetime` - a string for the preferred format to show datetimes,\n    it can't contain the `%c` format and defaults to `\"%Y-%m-%d %H:%M:%S\"`\n    if the option is not received\n\n  * `:preferred_date` - a string for the preferred format to show dates,\n    it can't contain the `%x` format and defaults to `\"%Y-%m-%d\"`\n    if the option is not received\n\n  * `:preferred_time` - a string for the preferred format to show times,\n    it can't contain the `%X` format and defaults to `\"%H:%M:%S\"`\n    if the option is not received\n\n  * `:am_pm_names` - a function that receives either `:am` or `:pm` and returns\n    the name of the period of the day, if the option is not received it defaults\n    to a function that returns `\"am\"` and `\"pm\"`, respectively\n\n  *  `:month_names` - a function that receives a number and returns the name of\n    the corresponding month, if the option is not received it defaults to a\n    function that returns the month names in English\n\n  * `:abbreviated_month_names` - a function that receives a number and returns the\n    abbreviated name of the corresponding month, if the option is not received it\n    defaults to a function that returns the abbreviated month names in English\n\n  * `:day_of_week_names` - a function that receives a number and returns the name of\n    the corresponding day of week, if the option is not received it defaults to a\n    function that returns the day of week names in English\n\n  * `:abbreviated_day_of_week_names` - a function that receives a number and returns\n    the abbreviated name of the corresponding day of week, if the option is not received\n    it defaults to a function that returns the abbreviated day of week names in English\n\n## Formatting syntax\n\nThe formatting syntax for strftime is a sequence of characters in the following format:\n\n    %<padding><width><format>\n\nwhere:\n\n  * `%`: indicates the start of a formatted section\n  * `<padding>`: set the padding (see below)\n  * `<width>`: a number indicating the minimum size of the formatted section\n  * `<format>`: the format itself (see below)\n\n### Accepted padding options\n\n  * `-`: no padding, removes all padding from the format\n  * `_`: pad with spaces\n  * `0`: pad with zeroes\n\n### Accepted formats\n\nThe accepted formats are:\n\nFormat | Description                                                             | Examples (in ISO)\n:----- | :-----------------------------------------------------------------------| :------------------------\na      | Abbreviated name of day                                                 | Mon\nA      | Full name of day                                                        | Monday\nb      | Abbreviated month name                                                  | Jan\nB      | Full month name                                                         | January\nc      | Preferred date+time representation                                      | 2018-10-17 12:34:56\nd      | Day of the month                                                        | 01, 31\nf      | Microseconds *(does not support width and padding modifiers)*           | 000000, 999999, 0123\nH      | Hour using a 24-hour clock                                              | 00, 23\nI      | Hour using a 12-hour clock                                              | 01, 12\nj      | Day of the year                                                         | 001, 366\nm      | Month                                                                   | 01, 12\nM      | Minute                                                                  | 00, 59\np      | \"AM\" or \"PM\" (noon is \"PM\", midnight as \"AM\")                           | AM, PM\nP      | \"am\" or \"pm\" (noon is \"pm\", midnight as \"am\")                           | am, pm\nq      | Quarter                                                                 | 1, 2, 3, 4\nS      | Second                                                                  | 00, 59, 60\nu      | Day of the week                                                         | 1 (Monday), 7 (Sunday)\nx      | Preferred date (without time) representation                            | 2018-10-17\nX      | Preferred time (without date) representation                            | 12:34:56\ny      | Year as 2-digits                                                        | 01, 01, 86, 18\nY      | Year                                                                    | -0001, 0001, 1986\nz      | +hhmm/-hhmm time zone offset from UTC (empty string if naive)           | +0300, -0530\nZ      | Time zone abbreviation (empty string if naive)                          | CET, BRST\n%      | Literal \"%\" character                                                   | %\n\nAny other character will be interpreted as an invalid format and raise an error\n\n## Examples\n\nWithout options:\n\n    iex> Calendar.strftime(~U[2019-08-26 13:52:06.0Z], \"%y-%m-%d %I:%M:%S %p\")\n    \"19-08-26 01:52:06 PM\"\n\n    iex> Calendar.strftime(~U[2019-08-26 13:52:06.0Z], \"%a, %B %d %Y\")\n    \"Mon, August 26 2019\"\n\n    iex> Calendar.strftime(~U[2020-04-02 13:52:06.0Z], \"%B %-d, %Y\")\n    \"April 2, 2020\"\n\n    iex> Calendar.strftime(~U[2019-08-26 13:52:06.0Z], \"%c\")\n    \"2019-08-26 13:52:06\"\n\nWith options:\n\n    iex> Calendar.strftime(~U[2019-08-26 13:52:06.0Z], \"%c\", preferred_datetime: \"%H:%M:%S %d-%m-%y\")\n    \"13:52:06 26-08-19\"\n\n    iex> Calendar.strftime(\n    ...>  ~U[2019-08-26 13:52:06.0Z],\n    ...>  \"%A\",\n    ...>  day_of_week_names: fn day_of_week ->\n    ...>    {\"segunda-feira\", \"tera-feira\", \"quarta-feira\", \"quinta-feira\",\n    ...>    \"sexta-feira\", \"sbado\", \"domingo\"}\n    ...>    |> elem(day_of_week - 1)\n    ...>  end\n    ...>)\n    \"segunda-feira\"\n\n    iex> Calendar.strftime(\n    ...>  ~U[2019-08-26 13:52:06.0Z],\n    ...>  \"%B\",\n    ...>  month_names: fn month ->\n    ...>    {\"\", \"\", \"\", \"\", \"\", \"\",\n    ...>    \"\", \"\", \"\", \"\", \"\", \"\"}\n    ...>    |> elem(month - 1)\n    ...>  end\n    ...>)\n    \"\"","prompt":"Can you write a docstring for the following Elixir function? strftime(date_or_time_or_datetime, string_format, user_options \\\\ [])"}
{"completion":"Returns a microsecond tuple truncated to a given precision (`:microsecond`,\n`:millisecond` or `:second`).","prompt":"Can you write a docstring for the following Elixir function? truncate(microsecond_tuple, atom)"}
{"completion":"This module defines the responsibilities for working with\ncalendars, dates, times and datetimes in Elixir.\n\nCurrently it defines types and the minimal implementation\nfor a calendar behaviour in Elixir. The goal of the Calendar\nfeatures in Elixir is to provide a base for interoperability\ninstead of full-featured datetime API.\n\nFor the actual date, time and datetime structures, see `Date`,\n`Time`, `NaiveDateTime` and `DateTime`.\n\nNote designations for year, month, day, and the like, are overspecified\n(i.e. an integer instead of `1..12` for months) because different\ncalendars may have a different number of days per month, months per year and so on.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Calendar"}
{"completion":"Checks if a function is a local without parens.","prompt":"Can you write a docstring for the following Elixir function? local_without_parens?(fun, arity, locals_without_parens)"}
{"completion":"Lists all default locals without parens.","prompt":"Can you write a docstring for the following Elixir function? locals_without_parens()"}
{"completion":"Converts the quoted expression into an algebra document.","prompt":"Can you write a docstring for the following Elixir function? to_algebra(quoted, opts \\\\ [])"}
{"completion":"Receives a string and returns a quoted expression\nwith a cursor at the nearest argument position.\n\nThis function receives a string with an Elixir code fragment,\nrepresenting a cursor position, and converts such string to\nAST with the inclusion of special `__cursor__()` node based\non the position of the cursor with a container.\n\nA container is any Elixir expression starting with `(`,\n`{`, and `[`. This includes function calls, tuples, lists,\nmaps, and so on. For example, take this code, which would\nbe given as input:\n\n    max(some_value,\n\nThis function will return the AST equivalent to:\n\n    max(some_value, __cursor__())\n\nIn other words, this function is capable of closing any open\nbrackets and insert the cursor position. Any content at the\ncursor position that is after a comma or an opening bracket\nis discarded. For example, if this is given as input:\n\n    max(some_value, another_val\n\nIt will return the same AST:\n\n    max(some_value, __cursor__())\n\nSimilarly, if only this is given:\n\n    max(some_va\n\nThen it returns:\n\n    max(__cursor__())\n\nCalls without parenthesis are also supported, as we assume the\nbrackets are implicit.\n\nOperators and anonymous functions are not containers, and therefore\nwill be discarded. The following will all return the same AST:\n\n    max(some_value,\n    max(some_value, fn x -> x end\n    max(some_value, 1 + another_val\n    max(some_value, 1 |> some_fun() |> another_fun\n\nOn the other hand, tuples, lists, maps, and binaries all retain the\ncursor position:\n\n    max(some_value, [1, 2,\n\nReturns the following AST:\n\n    max(some_value, [1, 2, __cursor__()])\n\nKeyword lists (and do-end blocks) are also retained. The following:\n\n    if(some_value, do:\n    if(some_value, do: :token\n    if(some_value, do: 1 + val\n\nall return:\n\n    if(some_value, do: __cursor__())\n\nThe AST returned by this function is not safe to evaluate but\nit can be analyzed and expanded.\n\n## Examples\n\nFunction call:\n\n    iex> Code.Fragment.container_cursor_to_quoted(\"max(some_value, \")\n    {:ok, {:max, [line: 1], [{:some_value, [line: 1], nil}, {:__cursor__, [line: 1], []}]}}\n\nContainers (for example, a list):\n\n    iex> Code.Fragment.container_cursor_to_quoted(\"[some, value\")\n    {:ok, [{:some, [line: 1], nil}, {:__cursor__, [line: 1], []}]}\n\nFor binaries, the `::` is exclusively kept as an operator:\n\n    iex> Code.Fragment.container_cursor_to_quoted(\"<<some::integer\")\n    {:ok, {:<<>>, [line: 1], [{:\"::\", [line: 1], [{:some, [line: 1], nil}, {:__cursor__, [line: 1], []}]}]}}\n\n## Options\n\n  * `:file` - the filename to be reported in case of parsing errors.\n    Defaults to `\"nofile\"`.\n\n  * `:line` - the starting line of the string being parsed.\n    Defaults to 1.\n\n  * `:column` - the starting column of the string being parsed.\n    Defaults to 1.\n\n  * `:columns` - when `true`, attach a `:column` key to the quoted\n    metadata. Defaults to `false`.\n\n  * `:token_metadata` - when `true`, includes token-related\n    metadata in the expression AST, such as metadata for `do` and `end`\n    tokens, for closing tokens, end of expressions, as well as delimiters\n    for sigils. See `t:Macro.metadata/0`. Defaults to `false`.\n\n  * `:literal_encoder` - a function to encode literals in the AST.\n    See the documentation for `Code.string_to_quoted/2` for more information.","prompt":"Can you write a docstring for the following Elixir function? container_cursor_to_quoted(fragment, opts \\\\ [])"}
{"completion":"Receives a string and returns the cursor context.\n\nThis function receives a string with an Elixir code fragment,\nrepresenting a cursor position, and based on the string, it\nprovides contextual information about said position. The\nreturn of this function can then be used to provide tips,\nsuggestions, and autocompletion functionality.\n\nThis function provides a best-effort detection and may not be\naccurate under all circumstances. See the \"Limitations\"\nsection below.\n\nConsider adding a catch-all clause when handling the return\ntype of this function as new cursor information may be added\nin future releases.\n\n## Examples\n\n    iex> Code.Fragment.cursor_context(\"\")\n    :expr\n\n    iex> Code.Fragment.cursor_context(\"hello_wor\")\n    {:local_or_var, 'hello_wor'}\n\n## Return values\n\n  * `{:alias, charlist}` - the context is an alias, potentially\n    a nested one, such as `Hello.Wor` or `HelloWor`\n\n  * `{:alias, inside_alias, charlist}` - the context is an alias, potentially\n    a nested one, where `inside_alias` is an expression `{:module_attribute, charlist}`\n    or `{:local_or_var, charlist}` and `charlist` is a static part\n    Examples are `__MODULE__.Submodule` or `@hello.Submodule`\n\n  * `{:dot, inside_dot, charlist}` - the context is a dot\n    where `inside_dot` is either a `{:var, charlist}`, `{:alias, charlist}`,\n    `{:module_attribute, charlist}`, `{:unquoted_atom, charlist}` or a `dot`\n    itself. If a var is given, this may either be a remote call or a map\n    field access. Examples are `Hello.wor`, `:hello.wor`, `hello.wor`,\n    `Hello.nested.wor`, `hello.nested.wor`, and `@hello.world`. If `charlist`\n    is empty and `inside_dot` is an alias, then the autocompletion may either\n    be an alias or a remote call.\n\n  * `{:dot_arity, inside_dot, charlist}` - the context is a dot arity\n    where `inside_dot` is either a `{:var, charlist}`, `{:alias, charlist}`,\n    `{:module_attribute, charlist}`, `{:unquoted_atom, charlist}` or a `dot`\n    itself. If a var is given, it must be a remote arity. Examples are\n    `Hello.world/`, `:hello.world/`, `hello.world/2`, and `@hello.world/2`\n\n  * `{:dot_call, inside_dot, charlist}` - the context is a dot\n    call. This means parentheses or space have been added after the expression.\n    where `inside_dot` is either a `{:var, charlist}`, `{:alias, charlist}`,\n    `{:module_attribute, charlist}`, `{:unquoted_atom, charlist}` or a `dot`\n    itself. If a var is given, it must be a remote call. Examples are\n    `Hello.world(`, `:hello.world(`, `Hello.world `, `hello.world(`, `hello.world `,\n    and `@hello.world(`\n\n  * `:expr` - may be any expression. Autocompletion may suggest an alias,\n    local or var\n\n  * `{:local_or_var, charlist}` - the context is a variable or a local\n    (import or local) call, such as `hello_wor`\n\n  * `{:local_arity, charlist}` - the context is a local (import or local)\n    arity, such as `hello_world/`\n\n  * `{:local_call, charlist}` - the context is a local (import or local)\n    call, such as `hello_world(` and `hello_world `\n\n  * `{:module_attribute, charlist}` - the context is a module attribute,\n    such as `@hello_wor`\n\n  * `{:operator, charlist}` - the context is an operator, such as `+` or\n    `==`. Note textual operators, such as `when` do not appear as operators\n    but rather as `:local_or_var`. `@` is never an `:operator` and always a\n    `:module_attribute`\n\n  * `{:operator_arity, charlist}` - the context is an operator arity, which\n    is an operator followed by /, such as `+/`, `not/` or `when/`\n\n  * `{:operator_call, charlist}` - the context is an operator call, which is\n    an operator followed by space, such as `left + `, `not ` or `x when `\n\n  * `:none` - no context possible\n\n  * `{:sigil, charlist}` - the context is a sigil. It may be either the beginning\n    of a sigil, such as `~` or `~s`, or an operator starting with `~`, such as\n    `~>` and `~>>`\n\n  * `{:struct, inside_struct}` - the context is a struct, such as `%`, `%UR` or `%URI`.\n    `inside_struct` can either be a `charlist` in case of a static alias or an\n    expression `{:alias, inside_alias, charlist}`, `{:module_attribute, charlist}`,\n    `{:local_or_var, charlist}`, `{:dot, inside_dot, charlist}`\n\n  * `{:unquoted_atom, charlist}` - the context is an unquoted atom. This\n    can be any atom or an atom representing a module\n\n## Limitations\n\nThe current algorithm only considers the last line of the input. This means\nit will also show suggestions inside strings, heredocs, etc, which is\nintentional as it helps with doctests, references, and more.","prompt":"Can you write a docstring for the following Elixir function? cursor_context(fragment, opts \\\\ [])"}
{"completion":"Receives a string and returns the surround context.\n\nThis function receives a string with an Elixir code fragment\nand a `position`. It returns a map containing the beginning\nand ending of the identifier alongside its context, or `:none`\nif there is nothing with a known context.\n\nThe difference between `cursor_context/2` and `surround_context/3`\nis that the former assumes the expression in the code fragment\nis incomplete. For example, `do` in `cursor_context/2` may be\na keyword or a variable or a local call, while `surround_context/3`\nassumes the expression in the code fragment is complete, therefore\n`do` would always be a keyword.\n\nThe `position` contains both the `line` and `column`, both starting\nwith the index of 1. The column must precede the surrounding expression.\nFor example, the expression `foo`, will return something for the columns\n1, 2, and 3, but not 4:\n\n    foo\n    ^ column 1\n\n    foo\n     ^ column 2\n\n    foo\n      ^ column 3\n\n    foo\n       ^ column 4\n\nThe returned map contains the column the expression starts and the\nfirst column after the expression ends.\n\nSimilar to `cursor_context/2`, this function also provides a best-effort\ndetection and may not be accurate under all circumstances. See the\n\"Return values\" and \"Limitations\" section under `cursor_context/2` for\nmore information.\n\n## Examples\n\n    iex> Code.Fragment.surround_context(\"foo\", {1, 1})\n    %{begin: {1, 1}, context: {:local_or_var, 'foo'}, end: {1, 4}}\n\n## Differences to `cursor_context/2`\n\nBecause `surround_context/3` deals with complete code, it has some\ndifference to `cursor_context/2`:\n\n  * `dot_call`/`dot_arity` and `operator_call`/`operator_arity`\n    are collapsed into `dot` and `operator` contexts respectively\n    as there aren't any meaningful distinctions between them\n\n  * On the other hand, this function still makes a distinction between\n    `local_call`/`local_arity` and `local_or_var`, since the latter can\n    be a local or variable\n\n  * `@` when not followed by any identifier is returned as `{:operator, '@'}`\n    (in contrast to `{:module_attribute, ''}` in `cursor_context/2`\n\n  * This function never returns empty sigils `{:sigil, ''}` or empty structs\n    `{:struct, ''}` as context\n\n  * This function returns keywords as `{:keyword, 'do'}`\n\n  * This function never returns `:expr`","prompt":"Can you write a docstring for the following Elixir function? surround_context(fragment, position, options \\\\ [])"}
{"completion":"This module provides conveniences for analyzing fragments of\ntextual code and extract available information whenever possible.\n\nMost of the functions in this module provide a best-effort\nand may not be accurate under all circumstances. Read each\ndocumentation for more information.\n\nThis module should be considered experimental.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Code.Fragment"}
{"completion":"Checks if the given identifier is a binary op.\n\n## Examples\n\n    iex> Code.Identifier.binary_op(:+)\n    {:left, 210}","prompt":"Can you write a docstring for the following Elixir function? binary_op(op)"}
{"completion":"Escapes the given identifier.","prompt":"Can you write a docstring for the following Elixir function? escape(binary, char, limit \\\\ :infinity, fun \\\\ &escape_map/1)"}
{"completion":"Extracts the name and arity of the parent from the anonymous function identifier.","prompt":"Can you write a docstring for the following Elixir function? extract_anonymous_fun_parent(atom)"}
{"completion":"Checks if the given identifier is an unary op.\n\n## Examples\n\n    iex> Code.Identifier.unary_op(:+)\n    {:non_associative, 300}","prompt":"Can you write a docstring for the following Elixir function? unary_op(op)"}
{"completion":"Wraps literals in the quoted expression to conform to the AST format expected\nby the formatter.","prompt":"Can you write a docstring for the following Elixir function? normalize(quoted, opts \\\\ [])"}
{"completion":"Returns all callbacks available from the module's BEAM code.\n\nThe result is returned as a list of tuples where the first\nelement is spec name and arity and the second is the spec.\n\nThe module must have a corresponding BEAM file\nwhich can be located by the runtime system. The types will be\nin the Erlang Abstract Format.","prompt":"Can you write a docstring for the following Elixir function? fetch_callbacks(module)"}
{"completion":"Returns all specs available from the module's BEAM code.\n\nThe result is returned as a list of tuples where the first\nelement is spec name and arity and the second is the spec.\n\nThe module must have a corresponding BEAM file which can be\nlocated by the runtime system. The types will be in the Erlang\nAbstract Format.","prompt":"Can you write a docstring for the following Elixir function? fetch_specs(module)"}
{"completion":"Returns all types available from the module's BEAM code.\n\nThe result is returned as a list of tuples where the first\nelement is the type (`:typep`, `:type` and `:opaque`).\n\nThe module must have a corresponding BEAM file which can be\nlocated by the runtime system. The types will be in the Erlang\nAbstract Format.","prompt":"Can you write a docstring for the following Elixir function? fetch_types(module)"}
{"completion":"Converts a spec clause back to Elixir quoted expression.","prompt":"Can you write a docstring for the following Elixir function? spec_to_quoted(name, spec)"}
{"completion":"Converts a type clause back to Elixir AST.","prompt":"Can you write a docstring for the following Elixir function? type_to_quoted(type)"}
{"completion":"Appends a path to the end of the Erlang VM code path list.\n\nThis is the list of directories the Erlang VM uses for\nfinding module code. The list of files is managed per Erlang\nVM node.\n\nThe path is expanded with `Path.expand/1` before being appended.\nIf this path does not exist, an error is returned.\n\n## Examples\n\n    Code.append_path(\".\")\n    #=> true\n\n    Code.append_path(\"/does_not_exist\")\n    #=> {:error, :bad_directory}","prompt":"Can you write a docstring for the following Elixir function? append_path(path)"}
{"completion":"Returns a list with all available compiler options.\n\nFor a description of all options, see `put_compiler_option/2`.\n\n## Examples\n\n    Code.available_compiler_options()\n    #=> [:docs, :debug_info, ...]","prompt":"Can you write a docstring for the following Elixir function? available_compiler_options()"}
{"completion":"Returns true if the current process can await for module compilation.\n\nWhen compiling Elixir code via `Kernel.ParallelCompiler`, which is\nused by Mix and `elixirc`, calling a module that has not yet been\ncompiled will block the caller until the module becomes available.\nExecuting Elixir scripts, such as passing a filename to `elixir`,\ndoes not await.","prompt":"Can you write a docstring for the following Elixir function? can_await_module_compilation?()"}
{"completion":"Compiles the given file.\n\nAccepts `relative_to` as an argument to tell where the file is located.\n\nReturns a list of tuples where the first element is the module name and\nthe second one is its bytecode (as a binary). Opposite to `require_file/2`,\nit does not track the filename of the compiled file.\n\nIf you would like to get the result of evaluating file rather than the\nmodules defined in it, see `eval_file/2`.\n\nFor compiling many files concurrently, see `Kernel.ParallelCompiler.compile/2`.","prompt":"Can you write a docstring for the following Elixir function? compile_file(file, relative_to \\\\ nil)"}
{"completion":"Compiles the quoted expression.\n\nReturns a list of tuples where the first element is the module name and\nthe second one is its bytecode (as a binary). A `file` can be\ngiven as second argument which will be used for reporting warnings\nand errors.","prompt":"Can you write a docstring for the following Elixir function? compile_quoted(quoted, file \\\\ \"nofile\")"}
{"completion":"Compiles the given string.\n\nReturns a list of tuples where the first element is the module name\nand the second one is its bytecode (as a binary). A `file` can be\ngiven as second argument which will be used for reporting warnings\nand errors.\n\n**Warning**: `string` can be any Elixir code and code can be executed with\nthe same privileges as the Erlang VM: this means that such code could\ncompromise the machine (for example by executing system commands).\nDon't use `compile_string/2` with untrusted input (such as strings coming\nfrom the network).","prompt":"Can you write a docstring for the following Elixir function? compile_string(string, file \\\\ \"nofile\")"}
{"completion":"Gets all compilation options from the code server.\n\nTo get individual options, see `get_compiler_option/1`.\nFor a description of all options, see `put_compiler_option/2`.\n\n## Examples\n\n    Code.compiler_options()\n    #=> %{debug_info: true, docs: true, ...}","prompt":"Can you write a docstring for the following Elixir function? compiler_options()"}
{"completion":"Stores all given compilation options.\n\nChanging the compilation options affect all processes\nrunning in a given Erlang VM node. To store individual\noptions and for a description of all options, see\n`put_compiler_option/2`.\n\n## Examples\n\n    Code.compiler_options()\n    #=> %{debug_info: true, docs: true, ...}","prompt":"Can you write a docstring for the following Elixir function? compiler_options(opts)"}
{"completion":"Deletes a path from the Erlang VM code path list.\n\nThis is the list of directories the Erlang VM uses for finding\nmodule code. The list of files is managed per Erlang VM node.\n\nThe path is expanded with `Path.expand/1` before being deleted. If the\npath does not exist, this function returns `false`.\n\n## Examples\n\n    Code.prepend_path(\".\")\n    Code.delete_path(\".\")\n    #=> true\n\n    Code.delete_path(\"/does_not_exist\")\n    #=> false","prompt":"Can you write a docstring for the following Elixir function? delete_path(path)"}
{"completion":"Similar to `ensure_compiled!/1` but indicates you can continue without said module.\n\nWhile `ensure_compiled!/1` indicates to the Elixir compiler you can\nonly continue when said module is available, this function indicates\nyou may continue compilation without said module.\n\nIf it succeeds in loading the module, it returns `{:module, module}`.\nIf not, returns `{:error, reason}` with the error reason.\nIf the module being checked is currently in a compiler deadlock,\nthis function returns `{:error, :unavailable}`. Unavailable doesn't\nnecessarily mean the module doesn't exist, just that it is not currently\navailable, but it (or may not) become available in the future.\n\nTherefore, if you can only continue if the module is available, use\n`ensure_compiled!/1` instead. In particular, do not do this:\n\n    case Code.ensure_compiled(module) do\n      {:module, _} -> module\n      {:error, _} -> raise ...\n    end\n\nSee the module documentation for more information on code loading.","prompt":"Can you write a docstring for the following Elixir function? ensure_compiled(module)"}
{"completion":"Ensures the given module is compiled and loaded.\n\nIf the module is already loaded, it works as no-op. If the module was\nnot compiled yet, `ensure_compiled!/1` halts the compilation of the caller\nuntil the module given to `ensure_compiled!/1` becomes available or\nall files for the current project have been compiled. If compilation\nfinishes and the module is not available or is in a deadlock, an error\nis raised.\n\nGiven this function halts compilation, use it carefully. In particular,\navoid using it to guess which modules are in the system. Overuse of this\nfunction can also lead to deadlocks, where two modules check at the same time\nif the other is compiled. This returns a specific unavailable error code,\nwhere we cannot successfully verify a module is available or not.\n\nSee the module documentation for more information on code loading.","prompt":"Can you write a docstring for the following Elixir function? ensure_compiled!(module)"}
{"completion":"Ensures the given module is loaded.\n\nIf the module is already loaded, this works as no-op. If the module\nwas not yet loaded, it tries to load it.\n\nIf it succeeds in loading the module, it returns `{:module, module}`.\nIf not, returns `{:error, reason}` with the error reason.\n\nSee the module documentation for more information on code loading.\n\n## Examples\n\n    iex> Code.ensure_loaded(Atom)\n    {:module, Atom}\n\n    iex> Code.ensure_loaded(DoesNotExist)\n    {:error, :nofile}","prompt":"Can you write a docstring for the following Elixir function? ensure_loaded(module)"}
{"completion":"Same as `ensure_loaded/1` but raises if the module cannot be loaded.","prompt":"Can you write a docstring for the following Elixir function? ensure_loaded!(module)"}
{"completion":"Ensures the given module is loaded.\n\nSimilar to `ensure_loaded/1`, but returns `true` if the module\nis already loaded or was successfully loaded. Returns `false`\notherwise.\n\n## Examples\n\n    iex> Code.ensure_loaded?(Atom)\n    true","prompt":"Can you write a docstring for the following Elixir function? ensure_loaded?(module)"}
{"completion":"Returns an environment for evaluation.\n\nIt accepts either a `Macro.Env`, that is then pruned and prepared,\nor a list of options. It returns an environment that is ready for\nevaluation.\n\nMost functions in this module will automatically prepare the given\nenvironment for evaluation, so you don't need to explicitly call\nthis function, with the exception of `eval_quoted_with_env/3`,\nwhich was designed precisely to be called in a loop, to implement\nfeatures such as interactive shells or anything else with multiple\nevaluations.\n\n## Options\n\nIf an env is not given, the options can be:\n\n  * `:file` - the file to be considered in the evaluation\n\n  * `:line` - the line on which the script starts","prompt":"Can you write a docstring for the following Elixir function? env_for_eval(env_or_opts)"}
{"completion":"Evaluates the given file.\n\nAccepts `relative_to` as an argument to tell where the file is located.\n\nWhile `require_file/2` and `compile_file/2` return the loaded modules and their\nbytecode, `eval_file/2` simply evaluates the file contents and returns the\nevaluation result and its binding (exactly the same return value as `eval_string/3`).","prompt":"Can you write a docstring for the following Elixir function? eval_file(file, relative_to \\\\ nil)"}
{"completion":"Evaluates the quoted contents.\n\n**Warning**: Calling this function inside a macro is considered bad\npractice as it will attempt to evaluate runtime values at compile time.\nMacro arguments are typically transformed by unquoting them into the\nreturned quoted expressions (instead of evaluated).\n\nSee `eval_string/3` for a description of `binding` and `opts`.\n\n## Examples\n\n    iex> contents = quote(do: var!(a) + var!(b))\n    iex> {result, binding} = Code.eval_quoted(contents, [a: 1, b: 2], file: __ENV__.file, line: __ENV__.line)\n    iex> result\n    3\n    iex> Enum.sort(binding)\n    [a: 1, b: 2]\n\nFor convenience, you can pass `__ENV__/0` as the `opts` argument and\nall options will be automatically extracted from the current environment:\n\n    iex> contents = quote(do: var!(a) + var!(b))\n    iex> {result, binding} = Code.eval_quoted(contents, [a: 1, b: 2], __ENV__)\n    iex> result\n    3\n    iex> Enum.sort(binding)\n    [a: 1, b: 2]","prompt":"Can you write a docstring for the following Elixir function? eval_quoted(quoted, binding \\\\ [], env_or_opts \\\\ [])"}
{"completion":"Evaluates the given `quoted` contents with `binding` and `env`.\n\nThis function is meant to be called in a loop, to implement features\nsuch as interactive shells or anything else with multiple evaluations.\nTherefore, the first time you call this function, you must compute\nthe initial environment with `env_for_eval/1`. The remaining calls\nmust pass the environment that was returned by this function.\n\n## Options\n\n  * `:prune_binding` - (since v1.14.2) prune binding to keep only\n    variables read or written by the evaluated code. Note that\n    variables used by modules are always pruned, even if later used\n    by the modules. You can submit to the `:on_module` tracer event\n    and access the variables used by the module from its environment.","prompt":"Can you write a docstring for the following Elixir function? eval_quoted_with_env(quoted, binding, env, opts \\\\ [])"}
{"completion":"Evaluates the contents given by `string`.\n\nThe `binding` argument is a list of all variables and their values.\nThe `opts` argument is a keyword list of environment options.\n\n**Warning**: `string` can be any Elixir code and will be executed with\nthe same privileges as the Erlang VM: this means that such code could\ncompromise the machine (for example by executing system commands).\nDon't use `eval_string/3` with untrusted input (such as strings coming\nfrom the network).\n\n## Options\n\nOptions can be:\n\n  * `:file` - the file to be considered in the evaluation\n\n  * `:line` - the line on which the script starts\n\nAdditionally, you may also pass an environment as second argument,\nso the evaluation happens within that environment.\n\nReturns a tuple of the form `{value, binding}`, where `value` is the value\nreturned from evaluating `string`. If an error occurs while evaluating\n`string`, an exception will be raised.\n\n`binding` is a list with all variable names and their values after evaluating\n`string`. The binding keys are usually atoms, but they may be a tuple for variables\ndefined in a different context. The names are in no particular order.\n\n## Examples\n\n    iex> {result, binding} = Code.eval_string(\"a + b\", [a: 1, b: 2], file: __ENV__.file, line: __ENV__.line)\n    iex> result\n    3\n    iex> Enum.sort(binding)\n    [a: 1, b: 2]\n\n    iex> {result, binding} = Code.eval_string(\"c = a + b\", [a: 1, b: 2], __ENV__)\n    iex> result\n    3\n    iex> Enum.sort(binding)\n    [a: 1, b: 2, c: 3]\n\n    iex> {result, binding} = Code.eval_string(\"a = a + b\", [a: 1, b: 2])\n    iex> result\n    3\n    iex> Enum.sort(binding)\n    [a: 3, b: 2]\n\nFor convenience, you can pass `__ENV__/0` as the `opts` argument and\nall imports, requires and aliases defined in the current environment\nwill be automatically carried over:\n\n    iex> {result, binding} = Code.eval_string(\"a + b\", [a: 1, b: 2], __ENV__)\n    iex> result\n    3\n    iex> Enum.sort(binding)\n    [a: 1, b: 2]","prompt":"Can you write a docstring for the following Elixir function? eval_string(string, binding \\\\ [], opts \\\\ [])"}
{"completion":"Returns the docs for the given module or path to `.beam` file.\n\nWhen given a module name, it finds its BEAM code and reads the docs from it.\n\nWhen given a path to a `.beam` file, it will load the docs directly from that\nfile.\n\nIt returns the term stored in the documentation chunk in the format defined by\n[EEP 48](https://www.erlang.org/eeps/eep-0048.html) or `{:error, reason}` if\nthe chunk is not available.\n\n## Examples\n\n    # Module documentation of an existing module\n    iex> {:docs_v1, _, :elixir, _, %{\"en\" => module_doc}, _, _} = Code.fetch_docs(Atom)\n    iex> module_doc |> String.split(\"\\n\") |> Enum.at(0)\n    \"Atoms are constants whose values are their own name.\"\n\n    # A module that doesn't exist\n    iex> Code.fetch_docs(ModuleNotGood)\n    {:error, :module_not_found}","prompt":"Can you write a docstring for the following Elixir function? fetch_docs(module_or_path)"}
{"completion":"Formats a file.\n\nSee `format_string!/2` for more information on code formatting and\navailable options.","prompt":"Can you write a docstring for the following Elixir function? format_file!(file, opts \\\\ [])"}
{"completion":"Formats the given code `string`.\n\nThe formatter receives a string representing Elixir code and\nreturns iodata representing the formatted code according to\npre-defined rules.\n\n## Options\n\n  * `:file` - the file which contains the string, used for error\n    reporting\n\n  * `:line` - the line the string starts, used for error reporting\n\n  * `:line_length` - the line length to aim for when formatting\n    the document. Defaults to 98. Note this value is used as\n    guideline but there are situations where it is not enforced.\n    See the \"Line length\" section below for more information\n\n  * `:locals_without_parens` - a keyword list of name and arity\n    pairs that should be kept without parens whenever possible.\n    The arity may be the atom `:*`, which implies all arities of\n    that name. The formatter already includes a list of functions\n    and this option augments this list.\n\n  * `:force_do_end_blocks` (since v1.9.0) - when `true`, converts all\n    inline usages of `do: ...`,  `else: ...` and friends into `do`-`end`\n    blocks. Defaults to `false`. Note that this option is convergent:\n    once you set it to `true`, **all keywords** will be converted.\n    If you set it to `false` later on, `do`-`end` blocks won't be\n    converted back to keywords.\n\n  * `:normalize_bitstring_modifiers` (since v1.14.0) - when `true`,\n    removes unnecessary parentheses in known bitstring\n    [modifiers](`<<>>/1`), for example `<<foo::binary()>>`\n    becomes `<<foo::binary>>`, or adds parentheses for custom\n    modifiers, where `<<foo::custom_type>>` becomes `<<foo::custom_type()>>`.\n    Defaults to `true`. This option changes the AST.\n\n## Design principles\n\nThe formatter was designed under three principles.\n\nFirst, the formatter never changes the semantics of the code.\nThis means the input AST and the output AST are almost always equivalent.\nThe only cases where the formatter will change the AST is when the input AST\nwould cause *compiler warnings* and the output AST won't. The cases where\nthe formatter changes the AST can be disabled through formatting options\nif desired.\n\nThe second principle is to provide as little configuration as possible.\nThis eases the formatter adoption by removing contention points while\nmaking sure a single style is followed consistently by the community as\na whole.\n\nThe formatter does not hard code names. The formatter will not behave\nspecially because a function is named `defmodule`, `def`, or the like. This\nprinciple mirrors Elixir's goal of being an extensible language where\ndevelopers can extend the language with new constructs as if they were\npart of the language. When it is absolutely necessary to change behaviour\nbased on the name, this behaviour should be configurable, such as the\n`:locals_without_parens` option.\n\n## Running the formatter\n\nThe formatter attempts to fit the most it can on a single line and\nintroduces line breaks wherever possible when it cannot.\n\nIn some cases, this may lead to undesired formatting. Therefore, **some\ncode generated by the formatter may not be aesthetically pleasing and\nmay require explicit intervention from the developer**. That's why we\ndo not recommend to run the formatter blindly in an existing codebase.\nInstead you should format and sanity check each formatted file.\n\nFor example, the formatter may break a long function definition over\nmultiple clauses:\n\n    def my_function(\n      %User{name: name, age: age, ...},\n      arg1,\n      arg2\n    ) do\n      ...\n    end\n\nWhile the code above is completely valid, you may prefer to match on\nthe struct variables inside the function body in order to keep the\ndefinition on a single line:\n\n    def my_function(%User{} = user, arg1, arg2) do\n      %{name: name, age: age, ...} = user\n      ...\n    end\n\nIn some situations, you can use the fact the formatter does not generate\nelegant code as a hint for refactoring. Take this code:\n\n    def board?(board_id, %User{} = user, available_permissions, required_permissions) do\n      Tracker.OrganizationMembers.user_in_organization?(user.id, board.organization_id) and\n        required_permissions == Enum.to_list(MapSet.intersection(MapSet.new(required_permissions), MapSet.new(available_permissions)))\n    end\n\nThe code above has very long lines and running the formatter is not going\nto address this issue. In fact, the formatter may make it more obvious that\nyou have complex expressions:\n\n    def board?(board_id, %User{} = user, available_permissions, required_permissions) do\n      Tracker.OrganizationMembers.user_in_organization?(user.id, board.organization_id) and\n        required_permissions ==\n          Enum.to_list(\n            MapSet.intersection(\n              MapSet.new(required_permissions),\n              MapSet.new(available_permissions)\n            )\n          )\n    end\n\nTake such cases as a suggestion that your code should be refactored:\n\n    def board?(board_id, %User{} = user, available_permissions, required_permissions) do\n      Tracker.OrganizationMembers.user_in_organization?(user.id, board.organization_id) and\n        matching_permissions?(required_permissions, available_permissions)\n    end\n\n    defp matching_permissions?(required_permissions, available_permissions) do\n      intersection =\n        required_permissions\n        |> MapSet.new()\n        |> MapSet.intersection(MapSet.new(available_permissions))\n        |> Enum.to_list()\n\n      required_permissions == intersection\n    end\n\nTo sum it up: since the formatter cannot change the semantics of your\ncode, sometimes it is necessary to tweak or refactor the code to get\noptimal formatting. To help better understand how to control the formatter,\nwe describe in the next sections the cases where the formatter keeps the\nuser encoding and how to control multiline expressions.\n\n## Line length\n\nAnother point about the formatter is that the `:line_length` configuration\nis a guideline. In many cases, it is not possible for the formatter to break\nyour code apart, which means it will go over the line length. For example,\nif you have a long string:\n\n    \"this is a very long string that will go over the line length\"\n\nThe formatter doesn't know how to break it apart without changing the\ncode underlying syntax representation, so it is up to you to step in:\n\n    \"this is a very long string \" <>\n       \"that will go over the line length\"\n\nThe string concatenation makes the code fit on a single line and also\ngives more options to the formatter.\n\nThis may also appear in do/end blocks, where the `do` keyword (or `->`)\nmay go over the line length because there is no opportunity for the\nformatter to introduce a line break in a readable way. For example,\nif you do:\n\n    case very_long_expression() do\n    end\n\nAnd only the `do` keyword is above the line length, Elixir **will not**\nemit this:\n\n    case very_long_expression()\n    do\n    end\n\nSo it prefers to not touch the line at all and leave `do` above the\nline limit.\n\n## Keeping user's formatting\n\nThe formatter respects the input format in some cases. Those are\nlisted below:\n\n  * Insignificant digits in numbers are kept as is. The formatter\n    however always inserts underscores for decimal numbers with more\n    than 5 digits and converts hexadecimal digits to uppercase\n\n  * Strings, charlists, atoms and sigils are kept as is. No character\n    is automatically escaped or unescaped. The choice of delimiter is\n    also respected from the input\n\n  * Newlines inside blocks are kept as in the input except for:\n    1) expressions that take multiple lines will always have an empty\n    line before and after and 2) empty lines are always squeezed\n    together into a single empty line\n\n  * The choice between `:do` keyword and `do`-`end` blocks is left\n    to the user\n\n  * Lists, tuples, bitstrings, maps, structs and function calls will be\n    broken into multiple lines if they are followed by a newline in the\n    opening bracket and preceded by a new line in the closing bracket\n\n  * Newlines before certain operators (such as the pipeline operators)\n    and before other operators (such as comparison operators)\n\nThe behaviours above are not guaranteed. We may remove or add new\nrules in the future. The goal of documenting them is to provide better\nunderstanding on what to expect from the formatter.\n\n### Multi-line lists, maps, tuples, and the like\n\nYou can force lists, tuples, bitstrings, maps, structs and function\ncalls to have one entry per line by adding a newline after the opening\nbracket and a new line before the closing bracket lines. For example:\n\n    [\n      foo,\n      bar\n    ]\n\nIf there are no newlines around the brackets, then the formatter will\ntry to fit everything on a single line, such that the snippet below\n\n    [foo,\n     bar]\n\nwill be formatted as\n\n    [foo, bar]\n\nYou can also force function calls and keywords to be rendered on multiple\nlines by having each entry on its own line:\n\n    defstruct name: nil,\n              age: 0\n\nThe code above will be kept with one keyword entry per line by the\nformatter. To avoid that, just squash everything into a single line.\n\n### Parens and no parens in function calls\n\nElixir has two syntaxes for function calls. With parens and no parens.\nBy default, Elixir will add parens to all calls except for:\n\n  1. calls that have `do`-`end` blocks\n  2. local calls without parens where the name and arity of the local\n     call is also listed under `:locals_without_parens` (except for\n     calls with arity 0, where the compiler always require parens)\n\nThe choice of parens and no parens also affects indentation. When a\nfunction call with parens doesn't fit on the same line, the formatter\nintroduces a newline around parens and indents the arguments with two\nspaces:\n\n    some_call(\n      arg1,\n      arg2,\n      arg3\n    )\n\nOn the other hand, function calls without parens are always indented\nby the function call length itself, like this:\n\n    some_call arg1,\n              arg2,\n              arg3\n\nIf the last argument is a data structure, such as maps and lists, and\nthe beginning of the data structure fits on the same line as the function\ncall, then no indentation happens, this allows code like this:\n\n    Enum.reduce(some_collection, initial_value, fn element, acc ->\n      # code\n    end)\n\n    some_function_without_parens %{\n      foo: :bar,\n      baz: :bat\n    }\n\n## Code comments\n\nThe formatter also handles code comments in a way to guarantee a space\nis always added between the beginning of the comment (#) and the next\ncharacter.\n\nThe formatter also extracts all trailing comments to their previous line.\nFor example, the code below\n\n    hello #world\n\nwill be rewritten to\n\n    # world\n    hello\n\nBecause code comments are handled apart from the code representation (AST),\nthere are some situations where code comments are seen as ambiguous by the\ncode formatter. For example, the comment in the anonymous function below\n\n    fn\n      arg1 ->\n        body1\n        # comment\n\n      arg2 ->\n        body2\n    end\n\nand in this one\n\n    fn\n      arg1 ->\n        body1\n\n      # comment\n      arg2 ->\n        body2\n    end\n\nare considered equivalent (the nesting is discarded alongside most of\nuser formatting). In such cases, the code formatter will always format to\nthe latter.\n\n## Newlines\n\nThe formatter converts all newlines in code from `\\r\\n` to `\\n`.","prompt":"Can you write a docstring for the following Elixir function? format_string!(string, opts \\\\ [])"}
{"completion":"Returns the value of a given compiler option.\n\nFor a description of all options, see `put_compiler_option/2`.\n\n## Examples\n\n    Code.get_compiler_option(:debug_info)\n    #=> true","prompt":"Can you write a docstring for the following Elixir function? get_compiler_option(key)"}
{"completion":"Prepends a path to the beginning of the Erlang VM code path list.\n\nThis is the list of directories the Erlang VM uses for finding\nmodule code. The list of files is managed per Erlang VM node.\n\nThe path is expanded with `Path.expand/1` before being prepended.\nIf this path does not exist, an error is returned.\n\n## Examples\n\n    Code.prepend_path(\".\")\n    #=> true\n\n    Code.prepend_path(\"/does_not_exist\")\n    #=> {:error, :bad_directory}","prompt":"Can you write a docstring for the following Elixir function? prepend_path(path)"}
{"completion":"Purge compiler modules.\n\nThe compiler utilizes temporary modules to compile code. For example,\n`elixir_compiler_1`, `elixir_compiler_2`, and so on. In case the compiled code\nstores references to anonymous functions or similar, the Elixir compiler\nmay be unable to reclaim those modules, keeping an unnecessary amount of\ncode in memory and eventually leading to modules such as `elixir_compiler_12345`.\n\nThis function purges all modules currently kept by the compiler, allowing\nold compiler module names to be reused. If there are any processes running\nany code from such modules, they will be terminated too.\n\nThis function is only meant to be called if you have a long running node\nthat is constantly evaluating code.\n\nIt returns `{:ok, number_of_modules_purged}`.","prompt":"Can you write a docstring for the following Elixir function? purge_compiler_modules()"}
{"completion":"Stores a compilation option.\n\nChanging the compilation options affect all processes running in a\ngiven Erlang VM node.\n\nAvailable options are:\n\n  * `:docs` - when `true`, retains documentation in the compiled module.\n    Defaults to `true`.\n\n  * `:debug_info` - when `true`, retains debug information in the compiled\n    module. This enables static analysis tools as it allows developers to\n    partially reconstruct the original source code. Therefore, disabling\n    `:debug_info` is not recommended as it removes the ability of the\n    Elixir compiler and other tools to provide feedback. If you want to\n    remove the `:debug_info` while deploying, tools like `mix release`\n    already do such by default.\n\n  * `:ignore_already_consolidated` - when `true`, does not warn when a protocol\n    has already been consolidated and a new implementation is added. Defaults\n    to `false`.\n\n  * `:ignore_module_conflict` - when `true`, does not warn when a module has\n    already been defined. Defaults to `false`.\n\n  * `:relative_paths` - when `true`, uses relative paths in quoted nodes,\n    warnings, and errors generated by the compiler. Note disabling this option\n    won't affect runtime warnings and errors. Defaults to `true`.\n\n  * `:warnings_as_errors` - causes compilation to fail when warnings are\n    generated. Defaults to `false`.\n\n  * `:no_warn_undefined` (since v1.10.0) - list of modules and `{Mod, fun, arity}`\n    tuples that will not emit warnings that the module or function does not exist\n    at compilation time. Pass atom `:all` to skip warning for all undefined\n    functions. This can be useful when doing dynamic compilation. Defaults to `[]`.\n\n  * `:tracers` (since v1.10.0) - a list of tracers (modules) to be used during\n    compilation. See the module docs for more information. Defaults to `[]`.\n\n  * `:parser_options` (since v1.10.0) - a keyword list of options to be given\n    to the parser when compiling files. It accepts the same options as\n    `string_to_quoted/2` (except by the options that change the AST itself).\n    This can be used in combination with the tracer to retrieve localized\n    information about events happening during compilation. Defaults to `[]`.\n\nIt always returns `:ok`. Raises an error for invalid options.\n\n## Examples\n\n    Code.put_compiler_option(:debug_info, true)\n    #=> :ok","prompt":"Can you write a docstring for the following Elixir function? put_compiler_option(key, value)"}
{"completion":"Converts a quoted expression to an algebra document using Elixir's formatter rules.\n\nThe algebra document can be converted into a string by calling:\n\n    doc\n    |> Inspect.Algebra.format(:infinity)\n    |> IO.iodata_to_binary()\n\nFor a high-level function that does the same, see `Macro.to_string/1`.\n\n## Formatting considerations\n\nThe Elixir AST does not contain metadata for literals like strings, lists, or\ntuples with two elements, which means that the produced algebra document will\nnot respect all of the user preferences and comments may be misplaced.\nTo get better results, you can use the `:token_metadata`, `:unescape` and\n`:literal_encoder` options to `string_to_quoted/2` to provide additional\ninformation to the formatter:\n\n    [\n      literal_encoder: &{:ok, {:__block__, &2, [&1]}},\n      token_metadata: true,\n      unescape: false\n    ]\n\nThis will produce an AST that contains information such as `do` blocks start\nand end lines or sigil delimiters, and by wrapping literals in blocks they can\nnow hold metadata like line number, string delimiter and escaped sequences, or\ninteger formatting (such as `0x2a` instead of `47`). However, **note this AST is\nnot valid**. If you evaluate it, it won't have the same semantics as the regular\nElixir AST due to the `:unescape` and `:literal_encoder` options. However,\nthose options are useful if you're doing source code manipulation, where it's\nimportant to preserve user choices and comments placing.\n\n## Options\n\n  * `:comments` - the list of comments associated with the quoted expression.\n    Defaults to `[]`. It is recommended that both `:token_metadata` and\n    `:literal_encoder` options are given to `string_to_quoted_with_comments/2`\n    in order to get proper placement for comments\n\n  * `:escape` - when `true`, escaped sequences like `\\n` will be escaped into\n    `\\\\n`. If the `:unescape` option was set to `false` when using\n    `string_to_quoted/2`, setting this option to `false` will prevent it from\n    escaping the sequences twice. Defaults to `true`.\n\n  * `:locals_without_parens` - a keyword list of name and arity\n    pairs that should be kept without parens whenever possible.\n    The arity may be the atom `:*`, which implies all arities of\n    that name. The formatter already includes a list of functions\n    and this option augments this list.","prompt":"Can you write a docstring for the following Elixir function? quoted_to_algebra(quoted, opts \\\\ [])"}
{"completion":"Requires the given `file`.\n\nAccepts `relative_to` as an argument to tell where the file is located.\nIf the file was already required, `require_file/2` doesn't do anything and\nreturns `nil`.\n\nNote that if `require_file/2` is invoked by different processes concurrently,\nthe first process to invoke `require_file/2` acquires a lock and the remaining\nones will block until the file is available. This means that if `require_file/2`\nis called more than once with a given file, that file will be compiled only once.\nThe first process to call `require_file/2` will get the list of loaded modules,\nothers will get `nil`. The list of required files is managed per Erlang VM node.\n\nSee `compile_file/2` if you would like to compile a file without tracking its\nfilenames. Finally, if you would like to get the result of evaluating a file rather\nthan the modules defined in it, see `eval_file/2`.\n\n## Examples\n\nIf the file has not been required, it returns the list of modules:\n\n    modules = Code.require_file(\"eex_test.exs\", \"../eex/test\")\n    List.first(modules)\n    #=> {EExTest.Compiled, <<70, 79, 82, 49, ...>>}\n\nIf the file has been required, it returns `nil`:\n\n    Code.require_file(\"eex_test.exs\", \"../eex/test\")\n    #=> nil","prompt":"Can you write a docstring for the following Elixir function? require_file(file, relative_to \\\\ nil)"}
{"completion":"Lists all required files.\n\n## Examples\n\n    Code.require_file(\"../eex/test/eex_test.exs\")\n    List.first(Code.required_files()) =~ \"eex_test.exs\"\n    #=> true","prompt":"Can you write a docstring for the following Elixir function? required_files()"}
{"completion":"Converts the given string to its quoted form.\n\nReturns `{:ok, quoted_form}` if it succeeds,\n`{:error, {meta, message_info, token}}` otherwise.\n\n## Options\n\n  * `:file` - the filename to be reported in case of parsing errors.\n    Defaults to `\"nofile\"`.\n\n  * `:line` - the starting line of the string being parsed.\n    Defaults to 1.\n\n  * `:column` - (since v1.11.0) the starting column of the string being parsed.\n    Defaults to 1.\n\n  * `:columns` - when `true`, attach a `:column` key to the quoted\n    metadata. Defaults to `false`.\n\n  * `:unescape` (since v1.10.0) - when `false`, preserves escaped sequences.\n    For example, `\"null byte\\\\t\\\\x00\"` will be kept as is instead of being\n    converted to a bitstring literal. Note if you set this option to false, the\n    resulting AST is no longer valid, but it can be useful to analyze/transform\n    source code, typically in in combination with `quoted_to_algebra/2`.\n    Defaults to `true`.\n\n  * `:existing_atoms_only` - when `true`, raises an error\n    when non-existing atoms are found by the tokenizer.\n    Defaults to `false`.\n\n  * `:token_metadata` (since v1.10.0) - when `true`, includes token-related\n    metadata in the expression AST, such as metadata for `do` and `end`\n    tokens, for closing tokens, end of expressions, as well as delimiters\n    for sigils. See `t:Macro.metadata/0`. Defaults to `false`.\n\n  * `:literal_encoder` (since v1.10.0) - how to encode literals in the AST.\n    It must be a function that receives two arguments, the literal and its\n    metadata, and it must return `{:ok, ast :: Macro.t}` or\n    `{:error, reason :: binary}`. If you return anything than the literal\n    itself as the `term`, then the AST is no longer valid. This option\n    may still useful for textual analysis of the source code.\n\n  * `:static_atoms_encoder` - the static atom encoder function, see\n    \"The `:static_atoms_encoder` function\" section below. Note this\n    option overrides the `:existing_atoms_only` behaviour for static\n    atoms but `:existing_atoms_only` is still used for dynamic atoms,\n    such as atoms with interpolations.\n\n  * `:warn_on_unnecessary_quotes` - when `false`, does not warn\n    when atoms, keywords or calls have unnecessary quotes on\n    them. Defaults to `true`.\n\n## `Macro.to_string/2`\n\nThe opposite of converting a string to its quoted form is\n`Macro.to_string/2`, which converts a quoted form to a string/binary\nrepresentation.\n\n## The `:static_atoms_encoder` function\n\nWhen `static_atoms_encoder: &my_encoder/2` is passed as an argument,\n`my_encoder/2` is called every time the tokenizer needs to create a\n\"static\" atom. Static atoms are atoms in the AST that function as\naliases, remote calls, local calls, variable names, regular atoms\nand keyword lists.\n\nThe encoder function will receive the atom name (as a binary) and a\nkeyword list with the current file, line and column. It must return\n`{:ok, token :: term} | {:error, reason :: binary}`.\n\nThe encoder function is supposed to create an atom from the given\nstring. To produce a valid AST, it is required to return `{:ok, term}`,\nwhere `term` is an atom. It is possible to return something other than an atom,\nhowever, in that case the AST is no longer \"valid\" in that it cannot\nbe used to compile or evaluate Elixir code. A use case for this is\nif you want to use the Elixir parser in a user-facing situation, but\nyou don't want to exhaust the atom table.\n\nThe atom encoder is not called for *all* atoms that are present in\nthe AST. It won't be invoked for the following atoms:\n\n  * operators (`:+`, `:-`, and so on)\n\n  * syntax keywords (`fn`, `do`, `else`, and so on)\n\n  * atoms containing interpolation (`:\"#{1 + 1} is two\"`), as these\n    atoms are constructed at runtime.","prompt":"Can you write a docstring for the following Elixir function? string_to_quoted(string, opts \\\\ [])"}
{"completion":"Converts the given string to its quoted form.\n\nIt returns the AST if it succeeds,\nraises an exception otherwise. The exception is a `TokenMissingError`\nin case a token is missing (usually because the expression is incomplete),\n`SyntaxError` otherwise.\n\nCheck `string_to_quoted/2` for options information.","prompt":"Can you write a docstring for the following Elixir function? string_to_quoted!(string, opts \\\\ [])"}
{"completion":"Converts the given string to its quoted form and a list of comments.\n\nThis function is useful when performing textual changes to the source code,\nwhile preserving information like comments and literals position.\n\nReturns `{:ok, quoted_form, comments}` if it succeeds,\n`{:error, {line, error, token}}` otherwise.\n\nComments are maps with the following fields:\n\n  * `:line` - The line number the source code\n\n  * `:text` - The full text of the comment, including the leading `#`\n\n  * `:previous_eol_count` - How many end of lines there are between the comment and the previous AST node or comment\n\n  * `:next_eol_count` - How many end of lines there are between the comment and the next AST node or comment\n\nCheck `string_to_quoted/2` for options information.\n\n## Examples\n\n    iex> Code.string_to_quoted_with_comments(\"\"\"\n    ...> :foo\n    ...>\n    ...> # Hello, world!\n    ...>\n    ...>\n    ...> # Some more comments!\n    ...> \"\"\")\n    {:ok, :foo, [\n      %{line: 3, column: 1, previous_eol_count: 2, next_eol_count: 3, text: \"# Hello, world!\"},\n      %{line: 6, column: 1, previous_eol_count: 3, next_eol_count: 1, text: \"# Some more comments!\"},\n    ]}\n\n    iex> Code.string_to_quoted_with_comments(\":foo # :bar\")\n    {:ok, :foo, [\n      %{line: 1, column: 6, previous_eol_count: 0, next_eol_count: 0, text: \"# :bar\"}\n    ]}","prompt":"Can you write a docstring for the following Elixir function? string_to_quoted_with_comments(string, opts \\\\ [])"}
{"completion":"Converts the given string to its quoted form and a list of comments.\n\nReturns the AST and a list of comments if it succeeds, raises an exception\notherwise. The exception is a `TokenMissingError` in case a token is missing\n(usually because the expression is incomplete), `SyntaxError` otherwise.\n\nCheck `string_to_quoted/2` for options information.","prompt":"Can you write a docstring for the following Elixir function? string_to_quoted_with_comments!(string, opts \\\\ [])"}
{"completion":"Removes files from the required files list.\n\nThe modules defined in the file are not removed;\ncalling this function only removes them from the list,\nallowing them to be required again.\n\nThe list of files is managed per Erlang VM node.\n\n## Examples\n\n    # Require EEx test code\n    Code.require_file(\"../eex/test/eex_test.exs\")\n\n    # Now unrequire all files\n    Code.unrequire_files(Code.required_files())\n\n    # Note that modules are still available\n    function_exported?(EExTest.Compiled, :before_compile, 0)\n    #=> true","prompt":"Can you write a docstring for the following Elixir function? unrequire_files(files)"}
{"completion":"Utilities for managing code compilation, code evaluation, and code loading.\n\nThis module complements Erlang's [`:code` module](`:code`)\nto add behaviour which is specific to Elixir. For functions to\nmanipulate Elixir's AST (rather than evaluating it), see the\n`Macro` module.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Code"}
{"completion":"Working with files\n\nThis module contains three functions for compiling and evaluating files.\nHere is a summary of them and their behaviour:\n\n  * `require_file/2` - compiles a file and tracks its name. It does not\n    compile the file again if it has been previously required.\n\n  * `compile_file/2` - compiles a file without tracking its name. Compiles the\n    file multiple times when invoked multiple times.\n\n  * `eval_file/2` - evaluates the file contents without tracking its name. It\n    returns the result of the last expression in the file, instead of the modules\n    defined in it. Evaluated files do not trigger the compilation tracers described\n    in the next section.\n\nIn a nutshell, the first must be used when you want to keep track of the files\nhandled by the system, to avoid the same file from being compiled multiple\ntimes. This is common in scripts.\n\n`compile_file/2` must be used when you are interested in the modules defined in a\nfile, without tracking. `eval_file/2` should be used when you are interested in\nthe result of evaluating the file rather than the modules it defines.\n\nThe functions above work with Elixir source. If you want to work\nwith modules compiled to bytecode, which have the `.beam` extension\nand are typically found below the _build directory of a Mix project,\nsee the functions in Erlang's [`:code`](`:code`) module.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Code"}
{"completion":"Code loading on the Erlang VM\n\nErlang has two modes to load code: interactive and embedded.\n\nBy default, the Erlang VM runs in interactive mode, where modules\nare loaded as needed. In embedded mode the opposite happens, as all\nmodules need to be loaded upfront or explicitly.\n\nYou can use `ensure_loaded/1` (as well as `ensure_loaded?/1` and\n`ensure_loaded!/1`) to check if a module is loaded before using it and\nact.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Code"}
{"completion":"`ensure_compiled/1` and `ensure_compiled!/1`\n\nElixir also includes `ensure_compiled/1` and `ensure_compiled!/1`\nfunctions that are a superset of `ensure_loaded/1`.\n\nSince Elixir's compilation happens in parallel, in some situations\nyou may need to use a module that was not yet compiled, therefore\nit can't even be loaded.\n\nWhen invoked, `ensure_compiled/1` and `ensure_compiled!/1` halt the\ncompilation of the caller until the module becomes available. Note\nthe distinction between `ensure_compiled/1` and `ensure_compiled!/1`\nis important: if you are using `ensure_compiled!/1`, you are\nindicating to the compiler that you can only continue if said module\nis available.\n\nIf you are using `Code.ensure_compiled/1`, you are implying you may\ncontinue without the module and therefore Elixir may return\n`{:error, :unavailable}` for cases where the module is not yet available\n(but may be available later on).\n\nFor those reasons, developers must typically use `Code.ensure_compiled!/1`.\nIn particular, do not do this:\n\n    case Code.ensure_compiled(module) do\n      {:module, _} -> module\n      {:error, _} -> raise ...\n    end\n\nFinally, note you only need `ensure_compiled!/1` to check for modules\nbeing defined within the same project. It does not apply to modules from\ndependencies as dependencies are always compiled upfront.\n\nIn most cases, `ensure_loaded/1` is enough. `ensure_compiled!/1`\nmust be used in rare cases, usually involving macros that need to\ninvoke a module for callback information. The use of `ensure_compiled/1`\nis even less likely.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Code"}
{"completion":"Compilation tracers\n\nElixir supports compilation tracers, which allows modules to observe constructs\nhandled by the Elixir compiler when compiling files. A tracer is a module\nthat implements the `trace/2` function. The function receives the event name\nas first argument and `Macro.Env` as second and it must return `:ok`. It is\nvery important for a tracer to do as little work as possible synchronously\nand dispatch the bulk of the work to a separate process. **Slow tracers will\nslow down compilation**.\n\nYou can configure your list of tracers via `put_compiler_option/2`. The\nfollowing events are available to tracers:\n\n  * `:start` - (since v1.11.0) invoked whenever the compiler starts to trace\n    a new lexical context. A lexical context is started when compiling a new\n    file or when defining a module within a function. Note evaluated code\n    does not start a new lexical context (because they don't track unused\n    aliases, imports, etc) but defining a module inside evaluated code will.\n\n    Note this event may be emitted in parallel, where multiple files/modules\n    invoke `:start` and run at the same time. The value of the `lexical_tracker`\n    of the macro environment, albeit opaque, can be used to uniquely identify\n    the environment.\n\n  * `:stop` - (since v1.11.0) invoked whenever the compiler stops tracing a\n    new lexical context, such as a new file.\n\n  * `{:import, meta, module, opts}` - traced whenever `module` is imported.\n    `meta` is the import AST metadata and `opts` are the import options.\n\n  * `{:imported_function, meta, module, name, arity}` and\n    `{:imported_macro, meta, module, name, arity}` - traced whenever an\n    imported function or macro is invoked. `meta` is the call AST metadata,\n    `module` is the module the import is from, followed by the `name` and `arity`\n    of the imported function/macro.\n\n  * `{:alias, meta, alias, as, opts}` - traced whenever `alias` is aliased\n    to `as`. `meta` is the alias AST metadata and `opts` are the alias options.\n\n  * `{:alias_expansion, meta, as, alias}` traced whenever there is an alias\n    expansion for a previously defined `alias`, i.e. when the user writes `as`\n    which is expanded to `alias`. `meta` is the alias expansion AST metadata.\n\n  * `{:alias_reference, meta, module}` - traced whenever there is an alias\n    in the code, i.e. whenever the user writes `MyModule.Foo.Bar` in the code,\n    regardless if it was expanded or not.\n\n  * `{:require, meta, module, opts}` - traced whenever `module` is required.\n    `meta` is the require AST metadata and `opts` are the require options.\n    If the `meta` option contains the `:from_macro`, then `require` was called\n    from within a macro and therefore must be treated as a compile-time dependency.\n\n  * `{:struct_expansion, meta, module, keys}` - traced whenever `module`'s struct\n    is expanded. `meta` is the struct AST metadata and `keys` are the keys being\n    used by expansion\n\n  * `{:remote_function, meta, module, name, arity}` and\n    `{:remote_macro, meta, module, name, arity}` - traced whenever a remote\n    function or macro is referenced. `meta` is the call AST metadata, `module`\n    is the invoked module, followed by the `name` and `arity`.\n\n  * `{:local_function, meta, name, arity}` and\n    `{:local_macro, meta, name, arity}` - traced whenever a local\n    function or macro is referenced. `meta` is the call AST metadata, followed by\n    the `name` and `arity`.\n\n  * `{:compile_env, app, path, return}` - traced whenever `Application.compile_env/3`\n    or `Application.compile_env!/2` are called. `app` is an atom, `path` is a list\n    of keys to traverse in the application environment and `return` is either\n    `{:ok, value}` or `:error`.\n\n  * `{:on_module, bytecode, _ignore}` - (since v1.11.0) traced whenever a module\n    is defined. This is equivalent to the `@after_compile` callback and invoked\n    after any `@after_compile` in the given module. The third element is currently\n    `:none` but it may provide more metadata in the future. It is best to ignore\n    it at the moment. Note that `Module` functions expecting not yet compiled modules\n    (such as `Module.definitions_in/1`) are still available at the time this event\n    is emitted.\n\nThe `:tracers` compiler option can be combined with the `:parser_options`\ncompiler option to enrich the metadata of the traced events above.\n\nNew events may be added at any time in the future, therefore it is advised\nfor the `trace/2` function to have a \"catch-all\" clause.\n\nBelow is an example tracer that prints all remote function invocations:\n\n    defmodule MyTracer do\n      def trace({:remote_function, _meta, module, name, arity}, env) do\n        IO.puts \"#{env.file}:#{env.line} #{inspect(module)}.#{name}/#{arity}\"\n        :ok\n      end\n\n      def trace(_event, _env) do\n        :ok\n      end\n    end","prompt":"Can you write a docstring for the following Elixir function? Elixir.Code"}
{"completion":"Returns an initial accumulator and a \"collector\" function.\n\nReceives a `collectable` which can be used as the initial accumulator that will\nbe passed to the function.\n\nThe collector function receives a term and a command and injects the term into\nthe collectable accumulator on every `{:cont, term}` command.\n\n`:done` is passed as a command when no further values will be injected. This\nis useful when there's a need to close resources or normalizing values. A\ncollectable must be returned when the command is `:done`.\n\nIf injection is suddenly interrupted, `:halt` is passed and the function\ncan return any value as it won't be used.\n\nFor examples on how to use the `Collectable` protocol and `into/1` see the\nmodule documentation.","prompt":"Can you write a docstring for the following Elixir function? into(collectable)"}
{"completion":"A protocol to traverse data structures.\n\nThe `Enum.into/2` function uses this protocol to insert an\nenumerable into a collection:\n\n    iex> Enum.into([a: 1, b: 2], %{})\n    %{a: 1, b: 2}","prompt":"Can you write a docstring for the following Elixir function? Elixir.Collectable"}
{"completion":"Why Collectable?\n\nThe `Enumerable` protocol is useful to take values out of a collection.\nIn order to support a wide range of values, the functions provided by\nthe `Enumerable` protocol do not keep shape. For example, passing a\nmap to `Enum.map/2` always returns a list.\n\nThis design is intentional. `Enumerable` was designed to support infinite\ncollections, resources and other structures with fixed shape. For example,\nit doesn't make sense to insert values into a `Range`, as it has a\nfixed shape where only the range limits and step are stored.\n\nThe `Collectable` module was designed to fill the gap left by the\n`Enumerable` protocol. `Collectable.into/1` can be seen as the opposite of\n`Enumerable.reduce/3`. If the functions in `Enumerable` are about taking values out,\nthen `Collectable.into/1` is about collecting those values into a structure.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Collectable"}
{"completion":"Examples\n\nTo show how to manually use the `Collectable` protocol, let's play with a\nsimplified implementation for `MapSet`.\n\n    iex> {initial_acc, collector_fun} = Collectable.into(MapSet.new())\n    iex> updated_acc = Enum.reduce([1, 2, 3], initial_acc, fn elem, acc ->\n    ...>   collector_fun.(acc, {:cont, elem})\n    ...> end)\n    iex> collector_fun.(updated_acc, :done)\n    MapSet.new([1, 2, 3])\n\nTo show how the protocol can be implemented, we can again look at the\nsimplified implementation for `MapSet`. In this implementation \"collecting\" elements\nsimply means inserting them in the set through `MapSet.put/2`.\n\n    defimpl Collectable, for: MapSet do\n      def into(map_set) do\n        collector_fun = fn\n          map_set_acc, {:cont, elem} ->\n            MapSet.put(map_set_acc, elem)\n\n          map_set_acc, :done ->\n            map_set_acc\n\n          _map_set_acc, :halt ->\n            :ok\n        end\n\n        initial_acc = map_set\n\n        {initial_acc, collector_fun}\n      end\n    end\n\nSo now we can call `Enum.into/2`:\n\n    iex> Enum.into([1, 2, 3], MapSet.new())\n    MapSet.new([1, 2, 3])","prompt":"Can you write a docstring for the following Elixir function? Elixir.Collectable"}
{"completion":"Resolves a `t:config_path/0` to an actual path.","prompt":"Can you write a docstring for the following Elixir function? resolve_config_path!(path)"}
{"completion":"Validates a `t:config_path/0`.","prompt":"Can you write a docstring for the following Elixir function? validate_config_path!(path)"}
{"completion":"Specifies a provider API that loads configuration during boot.\n\nConfig providers are typically used during releases to load\nexternal configuration while the system boots. This is done\nby starting the VM with the minimum amount of applications\nrunning, then invoking all of the providers, and then\nrestarting the system. This requires a mutable configuration\nfile on disk, as the results of the providers are written to\nthe file system. For more information on runtime configuration,\nsee `mix release`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Config.Provider"}
{"completion":"Multiple config files\n\nOne common use of config providers is to specify multiple\nconfiguration files in a release. Elixir ships with one provider,\ncalled `Config.Reader`, which is capable of handling Elixir's\nbuilt-in config files.\n\nFor example, imagine you want to list some basic configuration\non Mix's built-in `config/runtime.exs` file, but you also want\nto support additional configuration files. To do so, you can add\nthis inside the `def project` portion of  your `mix.exs`:\n\n    releases: [\n      demo: [\n        config_providers: [\n          {Config.Reader, {:system, \"RELEASE_ROOT\", \"/extra_config.exs\"}}\n        ]\n      ]\n    ]\n\nYou can place this `extra_config.exs` file in your release in\nmultiple ways:\n\n  1. If it is available on the host when assembling the release,\n    you can place it on \"rel/overlays/extra_config.exs\" and it\n    will be automatically copied to the release root\n\n  2. If it is available on the target during deployment, you can\n    simply copy it to the release root as a step in your deployment\n\nNow once the system boots, it will load both `config/runtime.exs`\nand `extra_config.exs` early in the boot process. You can learn\nmore options on `Config.Reader`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Config.Provider"}
{"completion":"Custom config provider\n\nYou can also implement custom config providers, similar to how\n`Config.Reader` works. For example, imagine you need to load\nsome configuration from a JSON file and load that into the system.\nSaid configuration provider would look like:\n\n    defmodule JSONConfigProvider do\n      @behaviour Config.Provider\n\n      # Let's pass the path to the JSON file as config\n      @impl true\n      def init(path) when is_binary(path), do: path\n\n      @impl true\n      def load(config, path) do\n        # We need to start any app we may depend on.\n        {:ok, _} = Application.ensure_all_started(:jason)\n\n        json = path |> File.read!() |> Jason.decode!()\n\n        Config.Reader.merge(\n          config,\n          my_app: [\n            some_value: json[\"my_app_some_value\"],\n            another_value: json[\"my_app_another_value\"],\n          ]\n        )\n      end\n    end\n\nThen, when specifying your release, you can specify the provider in\nthe release configuration:\n\n    releases: [\n      demo: [\n        config_providers: [\n          {JSONConfigProvider, \"/etc/config.json\"}\n        ]\n      ]\n    ]","prompt":"Can you write a docstring for the following Elixir function? Elixir.Config.Provider"}
{"completion":"Evaluates the configuration `contents` for the given `file`.\n\nAccepts the same options as `read!/2`.","prompt":"Can you write a docstring for the following Elixir function? eval!(file, contents, opts \\\\ [])"}
{"completion":"Merges two configurations.\n\nThe configurations are merged together with the values in\nthe second one having higher preference than the first in\ncase of conflicts. In case both values are set to keyword\nlists, it deep merges them.\n\n## Examples\n\n    iex> Config.Reader.merge([app: [k: :v1]], [app: [k: :v2]])\n    [app: [k: :v2]]\n\n    iex> Config.Reader.merge([app: [k: [v1: 1, v2: 2]]], [app: [k: [v2: :a, v3: :b]]])\n    [app: [k: [v1: 1, v2: :a, v3: :b]]]\n\n    iex> Config.Reader.merge([app1: []], [app2: []])\n    [app1: [], app2: []]","prompt":"Can you write a docstring for the following Elixir function? merge(config1, config2)"}
{"completion":"Reads the configuration file.\n\n## Options\n\n  * `:imports` - a list of already imported paths or `:disabled`\n    to disable imports\n\n  * `:env` - the environment the configuration file runs on.\n    See `Config.config_env/0` for sample usage\n\n  * `:target` - the target the configuration file runs on.\n    See `Config.config_target/0` for sample usage","prompt":"Can you write a docstring for the following Elixir function? read!(file, opts \\\\ [])"}
{"completion":"Reads the given configuration file and returns the configuration\nwith its imports.\n\nAccepts the same options as `read!/2`. Although note the `:imports`\noption cannot be disabled in `read_imports!/2`.","prompt":"Can you write a docstring for the following Elixir function? read_imports!(file, opts \\\\ [])"}
{"completion":"API for reading config files defined with `Config`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Config.Reader"}
{"completion":"As a provider\n\n`Config.Reader` can also be used as a `Config.Provider`. A config\nprovider is used during releases to customize how applications are\nconfigured. When used as a provider, it expects a single argument:\nthe configuration path (as outlined in `t:Config.Provider.config_path/0`)\nfor the file to be read and loaded during the system boot.\n\nFor example, if you expect the target system to have a config file\nin an absolute path, you can add this inside the `def project` portion\nof  your `mix.exs`:\n\n    releases: [\n      demo: [\n        config_providers: [\n          {Config.Reader, \"/etc/config.exs\"}\n        ]\n      ]\n    ]\n\nOr if you want to read a custom path inside the release:\n\n    config_providers: [{Config.Reader, {:system, \"RELEASE_ROOT\", \"/config.exs\"}}]\n\nYou can also pass a keyword list of options to the reader,\nwhere the `:path` is a required key:\n\n    config_providers: [\n      {Config.Reader,\n       path: \"/etc/config.exs\",\n       env: :prod,\n       imports: :disabled}\n    ]\n\nRemember Mix already loads `config/runtime.exs` by default.\nFor more examples and scenarios, see the `Config.Provider` module.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Config.Reader"}
{"completion":"Configures the given `root_key`.\n\nKeyword lists are always deep-merged.\n\n## Examples\n\nThe given `opts` are merged into the existing configuration\nfor the given `root_key`. Conflicting keys are overridden by the\nones specified in `opts`, unless they are keywords, which are\ndeep merged recursively. For example, the application configuration\nbelow\n\n    config :logger,\n      level: :warn,\n      backends: [:console]\n\n    config :logger,\n      level: :info,\n      truncate: 1024\n\nwill have a final configuration for `:logger` of:\n\n    [level: :info, backends: [:console], truncate: 1024]","prompt":"Can you write a docstring for the following Elixir function? config(root_key, opts)"}
{"completion":"Configures the given `key` for the given `root_key`.\n\nKeyword lists are always deep merged.\n\n## Examples\n\nThe given `opts` are merged into the existing values for `key`\nin the given `root_key`. Conflicting keys are overridden by the\nones specified in `opts`, unless they are keywords, which are\ndeep merged recursively. For example, the application configuration\nbelow\n\n    config :ecto, Repo,\n      log_level: :warn,\n      adapter: Ecto.Adapters.Postgres,\n      metadata: [read_only: true]\n\n    config :ecto, Repo,\n      log_level: :info,\n      pool_size: 10,\n      metadata: [replica: true]\n\nwill have a final value of the configuration for the `Repo`\nkey in the `:ecto` application of:\n\n    Application.get_env(:ecto, Repo)\n    #=> [\n    #=>   log_level: :info,\n    #=>   pool_size: 10,\n    #=>   adapter: Ecto.Adapters.Postgres,\n    #=>   metadata: [read_only: true, replica: true]\n    #=> ]","prompt":"Can you write a docstring for the following Elixir function? config(root_key, key, opts)"}
{"completion":"A simple keyword-based configuration API.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Config"}
{"completion":"Example\n\nThis module is most commonly used to define application configuration,\ntypically in `config/config.exs`:\n\n    import Config\n\n    config :some_app,\n      key1: \"value1\",\n      key2: \"value2\"\n\n    import_config \"#{config_env()}.exs\"\n\n`import Config` will import the functions `config/2`, `config/3`\n`config_env/0`, `config_target/0`, and `import_config/1`\nto help you manage your configuration.\n\n`config/2` and `config/3` are used to define key-value configuration\nfor a given application. Once Mix starts, it will automatically\nevaluate the configuration file and persist the configuration above\ninto `:some_app`'s application environment, which can be accessed in\nas follows:\n\n    \"value1\" = Application.fetch_env!(:some_app, :key1)\n\nFinally, the line `import_config \"#{config_env()}.exs\"` will import\nother config files based on the current configuration environment,\nsuch as `config/dev.exs` and `config/test.exs`.\n\n`Config` also provides a low-level API for evaluating and reading\nconfiguration, under the `Config.Reader` module.\n\n> **Important:** if you are writing a library to be used by other developers,\n> it is generally recommended to avoid the application environment, as the\n> application environment is effectively a global storage. Also note that\n> the `config/config.exs` of a library is not evaluated when the library is\n> used as a dependency, as configuration is always meant to configure the\n> current project. For more information, read our [library guidelines](library-guidelines.md).","prompt":"Can you write a docstring for the following Elixir function? Elixir.Config"}
{"completion":"Migrating from `use Mix.Config`\n\nThe `Config` module in Elixir was introduced in v1.9 as a replacement to\n`Mix.Config`, which was specific to Mix and has been deprecated.\n\nYou can leverage `Config` instead of `Mix.Config` in three steps. The first\nstep is to replace `use Mix.Config` at the top of your config files by\n`import Config`.\n\nThe second is to make sure your `import_config/1` calls do not have a\nwildcard character. If so, you need to perform the wildcard lookup\nmanually. For example, if you did:\n\n    import_config \"../apps/*/config/config.exs\"\n\nIt has to be replaced by:\n\n    for config <- \"../apps/*/config/config.exs\" |> Path.expand(__DIR__) |> Path.wildcard() do\n      import_config config\n    end\n\nThe last step is to replace all `Mix.env()` calls in the config files with `config_env()`.\n\nKeep in mind you must also avoid using `Mix.env()` inside your project files.\nTo check the environment at _runtime_, you may add a configuration key:\n\n    # config.exs\n    ...\n    config :my_app, env: config_env()\n\nThen, in other scripts and modules, you may get the environment with\n`Application.fetch_env!/2`:\n\n    # router.exs\n    ...\n    if Application.fetch_env!(:my_app, :env) == :prod do\n      ...\n    end\n\nThe only files where you may access functions from the `Mix` module are\nthe `mix.exs` file and inside custom Mix tasks, which always within the\n`Mix.Tasks` namespace.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Config"}
{"completion":"config/runtime.exs\n\nFor runtime configuration, you can use the `config/runtime.exs` file.\nIt is executed right before applications start in both Mix and releases\n(assembled with `mix release`).","prompt":"Can you write a docstring for the following Elixir function? Elixir.Config"}
{"completion":"Returns an inclusive range between dates.\n\nRanges must be created with the `Date.range/2` or `Date.range/3` function.\n\nThe following fields are public:\n\n  * `:first` - the initial date on the range\n  * `:last` - the last date on the range\n  * `:step` - (since v1.12.0) the step\n\nThe remaining fields are private and should not be accessed.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Date.Range"}
{"completion":"Adds the number of days to the given `date`.\n\nThe days are counted as Gregorian days. The date is returned in the same\ncalendar as it was given in.\n\n## Examples\n\n    iex> Date.add(~D[2000-01-03], -2)\n    ~D[2000-01-01]\n    iex> Date.add(~D[2000-01-01], 2)\n    ~D[2000-01-03]\n    iex> Date.add(~N[2000-01-01 09:00:00], 2)\n    ~D[2000-01-03]\n    iex> Date.add(~D[-0010-01-01], -2)\n    ~D[-0011-12-30]","prompt":"Can you write a docstring for the following Elixir function? add(date, days)"}
{"completion":"Calculates a date that is the first day of the month for the given `date`.\n\n## Examples\n\n    iex> Date.beginning_of_month(~D[2000-01-31])\n    ~D[2000-01-01]\n    iex> Date.beginning_of_month(~D[2000-01-01])\n    ~D[2000-01-01]\n    iex> Date.beginning_of_month(~N[2000-01-31 01:23:45])\n    ~D[2000-01-01]","prompt":"Can you write a docstring for the following Elixir function? beginning_of_month(date)"}
{"completion":"Calculates a date that is the first day of the week for the given `date`.\n\nIf the day is already the first day of the week, it returns the\nday itself. For the built-in ISO calendar, the week starts on Monday.\nA weekday rather than `:default` can be given as `starting_on`.\n\n## Examples\n\n    iex> Date.beginning_of_week(~D[2020-07-11])\n    ~D[2020-07-06]\n    iex> Date.beginning_of_week(~D[2020-07-06])\n    ~D[2020-07-06]\n    iex> Date.beginning_of_week(~D[2020-07-11], :sunday)\n    ~D[2020-07-05]\n    iex> Date.beginning_of_week(~D[2020-07-11], :saturday)\n    ~D[2020-07-11]\n    iex> Date.beginning_of_week(~N[2020-07-11 01:23:45])\n    ~D[2020-07-06]","prompt":"Can you write a docstring for the following Elixir function? beginning_of_week(date, starting_on \\\\ :default)"}
{"completion":"Compares two date structs.\n\nReturns `:gt` if first date is later than the second\nand `:lt` for vice versa. If the two dates are equal\n`:eq` is returned.\n\n## Examples\n\n    iex> Date.compare(~D[2016-04-16], ~D[2016-04-28])\n    :lt\n\nThis function can also be used to compare across more\ncomplex calendar types by considering only the date fields:\n\n    iex> Date.compare(~D[2016-04-16], ~N[2016-04-28 01:23:45])\n    :lt\n    iex> Date.compare(~D[2016-04-16], ~N[2016-04-16 01:23:45])\n    :eq\n    iex> Date.compare(~N[2016-04-16 12:34:56], ~N[2016-04-16 01:23:45])\n    :eq","prompt":"Can you write a docstring for the following Elixir function? compare(date1, date2)"}
{"completion":"Converts the given `date` from its calendar to the given `calendar`.\n\nReturns `{:ok, date}` if the calendars are compatible,\nor `{:error, :incompatible_calendars}` if they are not.\n\nSee also `Calendar.compatible_calendars?/2`.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> Date.convert(~D[2000-01-01], Calendar.Holocene)\n    {:ok, %Date{calendar: Calendar.Holocene, year: 12000, month: 1, day: 1}}","prompt":"Can you write a docstring for the following Elixir function? convert(date, calendar)"}
{"completion":"Similar to `Date.convert/2`, but raises an `ArgumentError`\nif the conversion between the two calendars is not possible.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> Date.convert!(~D[2000-01-01], Calendar.Holocene)\n    %Date{calendar: Calendar.Holocene, year: 12000, month: 1, day: 1}","prompt":"Can you write a docstring for the following Elixir function? convert!(date, calendar)"}
{"completion":"Calculates the day-of-era and era for a given\ncalendar `date`.\n\nReturns a tuple `{day, era}` representing the\nday within the era and the era number.\n\n## Examples\n\n    iex> Date.day_of_era(~D[0001-01-01])\n    {1, 1}\n\n    iex> Date.day_of_era(~D[0000-12-31])\n    {1, 0}","prompt":"Can you write a docstring for the following Elixir function? day_of_era(date)"}
{"completion":"Calculates the day of the week of a given `date`.\n\nReturns the day of the week as an integer. For the ISO 8601\ncalendar (the default), it is an integer from 1 to 7, where\n1 is Monday and 7 is Sunday.\n\nAn optional `starting_on` value may be supplied, which\nconfigures the weekday the week starts on. The default value\nfor it is `:default`, which translates to `:monday` for the\nbuilt-in ISO calendar. Any other weekday may be given to.\n\n## Examples\n\n    iex> Date.day_of_week(~D[2016-10-31])\n    1\n    iex> Date.day_of_week(~D[2016-11-01])\n    2\n    iex> Date.day_of_week(~N[2016-11-01 01:23:45])\n    2\n    iex> Date.day_of_week(~D[-0015-10-30])\n    3\n\n    iex> Date.day_of_week(~D[2016-10-31], :sunday)\n    2\n    iex> Date.day_of_week(~D[2016-11-01], :sunday)\n    3\n    iex> Date.day_of_week(~N[2016-11-01 01:23:45], :sunday)\n    3\n    iex> Date.day_of_week(~D[-0015-10-30], :sunday)\n    4","prompt":"Can you write a docstring for the following Elixir function? day_of_week(date, starting_on \\\\ :default)"}
{"completion":"Calculates the day of the year of a given `date`.\n\nReturns the day of the year as an integer. For the ISO 8601\ncalendar (the default), it is an integer from 1 to 366.\n\n## Examples\n\n    iex> Date.day_of_year(~D[2016-01-01])\n    1\n    iex> Date.day_of_year(~D[2016-11-01])\n    306\n    iex> Date.day_of_year(~D[-0015-10-30])\n    303\n    iex> Date.day_of_year(~D[2004-12-31])\n    366","prompt":"Can you write a docstring for the following Elixir function? day_of_year(date)"}
{"completion":"Returns the number of days in the given `date` month.\n\n## Examples\n\n    iex> Date.days_in_month(~D[1900-01-13])\n    31\n    iex> Date.days_in_month(~D[1900-02-09])\n    28\n    iex> Date.days_in_month(~N[2000-02-20 01:23:45])\n    29","prompt":"Can you write a docstring for the following Elixir function? days_in_month(date)"}
{"completion":"Calculates the difference between two dates, in a full number of days.\n\nIt returns the number of Gregorian days between the dates. Only `Date`\nstructs that follow the same or compatible calendars can be compared\nthis way. If two calendars are not compatible, it will raise.\n\n## Examples\n\n    iex> Date.diff(~D[2000-01-03], ~D[2000-01-01])\n    2\n    iex> Date.diff(~D[2000-01-01], ~D[2000-01-03])\n    -2\n    iex> Date.diff(~D[0000-01-02], ~D[-0001-12-30])\n    3\n    iex> Date.diff(~D[2000-01-01], ~N[2000-01-03 09:00:00])\n    -2","prompt":"Can you write a docstring for the following Elixir function? diff(date1, date2)"}
{"completion":"Calculates a date that is the last day of the month for the given `date`.\n\n## Examples\n\n    iex> Date.end_of_month(~D[2000-01-01])\n    ~D[2000-01-31]\n    iex> Date.end_of_month(~D[2000-01-31])\n    ~D[2000-01-31]\n    iex> Date.end_of_month(~N[2000-01-01 01:23:45])\n    ~D[2000-01-31]","prompt":"Can you write a docstring for the following Elixir function? end_of_month(date)"}
{"completion":"Calculates a date that is the last day of the week for the given `date`.\n\nIf the day is already the last day of the week, it returns the\nday itself. For the built-in ISO calendar, the week ends on Sunday.\nA weekday rather than `:default` can be given as `starting_on`.\n\n## Examples\n\n    iex> Date.end_of_week(~D[2020-07-11])\n    ~D[2020-07-12]\n    iex> Date.end_of_week(~D[2020-07-05])\n    ~D[2020-07-05]\n    iex> Date.end_of_week(~D[2020-07-06], :sunday)\n    ~D[2020-07-11]\n    iex> Date.end_of_week(~D[2020-07-06], :saturday)\n    ~D[2020-07-10]\n    iex> Date.end_of_week(~N[2020-07-11 01:23:45])\n    ~D[2020-07-12]","prompt":"Can you write a docstring for the following Elixir function? end_of_week(date, starting_on \\\\ :default)"}
{"completion":"Converts an Erlang date tuple to a `Date` struct.\n\nOnly supports converting dates which are in the ISO calendar,\nor other calendars in which the days also start at midnight.\nAttempting to convert dates from other calendars will return an error tuple.\n\n## Examples\n\n    iex> Date.from_erl({2000, 1, 1})\n    {:ok, ~D[2000-01-01]}\n    iex> Date.from_erl({2000, 13, 1})\n    {:error, :invalid_date}","prompt":"Can you write a docstring for the following Elixir function? from_erl(tuple, calendar \\\\ Calendar.ISO)"}
{"completion":"Converts an Erlang date tuple but raises for invalid dates.\n\n## Examples\n\n    iex> Date.from_erl!({2000, 1, 1})\n    ~D[2000-01-01]\n    iex> Date.from_erl!({2000, 13, 1})\n    ** (ArgumentError) cannot convert {2000, 13, 1} to date, reason: :invalid_date","prompt":"Can you write a docstring for the following Elixir function? from_erl!(tuple, calendar \\\\ Calendar.ISO)"}
{"completion":"Converts a number of gregorian days to a `Date` struct.\n\n## Examples\n\n    iex> Date.from_gregorian_days(1)\n    ~D[0000-01-02]\n    iex> Date.from_gregorian_days(730_485)\n    ~D[2000-01-01]\n    iex> Date.from_gregorian_days(-1)\n    ~D[-0001-12-31]","prompt":"Can you write a docstring for the following Elixir function? from_gregorian_days(days, calendar \\\\ Calendar.ISO)"}
{"completion":"Parses the extended \"Dates\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nThe year parsed by this function is limited to four digits.\n\n## Examples\n\n    iex> Date.from_iso8601(\"2015-01-23\")\n    {:ok, ~D[2015-01-23]}\n\n    iex> Date.from_iso8601(\"2015:01:23\")\n    {:error, :invalid_format}\n\n    iex> Date.from_iso8601(\"2015-01-32\")\n    {:error, :invalid_date}","prompt":"Can you write a docstring for the following Elixir function? from_iso8601(string, calendar \\\\ Calendar.ISO)"}
{"completion":"Parses the extended \"Dates\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nRaises if the format is invalid.\n\n## Examples\n\n    iex> Date.from_iso8601!(\"2015-01-23\")\n    ~D[2015-01-23]\n    iex> Date.from_iso8601!(\"2015:01:23\")\n    ** (ArgumentError) cannot parse \"2015:01:23\" as date, reason: :invalid_format","prompt":"Can you write a docstring for the following Elixir function? from_iso8601!(string, calendar \\\\ Calendar.ISO)"}
{"completion":"Returns `true` if the year in the given `date` is a leap year.\n\n## Examples\n\n    iex> Date.leap_year?(~D[2000-01-01])\n    true\n    iex> Date.leap_year?(~D[2001-01-01])\n    false\n    iex> Date.leap_year?(~D[2004-01-01])\n    true\n    iex> Date.leap_year?(~D[1900-01-01])\n    false\n    iex> Date.leap_year?(~N[2004-01-01 01:23:45])\n    true","prompt":"Can you write a docstring for the following Elixir function? leap_year?(date)"}
{"completion":"Returns the number of months in the given `date` year.\n\n## Example\n\n    iex> Date.months_in_year(~D[1900-01-13])\n    12","prompt":"Can you write a docstring for the following Elixir function? months_in_year(date)"}
{"completion":"Builds a new ISO date.\n\nExpects all values to be integers. Returns `{:ok, date}` if each\nentry fits its appropriate range, returns `{:error, reason}` otherwise.\n\n## Examples\n\n    iex> Date.new(2000, 1, 1)\n    {:ok, ~D[2000-01-01]}\n    iex> Date.new(2000, 13, 1)\n    {:error, :invalid_date}\n    iex> Date.new(2000, 2, 29)\n    {:ok, ~D[2000-02-29]}\n\n    iex> Date.new(2000, 2, 30)\n    {:error, :invalid_date}\n    iex> Date.new(2001, 2, 29)\n    {:error, :invalid_date}","prompt":"Can you write a docstring for the following Elixir function? new(year, month, day, calendar \\\\ Calendar.ISO)"}
{"completion":"Builds a new ISO date.\n\nExpects all values to be integers. Returns `date` if each\nentry fits its appropriate range, raises if the date is invalid.\n\n## Examples\n\n    iex> Date.new!(2000, 1, 1)\n    ~D[2000-01-01]\n    iex> Date.new!(2000, 13, 1)\n    ** (ArgumentError) cannot build date, reason: :invalid_date\n    iex> Date.new!(2000, 2, 29)\n    ~D[2000-02-29]","prompt":"Can you write a docstring for the following Elixir function? new!(year, month, day, calendar \\\\ Calendar.ISO)"}
{"completion":"Calculates the quarter of the year of a given `date`.\n\nReturns the day of the year as an integer. For the ISO 8601\ncalendar (the default), it is an integer from 1 to 4.\n\n## Examples\n\n    iex> Date.quarter_of_year(~D[2016-10-31])\n    4\n    iex> Date.quarter_of_year(~D[2016-01-01])\n    1\n    iex> Date.quarter_of_year(~N[2016-04-01 01:23:45])\n    2\n    iex> Date.quarter_of_year(~D[-0015-09-30])\n    3","prompt":"Can you write a docstring for the following Elixir function? quarter_of_year(date)"}
{"completion":"Returns a range of dates.\n\nA range of dates represents a discrete number of dates where\nthe first and last values are dates with matching calendars.\n\nRanges of dates can be either increasing (`first <= last`) or\ndecreasing (`first > last`). They are also always inclusive.\n\n## Examples\n\n    iex> Date.range(~D[1999-01-01], ~D[2000-01-01])\n    Date.range(~D[1999-01-01], ~D[2000-01-01])\n\nA range of dates implements the `Enumerable` protocol, which means\nfunctions in the `Enum` module can be used to work with\nranges:\n\n    iex> range = Date.range(~D[2001-01-01], ~D[2002-01-01])\n    iex> range\n    Date.range(~D[2001-01-01], ~D[2002-01-01])\n    iex> Enum.count(range)\n    366\n    iex> ~D[2001-02-01] in range\n    true\n    iex> Enum.take(range, 3)\n    [~D[2001-01-01], ~D[2001-01-02], ~D[2001-01-03]]","prompt":"Can you write a docstring for the following Elixir function? range(first, last)"}
{"completion":"Returns a range of dates with a step.\n\n## Examples\n\n    iex> range = Date.range(~D[2001-01-01], ~D[2002-01-01], 2)\n    iex> range\n    Date.range(~D[2001-01-01], ~D[2002-01-01], 2)\n    iex> Enum.count(range)\n    183\n    iex> ~D[2001-01-03] in range\n    true\n    iex> Enum.take(range, 3)\n    [~D[2001-01-01], ~D[2001-01-03], ~D[2001-01-05]]","prompt":"Can you write a docstring for the following Elixir function? range(first, last, step)"}
{"completion":"Converts the given `date` to an Erlang date tuple.\n\nOnly supports converting dates which are in the ISO calendar,\nor other calendars in which the days also start at midnight.\nAttempting to convert dates from other calendars will raise.\n\n## Examples\n\n    iex> Date.to_erl(~D[2000-01-01])\n    {2000, 1, 1}\n\n    iex> Date.to_erl(~N[2000-01-01 00:00:00])\n    {2000, 1, 1}","prompt":"Can you write a docstring for the following Elixir function? to_erl(date)"}
{"completion":"Converts a `date` struct to a number of gregorian days.\n\n## Examples\n\n    iex> Date.to_gregorian_days(~D[0000-01-02])\n    1\n    iex> Date.to_gregorian_days(~D[2000-01-01])\n    730_485\n    iex> Date.to_gregorian_days(~N[2000-01-01 00:00:00])\n    730_485","prompt":"Can you write a docstring for the following Elixir function? to_gregorian_days(date)"}
{"completion":"Converts the given `date` to\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nBy default, `Date.to_iso8601/2` returns dates formatted in the \"extended\"\nformat, for human readability. It also supports the \"basic\" format through passing the `:basic` option.\n\nOnly supports converting dates which are in the ISO calendar,\nor other calendars in which the days also start at midnight.\nAttempting to convert dates from other calendars will raise an `ArgumentError`.\n\n### Examples\n\n    iex> Date.to_iso8601(~D[2000-02-28])\n    \"2000-02-28\"\n\n    iex> Date.to_iso8601(~D[2000-02-28], :basic)\n    \"20000228\"\n\n    iex> Date.to_iso8601(~N[2000-02-28 00:00:00])\n    \"2000-02-28\"","prompt":"Can you write a docstring for the following Elixir function? to_iso8601(date, format \\\\ :extended)"}
{"completion":"Converts the given date to a string according to its calendar.\n\n### Examples\n\n    iex> Date.to_string(~D[2000-02-28])\n    \"2000-02-28\"\n    iex> Date.to_string(~N[2000-02-28 01:23:45])\n    \"2000-02-28\"\n    iex> Date.to_string(~D[-0100-12-15])\n    \"-0100-12-15\"","prompt":"Can you write a docstring for the following Elixir function? to_string(date)"}
{"completion":"Returns the current date in UTC.\n\n## Examples\n\n    iex> date = Date.utc_today()\n    iex> date.year >= 2016\n    true","prompt":"Can you write a docstring for the following Elixir function? utc_today(calendar \\\\ Calendar.ISO)"}
{"completion":"Calculates the year-of-era and era for a given\ncalendar year.\n\nReturns a tuple `{year, era}` representing the\nyear within the era and the era number.\n\n## Examples\n\n    iex> Date.year_of_era(~D[0001-01-01])\n    {1, 1}\n    iex> Date.year_of_era(~D[0000-12-31])\n    {1, 0}\n    iex> Date.year_of_era(~D[-0001-01-01])\n    {2, 0}","prompt":"Can you write a docstring for the following Elixir function? year_of_era(date)"}
{"completion":"A Date struct and functions.\n\nThe Date struct contains the fields year, month, day and calendar.\nNew dates can be built with the `new/3` function or using the\n`~D` (see `sigil_D/2`) sigil:\n\n    iex> ~D[2000-01-01]\n    ~D[2000-01-01]\n\nBoth `new/3` and sigil return a struct where the date fields can\nbe accessed directly:\n\n    iex> date = ~D[2000-01-01]\n    iex> date.year\n    2000\n    iex> date.month\n    1\n\nThe functions on this module work with the `Date` struct as well\nas any struct that contains the same fields as the `Date` struct,\nsuch as `NaiveDateTime` and `DateTime`. Such functions expect\n`t:Calendar.date/0` in their typespecs (instead of `t:t/0`).\n\nDevelopers should avoid creating the Date structs directly\nand instead rely on the functions provided by this module as well\nas the ones in third-party calendar libraries.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Date"}
{"completion":"Comparing dates\n\nComparisons in Elixir using `==/2`, `>/2`, `</2` and similar are structural\nand based on the `Date` struct fields. For proper comparison between\ndates, use the `compare/2` function. The existence of the `compare/2`\nfunction in this module also allows using `Enum.min/2` and `Enum.max/2`\nfunctions to get the minimum and maximum date of an `Enum`. For example:\n\n    iex>  Enum.min([~D[2017-03-31], ~D[2017-04-01]], Date)\n    ~D[2017-03-31]","prompt":"Can you write a docstring for the following Elixir function? Elixir.Date"}
{"completion":"Using epochs\n\nThe `add/2` and `diff/2` functions can be used for computing dates\nor retrieving the number of days between instants. For example, if there\nis an interest in computing the number of days from the Unix epoch\n(1970-01-01):\n\n    iex> Date.diff(~D[2010-04-17], ~D[1970-01-01])\n    14716\n\n    iex> Date.add(~D[1970-01-01], 14716)\n    ~D[2010-04-17]\n\nThose functions are optimized to deal with common epochs, such\nas the Unix Epoch above or the Gregorian Epoch (0000-01-01).","prompt":"Can you write a docstring for the following Elixir function? Elixir.Date"}
{"completion":"Adds a specified amount of time to a `DateTime`.\n\nAccepts an `amount_to_add` in any `unit`. `unit` can be `:day`,\n`:hour`, `:minute`, `:second` or any subsecond precision from\n`t:System.time_unit/0`. It defaults to `:second`. Negative values\nwill move backwards in time.\n\nThis function always consider the unit to be computed according\nto the `Calendar.ISO`.\n\nThis function uses relies on a contiguous representation of time,\nignoring the wall time and timezone changes. For example, if you add\none day when there are summer time/daylight saving time changes,\nit will also change the time forward or backward by one hour,\nso the ellapsed time is precisely 24 hours. Similarly, adding just\na few seconds to a datetime just before \"spring forward\" can cause\nwall time to increase by more than an hour.\n\nWhile this means this function is precise in terms of ellapsed time,\nits result may be misleading in certain use cases. For example, if a\nuser requests a meeting to happen every day at 15:00 and you use this\nfunction to compute all future meetings by adding day after day, this\nfunction may change the meeting time to 14:00 or 16:00 if there are\nchanges to the current timezone. Computing of recurring datetimes is\nnot currently supported in Elixir's standard library but it is available\nby third-party libraries.\n\n### Examples\n\n    iex> dt = DateTime.from_naive!(~N[2018-11-15 10:00:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> dt |> DateTime.add(3600, :second, FakeTimeZoneDatabase)\n    #DateTime<2018-11-15 11:00:00+01:00 CET Europe/Copenhagen>\n\n    iex> DateTime.add(~U[2018-11-15 10:00:00Z], 3600, :second)\n    ~U[2018-11-15 11:00:00Z]\n\nWhen adding 3 seconds just before \"spring forward\" we go from 1:59:59 to 3:00:02:\n\n    iex> dt = DateTime.from_naive!(~N[2019-03-31 01:59:59.123], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> dt |> DateTime.add(3, :second, FakeTimeZoneDatabase)\n    #DateTime<2019-03-31 03:00:02.123+02:00 CEST Europe/Copenhagen>\n\nWhen adding 1 day during \"spring forward\", the hour also changes:\n\n    iex> dt = DateTime.from_naive!(~N[2019-03-31 01:00:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> dt |> DateTime.add(1, :day, FakeTimeZoneDatabase)\n    #DateTime<2019-04-01 02:00:00+02:00 CEST Europe/Copenhagen>\n\nThis operation merges the precision of the naive date time with the given unit:\n\n    iex> result = DateTime.add(~U[2014-10-02 00:29:10Z], 21, :millisecond)\n    ~U[2014-10-02 00:29:10.021Z]\n    iex> result.microsecond\n    {21000, 3}","prompt":"Can you write a docstring for the following Elixir function? add(datetime, amount_to_add, unit \\\\ :second, time_zone_database \\\\ Calendar.get_time_zone_database())"}
{"completion":"Compares two datetime structs.\n\nReturns `:gt` if the first datetime is later than the second\nand `:lt` for vice versa. If the two datetimes are equal\n`:eq` is returned.\n\nNote that both UTC and Standard offsets will be taken into\naccount when comparison is done.\n\n## Examples\n\n    iex> dt1 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                 utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> dt2 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                 utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.compare(dt1, dt2)\n    :gt","prompt":"Can you write a docstring for the following Elixir function? compare(datetime1, datetime2)"}
{"completion":"Converts a given `datetime` from one calendar to another.\n\nIf it is not possible to convert unambiguously between the calendars\n(see `Calendar.compatible_calendars?/2`), an `{:error, :incompatible_calendars}` tuple\nis returned.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> dt1 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                 utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> DateTime.convert(dt1, Calendar.Holocene)\n    {:ok, %DateTime{calendar: Calendar.Holocene, day: 29, hour: 23,\n                    microsecond: {0, 0}, minute: 0, month: 2, second: 7, std_offset: 0,\n                    time_zone: \"America/Manaus\", utc_offset: -14400, year: 12000,\n                    zone_abbr: \"AMT\"}}","prompt":"Can you write a docstring for the following Elixir function? convert(datetime, calendar)"}
{"completion":"Converts a given `datetime` from one calendar to another.\n\nIf it is not possible to convert unambiguously between the calendars\n(see `Calendar.compatible_calendars?/2`), an ArgumentError is raised.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> dt1 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                 utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> DateTime.convert!(dt1, Calendar.Holocene)\n    %DateTime{calendar: Calendar.Holocene, day: 29, hour: 23,\n              microsecond: {0, 0}, minute: 0, month: 2, second: 7, std_offset: 0,\n              time_zone: \"America/Manaus\", utc_offset: -14400, year: 12000,\n              zone_abbr: \"AMT\"}","prompt":"Can you write a docstring for the following Elixir function? convert!(datetime, calendar)"}
{"completion":"Subtracts `datetime2` from `datetime1`.\n\nThe answer can be returned in any `:day`, `:hour`, `:minute`, or any `unit`\navailable from `t:System.time_unit/0`. The unit is measured according to\n`Calendar.ISO` and defaults to `:second`.\n\nFractional results are not supported and are truncated.\n\n## Examples\n\n    iex> dt1 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                 utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> dt2 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                 utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.diff(dt1, dt2)\n    18000\n    iex> DateTime.diff(dt2, dt1)\n    -18000\n    iex> DateTime.diff(dt1, dt2, :hour)\n    5\n    iex> DateTime.diff(dt2, dt1, :hour)\n    -5","prompt":"Can you write a docstring for the following Elixir function? diff(datetime1, datetime2, unit \\\\ :second)"}
{"completion":"Converts a number of gregorian seconds to a `DateTime` struct.\n\nThe returned `DateTime` will have `UTC` timezone, if you want other timezone, please use\n`DateTime.shift_zone/3`.\n\n## Examples\n\n    iex> DateTime.from_gregorian_seconds(1)\n    ~U[0000-01-01 00:00:01Z]\n    iex> DateTime.from_gregorian_seconds(63_755_511_991, {5000, 3})\n    ~U[2020-05-01 00:26:31.005Z]\n    iex> DateTime.from_gregorian_seconds(-1)\n    ~U[-0001-12-31 23:59:59Z]","prompt":"Can you write a docstring for the following Elixir function? from_gregorian_seconds(seconds, arg \\\\ {0, 0}, calendar \\\\ Calendar.ISO)"}
{"completion":"Parses the extended \"Date and time of day\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nSince ISO 8601 does not include the proper time zone, the given\nstring will be converted to UTC and its offset in seconds will be\nreturned as part of this function. Therefore offset information\nmust be present in the string.\n\nAs specified in the standard, the separator \"T\" may be omitted if\ndesired as there is no ambiguity within this function.\n\nNote leap seconds are not supported by the built-in Calendar.ISO.\n\n## Examples\n\n    iex> {:ok, datetime, 0} = DateTime.from_iso8601(\"2015-01-23T23:50:07Z\")\n    iex> datetime\n    ~U[2015-01-23 23:50:07Z]\n\n    iex> {:ok, datetime, 9000} = DateTime.from_iso8601(\"2015-01-23T23:50:07.123+02:30\")\n    iex> datetime\n    ~U[2015-01-23 21:20:07.123Z]\n\n    iex> {:ok, datetime, 9000} = DateTime.from_iso8601(\"2015-01-23T23:50:07,123+02:30\")\n    iex> datetime\n    ~U[2015-01-23 21:20:07.123Z]\n\n    iex> {:ok, datetime, 0} = DateTime.from_iso8601(\"-2015-01-23T23:50:07Z\")\n    iex> datetime\n    ~U[-2015-01-23 23:50:07Z]\n\n    iex> {:ok, datetime, 9000} = DateTime.from_iso8601(\"-2015-01-23T23:50:07,123+02:30\")\n    iex> datetime\n    ~U[-2015-01-23 21:20:07.123Z]\n\n    iex> {:ok, datetime, 9000} = DateTime.from_iso8601(\"20150123T235007.123+0230\", :basic)\n    iex> datetime\n    ~U[2015-01-23 21:20:07.123Z]\n\n    iex> DateTime.from_iso8601(\"2015-01-23P23:50:07\")\n    {:error, :invalid_format}\n    iex> DateTime.from_iso8601(\"2015-01-23T23:50:07\")\n    {:error, :missing_offset}\n    iex> DateTime.from_iso8601(\"2015-01-23 23:50:61\")\n    {:error, :invalid_time}\n    iex> DateTime.from_iso8601(\"2015-01-32 23:50:07\")\n    {:error, :invalid_date}\n    iex> DateTime.from_iso8601(\"2015-01-23T23:50:07.123-00:00\")\n    {:error, :invalid_format}","prompt":"Can you write a docstring for the following Elixir function? from_iso8601(string, format_or_calendar \\\\ Calendar.ISO)"}
{"completion":"Converts to ISO8601 specifying both a calendar and a mode.\n\nSee `from_iso8601/2` for more information.\n\n## Examples\n\n    iex> {:ok, datetime, 9000} = DateTime.from_iso8601(\"2015-01-23T23:50:07,123+02:30\", Calendar.ISO, :extended)\n    iex> datetime\n    ~U[2015-01-23 21:20:07.123Z]\n\n    iex> {:ok, datetime, 9000} = DateTime.from_iso8601(\"20150123T235007.123+0230\", Calendar.ISO, :basic)\n    iex> datetime\n    ~U[2015-01-23 21:20:07.123Z]","prompt":"Can you write a docstring for the following Elixir function? from_iso8601(string, calendar, format)"}
{"completion":"Converts the given `NaiveDateTime` to `DateTime`.\n\nIt expects a time zone to put the `NaiveDateTime` in.\nIf the time zone is \"Etc/UTC\", it always succeeds. Otherwise,\nthe NaiveDateTime is checked against the time zone database\ngiven as `time_zone_database`. See the \"Time zone database\"\nsection in the module documentation.\n\n## Examples\n\n    iex> DateTime.from_naive(~N[2016-05-24 13:26:08.003], \"Etc/UTC\")\n    {:ok, ~U[2016-05-24 13:26:08.003Z]}\n\nWhen the datetime is ambiguous - for instance during changing from summer\nto winter time - the two possible valid datetimes are returned in a tuple.\nThe first datetime is also the one which comes first chronologically, while\nthe second one comes last.\n\n    iex> {:ambiguous, first_dt, second_dt} = DateTime.from_naive(~N[2018-10-28 02:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> first_dt\n    #DateTime<2018-10-28 02:30:00+02:00 CEST Europe/Copenhagen>\n    iex> second_dt\n    #DateTime<2018-10-28 02:30:00+01:00 CET Europe/Copenhagen>\n\nWhen there is a gap in wall time - for instance in spring when the clocks are\nturned forward - the latest valid datetime just before the gap and the first\nvalid datetime just after the gap.\n\n    iex> {:gap, just_before, just_after} = DateTime.from_naive(~N[2019-03-31 02:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> just_before\n    #DateTime<2019-03-31 01:59:59.999999+01:00 CET Europe/Copenhagen>\n    iex> just_after\n    #DateTime<2019-03-31 03:00:00+02:00 CEST Europe/Copenhagen>\n\nMost of the time there is one, and just one, valid datetime for a certain\ndate and time in a certain time zone.\n\n    iex> {:ok, datetime} = DateTime.from_naive(~N[2018-07-28 12:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> datetime\n    #DateTime<2018-07-28 12:30:00+02:00 CEST Europe/Copenhagen>\n\nThis function accepts any map or struct that contains at least the same fields as a `NaiveDateTime`\nstruct. The most common example of that is a `DateTime`. In this case the information about the time\nzone of that `DateTime` is completely ignored. This is the same principle as passing a `DateTime` to\n`Date.to_iso8601/2`. `Date.to_iso8601/2` extracts only the date-specific fields (calendar, year,\nmonth and day) of the given structure and ignores all others.\n\nThis way if you have a `DateTime` in one time zone, you can get the same wall time in another time zone.\nFor instance if you have 2018-08-24 10:00:00 in Copenhagen and want a `DateTime` for 2018-08-24 10:00:00\nin UTC you can do:\n\n    iex> cph_datetime = DateTime.from_naive!(~N[2018-08-24 10:00:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> {:ok, utc_datetime} = DateTime.from_naive(cph_datetime, \"Etc/UTC\", FakeTimeZoneDatabase)\n    iex> utc_datetime\n    ~U[2018-08-24 10:00:00Z]\n\nIf instead you want a `DateTime` for the same point time in a different time zone see the\n`DateTime.shift_zone/3` function which would convert 2018-08-24 10:00:00 in Copenhagen\nto 2018-08-24 08:00:00 in UTC.","prompt":"Can you write a docstring for the following Elixir function? from_naive(naive_datetime, time_zone, time_zone_database \\\\ Calendar.get_time_zone_database())"}
{"completion":"Converts the given `NaiveDateTime` to `DateTime`.\n\nIt expects a time zone to put the NaiveDateTime in.\nIf the time zone is \"Etc/UTC\", it always succeeds. Otherwise,\nthe NaiveDateTime is checked against the time zone database\ngiven as `time_zone_database`. See the \"Time zone database\"\nsection in the module documentation.\n\n## Examples\n\n    iex> DateTime.from_naive!(~N[2016-05-24 13:26:08.003], \"Etc/UTC\")\n    ~U[2016-05-24 13:26:08.003Z]\n\n    iex> DateTime.from_naive!(~N[2018-05-24 13:26:08.003], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    #DateTime<2018-05-24 13:26:08.003+02:00 CEST Europe/Copenhagen>","prompt":"Can you write a docstring for the following Elixir function? from_naive!(naive_datetime, time_zone, time_zone_database \\\\ Calendar.get_time_zone_database())"}
{"completion":"Converts the given Unix time to `DateTime`.\n\nThe integer can be given in different unit\naccording to `System.convert_time_unit/3` and it will\nbe converted to microseconds internally. Up to\n253402300799 seconds is supported.\n\nUnix times are always in UTC and therefore the DateTime\nwill be returned in UTC.\n\n## Examples\n\n    iex> {:ok, datetime} = DateTime.from_unix(1_464_096_368)\n    iex> datetime\n    ~U[2016-05-24 13:26:08Z]\n\n    iex> {:ok, datetime} = DateTime.from_unix(1_432_560_368_868_569, :microsecond)\n    iex> datetime\n    ~U[2015-05-25 13:26:08.868569Z]\n\n    iex> {:ok, datetime} = DateTime.from_unix(253_402_300_799)\n    iex> datetime\n    ~U[9999-12-31 23:59:59Z]\n\n    iex> {:error, :invalid_unix_time} = DateTime.from_unix(253_402_300_800)\n\nThe unit can also be an integer as in `t:System.time_unit/0`:\n\n    iex> {:ok, datetime} = DateTime.from_unix(143_256_036_886_856, 1024)\n    iex> datetime\n    ~U[6403-03-17 07:05:22.320312Z]\n\nNegative Unix times are supported up to -377705116800 seconds:\n\n    iex> {:ok, datetime} = DateTime.from_unix(-377_705_116_800)\n    iex> datetime\n    ~U[-9999-01-01 00:00:00Z]\n\n    iex> {:error, :invalid_unix_time} = DateTime.from_unix(-377_705_116_801)","prompt":"Can you write a docstring for the following Elixir function? from_unix(integer, unit \\\\ :second, calendar \\\\ Calendar.ISO)"}
{"completion":"Converts the given Unix time to `DateTime`.\n\nThe integer can be given in different unit\naccording to `System.convert_time_unit/3` and it will\nbe converted to microseconds internally.\n\nUnix times are always in UTC and therefore the DateTime\nwill be returned in UTC.\n\n## Examples\n\n    # An easy way to get the Unix epoch is passing 0 to this function\n    iex> DateTime.from_unix!(0)\n    ~U[1970-01-01 00:00:00Z]\n\n    iex> DateTime.from_unix!(1_464_096_368)\n    ~U[2016-05-24 13:26:08Z]\n\n    iex> DateTime.from_unix!(1_432_560_368_868_569, :microsecond)\n    ~U[2015-05-25 13:26:08.868569Z]\n\n    iex> DateTime.from_unix!(143_256_036_886_856, 1024)\n    ~U[6403-03-17 07:05:22.320312Z]","prompt":"Can you write a docstring for the following Elixir function? from_unix!(integer, unit \\\\ :second, calendar \\\\ Calendar.ISO)"}
{"completion":"Builds a datetime from date and time structs.\n\nIt expects a time zone to put the `DateTime` in.\nIf the time zone is not passed it will default to `\"Etc/UTC\"`,\nwhich always succeeds. Otherwise, the `DateTime` is checked against the time zone database\ngiven as `time_zone_database`. See the \"Time zone database\"\nsection in the module documentation.\n\n## Examples\n\n    iex> DateTime.new(~D[2016-05-24], ~T[13:26:08.003], \"Etc/UTC\")\n    {:ok, ~U[2016-05-24 13:26:08.003Z]}\n\nWhen the datetime is ambiguous - for instance during changing from summer\nto winter time - the two possible valid datetimes are returned in a tuple.\nThe first datetime is also the one which comes first chronologically, while\nthe second one comes last.\n\n    iex> {:ambiguous, first_dt, second_dt} = DateTime.new(~D[2018-10-28], ~T[02:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> first_dt\n    #DateTime<2018-10-28 02:30:00+02:00 CEST Europe/Copenhagen>\n    iex> second_dt\n    #DateTime<2018-10-28 02:30:00+01:00 CET Europe/Copenhagen>\n\nWhen there is a gap in wall time - for instance in spring when the clocks are\nturned forward - the latest valid datetime just before the gap and the first\nvalid datetime just after the gap.\n\n    iex> {:gap, just_before, just_after} = DateTime.new(~D[2019-03-31], ~T[02:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> just_before\n    #DateTime<2019-03-31 01:59:59.999999+01:00 CET Europe/Copenhagen>\n    iex> just_after\n    #DateTime<2019-03-31 03:00:00+02:00 CEST Europe/Copenhagen>\n\nMost of the time there is one, and just one, valid datetime for a certain\ndate and time in a certain time zone.\n\n    iex> {:ok, datetime} = DateTime.new(~D[2018-07-28], ~T[12:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> datetime\n    #DateTime<2018-07-28 12:30:00+02:00 CEST Europe/Copenhagen>","prompt":"Can you write a docstring for the following Elixir function? new(date, time, time_zone \\\\ \"Etc/UTC\", time_zone_database \\\\ Calendar.get_time_zone_database())"}
{"completion":"Builds a datetime from date and time structs, raising on errors.\n\nIt expects a time zone to put the `DateTime` in.\nIf the time zone is not passed it will default to `\"Etc/UTC\"`,\nwhich always succeeds. Otherwise, the DateTime is checked against the time zone database\ngiven as `time_zone_database`. See the \"Time zone database\"\nsection in the module documentation.\n\n## Examples\n\n    iex> DateTime.new!(~D[2016-05-24], ~T[13:26:08.003], \"Etc/UTC\")\n    ~U[2016-05-24 13:26:08.003Z]\n\nWhen the datetime is ambiguous - for instance during changing from summer\nto winter time - an error will be raised.\n\n    iex> DateTime.new!(~D[2018-10-28], ~T[02:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    ** (ArgumentError) cannot build datetime with ~D[2018-10-28] and ~T[02:30:00] because such instant is ambiguous in time zone Europe/Copenhagen as there is an overlap between #DateTime<2018-10-28 02:30:00+02:00 CEST Europe/Copenhagen> and #DateTime<2018-10-28 02:30:00+01:00 CET Europe/Copenhagen>\n\nWhen there is a gap in wall time - for instance in spring when the clocks are\nturned forward - an error will be raised.\n\n    iex> DateTime.new!(~D[2019-03-31], ~T[02:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    ** (ArgumentError) cannot build datetime with ~D[2019-03-31] and ~T[02:30:00] because such instant does not exist in time zone Europe/Copenhagen as there is a gap between #DateTime<2019-03-31 01:59:59.999999+01:00 CET Europe/Copenhagen> and #DateTime<2019-03-31 03:00:00+02:00 CEST Europe/Copenhagen>\n\nMost of the time there is one, and just one, valid datetime for a certain\ndate and time in a certain time zone.\n\n    iex> datetime = DateTime.new!(~D[2018-07-28], ~T[12:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> datetime\n    #DateTime<2018-07-28 12:30:00+02:00 CEST Europe/Copenhagen>","prompt":"Can you write a docstring for the following Elixir function? new!(date, time, time_zone \\\\ \"Etc/UTC\", time_zone_database \\\\ Calendar.get_time_zone_database())"}
{"completion":"Returns the current datetime in the provided time zone.\n\nBy default, it uses the default time_zone returned by\n`Calendar.get_time_zone_database/0`, which defaults to\n`Calendar.UTCOnlyTimeZoneDatabase` which only handles \"Etc/UTC\" datetimes.\nOther time zone databases can be passed as argument or set globally.\nSee the \"Time zone database\" section in the module docs.\n\n## Examples\n\n    iex> {:ok, datetime} = DateTime.now(\"Etc/UTC\")\n    iex> datetime.time_zone\n    \"Etc/UTC\"\n\n    iex> DateTime.now(\"Europe/Copenhagen\")\n    {:error, :utc_only_time_zone_database}\n\n    iex> DateTime.now(\"bad timezone\", FakeTimeZoneDatabase)\n    {:error, :time_zone_not_found}","prompt":"Can you write a docstring for the following Elixir function? now(time_zone, time_zone_database \\\\ Calendar.get_time_zone_database())"}
{"completion":"Returns the current datetime in the provided time zone or raises on errors\n\nSee `now/2` for more information.\n\n## Examples\n\n    iex> datetime = DateTime.now!(\"Etc/UTC\")\n    iex> datetime.time_zone\n    \"Etc/UTC\"\n\n    iex> DateTime.now!(\"Europe/Copenhagen\")\n    ** (ArgumentError) cannot get current datetime in \"Europe/Copenhagen\" time zone, reason: :utc_only_time_zone_database\n\n    iex> DateTime.now!(\"bad timezone\", FakeTimeZoneDatabase)\n    ** (ArgumentError) cannot get current datetime in \"bad timezone\" time zone, reason: :time_zone_not_found","prompt":"Can you write a docstring for the following Elixir function? now!(time_zone, time_zone_database \\\\ Calendar.get_time_zone_database())"}
{"completion":"Changes the time zone of a `DateTime`.\n\nReturns a `DateTime` for the same point in time, but instead at\nthe time zone provided. It assumes that `DateTime` is valid and\nexists in the given time zone and calendar.\n\nBy default, it uses the default time zone database returned by\n`Calendar.get_time_zone_database/0`, which defaults to\n`Calendar.UTCOnlyTimeZoneDatabase` which only handles \"Etc/UTC\" datetimes.\nOther time zone databases can be passed as argument or set globally.\nSee the \"Time zone database\" section in the module docs.\n\n## Examples\n\n    iex> {:ok, pacific_datetime} = DateTime.shift_zone(~U[2018-07-16 10:00:00Z], \"America/Los_Angeles\", FakeTimeZoneDatabase)\n    iex> pacific_datetime\n    #DateTime<2018-07-16 03:00:00-07:00 PDT America/Los_Angeles>\n\n    iex> DateTime.shift_zone(~U[2018-07-16 10:00:00Z], \"bad timezone\", FakeTimeZoneDatabase)\n    {:error, :time_zone_not_found}","prompt":"Can you write a docstring for the following Elixir function? shift_zone(datetime, time_zone, time_zone_database \\\\ Calendar.get_time_zone_database())"}
{"completion":"Changes the time zone of a `DateTime` or raises on errors.\n\nSee `shift_zone/3` for more information.\n\n## Examples\n\n    iex> DateTime.shift_zone!(~U[2018-07-16 10:00:00Z], \"America/Los_Angeles\", FakeTimeZoneDatabase)\n    #DateTime<2018-07-16 03:00:00-07:00 PDT America/Los_Angeles>\n\n    iex> DateTime.shift_zone!(~U[2018-07-16 10:00:00Z], \"bad timezone\", FakeTimeZoneDatabase)\n    ** (ArgumentError) cannot shift ~U[2018-07-16 10:00:00Z] to \"bad timezone\" time zone, reason: :time_zone_not_found","prompt":"Can you write a docstring for the following Elixir function? shift_zone!(datetime, time_zone, time_zone_database \\\\ Calendar.get_time_zone_database())"}
{"completion":"Converts a `DateTime` into a `Date`.\n\nBecause `Date` does not hold time nor time zone information,\ndata will be lost during the conversion.\n\n## Examples\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.to_date(dt)\n    ~D[2000-02-29]","prompt":"Can you write a docstring for the following Elixir function? to_date(datetime)"}
{"completion":"Converts a `DateTime` struct to a number of gregorian seconds and microseconds.\n\n## Examples\n\n    iex> dt = %DateTime{year: 0000, month: 1, day: 1, zone_abbr: \"UTC\",\n    ...>                hour: 0, minute: 0, second: 1, microsecond: {0, 0},\n    ...>                utc_offset: 0, std_offset: 0, time_zone: \"Etc/UTC\"}\n    iex> DateTime.to_gregorian_seconds(dt)\n    {1, 0}\n\n    iex> dt = %DateTime{year: 2020, month: 5, day: 1, zone_abbr: \"UTC\",\n    ...>                hour: 0, minute: 26, second: 31, microsecond: {5000, 0},\n    ...>                utc_offset: 0, std_offset: 0, time_zone: \"Etc/UTC\"}\n    iex> DateTime.to_gregorian_seconds(dt)\n    {63_755_511_991, 5000}\n\n    iex> dt = %DateTime{year: 2020, month: 5, day: 1, zone_abbr: \"CET\",\n    ...>                hour: 1, minute: 26, second: 31, microsecond: {5000, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.to_gregorian_seconds(dt)\n    {63_755_511_991, 5000}","prompt":"Can you write a docstring for the following Elixir function? to_gregorian_seconds(datetime)"}
{"completion":"Converts the given datetime to\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601) format.\n\nBy default, `DateTime.to_iso8601/2` returns datetimes formatted in the \"extended\"\nformat, for human readability. It also supports the \"basic\" format through passing the `:basic` option.\n\nOnly supports converting datetimes which are in the ISO calendar,\nattempting to convert datetimes from other calendars will raise.\nYou can also optionally specify an offset for the formatted string.\n\nWARNING: the ISO 8601 datetime format does not contain the time zone nor\nits abbreviation, which means information is lost when converting to such\nformat.\n\n### Examples\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.to_iso8601(dt)\n    \"2000-02-29T23:00:07+01:00\"\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"UTC\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 0, std_offset: 0, time_zone: \"Etc/UTC\"}\n    iex> DateTime.to_iso8601(dt)\n    \"2000-02-29T23:00:07Z\"\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> DateTime.to_iso8601(dt, :extended)\n    \"2000-02-29T23:00:07-04:00\"\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> DateTime.to_iso8601(dt, :basic)\n    \"20000229T230007-0400\"\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> DateTime.to_iso8601(dt, :extended, 3600)\n    \"2000-03-01T04:00:07+01:00\"\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> DateTime.to_iso8601(dt, :extended, 0)\n    \"2000-03-01T03:00:07+00:00\"\n\n    iex> dt = %DateTime{year: 2000, month: 3, day: 01, zone_abbr: \"UTC\",\n    ...>                hour: 03, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 0, std_offset: 0, time_zone: \"Etc/UTC\"}\n    iex> DateTime.to_iso8601(dt, :extended, 0)\n    \"2000-03-01T03:00:07Z\"\n\n    iex> {:ok, dt, offset} = DateTime.from_iso8601(\"2000-03-01T03:00:07Z\")\n    iex> \"2000-03-01T03:00:07Z\" = DateTime.to_iso8601(dt, :extended, offset)","prompt":"Can you write a docstring for the following Elixir function? to_iso8601(datetime, format \\\\ :extended, offset \\\\ nil)"}
{"completion":"Converts the given `datetime` into a `NaiveDateTime`.\n\nBecause `NaiveDateTime` does not hold time zone information,\nany time zone related data will be lost during the conversion.\n\n## Examples\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 1},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.to_naive(dt)\n    ~N[2000-02-29 23:00:07.0]","prompt":"Can you write a docstring for the following Elixir function? to_naive(datetime)"}
{"completion":"Converts the given `datetime` to a string according to its calendar.\n\n### Examples\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.to_string(dt)\n    \"2000-02-29 23:00:07+01:00 CET Europe/Warsaw\"\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"UTC\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 0, std_offset: 0, time_zone: \"Etc/UTC\"}\n    iex> DateTime.to_string(dt)\n    \"2000-02-29 23:00:07Z\"\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> DateTime.to_string(dt)\n    \"2000-02-29 23:00:07-04:00 AMT America/Manaus\"\n\n    iex> dt = %DateTime{year: -100, month: 12, day: 19, zone_abbr: \"CET\",\n    ...>                hour: 3, minute: 20, second: 31, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Stockholm\"}\n    iex> DateTime.to_string(dt)\n    \"-0100-12-19 03:20:31+01:00 CET Europe/Stockholm\"","prompt":"Can you write a docstring for the following Elixir function? to_string(datetime)"}
{"completion":"Converts a `DateTime` into `Time`.\n\nBecause `Time` does not hold date nor time zone information,\ndata will be lost during the conversion.\n\n## Examples\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 1},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.to_time(dt)\n    ~T[23:00:07.0]","prompt":"Can you write a docstring for the following Elixir function? to_time(datetime)"}
{"completion":"Converts the given `datetime` to Unix time.\n\nThe `datetime` is expected to be using the ISO calendar\nwith a year greater than or equal to 0.\n\nIt will return the integer with the given unit,\naccording to `System.convert_time_unit/3`.\n\n## Examples\n\n    iex> 1_464_096_368 |> DateTime.from_unix!() |> DateTime.to_unix()\n    1464096368\n\n    iex> dt = %DateTime{calendar: Calendar.ISO, day: 20, hour: 18, microsecond: {273806, 6},\n    ...>                minute: 58, month: 11, second: 19, time_zone: \"America/Montevideo\",\n    ...>                utc_offset: -10800, std_offset: 3600, year: 2014, zone_abbr: \"UYST\"}\n    iex> DateTime.to_unix(dt)\n    1416517099\n\n    iex> flamel = %DateTime{calendar: Calendar.ISO, day: 22, hour: 8, microsecond: {527771, 6},\n    ...>                minute: 2, month: 3, second: 25, std_offset: 0, time_zone: \"Etc/UTC\",\n    ...>                utc_offset: 0, year: 1418, zone_abbr: \"UTC\"}\n    iex> DateTime.to_unix(flamel)\n    -17412508655","prompt":"Can you write a docstring for the following Elixir function? to_unix(datetime, unit \\\\ :second)"}
{"completion":"Returns the given datetime with the microsecond field truncated to the given\nprecision (`:microsecond`, `:millisecond` or `:second`).\n\nThe given datetime is returned unchanged if it already has lower precision than\nthe given precision.\n\n## Examples\n\n    iex> dt1 = %DateTime{year: 2017, month: 11, day: 7, zone_abbr: \"CET\",\n    ...>                 hour: 11, minute: 45, second: 18, microsecond: {123456, 6},\n    ...>                 utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Paris\"}\n    iex> DateTime.truncate(dt1, :microsecond)\n    #DateTime<2017-11-07 11:45:18.123456+01:00 CET Europe/Paris>\n\n    iex> dt2 = %DateTime{year: 2017, month: 11, day: 7, zone_abbr: \"CET\",\n    ...>                 hour: 11, minute: 45, second: 18, microsecond: {123456, 6},\n    ...>                 utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Paris\"}\n    iex> DateTime.truncate(dt2, :millisecond)\n    #DateTime<2017-11-07 11:45:18.123+01:00 CET Europe/Paris>\n\n    iex> dt3 = %DateTime{year: 2017, month: 11, day: 7, zone_abbr: \"CET\",\n    ...>                 hour: 11, minute: 45, second: 18, microsecond: {123456, 6},\n    ...>                 utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Paris\"}\n    iex> DateTime.truncate(dt3, :second)\n    #DateTime<2017-11-07 11:45:18+01:00 CET Europe/Paris>","prompt":"Can you write a docstring for the following Elixir function? truncate(datetime, precision)"}
{"completion":"Returns the current datetime in UTC.\n\nIf you want the current time in Unix seconds,\nuse `System.os_time/1` instead.\n\n## Examples\n\n    iex> datetime = DateTime.utc_now()\n    iex> datetime.time_zone\n    \"Etc/UTC\"","prompt":"Can you write a docstring for the following Elixir function? utc_now(calendar \\\\ Calendar.ISO)"}
{"completion":"A datetime implementation with a time zone.\n\nThis datetime can be seen as a snapshot of a date and time\nat a given time zone. For such purposes, it also includes both\nUTC and Standard offsets, as well as the zone abbreviation\nfield used exclusively for formatting purposes. Note future\ndatetimes are not necessarily guaranteed to exist, as time\nzones may change any time in the future due to geopolitical\nreasons. See the \"Datetimes as snapshots\" section for more\ninformation.\n\nRemember, comparisons in Elixir using `==/2`, `>/2`, `</2` and friends\nare structural and based on the DateTime struct fields. For proper\ncomparison between datetimes, use the `compare/2` function. The\nexistence of the `compare/2` function in this module also allows\nusing `Enum.min/2` and `Enum.max/2` functions to get the minimum and\nmaximum datetime of an `Enum`. For example:\n\n    iex> Enum.min([~U[2022-01-12 00:01:00.00Z], ~U[2021-01-12 00:01:00.00Z]], DateTime)\n    ~U[2021-01-12 00:01:00.00Z]\n\nDevelopers should avoid creating the `DateTime` struct directly\nand instead rely on the functions provided by this module as\nwell as the ones in third-party calendar libraries.","prompt":"Can you write a docstring for the following Elixir function? Elixir.DateTime"}
{"completion":"Time zone database\n\nMany functions in this module require a time zone database.\nBy default, it uses the default time zone database returned by\n`Calendar.get_time_zone_database/0`, which defaults to\n`Calendar.UTCOnlyTimeZoneDatabase` which only handles \"Etc/UTC\"\ndatetimes and returns `{:error, :utc_only_time_zone_database}`\nfor any other time zone.\n\nOther time zone databases can also be configured. Here are some\navailable options and libraries:\n\n  * [`tz`](https://github.com/mathieuprog/tz)\n  * [`tzdata`](https://github.com/lau/tzdata)\n  * [`zoneinfo`](https://github.com/smartrent/zoneinfo) -\n    recommended for embedded devices\n\nTo use them, first make sure it is added as a dependency in `mix.exs`.\nIt can then be configured either via configuration:\n\n    config :elixir, :time_zone_database, Tz.TimeZoneDatabase\n\nor by calling `Calendar.put_time_zone_database/1`:\n\n    Calendar.put_time_zone_database(Tz.TimeZoneDatabase)\n\nSee the proper names in the library installation instructions.","prompt":"Can you write a docstring for the following Elixir function? Elixir.DateTime"}
{"completion":"Datetimes as snapshots\n\nIn the first section, we described datetimes as a \"snapshot of\na date and time at a given time zone\". To understand precisely\nwhat we mean, let's see an example.\n\nImagine someone in Poland wants to schedule a meeting with someone\nin Brazil in the next year. The meeting will happen at 2:30 AM\nin the Polish time zone. At what time will the meeting happen in\nBrazil?\n\nYou can consult the time zone database today, one year before,\nusing the API in this module and it will give you an answer that\nis valid right now. However, this answer may not be valid in the\nfuture. Why? Because both Brazil and Poland may change their timezone\nrules, ultimately affecting the result. For example, a country may\nchoose to enter or abandon \"Daylight Saving Time\", which is a\nprocess where we adjust the clock one hour forward or one hour\nback once per year. Whenener the rules change, the exact instant\nthat 2:30 AM in Polish time will be in Brazil may change.\n\nIn other words, whenever working with future DateTimes, there is\nno guarantee the results you get will always be correct, until\nthe event actually happens. Therefore, when you ask for a future\ntime, the answers you get are a snapshot that reflects the current\nstate of the time zone rules. For datetimes in the past, this is\nnot a problem, because time zone rules do not change for past\nevents.\n\nTo make matters worse, it may be that the 2:30 AM in Polish time\ndoes not actually even exist or it is ambiguous. If a certain\ntime zone observes \"Daylight Saving Time\", they will move their\nclock forward once a year. When this happens, there is a whole\nhour that does not exist. Then, when they move the clock back,\nthere is a certain hour that will happen twice. So if you want\nto schedule a meeting when this shift back happens, you would\nneed to explicitly say which of the 2:30 AM you precisely mean.\nApplications that are date and time sensitive, need to take\nthese scenarios into account and correctly communicate them to\nusers.\n\nThe good news is: Elixir contains all of the building blocks\nnecessary to tackle those problems. The default timezone database\nused by Elixir, `Calendar.UTCOnlyTimeZoneDatabase`, only works\nwith UTC, which does not observe those issues. Once you bring\na proper time zone database, the functions in this module will\nquery the database and return the relevant information. For\nexample, look at how `DateTime.new/4` returns different results\nbased on the scenarios described in this section.","prompt":"Can you write a docstring for the following Elixir function? Elixir.DateTime"}
{"completion":"Generic API for dictionaries.\n\nIf you need a general dictionary, use the `Map` module.\nIf you need to manipulate keyword lists, use `Keyword`.\n\nTo convert maps into keywords and vice-versa, use the\n`new` function in the respective modules.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Dict"}
{"completion":"Returns a specification to start a dynamic supervisor under a supervisor.\n\nSee `Supervisor`.","prompt":"Can you write a docstring for the following Elixir function? child_spec(opts)"}
{"completion":"Returns a map containing count values for the supervisor.\n\nThe map contains the following keys:\n\n  * `:specs` - the number of children processes\n\n  * `:active` - the count of all actively running child processes managed by\n    this supervisor\n\n  * `:supervisors` - the count of all supervisors whether or not the child\n    process is still alive\n\n  * `:workers` - the count of all workers, whether or not the child process\n    is still alive","prompt":"Can you write a docstring for the following Elixir function? count_children(supervisor)"}
{"completion":"Receives a set of `options` that initializes a dynamic supervisor.\n\nThis is typically invoked at the end of the `c:init/1` callback of\nmodule-based supervisors. See the \"Module-based supervisors\" section\nin the module documentation for more information.\n\nIt accepts the same `options` as `start_link/1` (except for `:name`)\nand it returns a tuple containing the supervisor options.\n\n## Examples\n\n    def init(_arg) do\n      DynamicSupervisor.init(max_children: 1000)\n    end","prompt":"Can you write a docstring for the following Elixir function? init(options)"}
{"completion":"Dynamically adds a child specification to `supervisor` and starts that child.\n\n`child_spec` should be a valid child specification as detailed in the\n\"Child specification\" section of the documentation for `Supervisor`. The child\nprocess will be started as defined in the child specification. Note that while\nthe `:id` field is still required in the spec, the value is ignored and\ntherefore does not need to be unique.\n\nIf the child process start function returns `{:ok, child}` or `{:ok, child,\ninfo}`, then child specification and PID are added to the supervisor and\nthis function returns the same value.\n\nIf the child process start function returns `:ignore`, then no child is added\nto the supervision tree and this function returns `:ignore` too.\n\nIf the child process start function returns an error tuple or an erroneous\nvalue, or if it fails, the child specification is discarded and this function\nreturns `{:error, error}` where `error` is the error or erroneous value\nreturned from child process start function, or failure reason if it fails.\n\nIf the supervisor already has N children in a way that N exceeds the amount\nof `:max_children` set on the supervisor initialization (see `init/1`), then\nthis function returns `{:error, :max_children}`.","prompt":"Can you write a docstring for the following Elixir function? start_child(supervisor, child_spec)"}
{"completion":"Starts a supervisor with the given options.\n\nThis function is typically not invoked directly, instead it is invoked\nwhen using a `DynamicSupervisor` as a child of another supervisor:\n\n    children = [\n      {DynamicSupervisor, name: MySupervisor}\n    ]\n\nIf the supervisor is successfully spawned, this function returns\n`{:ok, pid}`, where `pid` is the PID of the supervisor. If the supervisor\nis given a name and a process with the specified name already exists,\nthe function returns `{:error, {:already_started, pid}}`, where `pid`\nis the PID of that process.\n\nNote that a supervisor started with this function is linked to the parent\nprocess and exits not only on crashes but also if the parent process exits\nwith `:normal` reason.\n\n## Options\n\n  * `:name` - registers the supervisor under the given name.\n    The supported values are described under the \"Name registration\"\n    section in the `GenServer` module docs.\n\n  * `:strategy` - the restart strategy option. The only supported\n    value is `:one_for_one` which means that no other child is\n    terminated if a child process terminates. You can learn more\n    about strategies in the `Supervisor` module docs.\n\n  * `:max_restarts` - the maximum number of restarts allowed in\n    a time frame. Defaults to `3`.\n\n  * `:max_seconds` - the time frame in which `:max_restarts` applies.\n    Defaults to `5`.\n\n  * `:max_children` - the maximum amount of children to be running\n    under this supervisor at the same time. When `:max_children` is\n    exceeded, `start_child/2` returns `{:error, :max_children}`. Defaults\n    to `:infinity`.\n\n  * `:extra_arguments` - arguments that are prepended to the arguments\n    specified in the child spec given to `start_child/2`. Defaults to\n    an empty list.","prompt":"Can you write a docstring for the following Elixir function? start_link(options)"}
{"completion":"Starts a module-based supervisor process with the given `module` and `init_arg`.\n\nTo start the supervisor, the `c:init/1` callback will be invoked in the given\n`module`, with `init_arg` as its argument. The `c:init/1` callback must return a\nsupervisor specification which can be created with the help of the `init/1`\nfunction.\n\nIf the `c:init/1` callback returns `:ignore`, this function returns\n`:ignore` as well and the supervisor terminates with reason `:normal`.\nIf it fails or returns an incorrect value, this function returns\n`{:error, term}` where `term` is a term with information about the\nerror, and the supervisor terminates with reason `term`.\n\nThe `:name` option can also be given in order to register a supervisor\nname, the supported values are described in the \"Name registration\"\nsection in the `GenServer` module docs.\n\nIf the supervisor is successfully spawned, this function returns\n`{:ok, pid}`, where `pid` is the PID of the supervisor. If the supervisor\nis given a name and a process with the specified name already exists,\nthe function returns `{:error, {:already_started, pid}}`, where `pid`\nis the PID of that process.\n\nNote that a supervisor started with this function is linked to the parent\nprocess and exits not only on crashes but also if the parent process exits\nwith `:normal` reason.","prompt":"Can you write a docstring for the following Elixir function? start_link(module, init_arg, opts \\\\ [])"}
{"completion":"Synchronously stops the given supervisor with the given `reason`.\n\nIt returns `:ok` if the supervisor terminates with the given\nreason. If it terminates with another reason, the call exits.\n\nThis function keeps OTP semantics regarding error reporting.\nIf the reason is any other than `:normal`, `:shutdown` or\n`{:shutdown, _}`, an error report is logged.","prompt":"Can you write a docstring for the following Elixir function? stop(supervisor, reason \\\\ :normal, timeout \\\\ :infinity)"}
{"completion":"Terminates the given child identified by `pid`.\n\nIf successful, this function returns `:ok`. If there is no process with\nthe given PID, this function returns `{:error, :not_found}`.","prompt":"Can you write a docstring for the following Elixir function? terminate_child(supervisor, pid)"}
{"completion":"Returns a list with information about all children.\n\nNote that calling this function when supervising a large number\nof children under low memory conditions can cause an out of memory\nexception.\n\nThis function returns a list of tuples containing:\n\n  * `id` - it is always `:undefined` for dynamic supervisors\n\n  * `child` - the PID of the corresponding child process or the\n    atom `:restarting` if the process is about to be restarted\n\n  * `type` - `:worker` or `:supervisor` as defined in the child\n    specification\n\n  * `modules` - as defined in the child specification","prompt":"Can you write a docstring for the following Elixir function? which_children(supervisor)"}
{"completion":"A supervisor optimized to only start children dynamically.\n\nThe `Supervisor` module was designed to handle mostly static children\nthat are started in the given order when the supervisor starts. A\n`DynamicSupervisor` starts with no children. Instead, children are\nstarted on demand via `start_child/2` and there is no ordering between\nchildren. This allows the `DynamicSupervisor` to hold millions of\nchildren by using efficient data structures and to execute certain\noperations, such as shutting down, concurrently.","prompt":"Can you write a docstring for the following Elixir function? Elixir.DynamicSupervisor"}
{"completion":"Examples\n\nA dynamic supervisor is started with no children and often a name:\n\n    children = [\n      {DynamicSupervisor, name: MyApp.DynamicSupervisor}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nThe options given in the child specification are documented in `start_link/1`.\n\nOnce the dynamic supervisor is running, we can start children\nwith `start_child/2`, which receives a child specification:\n\n    {:ok, agent1} = DynamicSupervisor.start_child(MyApp.DynamicSupervisor, {Agent, fn -> %{} end})\n    Agent.update(agent1, &Map.put(&1, :key, \"value\"))\n    Agent.get(agent1, & &1)\n    #=> %{key: \"value\"}\n\n    {:ok, agent2} = DynamicSupervisor.start_child(MyApp.DynamicSupervisor, {Agent, fn -> %{} end})\n    Agent.get(agent2, & &1)\n    #=> %{}\n\n    DynamicSupervisor.count_children(MyApp.DynamicSupervisor)\n    #=> %{active: 2, specs: 2, supervisors: 0, workers: 2}","prompt":"Can you write a docstring for the following Elixir function? Elixir.DynamicSupervisor"}
{"completion":"Scalability and partitioning\n\nThe `DynamicSupervisor` is a single process responsible for starting\nother processes. In some applications, the `DynamicSupervisor` may\nbecome a bottleneck. To address this, you can start multiple instances\nof the `DynamicSupervisor` and then pick a \"random\" instance to start\nthe child on.\n\nInstead of:\n\n    children = [\n      {DynamicSupervisor, name: MyApp.DynamicSupervisor}\n    ]\n\nand:\n\n    DynamicSupervisor.start_child(MyApp.DynamicSupervisor, {Agent, fn -> %{} end})\n\nYou can do this:\n\n    children = [\n      {PartitionSupervisor,\n       child_spec: DynamicSupervisor,\n       name: MyApp.DynamicSupervisors}\n    ]\n\nand then:\n\n    DynamicSupervisor.start_child(\n      {:via, PartitionSupervisor, {MyApp.DynamicSupervisors, self()}},\n      {Agent, fn -> %{} end}\n    )\n\nIn the code above, we start a partition supervisor that will by default\nstart a dynamic supervisor for each core in your machine. Then, instead\nof calling the `DynamicSupervisor` by name, you call it through the\npartition supervisor, using `self()` as the routing key. This means each\nprocess will be assigned one of the existing dynamic supervisors.\nRead the `PartitionSupervisor` docs for more information.","prompt":"Can you write a docstring for the following Elixir function? Elixir.DynamicSupervisor"}
{"completion":"Module-based supervisors\n\nSimilar to `Supervisor`, dynamic supervisors also support module-based\nsupervisors.\n\n    defmodule MyApp.DynamicSupervisor do\n      # Automatically defines child_spec/1\n      use DynamicSupervisor\n\n      def start_link(init_arg) do\n        DynamicSupervisor.start_link(__MODULE__, init_arg, name: __MODULE__)\n      end\n\n      @impl true\n      def init(_init_arg) do\n        DynamicSupervisor.init(strategy: :one_for_one)\n      end\n    end\n\nSee the `Supervisor` docs for a discussion of when you may want to use\nmodule-based supervisors. A `@doc` annotation immediately preceding\n`use DynamicSupervisor` will be attached to the generated `child_spec/1`\nfunction.","prompt":"Can you write a docstring for the following Elixir function? Elixir.DynamicSupervisor"}
{"completion":"Name registration\n\nA supervisor is bound to the same name registration rules as a `GenServer`.\nRead more about these rules in the documentation for `GenServer`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.DynamicSupervisor"}
{"completion":"Migrating from Supervisor's :simple_one_for_one\n\nIn case you were using the deprecated `:simple_one_for_one` strategy from\nthe `Supervisor` module, you can migrate to the `DynamicSupervisor` in\nfew steps.\n\nImagine the given \"old\" code:\n\n    defmodule MySupervisor do\n      use Supervisor\n\n      def start_link(init_arg) do\n        Supervisor.start_link(__MODULE__, init_arg, name: __MODULE__)\n      end\n\n      def start_child(foo, bar, baz) do\n        # This will start child by calling MyWorker.start_link(init_arg, foo, bar, baz)\n        Supervisor.start_child(__MODULE__, [foo, bar, baz])\n      end\n\n      @impl true\n      def init(init_arg) do\n        children = [\n          # Or the deprecated: worker(MyWorker, [init_arg])\n          %{id: MyWorker, start: {MyWorker, :start_link, [init_arg]}}\n        ]\n\n        Supervisor.init(children, strategy: :simple_one_for_one)\n      end\n    end\n\nIt can be upgraded to the DynamicSupervisor like this:\n\n    defmodule MySupervisor do\n      use DynamicSupervisor\n\n      def start_link(init_arg) do\n        DynamicSupervisor.start_link(__MODULE__, init_arg, name: __MODULE__)\n      end\n\n      def start_child(foo, bar, baz) do\n        # If MyWorker is not using the new child specs, we need to pass a map:\n        # spec = %{id: MyWorker, start: {MyWorker, :start_link, [foo, bar, baz]}}\n        spec = {MyWorker, foo: foo, bar: bar, baz: baz}\n        DynamicSupervisor.start_child(__MODULE__, spec)\n      end\n\n      @impl true\n      def init(init_arg) do\n        DynamicSupervisor.init(\n          strategy: :one_for_one,\n          extra_arguments: [init_arg]\n        )\n      end\n    end\n\nThe difference is that the `DynamicSupervisor` expects the child specification\nat the moment `start_child/2` is called, and no longer on the init callback.\nIf there are any initial arguments given on initialization, such as `[initial_arg]`,\nit can be given in the `:extra_arguments` flag on `DynamicSupervisor.init/1`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.DynamicSupervisor"}
{"completion":"Returns `true` if all elements in `enumerable` are truthy.\n\nWhen an element has a falsy value (`false` or `nil`) iteration stops immediately\nand `false` is returned. In all other cases `true` is returned.\n\n## Examples\n\n    iex> Enum.all?([1, 2, 3])\n    true\n\n    iex> Enum.all?([1, nil, 3])\n    false\n\n    iex> Enum.all?([])\n    true","prompt":"Can you write a docstring for the following Elixir function? all?(enumerable)"}
{"completion":"Returns `true` if `fun.(element)` is truthy for all elements in `enumerable`.\n\nIterates over `enumerable` and invokes `fun` on each element. If `fun` ever\nreturns a falsy value (`false` or `nil`), iteration stops immediately and\n`false` is returned. Otherwise, `true` is returned.\n\n## Examples\n\n    iex> Enum.all?([2, 4, 6], fn x -> rem(x, 2) == 0 end)\n    true\n\n    iex> Enum.all?([2, 3, 4], fn x -> rem(x, 2) == 0 end)\n    false\n\n    iex> Enum.all?([], fn _ -> nil end)\n    true\n\nAs the last example shows, `Enum.all?/2` returns `true` if `enumerable` is\nempty, regardless of `fun`. In an empty enumerable there is no element for\nwhich `fun` returns a falsy value, so the result must be `true`. This is a\nwell-defined logical argument for empty collections.","prompt":"Can you write a docstring for the following Elixir function? all?(enumerable, fun)"}
{"completion":"Returns `true` if at least one element in `enumerable` is truthy.\n\nWhen an element has a truthy value (neither `false` nor `nil`) iteration stops\nimmediately and `true` is returned. In all other cases `false` is returned.\n\n## Examples\n\n    iex> Enum.any?([false, false, false])\n    false\n\n    iex> Enum.any?([false, true, false])\n    true\n\n    iex> Enum.any?([])\n    false","prompt":"Can you write a docstring for the following Elixir function? any?(enumerable)"}
{"completion":"Returns `true` if `fun.(element)` is truthy for at least one element in `enumerable`.\n\nIterates over the `enumerable` and invokes `fun` on each element. When an invocation\nof `fun` returns a truthy value (neither `false` nor `nil`) iteration stops\nimmediately and `true` is returned. In all other cases `false` is returned.\n\n## Examples\n\n    iex> Enum.any?([2, 4, 6], fn x -> rem(x, 2) == 1 end)\n    false\n\n    iex> Enum.any?([2, 3, 4], fn x -> rem(x, 2) == 1 end)\n    true\n\n    iex> Enum.any?([], fn x -> x > 0 end)\n    false","prompt":"Can you write a docstring for the following Elixir function? any?(enumerable, fun)"}
{"completion":"Finds the element at the given `index` (zero-based).\n\nReturns `default` if `index` is out of bounds.\n\nA negative `index` can be passed, which means the `enumerable` is\nenumerated once and the `index` is counted from the end (for example,\n`-1` finds the last element).\n\n## Examples\n\n    iex> Enum.at([2, 4, 6], 0)\n    2\n\n    iex> Enum.at([2, 4, 6], 2)\n    6\n\n    iex> Enum.at([2, 4, 6], 4)\n    nil\n\n    iex> Enum.at([2, 4, 6], 4, :none)\n    :none","prompt":"Can you write a docstring for the following Elixir function? at(enumerable, index, default \\\\ nil)"}
{"completion":"Splits enumerable on every element for which `fun` returns a new\nvalue.\n\nReturns a list of lists.\n\n## Examples\n\n    iex> Enum.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) == 1))\n    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]","prompt":"Can you write a docstring for the following Elixir function? chunk_by(enumerable, fun)"}
{"completion":"Shortcut to `chunk_every(enumerable, count, count)`.","prompt":"Can you write a docstring for the following Elixir function? chunk_every(enumerable, count)"}
{"completion":"Returns list of lists containing `count` elements each, where\neach new chunk starts `step` elements into the `enumerable`.\n\n`step` is optional and, if not passed, defaults to `count`, i.e.\nchunks do not overlap.\n\nIf the last chunk does not have `count` elements to fill the chunk,\nelements are taken from `leftover` to fill in the chunk. If `leftover`\ndoes not have enough elements to fill the chunk, then a partial chunk\nis returned with less than `count` elements.\n\nIf `:discard` is given in `leftover`, the last chunk is discarded\nunless it has exactly `count` elements.\n\n## Examples\n\n    iex> Enum.chunk_every([1, 2, 3, 4, 5, 6], 2)\n    [[1, 2], [3, 4], [5, 6]]\n\n    iex> Enum.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, :discard)\n    [[1, 2, 3], [3, 4, 5]]\n\n    iex> Enum.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, [7])\n    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n\n    iex> Enum.chunk_every([1, 2, 3, 4], 3, 3, [])\n    [[1, 2, 3], [4]]\n\n    iex> Enum.chunk_every([1, 2, 3, 4], 10)\n    [[1, 2, 3, 4]]\n\n    iex> Enum.chunk_every([1, 2, 3, 4, 5], 2, 3, [])\n    [[1, 2], [4, 5]]\n\n    iex> Enum.chunk_every([1, 2, 3, 4], 3, 3, Stream.cycle([0]))\n    [[1, 2, 3], [4, 0, 0]]","prompt":"Can you write a docstring for the following Elixir function? chunk_every(enumerable, count, step, leftover \\\\ [])"}
{"completion":"Chunks the `enumerable` with fine grained control when every chunk is emitted.\n\n`chunk_fun` receives the current element and the accumulator and must return:\n\n  * `{:cont, chunk, acc}` to emit a chunk and continue with the accumulator\n  * `{:cont, acc}` to not emit any chunk and continue with the accumulator\n  * `{:halt, acc}` to halt chunking over the `enumerable`.\n\n`after_fun` is invoked with the final accumulator when iteration is\nfinished (or `halt`ed) to handle any trailing elements that were returned\nas part of an accumulator, but were not emitted as a chunk by `chunk_fun`.\nIt must return:\n\n  * `{:cont, chunk, acc}` to emit a chunk. The chunk will be appended to the\n    list of already emitted chunks.\n  * `{:cont, acc}` to not emit a chunk\n\nThe `acc` in `after_fun` is required in order to mirror the tuple format\nfrom `chunk_fun` but it will be discarded since the traversal is complete.\n\nReturns a list of emitted chunks.\n\n## Examples\n\n    iex> chunk_fun = fn element, acc ->\n    ...>   if rem(element, 2) == 0 do\n    ...>     {:cont, Enum.reverse([element | acc]), []}\n    ...>   else\n    ...>     {:cont, [element | acc]}\n    ...>   end\n    ...> end\n    iex> after_fun = fn\n    ...>   [] -> {:cont, []}\n    ...>   acc -> {:cont, Enum.reverse(acc), []}\n    ...> end\n    iex> Enum.chunk_while(1..10, [], chunk_fun, after_fun)\n    [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]\n    iex> Enum.chunk_while([1, 2, 3, 5, 7], [], chunk_fun, after_fun)\n    [[1, 2], [3, 5, 7]]","prompt":"Can you write a docstring for the following Elixir function? chunk_while(enumerable, acc, chunk_fun, after_fun)"}
{"completion":"Given an enumerable of enumerables, concatenates the `enumerables` into\na single list.\n\n## Examples\n\n    iex> Enum.concat([1..3, 4..6, 7..9])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    iex> Enum.concat([[1, [2], 3], [4], [5, 6]])\n    [1, [2], 3, 4, 5, 6]","prompt":"Can you write a docstring for the following Elixir function? concat(enumerables)"}
{"completion":"Concatenates the enumerable on the `right` with the enumerable on the\n`left`.\n\nThis function produces the same result as the `++/2` operator\nfor lists.\n\n## Examples\n\n    iex> Enum.concat(1..3, 4..6)\n    [1, 2, 3, 4, 5, 6]\n\n    iex> Enum.concat([1, 2, 3], [4, 5, 6])\n    [1, 2, 3, 4, 5, 6]","prompt":"Can you write a docstring for the following Elixir function? concat(left, right)"}
{"completion":"Returns the size of the `enumerable`.\n\n## Examples\n\n    iex> Enum.count([1, 2, 3])\n    3","prompt":"Can you write a docstring for the following Elixir function? count(enumerable)"}
{"completion":"Returns the count of elements in the `enumerable` for which `fun` returns\na truthy value.\n\n## Examples\n\n    iex> Enum.count([1, 2, 3, 4, 5], fn x -> rem(x, 2) == 0 end)\n    2","prompt":"Can you write a docstring for the following Elixir function? count(enumerable, fun)"}
{"completion":"Counts the enumerable stopping at `limit`.\n\nThis is useful for checking certain properties of the count of an enumerable\nwithout having to actually count the entire enumerable. For example, if you\nwanted to check that the count was exactly, at least, or more than a value.\n\nIf the enumerable implements `c:Enumerable.count/1`, the enumerable is\nnot traversed and we return the lower of the two numbers. To force\nenumeration, use `count_until/3` with `fn _ -> true end` as the second\nargument.\n\n## Examples\n\n    iex> Enum.count_until(1..20, 5)\n    5\n    iex> Enum.count_until(1..20, 50)\n    20\n    iex> Enum.count_until(1..10, 10) == 10 # At least 10\n    true\n    iex> Enum.count_until(1..11, 10 + 1) > 10 # More than 10\n    true\n    iex> Enum.count_until(1..5, 10) < 10 # Less than 10\n    true\n    iex> Enum.count_until(1..10, 10 + 1) == 10 # Exactly ten\n    true","prompt":"Can you write a docstring for the following Elixir function? count_until(enumerable, limit)"}
{"completion":"Counts the elements in the enumerable for which `fun` returns a truthy value, stopping at `limit`.\n\nSee `count/2` and `count_until/3` for more information.\n\n## Examples\n\n    iex> Enum.count_until(1..20, fn x -> rem(x, 2) == 0 end, 7)\n    7\n    iex> Enum.count_until(1..20, fn x -> rem(x, 2) == 0 end, 11)\n    10","prompt":"Can you write a docstring for the following Elixir function? count_until(enumerable, fun, limit)"}
{"completion":"Enumerates the `enumerable`, returning a list where all consecutive\nduplicated elements are collapsed to a single element.\n\nElements are compared using `===/2`.\n\nIf you want to remove all duplicated elements, regardless of order,\nsee `uniq/1`.\n\n## Examples\n\n    iex> Enum.dedup([1, 2, 3, 3, 2, 1])\n    [1, 2, 3, 2, 1]\n\n    iex> Enum.dedup([1, 1, 2, 2.0, :three, :three])\n    [1, 2, 2.0, :three]","prompt":"Can you write a docstring for the following Elixir function? dedup(enumerable)"}
{"completion":"Enumerates the `enumerable`, returning a list where all consecutive\nduplicated elements are collapsed to a single element.\n\nThe function `fun` maps every element to a term which is used to\ndetermine if two elements are duplicates.\n\n## Examples\n\n    iex> Enum.dedup_by([{1, :a}, {2, :b}, {2, :c}, {1, :a}], fn {x, _} -> x end)\n    [{1, :a}, {2, :b}, {1, :a}]\n\n    iex> Enum.dedup_by([5, 1, 2, 3, 2, 1], fn x -> x > 2 end)\n    [5, 1, 3, 2]","prompt":"Can you write a docstring for the following Elixir function? dedup_by(enumerable, fun)"}
{"completion":"Drops the `amount` of elements from the `enumerable`.\n\nIf a negative `amount` is given, the `amount` of last values will be dropped.\nThe `enumerable` will be enumerated once to retrieve the proper index and\nthe remaining calculation is performed from the end.\n\n## Examples\n\n    iex> Enum.drop([1, 2, 3], 2)\n    [3]\n\n    iex> Enum.drop([1, 2, 3], 10)\n    []\n\n    iex> Enum.drop([1, 2, 3], 0)\n    [1, 2, 3]\n\n    iex> Enum.drop([1, 2, 3], -1)\n    [1, 2]","prompt":"Can you write a docstring for the following Elixir function? drop(enumerable, amount)"}
{"completion":"Returns a list of every `nth` element in the `enumerable` dropped,\nstarting with the first element.\n\nThe first element is always dropped, unless `nth` is 0.\n\nThe second argument specifying every `nth` element must be a non-negative\ninteger.\n\n## Examples\n\n    iex> Enum.drop_every(1..10, 2)\n    [2, 4, 6, 8, 10]\n\n    iex> Enum.drop_every(1..10, 0)\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    iex> Enum.drop_every([1, 2, 3], 1)\n    []","prompt":"Can you write a docstring for the following Elixir function? drop_every(enumerable, nth)"}
{"completion":"Drops elements at the beginning of the `enumerable` while `fun` returns a\ntruthy value.\n\n## Examples\n\n    iex> Enum.drop_while([1, 2, 3, 2, 1], fn x -> x < 3 end)\n    [3, 2, 1]","prompt":"Can you write a docstring for the following Elixir function? drop_while(enumerable, fun)"}
{"completion":"Invokes the given `fun` for each element in the `enumerable`.\n\nReturns `:ok`.\n\n## Examples\n\n    Enum.each([\"some\", \"example\"], fn x -> IO.puts(x) end)\n    \"some\"\n    \"example\"\n    #=> :ok","prompt":"Can you write a docstring for the following Elixir function? each(enumerable, fun)"}
{"completion":"Determines if the `enumerable` is empty.\n\nReturns `true` if `enumerable` is empty, otherwise `false`.\n\n## Examples\n\n    iex> Enum.empty?([])\n    true\n\n    iex> Enum.empty?([1, 2, 3])\n    false","prompt":"Can you write a docstring for the following Elixir function? empty?(enumerable)"}
{"completion":"Finds the element at the given `index` (zero-based).\n\nReturns `{:ok, element}` if found, otherwise `:error`.\n\nA negative `index` can be passed, which means the `enumerable` is\nenumerated once and the `index` is counted from the end (for example,\n`-1` fetches the last element).\n\n## Examples\n\n    iex> Enum.fetch([2, 4, 6], 0)\n    {:ok, 2}\n\n    iex> Enum.fetch([2, 4, 6], -3)\n    {:ok, 2}\n\n    iex> Enum.fetch([2, 4, 6], 2)\n    {:ok, 6}\n\n    iex> Enum.fetch([2, 4, 6], 4)\n    :error","prompt":"Can you write a docstring for the following Elixir function? fetch(enumerable, index)"}
{"completion":"Finds the element at the given `index` (zero-based).\n\nRaises `OutOfBoundsError` if the given `index` is outside the range of\nthe `enumerable`.\n\n## Examples\n\n    iex> Enum.fetch!([2, 4, 6], 0)\n    2\n\n    iex> Enum.fetch!([2, 4, 6], 2)\n    6\n\n    iex> Enum.fetch!([2, 4, 6], 4)\n    ** (Enum.OutOfBoundsError) out of bounds error","prompt":"Can you write a docstring for the following Elixir function? fetch!(enumerable, index)"}
{"completion":"Filters the `enumerable`, i.e. returns only those elements\nfor which `fun` returns a truthy value.\n\nSee also `reject/2` which discards all elements where the\nfunction returns a truthy value.\n\n## Examples\n\n    iex> Enum.filter([1, 2, 3], fn x -> rem(x, 2) == 0 end)\n    [2]\n\nKeep in mind that `filter` is not capable of filtering and\ntransforming an element at the same time. If you would like\nto do so, consider using `flat_map/2`. For example, if you\nwant to convert all strings that represent an integer and\ndiscard the invalid one in one pass:\n\n    strings = [\"1234\", \"abc\", \"12ab\"]\n\n    Enum.flat_map(strings, fn string ->\n      case Integer.parse(string) do\n        # transform to integer\n        {int, _rest} -> [int]\n        # skip the value\n        :error -> []\n      end\n    end)","prompt":"Can you write a docstring for the following Elixir function? filter(enumerable, fun)"}
{"completion":"Returns the first element for which `fun` returns a truthy value.\nIf no such element is found, returns `default`.\n\n## Examples\n\n    iex> Enum.find([2, 3, 4], fn x -> rem(x, 2) == 1 end)\n    3\n\n    iex> Enum.find([2, 4, 6], fn x -> rem(x, 2) == 1 end)\n    nil\n    iex> Enum.find([2, 4, 6], 0, fn x -> rem(x, 2) == 1 end)\n    0","prompt":"Can you write a docstring for the following Elixir function? find(enumerable, default \\\\ nil, fun)"}
{"completion":"Similar to `find/3`, but returns the index (zero-based)\nof the element instead of the element itself.\n\n## Examples\n\n    iex> Enum.find_index([2, 4, 6], fn x -> rem(x, 2) == 1 end)\n    nil\n\n    iex> Enum.find_index([2, 3, 4], fn x -> rem(x, 2) == 1 end)\n    1","prompt":"Can you write a docstring for the following Elixir function? find_index(enumerable, fun)"}
{"completion":"Similar to `find/3`, but returns the value of the function\ninvocation instead of the element itself.\n\nThe return value is considered to be found when the result is truthy\n(neither `nil` nor `false`).\n\n## Examples\n\n    iex> Enum.find_value([2, 3, 4], fn x ->\n    ...>   if x > 2, do: x * x\n    ...> end)\n    9\n\n    iex> Enum.find_value([2, 4, 6], fn x -> rem(x, 2) == 1 end)\n    nil\n\n    iex> Enum.find_value([2, 3, 4], fn x -> rem(x, 2) == 1 end)\n    true\n\n    iex> Enum.find_value([1, 2, 3], \"no bools!\", &is_boolean/1)\n    \"no bools!\"","prompt":"Can you write a docstring for the following Elixir function? find_value(enumerable, default \\\\ nil, fun)"}
{"completion":"Maps the given `fun` over `enumerable` and flattens the result.\n\nThis function returns a new enumerable built by appending the result of invoking `fun`\non each element of `enumerable` together; conceptually, this is similar to a\ncombination of `map/2` and `concat/1`.\n\n## Examples\n\n    iex> Enum.flat_map([:a, :b, :c], fn x -> [x, x] end)\n    [:a, :a, :b, :b, :c, :c]\n\n    iex> Enum.flat_map([{1, 3}, {4, 6}], fn {x, y} -> x..y end)\n    [1, 2, 3, 4, 5, 6]\n\n    iex> Enum.flat_map([:a, :b, :c], fn x -> [[x]] end)\n    [[:a], [:b], [:c]]","prompt":"Can you write a docstring for the following Elixir function? flat_map(enumerable, fun)"}
{"completion":"Maps and reduces an `enumerable`, flattening the given results (only one level deep).\n\nIt expects an accumulator and a function that receives each enumerable\nelement, and must return a tuple containing a new enumerable (often a list)\nwith the new accumulator or a tuple with `:halt` as first element and\nthe accumulator as second.\n\n## Examples\n\n    iex> enumerable = 1..100\n    iex> n = 3\n    iex> Enum.flat_map_reduce(enumerable, 0, fn x, acc ->\n    ...>   if acc < n, do: {[x], acc + 1}, else: {:halt, acc}\n    ...> end)\n    {[1, 2, 3], 3}\n\n    iex> Enum.flat_map_reduce(1..5, 0, fn x, acc -> {[[x]], acc + x} end)\n    {[[1], [2], [3], [4], [5]], 15}","prompt":"Can you write a docstring for the following Elixir function? flat_map_reduce(enumerable, acc, fun)"}
{"completion":"Returns a map with keys as unique elements of `enumerable` and values\nas the count of every element.\n\n## Examples\n\n    iex> Enum.frequencies(~w{ant buffalo ant ant buffalo dingo})\n    %{\"ant\" => 3, \"buffalo\" => 2, \"dingo\" => 1}","prompt":"Can you write a docstring for the following Elixir function? frequencies(enumerable)"}
{"completion":"Returns a map with keys as unique elements given by `key_fun` and values\nas the count of every element.\n\n## Examples\n\n    iex> Enum.frequencies_by(~w{aa aA bb cc}, &String.downcase/1)\n    %{\"aa\" => 2, \"bb\" => 1, \"cc\" => 1}\n\n    iex> Enum.frequencies_by(~w{aaa aA bbb cc c}, &String.length/1)\n    %{3 => 2, 2 => 2, 1 => 1}","prompt":"Can you write a docstring for the following Elixir function? frequencies_by(enumerable, key_fun)"}
{"completion":"Splits the `enumerable` into groups based on `key_fun`.\n\nThe result is a map where each key is given by `key_fun`\nand each value is a list of elements given by `value_fun`.\nThe order of elements within each list is preserved from the `enumerable`.\nHowever, like all maps, the resulting map is unordered.\n\n## Examples\n\n    iex> Enum.group_by(~w{ant buffalo cat dingo}, &String.length/1)\n    %{3 => [\"ant\", \"cat\"], 5 => [\"dingo\"], 7 => [\"buffalo\"]}\n\n    iex> Enum.group_by(~w{ant buffalo cat dingo}, &String.length/1, &String.first/1)\n    %{3 => [\"a\", \"c\"], 5 => [\"d\"], 7 => [\"b\"]}","prompt":"Can you write a docstring for the following Elixir function? group_by(enumerable, key_fun, value_fun \\\\ fn x -> x end)"}
{"completion":"Intersperses `separator` between each element of the enumeration.\n\n## Examples\n\n    iex> Enum.intersperse([1, 2, 3], 0)\n    [1, 0, 2, 0, 3]\n\n    iex> Enum.intersperse([1], 0)\n    [1]\n\n    iex> Enum.intersperse([], 0)\n    []","prompt":"Can you write a docstring for the following Elixir function? intersperse(enumerable, separator)"}
{"completion":"Inserts the given `enumerable` into a `collectable`.\n\nNote that passing a non-empty list as the `collectable` is deprecated.\nIf you're collecting into a non-empty keyword list, consider using\n`Keyword.merge(collectable, Enum.to_list(enumerable))`. If you're collecting\ninto a non-empty list, consider something like `Enum.to_list(enumerable) ++ collectable`.\n\n## Examples\n\n    iex> Enum.into([1, 2], [])\n    [1, 2]\n\n    iex> Enum.into([a: 1, b: 2], %{})\n    %{a: 1, b: 2}\n\n    iex> Enum.into(%{a: 1}, %{b: 2})\n    %{a: 1, b: 2}\n\n    iex> Enum.into([a: 1, a: 2], %{})\n    %{a: 2}","prompt":"Can you write a docstring for the following Elixir function? into(enumerable, collectable)"}
{"completion":"Inserts the given `enumerable` into a `collectable` according to the\ntransformation function.\n\n## Examples\n\n    iex> Enum.into([1, 2, 3], [], fn x -> x * 3 end)\n    [3, 6, 9]\n\n    iex> Enum.into(%{a: 1, b: 2}, %{c: 3}, fn {k, v} -> {k, v * 2} end)\n    %{a: 2, b: 4, c: 3}","prompt":"Can you write a docstring for the following Elixir function? into(enumerable, collectable, transform)"}
{"completion":"Joins the given `enumerable` into a string using `joiner` as a\nseparator.\n\nIf `joiner` is not passed at all, it defaults to an empty string.\n\nAll elements in the `enumerable` must be convertible to a string,\notherwise an error is raised.\n\n## Examples\n\n    iex> Enum.join([1, 2, 3])\n    \"123\"\n\n    iex> Enum.join([1, 2, 3], \" = \")\n    \"1 = 2 = 3\"\n\n    iex> Enum.join([[\"a\", \"b\"], [\"c\", \"d\", \"e\", [\"f\", \"g\"]], \"h\", \"i\"], \" \")\n    \"ab cdefg h i\"","prompt":"Can you write a docstring for the following Elixir function? join(enumerable, joiner \\\\ \"\")"}
{"completion":"Returns a list where each element is the result of invoking\n`fun` on each corresponding element of `enumerable`.\n\nFor maps, the function expects a key-value tuple.\n\n## Examples\n\n    iex> Enum.map([1, 2, 3], fn x -> x * 2 end)\n    [2, 4, 6]\n\n    iex> Enum.map([a: 1, b: 2], fn {k, v} -> {k, -v} end)\n    [a: -1, b: -2]","prompt":"Can you write a docstring for the following Elixir function? map(enumerable, fun)"}
{"completion":"Returns a list of results of invoking `fun` on every `nth`\nelement of `enumerable`, starting with the first element.\n\nThe first element is always passed to the given function, unless `nth` is `0`.\n\nThe second argument specifying every `nth` element must be a non-negative\ninteger.\n\nIf `nth` is `0`, then `enumerable` is directly converted to a list,\nwithout `fun` being ever applied.\n\n## Examples\n\n    iex> Enum.map_every(1..10, 2, fn x -> x + 1000 end)\n    [1001, 2, 1003, 4, 1005, 6, 1007, 8, 1009, 10]\n\n    iex> Enum.map_every(1..10, 3, fn x -> x + 1000 end)\n    [1001, 2, 3, 1004, 5, 6, 1007, 8, 9, 1010]\n\n    iex> Enum.map_every(1..5, 0, fn x -> x + 1000 end)\n    [1, 2, 3, 4, 5]\n\n    iex> Enum.map_every([1, 2, 3], 1, fn x -> x + 1000 end)\n    [1001, 1002, 1003]","prompt":"Can you write a docstring for the following Elixir function? map_every(enumerable, nth, fun)"}
{"completion":"Maps and intersperses the given enumerable in one pass.\n\n## Examples\n\n    iex> Enum.map_intersperse([1, 2, 3], :a, &(&1 * 2))\n    [2, :a, 4, :a, 6]","prompt":"Can you write a docstring for the following Elixir function? map_intersperse(enumerable, separator, mapper)"}
{"completion":"Maps and joins the given `enumerable` in one pass.\n\nIf `joiner` is not passed at all, it defaults to an empty string.\n\nAll elements returned from invoking the `mapper` must be convertible to\na string, otherwise an error is raised.\n\n## Examples\n\n    iex> Enum.map_join([1, 2, 3], &(&1 * 2))\n    \"246\"\n\n    iex> Enum.map_join([1, 2, 3], \" = \", &(&1 * 2))\n    \"2 = 4 = 6\"","prompt":"Can you write a docstring for the following Elixir function? map_join(enumerable, joiner \\\\ \"\", mapper)"}
{"completion":"Invokes the given function to each element in the `enumerable` to reduce\nit to a single element, while keeping an accumulator.\n\nReturns a tuple where the first element is the mapped enumerable and\nthe second one is the final accumulator.\n\nThe function, `fun`, receives two arguments: the first one is the\nelement, and the second one is the accumulator. `fun` must return\na tuple with two elements in the form of `{result, accumulator}`.\n\nFor maps, the first tuple element must be a `{key, value}` tuple.\n\n## Examples\n\n    iex> Enum.map_reduce([1, 2, 3], 0, fn x, acc -> {x * 2, x + acc} end)\n    {[2, 4, 6], 6}","prompt":"Can you write a docstring for the following Elixir function? map_reduce(enumerable, acc, fun)"}
{"completion":"Returns the maximal element in the `enumerable` according\nto Erlang's term ordering.\n\nBy default, the comparison is done with the `>=` sorter function.\nIf multiple elements are considered maximal, the first one that\nwas found is returned. If you want the last element considered\nmaximal to be returned, the sorter function should not return true\nfor equal elements.\n\nIf the enumerable is empty, the provided `empty_fallback` is called.\nThe default `empty_fallback` raises `Enum.EmptyError`.\n\n## Examples\n\n    iex> Enum.max([1, 2, 3])\n    3\n\nThe fact this function uses Erlang's term ordering means that the comparison\nis structural and not semantic. For example:\n\n    iex> Enum.max([~D[2017-03-31], ~D[2017-04-01]])\n    ~D[2017-03-31]\n\nIn the example above, `max/2` returned March 31st instead of April 1st\nbecause the structural comparison compares the day before the year.\nFor this reason, most structs provide a \"compare\" function, such as\n`Date.compare/2`, which receives two structs and returns `:lt` (less-than),\n`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the\nsorting function, Elixir will automatically use the `compare/2` function\nof said module:\n\n    iex> Enum.max([~D[2017-03-31], ~D[2017-04-01]], Date)\n    ~D[2017-04-01]\n\nFinally, if you don't want to raise on empty enumerables, you can pass\nthe empty fallback:\n\n    iex> Enum.max([], &>=/2, fn -> 0 end)\n    0","prompt":"Can you write a docstring for the following Elixir function? max(enumerable, sorter \\\\ &>=/2, empty_fallback \\\\ fn -> raise Enum.EmptyError end)"}
{"completion":"Returns the maximal element in the `enumerable` as calculated\nby the given `fun`.\n\nBy default, the comparison is done with the `>=` sorter function.\nIf multiple elements are considered maximal, the first one that\nwas found is returned. If you want the last element considered\nmaximal to be returned, the sorter function should not return true\nfor equal elements.\n\nCalls the provided `empty_fallback` function and returns its value if\n`enumerable` is empty. The default `empty_fallback` raises `Enum.EmptyError`.\n\n## Examples\n\n    iex> Enum.max_by([\"a\", \"aa\", \"aaa\"], fn x -> String.length(x) end)\n    \"aaa\"\n\n    iex> Enum.max_by([\"a\", \"aa\", \"aaa\", \"b\", \"bbb\"], &String.length/1)\n    \"aaa\"\n\nThe fact this function uses Erlang's term ordering means that the\ncomparison is structural and not semantic. Therefore, if you want\nto compare structs, most structs provide a \"compare\" function, such as\n`Date.compare/2`, which receives two structs and returns `:lt` (less-than),\n`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the\nsorting function, Elixir will automatically use the `compare/2` function\nof said module:\n\n    iex> users = [\n    ...>   %{name: \"Ellis\", birthday: ~D[1943-05-11]},\n    ...>   %{name: \"Lovelace\", birthday: ~D[1815-12-10]},\n    ...>   %{name: \"Turing\", birthday: ~D[1912-06-23]}\n    ...> ]\n    iex> Enum.max_by(users, &(&1.birthday), Date)\n    %{name: \"Ellis\", birthday: ~D[1943-05-11]}\n\nFinally, if you don't want to raise on empty enumerables, you can pass\nthe empty fallback:\n\n    iex> Enum.max_by([], &String.length/1, fn -> nil end)\n    nil","prompt":"Can you write a docstring for the following Elixir function? max_by(enumerable, fun, sorter \\\\ &>=/2, empty_fallback \\\\ fn -> raise Enum.EmptyError end)"}
{"completion":"Checks if `element` exists within the `enumerable`.\n\nMembership is tested with the match (`===/2`) operator.\n\n## Examples\n\n    iex> Enum.member?(1..10, 5)\n    true\n    iex> Enum.member?(1..10, 5.0)\n    false\n\n    iex> Enum.member?([1.0, 2.0, 3.0], 2)\n    false\n    iex> Enum.member?([1.0, 2.0, 3.0], 2.000)\n    true\n\n    iex> Enum.member?([:a, :b, :c], :d)\n    false\n\n\nWhen called outside guards, the [`in`](`in/2`) and [`not in`](`in/2`)\noperators work by using this function.","prompt":"Can you write a docstring for the following Elixir function? member?(enumerable, element)"}
{"completion":"Returns the minimal element in the `enumerable` according\nto Erlang's term ordering.\n\nBy default, the comparison is done with the `<=` sorter function.\nIf multiple elements are considered minimal, the first one that\nwas found is returned. If you want the last element considered\nminimal to be returned, the sorter function should not return true\nfor equal elements.\n\nIf the enumerable is empty, the provided `empty_fallback` is called.\nThe default `empty_fallback` raises `Enum.EmptyError`.\n\n## Examples\n\n    iex> Enum.min([1, 2, 3])\n    1\n\nThe fact this function uses Erlang's term ordering means that the comparison\nis structural and not semantic. For example:\n\n    iex> Enum.min([~D[2017-03-31], ~D[2017-04-01]])\n    ~D[2017-04-01]\n\nIn the example above, `min/2` returned April 1st instead of March 31st\nbecause the structural comparison compares the day before the year.\nFor this reason, most structs provide a \"compare\" function, such as\n`Date.compare/2`, which receives two structs and returns `:lt` (less-than),\n`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the\nsorting function, Elixir will automatically use the `compare/2` function\nof said module:\n\n    iex> Enum.min([~D[2017-03-31], ~D[2017-04-01]], Date)\n    ~D[2017-03-31]\n\nFinally, if you don't want to raise on empty enumerables, you can pass\nthe empty fallback:\n\n    iex> Enum.min([], fn -> 0 end)\n    0","prompt":"Can you write a docstring for the following Elixir function? min(enumerable, sorter \\\\ &<=/2, empty_fallback \\\\ fn -> raise Enum.EmptyError end)"}
{"completion":"Returns the minimal element in the `enumerable` as calculated\nby the given `fun`.\n\nBy default, the comparison is done with the `<=` sorter function.\nIf multiple elements are considered minimal, the first one that\nwas found is returned. If you want the last element considered\nminimal to be returned, the sorter function should not return true\nfor equal elements.\n\nCalls the provided `empty_fallback` function and returns its value if\n`enumerable` is empty. The default `empty_fallback` raises `Enum.EmptyError`.\n\n## Examples\n\n    iex> Enum.min_by([\"a\", \"aa\", \"aaa\"], fn x -> String.length(x) end)\n    \"a\"\n\n    iex> Enum.min_by([\"a\", \"aa\", \"aaa\", \"b\", \"bbb\"], &String.length/1)\n    \"a\"\n\nThe fact this function uses Erlang's term ordering means that the\ncomparison is structural and not semantic. Therefore, if you want\nto compare structs, most structs provide a \"compare\" function, such as\n`Date.compare/2`, which receives two structs and returns `:lt` (less-than),\n`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the\nsorting function, Elixir will automatically use the `compare/2` function\nof said module:\n\n    iex> users = [\n    ...>   %{name: \"Ellis\", birthday: ~D[1943-05-11]},\n    ...>   %{name: \"Lovelace\", birthday: ~D[1815-12-10]},\n    ...>   %{name: \"Turing\", birthday: ~D[1912-06-23]}\n    ...> ]\n    iex> Enum.min_by(users, &(&1.birthday), Date)\n    %{name: \"Lovelace\", birthday: ~D[1815-12-10]}\n\nFinally, if you don't want to raise on empty enumerables, you can pass\nthe empty fallback:\n\n    iex> Enum.min_by([], &String.length/1, fn -> nil end)\n    nil","prompt":"Can you write a docstring for the following Elixir function? min_by(enumerable, fun, sorter \\\\ &<=/2, empty_fallback \\\\ fn -> raise Enum.EmptyError end)"}
{"completion":"Returns a tuple with the minimal and the maximal elements in the\nenumerable according to Erlang's term ordering.\n\nIf multiple elements are considered maximal or minimal, the first one\nthat was found is returned.\n\nCalls the provided `empty_fallback` function and returns its value if\n`enumerable` is empty. The default `empty_fallback` raises `Enum.EmptyError`.\n\n## Examples\n\n    iex> Enum.min_max([2, 3, 1])\n    {1, 3}\n\n    iex> Enum.min_max([], fn -> {nil, nil} end)\n    {nil, nil}","prompt":"Can you write a docstring for the following Elixir function? min_max(enumerable, empty_fallback \\\\ fn -> raise Enum.EmptyError end)"}
{"completion":"Returns a tuple with the minimal and the maximal elements in the\nenumerable as calculated by the given function.\n\nIf multiple elements are considered maximal or minimal, the first one\nthat was found is returned.\n\n## Examples\n\n    iex> Enum.min_max_by([\"aaa\", \"bb\", \"c\"], fn x -> String.length(x) end)\n    {\"c\", \"aaa\"}\n\n    iex> Enum.min_max_by([\"aaa\", \"a\", \"bb\", \"c\", \"ccc\"], &String.length/1)\n    {\"a\", \"aaa\"}\n\n    iex> Enum.min_max_by([], &String.length/1, fn -> {nil, nil} end)\n    {nil, nil}\n\nThe fact this function uses Erlang's term ordering means that the\ncomparison is structural and not semantic. Therefore, if you want\nto compare structs, most structs provide a \"compare\" function, such as\n`Date.compare/2`, which receives two structs and returns `:lt` (less-than),\n`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the\nsorting function, Elixir will automatically use the `compare/2` function\nof said module:\n\n    iex> users = [\n    ...>   %{name: \"Ellis\", birthday: ~D[1943-05-11]},\n    ...>   %{name: \"Lovelace\", birthday: ~D[1815-12-10]},\n    ...>   %{name: \"Turing\", birthday: ~D[1912-06-23]}\n    ...> ]\n    iex> Enum.min_max_by(users, &(&1.birthday), Date)\n    {\n      %{name: \"Lovelace\", birthday: ~D[1815-12-10]},\n      %{name: \"Ellis\", birthday: ~D[1943-05-11]}\n    }\n\nFinally, if you don't want to raise on empty enumerables, you can pass\nthe empty fallback:\n\n    iex> Enum.min_max_by([], &String.length/1, fn -> nil end)\n    nil","prompt":"Can you write a docstring for the following Elixir function? min_max_by(enumerable, fun, sorter_or_empty_fallback \\\\ &</2, empty_fallback \\\\ fn -> raise Enum.EmptyError end)"}
{"completion":"Returns the product of all elements.\n\nRaises `ArithmeticError` if `enumerable` contains a non-numeric value.\n\n## Examples\n\n    iex> Enum.product([])\n    1\n    iex> Enum.product([2, 3, 4])\n    24\n    iex> Enum.product([2.0, 3.0, 4.0])\n    24.0","prompt":"Can you write a docstring for the following Elixir function? product(enumerable)"}
{"completion":"Returns a random element of an `enumerable`.\n\nRaises `Enum.EmptyError` if `enumerable` is empty.\n\nThis function uses Erlang's [`:rand` module](`:rand`) to calculate\nthe random value. Check its documentation for setting a\ndifferent random algorithm or a different seed.\n\nThe implementation is based on the\n[reservoir sampling](https://en.wikipedia.org/wiki/Reservoir_sampling#Relation_to_Fisher-Yates_shuffle)\nalgorithm.\nIt assumes that the sample being returned can fit into memory;\nthe input `enumerable` doesn't have to, as it is traversed just once.\n\nIf a range is passed into the function, this function will pick a\nrandom value between the range limits, without traversing the whole\nrange (thus executing in constant time and constant memory).\n\n## Examples\n\nThe examples below use the `:exsss` pseudorandom algorithm since it's\nthe default from Erlang/OTP 22:\n\n    # Although not necessary, let's seed the random algorithm\n    iex> :rand.seed(:exsss, {100, 101, 102})\n    iex> Enum.random([1, 2, 3])\n    2\n    iex> Enum.random([1, 2, 3])\n    1\n    iex> Enum.random(1..1_000)\n    309","prompt":"Can you write a docstring for the following Elixir function? random(enumerable)"}
{"completion":"Invokes `fun` for each element in the `enumerable` with the\naccumulator.\n\nRaises `Enum.EmptyError` if `enumerable` is empty.\n\nThe first element of the `enumerable` is used as the initial value\nof the accumulator. Then, the function is invoked with the next\nelement and the accumulator. The result returned by the function\nis used as the accumulator for the next iteration, recursively.\nWhen the `enumerable` is done, the last accumulator is returned.\n\nSince the first element of the enumerable is used as the initial\nvalue of the accumulator, `fun` will only be executed `n - 1` times\nwhere `n` is the length of the enumerable. This function won't call\nthe specified function for enumerables that are one-element long.\n\nIf you wish to use another value for the accumulator, use\n`Enum.reduce/3`.\n\n## Examples\n\n    iex> Enum.reduce([1, 2, 3, 4], fn x, acc -> x * acc end)\n    24","prompt":"Can you write a docstring for the following Elixir function? reduce(enumerable, fun)"}
{"completion":"Invokes `fun` for each element in the `enumerable` with the accumulator.\n\nThe initial value of the accumulator is `acc`. The function is invoked for\neach element in the enumerable with the accumulator. The result returned\nby the function is used as the accumulator for the next iteration.\nThe function returns the last accumulator.\n\n## Examples\n\n    iex> Enum.reduce([1, 2, 3], 0, fn x, acc -> x + acc end)\n    6\n\n## Reduce as a building block\n\nReduce (sometimes called `fold`) is a basic building block in functional\nprogramming. Almost all of the functions in the `Enum` module can be\nimplemented on top of reduce. Those functions often rely on other operations,\nsuch as `Enum.reverse/1`, which are optimized by the runtime.\n\nFor example, we could implement `map/2` in terms of `reduce/3` as follows:\n\n    def my_map(enumerable, fun) do\n      enumerable\n      |> Enum.reduce([], fn x, acc -> [fun.(x) | acc] end)\n      |> Enum.reverse()\n    end\n\nIn the example above, `Enum.reduce/3` accumulates the result of each call\nto `fun` into a list in reverse order, which is correctly ordered at the\nend by calling `Enum.reverse/1`.\n\nImplementing functions like `map/2`, `filter/2` and others are a good\nexercise for understanding the power behind `Enum.reduce/3`. When an\noperation cannot be expressed by any of the functions in the `Enum`\nmodule, developers will most likely resort to `reduce/3`.","prompt":"Can you write a docstring for the following Elixir function? reduce(enumerable, acc, fun)"}
{"completion":"Reduces `enumerable` until `fun` returns `{:halt, term}`.\n\nThe return value for `fun` is expected to be\n\n  * `{:cont, acc}` to continue the reduction with `acc` as the new\n    accumulator or\n  * `{:halt, acc}` to halt the reduction\n\nIf `fun` returns `{:halt, acc}` the reduction is halted and the function\nreturns `acc`. Otherwise, if the enumerable is exhausted, the function returns\nthe accumulator of the last `{:cont, acc}`.\n\n## Examples\n\n    iex> Enum.reduce_while(1..100, 0, fn x, acc ->\n    ...>   if x < 5, do: {:cont, acc + x}, else: {:halt, acc}\n    ...> end)\n    10\n    iex> Enum.reduce_while(1..100, 0, fn x, acc ->\n    ...>   if x > 0, do: {:cont, acc + x}, else: {:halt, acc}\n    ...> end)\n    5050","prompt":"Can you write a docstring for the following Elixir function? reduce_while(enumerable, acc, fun)"}
{"completion":"Returns a list of elements in `enumerable` excluding those for which the function `fun` returns\na truthy value.\n\nSee also `filter/2`.\n\n## Examples\n\n    iex> Enum.reject([1, 2, 3], fn x -> rem(x, 2) == 0 end)\n    [1, 3]","prompt":"Can you write a docstring for the following Elixir function? reject(enumerable, fun)"}
{"completion":"Returns a list of elements in `enumerable` in reverse order.\n\n## Examples\n\n    iex> Enum.reverse([1, 2, 3])\n    [3, 2, 1]","prompt":"Can you write a docstring for the following Elixir function? reverse(enumerable)"}
{"completion":"Reverses the elements in `enumerable`, appends the `tail`, and returns\nit as a list.\n\nThis is an optimization for\n`enumerable |> Enum.reverse() |> Enum.concat(tail)`.\n\n## Examples\n\n    iex> Enum.reverse([1, 2, 3], [4, 5, 6])\n    [3, 2, 1, 4, 5, 6]","prompt":"Can you write a docstring for the following Elixir function? reverse(enumerable, tail)"}
{"completion":"Reverses the `enumerable` in the range from initial `start_index`\nthrough `count` elements.\n\nIf `count` is greater than the size of the rest of the `enumerable`,\nthen this function will reverse the rest of the enumerable.\n\n## Examples\n\n    iex> Enum.reverse_slice([1, 2, 3, 4, 5, 6], 2, 4)\n    [1, 2, 6, 5, 4, 3]","prompt":"Can you write a docstring for the following Elixir function? reverse_slice(enumerable, start_index, count)"}
{"completion":"Applies the given function to each element in the `enumerable`,\nstoring the result in a list and passing it as the accumulator\nfor the next computation. Uses the first element in the `enumerable`\nas the starting value.\n\n## Examples\n\n    iex> Enum.scan(1..5, &(&1 + &2))\n    [1, 3, 6, 10, 15]","prompt":"Can you write a docstring for the following Elixir function? scan(enumerable, fun)"}
{"completion":"Applies the given function to each element in the `enumerable`,\nstoring the result in a list and passing it as the accumulator\nfor the next computation. Uses the given `acc` as the starting value.\n\n## Examples\n\n    iex> Enum.scan(1..5, 0, &(&1 + &2))\n    [1, 3, 6, 10, 15]","prompt":"Can you write a docstring for the following Elixir function? scan(enumerable, acc, fun)"}
{"completion":"Returns a list with the elements of `enumerable` shuffled.\n\nThis function uses Erlang's [`:rand` module](`:rand`) to calculate\nthe random value. Check its documentation for setting a\ndifferent random algorithm or a different seed.\n\n## Examples\n\nThe examples below use the `:exsss` pseudorandom algorithm since it's\nthe default from Erlang/OTP 22:\n\n    # Although not necessary, let's seed the random algorithm\n    iex> :rand.seed(:exsss, {1, 2, 3})\n    iex> Enum.shuffle([1, 2, 3])\n    [3, 2, 1]\n    iex> Enum.shuffle([1, 2, 3])\n    [2, 1, 3]","prompt":"Can you write a docstring for the following Elixir function? shuffle(enumerable)"}
{"completion":"Returns a subset list of the given `enumerable` by `index_range`.\n\n`index_range` must be a `Range`. Given an `enumerable`, it drops\nelements before `index_range.first` (zero-base), then it takes elements\nuntil element `index_range.last` (inclusively).\n\nIndexes are normalized, meaning that negative indexes will be counted\nfrom the end (for example, `-1` means the last element of the `enumerable`).\n\nIf `index_range.last` is out of bounds, then it is assigned as the index\nof the last element.\n\nIf the normalized `index_range.first` is out of bounds of the given\n`enumerable`, or this one is greater than the normalized `index_range.last`,\nthen `[]` is returned.\n\nIf a step `n` (other than `1`) is used in `index_range`, then it takes\nevery `n`th element from `index_range.first` to `index_range.last`\n(according to the same rules described above).\n\n## Examples\n\n    iex> Enum.slice([1, 2, 3, 4, 5], 1..3)\n    [2, 3, 4]\n\n    iex> Enum.slice([1, 2, 3, 4, 5], 3..10)\n    [4, 5]\n\n    # Last three elements (negative indexes)\n    iex> Enum.slice([1, 2, 3, 4, 5], -3..-1)\n    [3, 4, 5]\n\nFor ranges where `start > stop`, you need to explicit\nmark them as increasing:\n\n    iex> Enum.slice([1, 2, 3, 4, 5], 1..-2//1)\n    [2, 3, 4]\n\nThe step can be any positive number. For example, to\nget every 2 elements of the collection:\n\n    iex> Enum.slice([1, 2, 3, 4, 5], 0..-1//2)\n    [1, 3, 5]\n\nTo get every third element of the first ten elements:\n\n    iex> integers = Enum.to_list(1..20)\n    iex> Enum.slice(integers, 0..9//3)\n    [1, 4, 7, 10]\n\nIf the first position is after the end of the enumerable\nor after the last position of the range, it returns an\nempty list:\n\n    iex> Enum.slice([1, 2, 3, 4, 5], 6..10)\n    []\n\n    # first is greater than last\n    iex> Enum.slice([1, 2, 3, 4, 5], 6..5)\n    []","prompt":"Can you write a docstring for the following Elixir function? slice(enumerable, index_range)"}
{"completion":"Returns a subset list of the given `enumerable`, from `start_index` (zero-based)\nwith `amount` number of elements if available.\n\nGiven an `enumerable`, it drops elements right before element `start_index`;\nthen, it takes `amount` of elements, returning as many elements as possible if\nthere are not enough elements.\n\nA negative `start_index` can be passed, which means the `enumerable` is\nenumerated once and the index is counted from the end (for example,\n`-1` starts slicing from the last element).\n\nIt returns `[]` if `amount` is `0` or if `start_index` is out of bounds.\n\n## Examples\n\n    iex> Enum.slice(1..100, 5, 10)\n    [6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n\n    # amount to take is greater than the number of elements\n    iex> Enum.slice(1..10, 5, 100)\n    [6, 7, 8, 9, 10]\n\n    iex> Enum.slice(1..10, 5, 0)\n    []\n\n    # using a negative start index\n    iex> Enum.slice(1..10, -6, 3)\n    [5, 6, 7]\n    iex> Enum.slice(1..10, -11, 5)\n    [1, 2, 3, 4, 5]\n\n    # out of bound start index\n    iex> Enum.slice(1..10, 10, 5)\n    []","prompt":"Can you write a docstring for the following Elixir function? slice(enumerable, start_index, amount)"}
{"completion":"Slides a single or multiple elements given by `range_or_single_index` from `enumerable`\nto `insertion_index`.\n\nThe semantics of the range to be moved match the semantics of `Enum.slice/2`.\nSpecifically, that means:\n\n * Indices are normalized, meaning that negative indexes will be counted from the end\n    (for example, -1 means the last element of the enumerable). This will result in *two*\n    traversals of your enumerable on types like lists that don't provide a constant-time count.\n\n  * If the normalized index range's `last` is out of bounds, the range is truncated to the last element.\n\n  * If the normalized index range's `first` is out of bounds, the selected range for sliding\n    will be empty, so you'll get back your input list.\n\n  * Decreasing ranges (such as `5..0//1`) also select an empty range to be moved,\n    so you'll get back your input list.\n\n  * Ranges with any step but 1 will raise an error.\n\n## Examples\n\n    # Slide a single element\n    iex> Enum.slide([:a, :b, :c, :d, :e, :f, :g], 5, 1)\n    [:a, :f, :b, :c, :d, :e, :g]\n\n    # Slide a range of elements backward\n    iex> Enum.slide([:a, :b, :c, :d, :e, :f, :g], 3..5, 1)\n    [:a, :d, :e, :f, :b, :c, :g]\n\n    # Slide a range of elements forward\n    iex> Enum.slide([:a, :b, :c, :d, :e, :f, :g], 1..3, 5)\n    [:a, :e, :f, :b, :c, :d, :g]\n\n    # Slide with negative indices (counting from the end)\n    iex> Enum.slide([:a, :b, :c, :d, :e, :f, :g], 3..-1//1, 2)\n    [:a, :b, :d, :e, :f, :g, :c]\n    iex> Enum.slide([:a, :b, :c, :d, :e, :f, :g], -4..-2, 1)\n    [:a, :d, :e, :f, :b, :c, :g]\n\n    # Insert at negative indices (counting from the end)\n    iex> Enum.slide([:a, :b, :c, :d, :e, :f, :g], 3, -1)\n    [:a, :b, :c, :e, :f, :g, :d]","prompt":"Can you write a docstring for the following Elixir function? slide(enumerable, range_or_single_index, insertion_index)"}
{"completion":"Sorts the `enumerable` according to Erlang's term ordering.\n\nThis function uses the merge sort algorithm. Do not use this\nfunction to sort structs, see `sort/2` for more information.\n\n## Examples\n\n    iex> Enum.sort([3, 2, 1])\n    [1, 2, 3]","prompt":"Can you write a docstring for the following Elixir function? sort(enumerable)"}
{"completion":"Sorts the `enumerable` by the given function.\n\nThis function uses the merge sort algorithm. The given function should compare\ntwo arguments, and return `true` if the first argument precedes or is in the\nsame place as the second one.\n\n## Examples\n\n    iex> Enum.sort([1, 2, 3], &(&1 >= &2))\n    [3, 2, 1]\n\nThe sorting algorithm will be stable as long as the given function\nreturns `true` for values considered equal:\n\n    iex> Enum.sort([\"some\", \"kind\", \"of\", \"monster\"], &(byte_size(&1) <= byte_size(&2)))\n    [\"of\", \"some\", \"kind\", \"monster\"]\n\nIf the function does not return `true` for equal values, the sorting\nis not stable and the order of equal terms may be shuffled.\nFor example:\n\n    iex> Enum.sort([\"some\", \"kind\", \"of\", \"monster\"], &(byte_size(&1) < byte_size(&2)))\n    [\"of\", \"kind\", \"some\", \"monster\"]\n\n## Ascending and descending (since v1.10.0)\n\n`sort/2` allows a developer to pass `:asc` or `:desc` as the sorter, which is a convenience for\n[`&<=/2`](`<=/2`) and [`&>=/2`](`>=/2`) respectively.\n\n    iex> Enum.sort([2, 3, 1], :asc)\n    [1, 2, 3]\n    iex> Enum.sort([2, 3, 1], :desc)\n    [3, 2, 1]\n\n## Sorting structs\n\nDo not use `</2`, `<=/2`, `>/2`, `>=/2` and friends when sorting structs.\nThat's because the built-in operators above perform structural comparison\nand not a semantic one. Imagine we sort the following list of dates:\n\n    iex> dates = [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]\n    iex> Enum.sort(dates)\n    [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]\n\nNote that the returned result is incorrect, because `sort/1` by default uses\n`<=/2`, which will compare their structure. When comparing structures, the\nfields are compared in alphabetical order, which means the dates above will\nbe compared by `day`, `month` and then `year`, which is the opposite of what\nwe want.\n\nFor this reason, most structs provide a \"compare\" function, such as\n`Date.compare/2`, which receives two structs and returns `:lt` (less-than),\n`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the\nsorting function, Elixir will automatically use the `compare/2` function\nof said module:\n\n    iex> dates = [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]\n    iex> Enum.sort(dates, Date)\n    [~D[2019-01-01], ~D[2019-06-06], ~D[2020-03-02]]\n\nTo retrieve all dates in descending order, you can wrap the module in\na tuple with `:asc` or `:desc` as first element:\n\n    iex> dates = [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]\n    iex> Enum.sort(dates, {:asc, Date})\n    [~D[2019-01-01], ~D[2019-06-06], ~D[2020-03-02]]\n    iex> dates = [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]\n    iex> Enum.sort(dates, {:desc, Date})\n    [~D[2020-03-02], ~D[2019-06-06], ~D[2019-01-01]]","prompt":"Can you write a docstring for the following Elixir function? sort(enumerable, sorter)"}
{"completion":"Sorts the mapped results of the `enumerable` according to the provided `sorter`\nfunction.\n\nThis function maps each element of the `enumerable` using the\nprovided `mapper` function. The enumerable is then sorted by\nthe mapped elements using the `sorter`, which defaults to `:asc`\nand sorts the elements ascendingly.\n\n`sort_by/3` differs from `sort/2` in that it only calculates the\ncomparison value for each element in the enumerable once instead of\nonce for each element in each comparison. If the same function is\nbeing called on both elements, it's more efficient to use `sort_by/3`.\n\n## Ascending and descending (since v1.10.0)\n\n`sort_by/3` allows a developer to pass `:asc` or `:desc` as the sorter,\nwhich is a convenience for [`&<=/2`](`<=/2`) and [`&>=/2`](`>=/2`) respectively:\n    iex> Enum.sort_by([2, 3, 1], &(&1), :asc)\n    [1, 2, 3]\n\n    iex> Enum.sort_by([2, 3, 1], &(&1), :desc)\n    [3, 2, 1]\n\n## Examples\n\nUsing the default `sorter` of `:asc` :\n\n    iex> Enum.sort_by([\"some\", \"kind\", \"of\", \"monster\"], &byte_size/1)\n    [\"of\", \"some\", \"kind\", \"monster\"]\n\nSorting by multiple properties - first by size, then by first letter\n(this takes advantage of the fact that tuples are compared element-by-element):\n\n    iex> Enum.sort_by([\"some\", \"kind\", \"of\", \"monster\"], &{byte_size(&1), String.first(&1)})\n    [\"of\", \"kind\", \"some\", \"monster\"]\n\nSimilar to `sort/2`, you can pass a custom sorter:\n\n    iex> Enum.sort_by([\"some\", \"kind\", \"of\", \"monster\"], &byte_size/1, :desc)\n    [\"monster\", \"some\", \"kind\", \"of\"]\n\nAs in `sort/2`, avoid using the default sorting function to sort\nstructs, as by default it performs structural comparison instead of\na semantic one. In such cases, you shall pass a sorting function as\nthird element or any module that implements a `compare/2` function.\nFor example, to sort users by their birthday in both ascending and\ndescending order respectively:\n\n    iex> users = [\n    ...>   %{name: \"Ellis\", birthday: ~D[1943-05-11]},\n    ...>   %{name: \"Lovelace\", birthday: ~D[1815-12-10]},\n    ...>   %{name: \"Turing\", birthday: ~D[1912-06-23]}\n    ...> ]\n    iex> Enum.sort_by(users, &(&1.birthday), Date)\n    [\n      %{name: \"Lovelace\", birthday: ~D[1815-12-10]},\n      %{name: \"Turing\", birthday: ~D[1912-06-23]},\n      %{name: \"Ellis\", birthday: ~D[1943-05-11]}\n    ]\n    iex> Enum.sort_by(users, &(&1.birthday), {:desc, Date})\n    [\n      %{name: \"Ellis\", birthday: ~D[1943-05-11]},\n      %{name: \"Turing\", birthday: ~D[1912-06-23]},\n      %{name: \"Lovelace\", birthday: ~D[1815-12-10]}\n    ]\n\n## Performance characteristics\n\nAs detailed in the initial section, `sort_by/3` calculates the comparison\nvalue for each element in the enumerable once instead of once for each\nelement in each comparison. This implies `sort_by/3` must do an initial\npass on the data to compute those values.\n\nHowever, if those values are cheap to compute, for example, you have\nalready extracted the field you want to sort by into a tuple, then those\nextra passes become overhead. In such cases, consider using `List.keysort/3`\ninstead.\n\nLet's see an example. Imagine you have a list of products and you have a\nlist of IDs. You want to keep all products that are in the given IDs and\nreturn their names sorted by their price. You could write it like this:\n\n    for(\n      product <- products,\n      product.id in ids,\n      do: product\n    )\n    |> Enum.sort_by(& &1.price)\n    |> Enum.map(& &1.name)\n\nHowever, you could also write it like this:\n\n    for(\n      product <- products,\n      product.id in ids,\n      do: {product.name, product.price}\n    )\n    |> List.keysort(1)\n    |> Enum.map(&elem(&1, 0))\n\nUsing `List.keysort/3` will be a better choice for performance sensitive\ncode as it avoids additional traversals.","prompt":"Can you write a docstring for the following Elixir function? sort_by(enumerable, mapper, sorter \\\\ :asc)"}
{"completion":"Splits the `enumerable` into two enumerables, leaving `count`\nelements in the first one.\n\nIf `count` is a negative number, it starts counting from the\nback to the beginning of the `enumerable`.\n\nBe aware that a negative `count` implies the `enumerable`\nwill be enumerated twice: once to calculate the position, and\na second time to do the actual splitting.\n\n## Examples\n\n    iex> Enum.split([1, 2, 3], 2)\n    {[1, 2], [3]}\n\n    iex> Enum.split([1, 2, 3], 10)\n    {[1, 2, 3], []}\n\n    iex> Enum.split([1, 2, 3], 0)\n    {[], [1, 2, 3]}\n\n    iex> Enum.split([1, 2, 3], -1)\n    {[1, 2], [3]}\n\n    iex> Enum.split([1, 2, 3], -5)\n    {[], [1, 2, 3]}","prompt":"Can you write a docstring for the following Elixir function? split(enumerable, count)"}
{"completion":"Splits enumerable in two at the position of the element for which\n`fun` returns a falsy value (`false` or `nil`) for the first time.\n\nIt returns a two-element tuple with two lists of elements.\nThe element that triggered the split is part of the second list.\n\n## Examples\n\n    iex> Enum.split_while([1, 2, 3, 4], fn x -> x < 3 end)\n    {[1, 2], [3, 4]}\n\n    iex> Enum.split_while([1, 2, 3, 4], fn x -> x < 0 end)\n    {[], [1, 2, 3, 4]}\n\n    iex> Enum.split_while([1, 2, 3, 4], fn x -> x > 0 end)\n    {[1, 2, 3, 4], []}","prompt":"Can you write a docstring for the following Elixir function? split_while(enumerable, fun)"}
{"completion":"Splits the `enumerable` in two lists according to the given function `fun`.\n\nSplits the given `enumerable` in two lists by calling `fun` with each element\nin the `enumerable` as its only argument. Returns a tuple with the first list\ncontaining all the elements in `enumerable` for which applying `fun` returned\na truthy value, and a second list with all the elements for which applying\n`fun` returned a falsy value (`false` or `nil`).\n\nThe elements in both the returned lists are in the same relative order as they\nwere in the original enumerable (if such enumerable was ordered, like a\nlist). See the examples below.\n\n## Examples\n\n    iex> Enum.split_with([5, 4, 3, 2, 1, 0], fn x -> rem(x, 2) == 0 end)\n    {[4, 2, 0], [5, 3, 1]}\n\n    iex> Enum.split_with(%{a: 1, b: -2, c: 1, d: -3}, fn {_k, v} -> v < 0 end)\n    {[b: -2, d: -3], [a: 1, c: 1]}\n\n    iex> Enum.split_with(%{a: 1, b: -2, c: 1, d: -3}, fn {_k, v} -> v > 50 end)\n    {[], [a: 1, b: -2, c: 1, d: -3]}\n\n    iex> Enum.split_with(%{}, fn {_k, v} -> v > 50 end)\n    {[], []}","prompt":"Can you write a docstring for the following Elixir function? split_with(enumerable, fun)"}
{"completion":"Returns the sum of all elements.\n\nRaises `ArithmeticError` if `enumerable` contains a non-numeric value.\n\n## Examples\n\n    iex> Enum.sum([1, 2, 3])\n    6\n\n    iex> Enum.sum(1..10)\n    55\n\n    iex> Enum.sum(1..10//2)\n    25","prompt":"Can you write a docstring for the following Elixir function? sum(enumerable)"}
{"completion":"Takes an `amount` of elements from the beginning or the end of the `enumerable`.\n\nIf a positive `amount` is given, it takes the `amount` elements from the\nbeginning of the `enumerable`.\n\nIf a negative `amount` is given, the `amount` of elements will be taken from the end.\nThe `enumerable` will be enumerated once to retrieve the proper index and\nthe remaining calculation is performed from the end.\n\nIf amount is `0`, it returns `[]`.\n\n## Examples\n\n    iex> Enum.take([1, 2, 3], 2)\n    [1, 2]\n\n    iex> Enum.take([1, 2, 3], 10)\n    [1, 2, 3]\n\n    iex> Enum.take([1, 2, 3], 0)\n    []\n\n    iex> Enum.take([1, 2, 3], -1)\n    [3]","prompt":"Can you write a docstring for the following Elixir function? take(enumerable, amount)"}
{"completion":"Returns a list of every `nth` element in the `enumerable`,\nstarting with the first element.\n\nThe first element is always included, unless `nth` is 0.\n\nThe second argument specifying every `nth` element must be a non-negative\ninteger.\n\n## Examples\n\n    iex> Enum.take_every(1..10, 2)\n    [1, 3, 5, 7, 9]\n\n    iex> Enum.take_every(1..10, 0)\n    []\n\n    iex> Enum.take_every([1, 2, 3], 1)\n    [1, 2, 3]","prompt":"Can you write a docstring for the following Elixir function? take_every(enumerable, nth)"}
{"completion":"Takes `count` random elements from `enumerable`.\n\nNote that this function will traverse the whole `enumerable` to\nget the random sublist.\n\nSee `random/1` for notes on implementation and random seed.\n\n## Examples\n\n    # Although not necessary, let's seed the random algorithm\n    iex> :rand.seed(:exsss, {1, 2, 3})\n    iex> Enum.take_random(1..10, 2)\n    [3, 1]\n    iex> Enum.take_random(?a..?z, 5)\n    'mikel'","prompt":"Can you write a docstring for the following Elixir function? take_random(enumerable, count)"}
{"completion":"Takes the elements from the beginning of the `enumerable` while `fun` returns\na truthy value.\n\n## Examples\n\n    iex> Enum.take_while([1, 2, 3], fn x -> x < 3 end)\n    [1, 2]","prompt":"Can you write a docstring for the following Elixir function? take_while(enumerable, fun)"}
{"completion":"Converts `enumerable` to a list.\n\n## Examples\n\n    iex> Enum.to_list(1..3)\n    [1, 2, 3]","prompt":"Can you write a docstring for the following Elixir function? to_list(enumerable)"}
{"completion":"Enumerates the `enumerable`, removing all duplicated elements.\n\n## Examples\n\n    iex> Enum.uniq([1, 2, 3, 3, 2, 1])\n    [1, 2, 3]","prompt":"Can you write a docstring for the following Elixir function? uniq(enumerable)"}
{"completion":"Enumerates the `enumerable`, by removing the elements for which\nfunction `fun` returned duplicate elements.\n\nThe function `fun` maps every element to a term. Two elements are\nconsidered duplicates if the return value of `fun` is equal for\nboth of them.\n\nThe first occurrence of each element is kept.\n\n## Example\n\n    iex> Enum.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end)\n    [{1, :x}, {2, :y}]\n\n    iex> Enum.uniq_by([a: {:tea, 2}, b: {:tea, 2}, c: {:coffee, 1}], fn {_, y} -> y end)\n    [a: {:tea, 2}, c: {:coffee, 1}]","prompt":"Can you write a docstring for the following Elixir function? uniq_by(enumerable, fun)"}
{"completion":"Opposite of `zip/2`. Extracts two-element tuples from the\ngiven `enumerable` and groups them together.\n\nIt takes an `enumerable` with elements being two-element tuples and returns\na tuple with two lists, each of which is formed by the first and\nsecond element of each tuple, respectively.\n\nThis function fails unless `enumerable` is or can be converted into a\nlist of tuples with *exactly* two elements in each tuple.\n\n## Examples\n\n    iex> Enum.unzip([{:a, 1}, {:b, 2}, {:c, 3}])\n    {[:a, :b, :c], [1, 2, 3]}\n\n    iex> Enum.unzip(%{a: 1, b: 2})\n    {[:a, :b], [1, 2]}","prompt":"Can you write a docstring for the following Elixir function? unzip(list)"}
{"completion":"Returns the `enumerable` with each element wrapped in a tuple\nalongside its index.\n\nMay receive a function or an integer offset.\n\nIf an `offset` is given, it will index from the given offset instead of from\nzero.\n\nIf a `function` is given, it will index by invoking the function for each\nelement and index (zero-based) of the enumerable.\n\n## Examples\n\n    iex> Enum.with_index([:a, :b, :c])\n    [a: 0, b: 1, c: 2]\n\n    iex> Enum.with_index([:a, :b, :c], 3)\n    [a: 3, b: 4, c: 5]\n\n    iex> Enum.with_index([:a, :b, :c], fn element, index -> {index, element} end)\n    [{0, :a}, {1, :b}, {2, :c}]","prompt":"Can you write a docstring for the following Elixir function? with_index(enumerable, fun_or_offset \\\\ 0)"}
{"completion":"Zips corresponding elements from a finite collection of enumerables\ninto a list of tuples.\n\nThe zipping finishes as soon as any enumerable in the given collection completes.\n\n## Examples\n\n    iex> Enum.zip([[1, 2, 3], [:a, :b, :c], [\"foo\", \"bar\", \"baz\"]])\n    [{1, :a, \"foo\"}, {2, :b, \"bar\"}, {3, :c, \"baz\"}]\n\n    iex> Enum.zip([[1, 2, 3, 4, 5], [:a, :b, :c]])\n    [{1, :a}, {2, :b}, {3, :c}]","prompt":"Can you write a docstring for the following Elixir function? zip(enumerables)"}
{"completion":"Zips corresponding elements from two enumerables into a list\nof tuples.\n\nThe zipping finishes as soon as either enumerable completes.\n\n## Examples\n\n    iex> Enum.zip([1, 2, 3], [:a, :b, :c])\n    [{1, :a}, {2, :b}, {3, :c}]\n\n    iex> Enum.zip([1, 2, 3, 4, 5], [:a, :b, :c])\n    [{1, :a}, {2, :b}, {3, :c}]","prompt":"Can you write a docstring for the following Elixir function? zip(enumerable1, enumerable2)"}
{"completion":"Reduces over all of the given enumerables, halting as soon as any enumerable is\nempty.\n\nThe reducer will receive 2 args: a list of elements (one from each enum) and the\naccumulator.\n\nIn practice, the behaviour provided by this function can be achieved with:\n\n    Enum.reduce(Stream.zip(enums), acc, reducer)\n\nBut `zip_reduce/3` exists for convenience purposes.\n\n## Examples\n\n    iex> enums = [[1, 1], [2, 2], [3, 3]]\n    ...>  Enum.zip_reduce(enums, [], fn elements, acc ->\n    ...>    [List.to_tuple(elements) | acc]\n    ...> end)\n    [{1, 2, 3}, {1, 2, 3}]\n\n    iex> enums = [[1, 2], %{a: 3, b: 4}, [5, 6]]\n    ...> Enum.zip_reduce(enums, [], fn elements, acc ->\n    ...>   [List.to_tuple(elements) | acc]\n    ...> end)\n    [{2, {:b, 4}, 6}, {1, {:a, 3}, 5}]","prompt":"Can you write a docstring for the following Elixir function? zip_reduce(enums, acc, reducer)"}
{"completion":"Reduces over two enumerables halting as soon as either enumerable is empty.\n\nIn practice, the behaviour provided by this function can be achieved with:\n\n    Enum.reduce(Stream.zip(left, right), acc, reducer)\n\nBut `zip_reduce/4` exists for convenience purposes.\n\n## Examples\n\n    iex> Enum.zip_reduce([1, 2], [3, 4], 0, fn x, y, acc -> x + y + acc end)\n    10\n\n    iex> Enum.zip_reduce([1, 2], [3, 4], [], fn x, y, acc -> [x + y | acc] end)\n    [6, 4]","prompt":"Can you write a docstring for the following Elixir function? zip_reduce(left, right, acc, reducer)"}
{"completion":"Zips corresponding elements from a finite collection of enumerables\ninto list, transforming them with the `zip_fun` function as it goes.\n\nThe first element from each of the enums in `enumerables` will be put\ninto a list which is then passed to the one-arity `zip_fun` function.\nThen, the second elements from each of the enums are put into a list\nand passed to `zip_fun`, and so on until any one of the enums in\n`enumerables` runs out of elements.\n\nReturns a list with all the results of calling `zip_fun`.\n\n## Examples\n\n    iex> Enum.zip_with([[1, 2], [3, 4], [5, 6]], fn [x, y, z] -> x + y + z end)\n    [9, 12]\n\n    iex> Enum.zip_with([[1, 2], [3, 4]], fn [x, y] -> x + y end)\n    [4, 6]","prompt":"Can you write a docstring for the following Elixir function? zip_with(enumerables, zip_fun)"}
{"completion":"Zips corresponding elements from two enumerables into a list, transforming them with\nthe `zip_fun` function as it goes.\n\nThe corresponding elements from each collection are passed to the provided two-arity `zip_fun`\nfunction in turn. Returns a list that contains the result of calling `zip_fun` for each pair of\nelements.\n\nThe zipping finishes as soon as either enumerable runs out of elements.\n\n## Zipping Maps\n\nIt's important to remember that zipping inherently relies on order.\nIf you zip two lists you get the element at the index from each list in turn.\nIf we zip two maps together it's tempting to think that you will get the given\nkey in the left map and the matching key in the right map, but there is no such\nguarantee because map keys are not ordered! Consider the following:\n\n    left =  %{:a => 1, 1 => 3}\n    right = %{:a => 1, :b => :c}\n    Enum.zip(left, right)\n    # [{{1, 3}, {:a, 1}}, {{:a, 1}, {:b, :c}}]\n\nAs you can see `:a` does not get paired with `:a`. If this is what you want,\nyou should use `Map.merge/3`.\n\n## Examples\n\n    iex> Enum.zip_with([1, 2], [3, 4], fn x, y -> x + y end)\n    [4, 6]\n\n    iex> Enum.zip_with([1, 2], [3, 4, 5, 6], fn x, y -> x + y end)\n    [4, 6]\n\n    iex> Enum.zip_with([1, 2, 5, 6], [3, 4], fn x, y -> x + y end)\n    [4, 6]","prompt":"Can you write a docstring for the following Elixir function? zip_with(enumerable1, enumerable2, zip_fun)"}
{"completion":"Functions for working with collections (known as enumerables).\n\nIn Elixir, an enumerable is any data type that implements the\n`Enumerable` protocol. `List`s (`[1, 2, 3]`), `Map`s (`%{foo: 1, bar: 2}`)\nand `Range`s (`1..3`) are common data types used as enumerables:\n\n    iex> Enum.map([1, 2, 3], fn x -> x * 2 end)\n    [2, 4, 6]\n\n    iex> Enum.sum([1, 2, 3])\n    6\n\n    iex> Enum.map(1..3, fn x -> x * 2 end)\n    [2, 4, 6]\n\n    iex> Enum.sum(1..3)\n    6\n\n    iex> map = %{\"a\" => 1, \"b\" => 2}\n    iex> Enum.map(map, fn {k, v} -> {k, v * 2} end)\n    [{\"a\", 2}, {\"b\", 4}]\n\nHowever, many other enumerables exist in the language, such as `MapSet`s\nand the data type returned by `File.stream!/3` which allows a file to be\ntraversed as if it was an enumerable.\n\nThe functions in this module work in linear time. This means that, the\ntime it takes to perform an operation grows at the same rate as the length\nof the enumerable. This is expected on operations such as `Enum.map/2`.\nAfter all, if we want to traverse every element on a list, the longer the\nlist, the more elements we need to traverse, and the longer it will take.\n\nThis linear behaviour should also be expected on operations like `count/1`,\n`member?/2`, `at/2` and similar. While Elixir does allow data types to\nprovide performant variants for such operations, you should not expect it\nto always be available, since the `Enum` module is meant to work with a\nlarge variety of data types and not all data types can provide optimized\nbehaviour.\n\nFinally, note the functions in the `Enum` module are eager: they will\ntraverse the enumerable as soon as they are invoked. This is particularly\ndangerous when working with infinite enumerables. In such cases, you should\nuse the `Stream` module, which allows you to lazily express computations,\nwithout traversing collections, and work with possibly infinite collections.\nSee the `Stream` module for examples and documentation.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Enum"}
{"completion":"Retrieves the number of elements in the `enumerable`.\n\nIt should return `{:ok, count}` if you can count the number of elements\nin `enumerable` in a faster way than fully traversing it.\n\nOtherwise it should return `{:error, __MODULE__}` and a default algorithm\nbuilt on top of `reduce/3` that runs in linear time will be used.","prompt":"Can you write a docstring for the following Elixir function? count(enumerable)"}
{"completion":"Checks if an `element` exists within the `enumerable`.\n\nIt should return `{:ok, boolean}` if you can check the membership of a\ngiven element in `enumerable` with `===/2` without traversing the whole\nof it.\n\nOtherwise it should return `{:error, __MODULE__}` and a default algorithm\nbuilt on top of `reduce/3` that runs in linear time will be used.\n\nWhen called outside guards, the [`in`](`in/2`) and [`not in`](`in/2`)\noperators work by using this function.","prompt":"Can you write a docstring for the following Elixir function? member?(enumerable, element)"}
{"completion":"Reduces the `enumerable` into an element.\n\nMost of the operations in `Enum` are implemented in terms of reduce.\nThis function should apply the given `t:reducer/0` function to each\nelement in the `enumerable` and proceed as expected by the returned\naccumulator.\n\nSee the documentation of the types `t:result/0` and `t:acc/0` for\nmore information.\n\n## Examples\n\nAs an example, here is the implementation of `reduce` for lists:\n\n    def reduce(_list, {:halt, acc}, _fun), do: {:halted, acc}\n    def reduce(list, {:suspend, acc}, fun), do: {:suspended, acc, &reduce(list, &1, fun)}\n    def reduce([], {:cont, acc}, _fun), do: {:done, acc}\n    def reduce([head | tail], {:cont, acc}, fun), do: reduce(tail, fun.(head, acc), fun)","prompt":"Can you write a docstring for the following Elixir function? reduce(enumerable, acc, fun)"}
{"completion":"Returns a function that slices the data structure contiguously.\n\nIt should return either:\n\n  * `{:ok, size, slicing_fun}` - if the `enumerable` has a known\n    bound and can access a position in the `enumerable` without\n    traversing all previous elements. The `slicing_fun` will receive\n    a `start` position, the `amount` of elements to fetch, and a\n    `step`.\n\n  * `{:ok, size, to_list_fun}` - if the `enumerable` has a known bound\n    and can access a position in the `enumerable` by first converting\n    it to a list via `to_list_fun`.\n\n  * `{:error, __MODULE__}` - the enumerable cannot be sliced efficiently\n    and a default algorithm built on top of `reduce/3` that runs in\n    linear time will be used.\n\n## Differences to `count/1`\n\nThe `size` value returned by this function is used for boundary checks,\ntherefore it is extremely important that this function only returns `:ok`\nif retrieving the `size` of the `enumerable` is cheap, fast, and takes\nconstant time. Otherwise the simplest of operations, such as\n`Enum.at(enumerable, 0)`, will become too expensive.\n\nOn the other hand, the `count/1` function in this protocol should be\nimplemented whenever you can count the number of elements in the collection\nwithout traversing it.","prompt":"Can you write a docstring for the following Elixir function? slice(enumerable)"}
{"completion":"Enumerable protocol used by `Enum` and `Stream` modules.\n\nWhen you invoke a function in the `Enum` module, the first argument\nis usually a collection that must implement this protocol.\nFor example, the expression `Enum.map([1, 2, 3], &(&1 * 2))`\ninvokes `Enumerable.reduce/3` to perform the reducing operation that\nbuilds a mapped list by calling the mapping function `&(&1 * 2)` on\nevery element in the collection and consuming the element with an\naccumulated list.\n\nInternally, `Enum.map/2` is implemented as follows:\n\n    def map(enumerable, fun) do\n      reducer = fn x, acc -> {:cont, [fun.(x) | acc]} end\n      Enumerable.reduce(enumerable, {:cont, []}, reducer) |> elem(1) |> :lists.reverse()\n    end\n\nNote that the user-supplied function is wrapped into a `t:reducer/0` function.\nThe `t:reducer/0` function must return a tagged tuple after each step,\nas described in the `t:acc/0` type. At the end, `Enumerable.reduce/3`\nreturns `t:result/0`.\n\nThis protocol uses tagged tuples to exchange information between the\nreducer function and the data type that implements the protocol. This\nallows enumeration of resources, such as files, to be done efficiently\nwhile also guaranteeing the resource will be closed at the end of the\nenumeration. This protocol also allows suspension of the enumeration,\nwhich is useful when interleaving between many enumerables is required\n(as in the `zip/1` and `zip/2` functions).\n\nThis protocol requires four functions to be implemented, `reduce/3`,\n`count/1`, `member?/2`, and `slice/1`. The core of the protocol is the\n`reduce/3` function. All other functions exist as optimizations paths\nfor data structures that can implement certain properties in better\nthan linear time.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Enumerable"}
{"completion":"Attaches information to exceptions for extra debugging.\n\nThis operation is potentially expensive, as it reads data\nfrom the file system, parses beam files, evaluates code and\nso on.\n\nIf the exception module implements the optional `c:blame/2`\ncallback, it will be invoked to perform the computation.","prompt":"Can you write a docstring for the following Elixir function? blame(kind, error, stacktrace)"}
{"completion":"Blames the invocation of the given module, function and arguments.\n\nThis function will retrieve the available clauses from bytecode\nand evaluate them against the given arguments. The clauses are\nreturned as a list of `{args, guards}` pairs where each argument\nand each top-level condition in a guard separated by `and`/`or`\nis wrapped in a tuple with blame metadata.\n\nThis function returns either `{:ok, definition, clauses}` or `:error`.\nWhere `definition` is `:def`, `:defp`, `:defmacro` or `:defmacrop`.","prompt":"Can you write a docstring for the following Elixir function? blame_mfa(module, function, args)"}
{"completion":"Returns `true` if the given `term` is an exception.","prompt":"Can you write a docstring for the following Elixir function? exception?(term)"}
{"completion":"Normalizes and formats throw/errors/exits and stacktraces.\n\nIt relies on `format_banner/3` and `format_stacktrace/1`\nto generate the final format.\n\nIf `kind` is `{:EXIT, pid}`, it does not generate a stacktrace,\nas such exits are retrieved as messages without stacktraces.","prompt":"Can you write a docstring for the following Elixir function? format(kind, payload, stacktrace \\\\ [])"}
{"completion":"Normalizes and formats any throw/error/exit.\n\nThe message is formatted and displayed in the same\nformat as used by Elixir's CLI.\n\nThe third argument is the stacktrace which is used to enrich\na normalized error with more information. It is only used when\nthe kind is an error.","prompt":"Can you write a docstring for the following Elixir function? format_banner(kind, exception, stacktrace \\\\ [])"}
{"completion":"Formats an exit. It returns a string.\n\nOften there are errors/exceptions inside exits. Exits are often\nwrapped by the caller and provide stacktraces too. This function\nformats exits in a way to nicely show the exit reason, caller\nand stacktrace.","prompt":"Can you write a docstring for the following Elixir function? format_exit(reason)"}
{"completion":"Receives an anonymous function and arity and formats it as\nshown in stacktraces. The arity may also be a list of arguments.\n\n## Examples\n\n    Exception.format_fa(fn -> nil end, 1)\n    #=> \"#Function<...>/1\"","prompt":"Can you write a docstring for the following Elixir function? format_fa(fun, arity)"}
{"completion":"Formats the given `file` and `line` as shown in stacktraces.\n\nIf any of the values are `nil`, they are omitted.\n\n## Examples\n\n    iex> Exception.format_file_line(\"foo\", 1)\n    \"foo:1:\"\n\n    iex> Exception.format_file_line(\"foo\", nil)\n    \"foo:\"\n\n    iex> Exception.format_file_line(nil, nil)\n    \"\"","prompt":"Can you write a docstring for the following Elixir function? format_file_line(file, line, suffix \\\\ \"\")"}
{"completion":"Formats the given `file`, `line`, and `column` as shown in stacktraces.\n\nIf any of the values are `nil`, they are omitted.\n\n## Examples\n\n    iex> Exception.format_file_line_column(\"foo\", 1, 2)\n    \"foo:1:2:\"\n\n    iex> Exception.format_file_line_column(\"foo\", 1, nil)\n    \"foo:1:\"\n\n    iex> Exception.format_file_line_column(\"foo\", nil, nil)\n    \"foo:\"\n\n    iex> Exception.format_file_line_column(\"foo\", nil, 2)\n    \"foo:\"\n\n    iex> Exception.format_file_line_column(nil, nil, nil)\n    \"\"","prompt":"Can you write a docstring for the following Elixir function? format_file_line_column(file, line, column, suffix \\\\ \"\")"}
{"completion":"Receives a module, fun and arity and formats it\nas shown in stacktraces. The arity may also be a list\nof arguments.\n\n## Examples\n\n    iex> Exception.format_mfa(Foo, :bar, 1)\n    \"Foo.bar/1\"\n\n    iex> Exception.format_mfa(Foo, :bar, [])\n    \"Foo.bar()\"\n\n    iex> Exception.format_mfa(nil, :bar, [])\n    \"nil.bar()\"\n\nAnonymous functions are reported as -func/arity-anonfn-count-,\nwhere func is the name of the enclosing function. Convert to\n\"anonymous fn in func/arity\"","prompt":"Can you write a docstring for the following Elixir function? format_mfa(module, fun, arity)"}
{"completion":"Formats the stacktrace.\n\nA stacktrace must be given as an argument. If not, the stacktrace\nis retrieved from `Process.info/2`.","prompt":"Can you write a docstring for the following Elixir function? format_stacktrace(trace \\\\ nil)"}
{"completion":"Receives a stacktrace entry and formats it into a string.","prompt":"Can you write a docstring for the following Elixir function? format_stacktrace_entry(entry)"}
{"completion":"Gets the message for an `exception`.","prompt":"Can you write a docstring for the following Elixir function? message(exception)"}
{"completion":"Normalizes an exception, converting Erlang exceptions\nto Elixir exceptions.\n\nIt takes the `kind` spilled by `catch` as an argument and\nnormalizes only `:error`, returning the untouched payload\nfor others.\n\nThe third argument is the stacktrace which is used to enrich\na normalized error with more information. It is only used when\nthe kind is an error.","prompt":"Can you write a docstring for the following Elixir function? normalize(kind, payload, stacktrace \\\\ [])"}
{"completion":"Functions to format throw/catch/exit and exceptions.\n\nNote that stacktraces in Elixir are only available inside\ncatch and rescue by using the `__STACKTRACE__/0` variable.\n\nDo not rely on the particular format returned by the `format*`\nfunctions in this module. They may be changed in future releases\nin order to better suit Elixir's tool chain. In other words,\nby using the functions in this module it is guaranteed you will\nformat exceptions as in the current Elixir version being used.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Exception"}
{"completion":"Converts a `:file_info` record into a `File.Stat`.","prompt":"Can you write a docstring for the following Elixir function? from_record(file_info)"}
{"completion":"Converts a `File.Stat` struct to a `:file_info` record.","prompt":"Can you write a docstring for the following Elixir function? to_record(stat)"}
{"completion":"A struct that holds file information.\n\nIn Erlang, this struct is represented by a `:file_info` record.\nTherefore this module also provides functions for converting\nbetween the Erlang record and the Elixir struct.\n\nIts fields are:\n\n  * `size` - size of file in bytes.\n\n  * `type` - `:device | :directory | :regular | :other | :symlink`; the type of the\n    file.\n\n  * `access` - `:read | :write | :read_write | :none`; the current system\n    access to the file.\n\n  * `atime` - the last time the file was read.\n\n  * `mtime` - the last time the file was written.\n\n  * `ctime` - the interpretation of this time field depends on the operating\n    system. On Unix-like operating systems, it is the last time the file or the inode was changed.\n    In Windows, it is the time of creation.\n\n  * `mode` - the file permissions.\n\n  * `links` - the number of links to this file. This is always 1 for file\n    systems which have no concept of links.\n\n  * `major_device` - identifies the file system where the file is located.\n    In Windows, the number indicates a drive as follows: 0 means A:, 1 means\n    B:, and so on.\n\n  * `minor_device` - only valid for character devices on Unix-like systems. In all other\n    cases, this field is zero.\n\n  * `inode` - gives the inode number. On non-Unix-like file systems, this field\n    will be zero.\n\n  * `uid` - indicates the owner of the file. Will be zero for non-Unix-like file\n    systems.\n\n  * `gid` - indicates the group that owns the file. Will be zero for\n    non-Unix-like file systems.\n\nThe time type returned in `atime`, `mtime`, and `ctime` is dependent on the\ntime type set in options. `{:time, type}` where type can be `:local`,\n`:universal`, or `:posix`. Default is `:universal`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.File.Stat"}
{"completion":"Defines a `File.Stream` struct returned by `File.stream!/3`.\n\nThe following fields are public:\n\n  * `path`          - the file path\n  * `modes`         - the file modes\n  * `raw`           - a boolean indicating if bin functions should be used\n  * `line_or_bytes` - if reading should read lines or a given number of bytes","prompt":"Can you write a docstring for the following Elixir function? Elixir.File.Stream"}
{"completion":"Sets the current working directory.\n\nThe current working directory is set for the BEAM globally. This can lead to\nrace conditions if multiple processes are changing the current working\ndirectory concurrently. To run an external command in a given directory\nwithout changing the global current working directory, use the `:cd` option\nof `System.cmd/3` and `Port.open/2`.\n\nReturns `:ok` if successful, `{:error, reason}` otherwise.","prompt":"Can you write a docstring for the following Elixir function? cd(path)"}
{"completion":"The same as `cd/1`, but raises a `File.Error` exception if it fails.","prompt":"Can you write a docstring for the following Elixir function? cd!(path)"}
{"completion":"Changes the current directory to the given `path`,\nexecutes the given function and then reverts back\nto the previous path regardless of whether there is an exception.\n\nThe current working directory is temporarily set for the BEAM globally. This\ncan lead to race conditions if multiple processes are changing the current\nworking directory concurrently. To run an external command in a given\ndirectory without changing the global current working directory, use the\n`:cd` option of `System.cmd/3` and `Port.open/2`.\n\nRaises an error if retrieving or changing the current\ndirectory fails.","prompt":"Can you write a docstring for the following Elixir function? cd!(path, function)"}
{"completion":"Changes the group given by the group ID `gid`\nfor a given `file`. Returns `:ok` on success, or\n`{:error, reason}` on failure.","prompt":"Can you write a docstring for the following Elixir function? chgrp(path, gid)"}
{"completion":"Same as `chgrp/2`, but raises a `File.Error` exception in case of failure.\nOtherwise `:ok`.","prompt":"Can you write a docstring for the following Elixir function? chgrp!(path, gid)"}
{"completion":"Changes the `mode` for a given `file`.\n\nReturns `:ok` on success, or `{:error, reason}` on failure.\n\n## Permissions\n\nFile permissions are specified by adding together the following octal modes:\n\n  * `0o400` - read permission: owner\n  * `0o200` - write permission: owner\n  * `0o100` - execute permission: owner\n\n  * `0o040` - read permission: group\n  * `0o020` - write permission: group\n  * `0o010` - execute permission: group\n\n  * `0o004` - read permission: other\n  * `0o002` - write permission: other\n  * `0o001` - execute permission: other\n\nFor example, setting the mode `0o755` gives it\nwrite, read and execute permission to the owner\nand both read and execute permission to group\nand others.","prompt":"Can you write a docstring for the following Elixir function? chmod(path, mode)"}
{"completion":"Same as `chmod/2`, but raises a `File.Error` exception in case of failure.\nOtherwise `:ok`.","prompt":"Can you write a docstring for the following Elixir function? chmod!(path, mode)"}
{"completion":"Changes the owner given by the user ID `uid`\nfor a given `file`. Returns `:ok` on success,\nor `{:error, reason}` on failure.","prompt":"Can you write a docstring for the following Elixir function? chown(path, uid)"}
{"completion":"Same as `chown/2`, but raises a `File.Error` exception in case of failure.\nOtherwise `:ok`.","prompt":"Can you write a docstring for the following Elixir function? chown!(path, uid)"}
{"completion":"Closes the file referenced by `io_device`. It mostly returns `:ok`, except\nfor some severe errors such as out of memory.\n\nNote that if the option `:delayed_write` was used when opening the file,\n`close/1` might return an old write error and not even try to close the file.\nSee `open/2` for more information.","prompt":"Can you write a docstring for the following Elixir function? close(io_device)"}
{"completion":"Copies the contents of `source` to `destination`.\n\nBoth parameters can be a filename or an IO device opened\nwith `open/2`. `bytes_count` specifies the number of\nbytes to copy, the default being `:infinity`.\n\nIf file `destination` already exists, it is overwritten\nby the contents in `source`.\n\nReturns `{:ok, bytes_copied}` if successful,\n`{:error, reason}` otherwise.\n\nCompared to the `cp/3`, this function is more low-level,\nallowing a copy from device to device limited by a number of\nbytes. On the other hand, `cp/3` performs more extensive\nchecks on both source and destination and it also preserves\nthe file mode after copy.\n\nTypical error reasons are the same as in `open/2`,\n`read/1` and `write/3`.","prompt":"Can you write a docstring for the following Elixir function? copy(source, destination, bytes_count \\\\ :infinity)"}
{"completion":"The same as `copy/3` but raises a `File.CopyError` exception if it fails.\nReturns the `bytes_copied` otherwise.","prompt":"Can you write a docstring for the following Elixir function? copy!(source, destination, bytes_count \\\\ :infinity)"}
{"completion":"Copies the contents of `source_file` to `destination_file` preserving its modes.\n\n`source_file` must be a file or a symbolic link to one. `destination_file` must\nbe a path to a non-existent file. If either is a directory, `{:error, :eisdir}`\nwill be returned.\n\nThe function returns `:ok` in case of success. Otherwise, it returns\n`{:error, reason}`.\n\nIf you want to copy contents from an IO device to another device\nor do a straight copy from a source to a destination without\npreserving modes, check `copy/3` instead.\n\nNote: The command `cp` in Unix-like systems behaves differently depending on\nwhether the destination is an existing directory or not. We have chosen to\nexplicitly disallow copying to a destination which is a directory,\nand an error will be returned if tried.\n\n## Options\n\n  * `:on_conflict` - (since v1.14.0) Invoked when a file already exists in the destination.\n    The function receives arguments for `source_file` and `destination_file`. It should\n    return `true` if the existing file should be overwritten, `false` if otherwise.\n    The default callback returns `true`. On earlier versions, this callback could be\n    given as third argument, but such behaviour is now deprecated.","prompt":"Can you write a docstring for the following Elixir function? cp(source_file, destination_file, options \\\\ [])"}
{"completion":"The same as `cp/3`, but raises a `File.CopyError` exception if it fails.\nReturns `:ok` otherwise.","prompt":"Can you write a docstring for the following Elixir function? cp!(source_file, destination_file, options \\\\ [])"}
{"completion":"Copies the contents in `source` to `destination` recursively, maintaining the\nsource directory structure and modes.\n\nIf `source` is a file or a symbolic link to it, `destination` must be a path\nto an existent file, a symbolic link to one, or a path to a non-existent file.\n\nIf `source` is a directory, or a symbolic link to it, then `destination` must\nbe an existent `directory` or a symbolic link to one, or a path to a non-existent directory.\n\nIf the source is a file, it copies `source` to `destination`. If the `source`\nis a directory, it copies the contents inside source into the `destination` directory.\n\nIf a file already exists in the destination, it invokes the optional `on_conflict`\ncallback given as an option. See \"Options\" for more information.\n\nThis function may fail while copying files, in such cases, it will leave the\ndestination directory in a dirty state, where file which have already been\ncopied won't be removed.\n\nThe function returns `{:ok, files_and_directories}` in case of\nsuccess, `files_and_directories` lists all files and directories copied in no\nspecific order. It returns `{:error, reason, file}` otherwise.\n\nNote: The command `cp` in Unix-like systems behaves differently depending on\nwhether `destination` is an existing directory or not. We have chosen to\nexplicitly disallow this behaviour. If `source` is a `file` and `destination`\nis a directory, `{:error, :eisdir}` will be returned.\n\n## Options\n\n  * `:on_conflict` - (since v1.14.0) Invoked when a file already exists in the destination.\n    The function receives arguments for `source` and `destination`. It should return\n    `true` if the existing file should be overwritten, `false` if otherwise. The default\n    callback returns `true`. On earlier versions, this callback could be given as third\n    argument, but such behaviour is now deprecated.\n\n  * `:dereference_symlinks` - (since v1.14.0) By default, this function will copy symlinks\n    by creating symlinks that point to the same location. This option forces symlinks to be\n    dereferenced and have their contents copied instead when set to `true`. If the dereferenced\n    files do not exist, than the operation fails. The default is `false`.\n\n## Examples\n\n    # Copies file \"a.txt\" to \"b.txt\"\n    File.cp_r(\"a.txt\", \"b.txt\")\n\n    # Copies all files in \"samples\" to \"tmp\"\n    File.cp_r(\"samples\", \"tmp\")\n\n    # Same as before, but asks the user how to proceed in case of conflicts\n    File.cp_r(\"samples\", \"tmp\", on_conflict: fn source, destination ->\n      IO.gets(\"Overwriting #{destination} by #{source}. Type y to confirm. \") == \"y\\n\"\n    end)","prompt":"Can you write a docstring for the following Elixir function? cp_r(source, destination, options \\\\ [])"}
{"completion":"The same as `cp_r/3`, but raises a `File.CopyError` exception if it fails.\nReturns the list of copied files otherwise.","prompt":"Can you write a docstring for the following Elixir function? cp_r!(source, destination, options \\\\ [])"}
{"completion":"Gets the current working directory.\n\nIn rare circumstances, this function can fail on Unix-like systems. It may happen\nif read permissions do not exist for the parent directories of the\ncurrent directory. For this reason, returns `{:ok, cwd}` in case\nof success, `{:error, reason}` otherwise.","prompt":"Can you write a docstring for the following Elixir function? cwd()"}
{"completion":"The same as `cwd/0`, but raises a `File.Error` exception if it fails.","prompt":"Can you write a docstring for the following Elixir function? cwd!()"}
{"completion":"Returns `true` if the given path is a directory.\n\nThis function follows symbolic links, so if a symbolic link points to a\ndirectory, `true` is returned.\n\n## Options\n\nThe supported options are:\n\n  * `:raw` - a single atom to bypass the file server and only check\n    for the file locally\n\n## Examples\n\n    File.dir?(\"./test\")\n    #=> true\n\n    File.dir?(\"test\")\n    #=> true\n\n    File.dir?(\"/usr/bin\")\n    #=> true\n\n    File.dir?(\"~/Downloads\")\n    #=> false\n\n    \"~/Downloads\" |> Path.expand() |> File.dir?()\n    #=> true","prompt":"Can you write a docstring for the following Elixir function? dir?(path, opts \\\\ [])"}
{"completion":"Returns `true` if the given path exists.\n\nIt can be a regular file, directory, socket, symbolic link, named pipe, or device file.\nReturns `false` for symbolic links pointing to non-existing targets.\n\n## Options\n\nThe supported options are:\n\n  * `:raw` - a single atom to bypass the file server and only check\n    for the file locally\n\n## Examples\n\n    File.exists?(\"test/\")\n    #=> true\n\n    File.exists?(\"missing.txt\")\n    #=> false\n\n    File.exists?(\"/dev/null\")\n    #=> true","prompt":"Can you write a docstring for the following Elixir function? exists?(path, opts \\\\ [])"}
{"completion":"Creates a hard link `new` to the file `existing`.\n\nReturns `:ok` if successful, `{:error, reason}` otherwise.\nIf the operating system does not support hard links, returns\n`{:error, :enotsup}`.","prompt":"Can you write a docstring for the following Elixir function? ln(existing, new)"}
{"completion":"Same as `ln/2` but raises a `File.LinkError` exception if it fails.\nReturns `:ok` otherwise.","prompt":"Can you write a docstring for the following Elixir function? ln!(existing, new)"}
{"completion":"Creates a symbolic link `new` to the file or directory `existing`.\n\nReturns `:ok` if successful, `{:error, reason}` otherwise.\nIf the operating system does not support symlinks, returns\n`{:error, :enotsup}`.","prompt":"Can you write a docstring for the following Elixir function? ln_s(existing, new)"}
{"completion":"Same as `ln_s/2` but raises a `File.LinkError` exception if it fails.\nReturns `:ok` otherwise.","prompt":"Can you write a docstring for the following Elixir function? ln_s!(existing, new)"}
{"completion":"Returns the list of files in the given directory.\n\nReturns `{:ok, files}` in case of success,\n`{:error, reason}` otherwise.","prompt":"Can you write a docstring for the following Elixir function? ls(path \\\\ \".\")"}
{"completion":"The same as `ls/1` but raises a `File.Error` exception in case of an error.","prompt":"Can you write a docstring for the following Elixir function? ls!(path \\\\ \".\")"}
{"completion":"Returns information about the `path`. If the file is a symlink, sets\nthe `type` to `:symlink` and returns a `File.Stat` struct for the link. For any\nother file, returns exactly the same values as `stat/2`.\n\nFor more details, see `:file.read_link_info/2`.\n\n## Options\n\nThe accepted options are:\n\n  * `:time` - configures how the file timestamps are returned\n\nThe values for `:time` can be:\n\n  * `:universal` - returns a `{date, time}` tuple in UTC (default)\n  * `:local` - returns a `{date, time}` tuple using the machine time\n  * `:posix` - returns the time as integer seconds since epoch\n\nNote: Since file times are stored in POSIX time format on most operating systems,\nit is faster to retrieve file information with the `time: :posix` option.","prompt":"Can you write a docstring for the following Elixir function? lstat(path, opts \\\\ [])"}
{"completion":"Same as `lstat/2` but returns the `File.Stat` struct directly,\nor raises a `File.Error` exception if an error is returned.","prompt":"Can you write a docstring for the following Elixir function? lstat!(path, opts \\\\ [])"}
{"completion":"Tries to create the directory `path`.\n\nMissing parent directories are not created.\nReturns `:ok` if successful, or `{:error, reason}` if an error occurs.\n\nTypical error reasons are:\n\n  * `:eacces`  - missing search or write permissions for the parent\n    directories of `path`\n  * `:eexist`  - there is already a file or directory named `path`\n  * `:enoent`  - a component of `path` does not exist\n  * `:enospc`  - there is no space left on the device\n  * `:enotdir` - a component of `path` is not a directory;\n    on some platforms, `:enoent` is returned instead","prompt":"Can you write a docstring for the following Elixir function? mkdir(path)"}
{"completion":"Same as `mkdir/1`, but raises a `File.Error` exception in case of failure.\nOtherwise `:ok`.","prompt":"Can you write a docstring for the following Elixir function? mkdir!(path)"}
{"completion":"Tries to create the directory `path`.\n\nMissing parent directories are created. Returns `:ok` if successful, or\n`{:error, reason}` if an error occurs.\n\nTypical error reasons are:\n\n  * `:eacces`  - missing search or write permissions for the parent\n    directories of `path`\n  * `:enospc`  - there is no space left on the device\n  * `:enotdir` - a component of `path` is not a directory","prompt":"Can you write a docstring for the following Elixir function? mkdir_p(path)"}
{"completion":"Same as `mkdir_p/1`, but raises a `File.Error` exception in case of failure.\nOtherwise `:ok`.","prompt":"Can you write a docstring for the following Elixir function? mkdir_p!(path)"}
{"completion":"Opens the given `path`.\n\nIn order to write and read files, one must use the functions\nin the `IO` module. By default, a file is opened in `:binary` mode,\nwhich requires the functions `IO.binread/2` and `IO.binwrite/2`\nto interact with the file. A developer may pass `:utf8` as an\noption when opening the file and then all other functions from\n`IO` are available, since they work directly with Unicode data.\n\n`modes_or_function` can either be a list of modes or a function. If it's a\nlist, it's considered to be a list of modes (that are documented below). If\nit's a function, then it's equivalent to calling `open(path, [],\nmodes_or_function)`. See the documentation for `open/3` for more information\non this function.\n\nThe allowed modes:\n\n  * `:binary` - opens the file in binary mode, disabling special handling of Unicode sequences\n    (default mode).\n\n  * `:read` - the file, which must exist, is opened for reading.\n\n  * `:write` - the file is opened for writing. It is created if it does not\n    exist.\n\n    If the file does exists, and if write is not combined with read, the file\n    will be truncated.\n\n  * `:append` - the file will be opened for writing, and it will be created\n    if it does not exist. Every write operation to a file opened with append\n    will take place at the end of the file.\n\n  * `:exclusive` - the file, when opened for writing, is created if it does\n    not exist. If the file exists, open will return `{:error, :eexist}`.\n\n  * `:charlist` - when this term is given, read operations on the file will\n    return charlists rather than binaries.\n\n  * `:compressed` - makes it possible to read or write gzip compressed files.\n\n    The compressed option must be combined with either read or write, but not\n    both. Note that the file size obtained with `stat/1` will most probably\n    not match the number of bytes that can be read from a compressed file.\n\n  * `:utf8` - this option denotes how data is actually stored in the disk\n    file and makes the file perform automatic translation of characters to\n    and from UTF-8.\n\n    If data is sent to a file in a format that cannot be converted to the\n    UTF-8 or if data is read by a function that returns data in a format that\n    cannot cope with the character range of the data, an error occurs and the\n    file will be closed.\n\n  * `:delayed_write`, `:raw`, `:ram`, `:read_ahead`, `:sync`, `{:encoding, ...}`,\n    `{:read_ahead, pos_integer}`, `{:delayed_write, non_neg_integer, non_neg_integer}` -\n    for more information about these options see `:file.open/2`.\n\nThis function returns:\n\n  * `{:ok, io_device}` - the file has been opened in the requested mode.\n\n    `io_device` is actually the PID of the process which handles the file.\n    This process monitors the process that originally opened the file (the\n    owner process). If the owner process terminates, the file is closed and\n    the process itself terminates too. If any process to which the `io_device`\n    is linked terminates, the file will be closed and the process itself will\n    be terminated.\n\n    An `io_device` returned from this call can be used as an argument to the\n    `IO` module functions.\n\n  * `{:error, reason}` - the file could not be opened.\n\n## Examples\n\n    {:ok, file} = File.open(\"foo.tar.gz\", [:read, :compressed])\n    IO.read(file, :line)\n    File.close(file)","prompt":"Can you write a docstring for the following Elixir function? open(path, modes_or_function \\\\ [])"}
{"completion":"Similar to `open/2` but expects a function as its last argument.\n\nThe file is opened, given to the function as an argument and\nautomatically closed after the function returns, regardless\nif there was an error when executing the function.\n\nReturns `{:ok, function_result}` in case of success,\n`{:error, reason}` otherwise.\n\nThis function expects the file to be closed with success,\nwhich is usually the case unless the `:delayed_write` option\nis given. For this reason, we do not recommend passing\n`:delayed_write` to this function.\n\n## Examples\n\n    File.open(\"file.txt\", [:read, :write], fn file ->\n      IO.read(file, :line)\n    end)\n\nSee `open/2` for the list of available `modes`.","prompt":"Can you write a docstring for the following Elixir function? open(path, modes, function)"}
{"completion":"Similar to `open/2` but raises a `File.Error` exception if the file\ncould not be opened. Returns the IO device otherwise.\n\nSee `open/2` for the list of available modes.","prompt":"Can you write a docstring for the following Elixir function? open!(path, modes_or_function \\\\ [])"}
{"completion":"Similar to `open/3` but raises a `File.Error` exception if the file\ncould not be opened.\n\nIf it succeeds opening the file, it returns the `function` result on the IO device.\n\nSee `open/2` for the list of available `modes`.","prompt":"Can you write a docstring for the following Elixir function? open!(path, modes, function)"}
{"completion":"Returns `{:ok, binary}`, where `binary` is a binary data object that contains the contents\nof `path`, or `{:error, reason}` if an error occurs.\n\nTypical error reasons:\n\n  * `:enoent`  - the file does not exist\n  * `:eacces`  - missing permission for reading the file,\n    or for searching one of the parent directories\n  * `:eisdir`  - the named file is a directory\n  * `:enotdir` - a component of the file name is not a directory;\n    on some platforms, `:enoent` is returned instead\n  * `:enomem`  - there is not enough memory for the contents of the file\n\nYou can use `:file.format_error/1` to get a descriptive string of the error.","prompt":"Can you write a docstring for the following Elixir function? read(path)"}
{"completion":"Returns a binary with the contents of the given filename,\nor raises a `File.Error` exception if an error occurs.","prompt":"Can you write a docstring for the following Elixir function? read!(path)"}
{"completion":"Reads the symbolic link at `path`.\n\nIf `path` exists and is a symlink, returns `{:ok, target}`, otherwise returns\n`{:error, reason}`.\n\nFor more details, see `:file.read_link/1`.\n\nTypical error reasons are:\n\n  * `:einval` - path is not a symbolic link\n  * `:enoent` - path does not exist\n  * `:enotsup` - symbolic links are not supported on the current platform","prompt":"Can you write a docstring for the following Elixir function? read_link(path)"}
{"completion":"Same as `read_link/1` but returns the target directly,\nor raises a `File.Error` exception if an error is returned.","prompt":"Can you write a docstring for the following Elixir function? read_link!(path)"}
{"completion":"Returns `true` if the path is a regular file.\n\nThis function follows symbolic links, so if a symbolic link points to a\nregular file, `true` is returned.\n\n## Options\n\nThe supported options are:\n\n  * `:raw` - a single atom to bypass the file server and only check\n    for the file locally\n\n## Examples\n\n    File.regular?(__ENV__.file)\n    #=> true","prompt":"Can you write a docstring for the following Elixir function? regular?(path, opts \\\\ [])"}
{"completion":"Renames the `source` file to `destination` file.  It can be used to move files\n(and directories) between directories.  If moving a file, you must fully\nspecify the `destination` filename, it is not sufficient to simply specify\nits directory.\n\nReturns `:ok` in case of success, `{:error, reason}` otherwise.\n\nNote: The command `mv` in Unix-like systems behaves differently depending on\nwhether `source` is a file and the `destination` is an existing directory.\nWe have chosen to explicitly disallow this behaviour.\n\n## Examples\n\n    # Rename file \"a.txt\" to \"b.txt\"\n    File.rename(\"a.txt\", \"b.txt\")\n\n    # Rename directory \"samples\" to \"tmp\"\n    File.rename(\"samples\", \"tmp\")","prompt":"Can you write a docstring for the following Elixir function? rename(source, destination)"}
{"completion":"The same as `rename/2` but raises a `File.RenameError` exception if it fails.\nReturns `:ok` otherwise.","prompt":"Can you write a docstring for the following Elixir function? rename!(source, destination)"}
{"completion":"Tries to delete the file `path`.\n\nReturns `:ok` if successful, or `{:error, reason}` if an error occurs.\n\nNote the file is deleted even if in read-only mode.\n\nTypical error reasons are:\n\n  * `:enoent`  - the file does not exist\n  * `:eacces`  - missing permission for the file or one of its parents\n  * `:eperm`   - the file is a directory and user is not super-user\n  * `:enotdir` - a component of the file name is not a directory;\n    on some platforms, `:enoent` is returned instead\n  * `:einval`  - filename had an improper type, such as tuple\n\n## Examples\n\n    File.rm(\"file.txt\")\n    #=> :ok\n\n    File.rm(\"tmp_dir/\")\n    #=> {:error, :eperm}","prompt":"Can you write a docstring for the following Elixir function? rm(path)"}
{"completion":"Same as `rm/1`, but raises a `File.Error` exception in case of failure.\nOtherwise `:ok`.","prompt":"Can you write a docstring for the following Elixir function? rm!(path)"}
{"completion":"Removes files and directories recursively at the given `path`.\nSymlinks are not followed but simply removed, non-existing\nfiles are simply ignored (i.e. doesn't make this function fail).\n\nReturns `{:ok, files_and_directories}` with all files and\ndirectories removed in no specific order, `{:error, reason, file}`\notherwise.\n\n## Examples\n\n    File.rm_rf(\"samples\")\n    #=> {:ok, [\"samples\", \"samples/1.txt\"]}\n\n    File.rm_rf(\"unknown\")\n    #=> {:ok, []}","prompt":"Can you write a docstring for the following Elixir function? rm_rf(path)"}
{"completion":"Same as `rm_rf/1` but raises a `File.Error` exception in case of failures,\notherwise the list of files or directories removed.","prompt":"Can you write a docstring for the following Elixir function? rm_rf!(path)"}
{"completion":"Tries to delete the dir at `path`.\n\nReturns `:ok` if successful, or `{:error, reason}` if an error occurs.\nIt returns `{:error, :eexist}` if the directory is not empty.\n\n## Examples\n\n    File.rmdir(\"tmp_dir\")\n    #=> :ok\n\n    File.rmdir(\"non_empty_dir\")\n    #=> {:error, :eexist}\n\n    File.rmdir(\"file.txt\")\n    #=> {:error, :enotdir}","prompt":"Can you write a docstring for the following Elixir function? rmdir(path)"}
{"completion":"Same as `rmdir/1`, but raises a `File.Error` exception in case of failure.\nOtherwise `:ok`.","prompt":"Can you write a docstring for the following Elixir function? rmdir!(path)"}
{"completion":"Returns information about the `path`. If it exists, it\nreturns a `{:ok, info}` tuple, where info is a\n`File.Stat` struct. Returns `{:error, reason}` with\nthe same reasons as `read/1` if a failure occurs.\n\n## Options\n\nThe accepted options are:\n\n  * `:time` - configures how the file timestamps are returned\n\nThe values for `:time` can be:\n\n  * `:universal` - returns a `{date, time}` tuple in UTC (default)\n  * `:local` - returns a `{date, time}` tuple using the same time zone as the\n    machine\n  * `:posix` - returns the time as integer seconds since epoch\n\nNote: Since file times are stored in POSIX time format on most operating systems,\nit is faster to retrieve file information with the `time: :posix` option.","prompt":"Can you write a docstring for the following Elixir function? stat(path, opts \\\\ [])"}
{"completion":"Same as `stat/2` but returns the `File.Stat` directly,\nor raises a `File.Error` exception if an error is returned.","prompt":"Can you write a docstring for the following Elixir function? stat!(path, opts \\\\ [])"}
{"completion":"Returns a `File.Stream` for the given `path` with the given `modes`.\n\nThe stream implements both `Enumerable` and `Collectable` protocols,\nwhich means it can be used both for read and write.\n\nThe `line_or_bytes` argument configures how the file is read when\nstreaming, by `:line` (default) or by a given number of bytes. When\nusing the `:line` option, CRLF line breaks (`\"\\r\\n\"`) are normalized\nto LF (`\"\\n\"`).\n\nOperating the stream can fail on open for the same reasons as\n`File.open!/2`. Note that the file is automatically opened each time streaming\nbegins. There is no need to pass `:read` and `:write` modes, as those are\nautomatically set by Elixir.\n\n## Raw files\n\nSince Elixir controls when the streamed file is opened, the underlying\ndevice cannot be shared and as such it is convenient to open the file\nin raw mode for performance reasons. Therefore, Elixir **will** open\nstreams in `:raw` mode with the `:read_ahead` option unless an encoding\nis specified. This means any data streamed into the file must be\nconverted to `t:iodata/0` type. If you pass, for example, `[encoding: :utf8]`\nor `[encoding: {:utf16, :little}]` in the modes parameter,\nthe underlying stream will use `IO.write/2` and the `String.Chars` protocol\nto convert the data. See `IO.binwrite/2` and `IO.write/2` .\n\nOne may also consider passing the `:delayed_write` option if the stream\nis meant to be written to under a tight loop.\n\n## Byte order marks\n\nIf you pass `:trim_bom` in the modes parameter, the stream will\ntrim UTF-8, UTF-16 and UTF-32 byte order marks when reading from file.\n\nNote that this function does not try to discover the file encoding basing\non BOM.\n\n## Examples\n\n    # Read in 2048 byte chunks rather than lines\n    File.stream!(\"./test/test.data\", [], 2048)\n    #=> %File.Stream{line_or_bytes: 2048, modes: [:raw, :read_ahead, :binary],\n    #=>   path: \"./test/test.data\", raw: true}\n\nSee `Stream.run/1` for an example of streaming into a file.","prompt":"Can you write a docstring for the following Elixir function? stream!(path, modes \\\\ [], line_or_bytes \\\\ :line)"}
{"completion":"Updates modification time (mtime) and access time (atime) of\nthe given file.\n\nThe file is created if it doesn't exist. Requires datetime in UTC\n(as returned by `:erlang.universaltime()`) or an integer\nrepresenting the POSIX timestamp (as returned by `System.os_time(:second)`).\n\nIn Unix-like systems, changing the modification time may require\nyou to be either `root` or the owner of the file. Having write\naccess may not be enough. In those cases, touching the file the\nfirst time (to create it) will succeed, but touching an existing\nfile with fail with `{:error, :eperm}`.\n\n## Examples\n\n    File.touch(\"/tmp/a.txt\", {{2018, 1, 30}, {13, 59, 59}})\n    #=> :ok\n    File.touch(\"/fakedir/b.txt\", {{2018, 1, 30}, {13, 59, 59}})\n    {:error, :enoent}\n\n    File.touch(\"/tmp/a.txt\", 1544519753)\n    #=> :ok","prompt":"Can you write a docstring for the following Elixir function? touch(path, time \\\\ System.os_time(:second))"}
{"completion":"Same as `touch/2` but raises a `File.Error` exception if it fails.\nReturns `:ok` otherwise.\n\nThe file is created if it doesn't exist. Requires datetime in UTC\n(as returned by `:erlang.universaltime()`) or an integer\nrepresenting the POSIX timestamp (as returned by `System.os_time(:second)`).\n\n## Examples\n\n    File.touch!(\"/tmp/a.txt\", {{2018, 1, 30}, {13, 59, 59}})\n    #=> :ok\n    File.touch!(\"/fakedir/b.txt\", {{2018, 1, 30}, {13, 59, 59}})\n    ** (File.Error) could not touch \"/fakedir/b.txt\": no such file or directory\n\n    File.touch!(\"/tmp/a.txt\", 1544519753)","prompt":"Can you write a docstring for the following Elixir function? touch!(path, time \\\\ System.os_time(:second))"}
{"completion":"Writes `content` to the file `path`.\n\nThe file is created if it does not exist. If it exists, the previous\ncontents are overwritten. Returns `:ok` if successful, or `{:error, reason}`\nif an error occurs.\n\n`content` must be `iodata` (a list of bytes or a binary). Setting the\nencoding for this function has no effect.\n\n**Warning:** Every time this function is invoked, a file descriptor is opened\nand a new process is spawned to write to the file. For this reason, if you are\ndoing multiple writes in a loop, opening the file via `File.open/2` and using\nthe functions in `IO` to write to the file will yield much better performance\nthan calling this function multiple times.\n\nTypical error reasons are:\n\n  * `:enoent`  - a component of the file name does not exist\n  * `:enotdir` - a component of the file name is not a directory;\n    on some platforms, `:enoent` is returned instead\n  * `:enospc`  - there is no space left on the device\n  * `:eacces`  - missing permission for writing the file or searching one of\n    the parent directories\n  * `:eisdir`  - the named file is a directory\n\nCheck `File.open/2` for other available options.","prompt":"Can you write a docstring for the following Elixir function? write(path, content, modes \\\\ [])"}
{"completion":"Same as `write/3` but raises a `File.Error` exception if it fails.\nReturns `:ok` otherwise.","prompt":"Can you write a docstring for the following Elixir function? write!(path, content, modes \\\\ [])"}
{"completion":"Writes the given `File.Stat` back to the file system at the given\npath. Returns `:ok` or `{:error, reason}`.","prompt":"Can you write a docstring for the following Elixir function? write_stat(path, stat, opts \\\\ [])"}
{"completion":"Same as `write_stat/3` but raises a `File.Error` exception if it fails.\nReturns `:ok` otherwise.","prompt":"Can you write a docstring for the following Elixir function? write_stat!(path, stat, opts \\\\ [])"}
{"completion":"This module contains functions to manipulate files.\n\nSome of those functions are low-level, allowing the user\nto interact with files or IO devices, like `open/2`,\n`copy/3` and others. This module also provides higher\nlevel functions that work with filenames and have their naming\nbased on Unix variants. For example, one can copy a file\nvia `cp/3` and remove files and directories recursively\nvia `rm_rf/1`.\n\nPaths given to functions in this module can be either relative to the\ncurrent working directory (as returned by `File.cwd/0`), or absolute\npaths. Shell conventions like `~` are not expanded automatically.\nTo use paths like `~/Downloads`, you can use `Path.expand/1` or\n`Path.expand/2` to expand your path to an absolute path.","prompt":"Can you write a docstring for the following Elixir function? Elixir.File"}
{"completion":"Encoding\n\nIn order to write and read files, one must use the functions\nin the `IO` module. By default, a file is opened in binary mode,\nwhich requires the functions `IO.binread/2` and `IO.binwrite/2`\nto interact with the file. A developer may pass `:utf8` as an\noption when opening the file, then the slower `IO.read/2` and\n`IO.write/2` functions must be used as they are responsible for\ndoing the proper conversions and providing the proper data guarantees.\n\nNote that filenames when given as charlists in Elixir are\nalways treated as UTF-8. In particular, we expect that the\nshell and the operating system are configured to use UTF-8\nencoding. Binary filenames are considered raw and passed\nto the operating system as is.","prompt":"Can you write a docstring for the following Elixir function? Elixir.File"}
{"completion":"API\n\nMost of the functions in this module return `:ok` or\n`{:ok, result}` in case of success, `{:error, reason}`\notherwise. Those functions also have a variant\nthat ends with `!` which returns the result (instead of the\n`{:ok, result}` tuple) in case of success or raises an\nexception in case it fails. For example:\n\n    File.read(\"hello.txt\")\n    #=> {:ok, \"World\"}\n\n    File.read(\"invalid.txt\")\n    #=> {:error, :enoent}\n\n    File.read!(\"hello.txt\")\n    #=> \"World\"\n\n    File.read!(\"invalid.txt\")\n    #=> raises File.Error\n\nIn general, a developer should use the former in case they want\nto react if the file does not exist. The latter should be used\nwhen the developer expects their software to fail in case the\nfile cannot be read (i.e. it is literally an exception).","prompt":"Can you write a docstring for the following Elixir function? Elixir.File"}
{"completion":"Processes and raw files\n\nEvery time a file is opened, Elixir spawns a new process. Writing\nto a file is equivalent to sending messages to the process that\nwrites to the file descriptor.\n\nThis means files can be passed between nodes and message passing\nguarantees they can write to the same file in a network.\n\nHowever, you may not always want to pay the price for this abstraction.\nIn such cases, a file can be opened in `:raw` mode. The options `:read_ahead`\nand `:delayed_write` are also useful when operating on large files or\nworking with files in tight loops.\n\nCheck `:file.open/2` for more information about such options and\nother performance considerations.","prompt":"Can you write a docstring for the following Elixir function? Elixir.File"}
{"completion":"Rounds a float to the smallest integer greater than or equal to `num`.\n\n`ceil/2` also accepts a precision to round a floating-point value down\nto an arbitrary number of fractional digits (between 0 and 15).\n\nThe operation is performed on the binary floating point, without a\nconversion to decimal.\n\nThe behaviour of `ceil/2` for floats can be surprising. For example:\n\n    iex> Float.ceil(-12.52, 2)\n    -12.51\n\nOne may have expected it to ceil to -12.52. This is not a bug.\nMost decimal fractions cannot be represented as a binary floating point\nand therefore the number above is internally represented as -12.51999999,\nwhich explains the behaviour above.\n\nThis function always returns floats. `Kernel.trunc/1` may be used instead to\ntruncate the result to an integer afterwards.\n\n## Examples\n\n    iex> Float.ceil(34.25)\n    35.0\n    iex> Float.ceil(-56.5)\n    -56.0\n    iex> Float.ceil(34.251, 2)\n    34.26","prompt":"Can you write a docstring for the following Elixir function? ceil(number, precision \\\\ 0)"}
{"completion":"Rounds a float to the largest number less than or equal to `num`.\n\n`floor/2` also accepts a precision to round a floating-point value down\nto an arbitrary number of fractional digits (between 0 and 15).\nThe operation is performed on the binary floating point, without a\nconversion to decimal.\n\nThis function always returns a float. `Kernel.trunc/1` may be used instead to\ntruncate the result to an integer afterwards.\n\n## Known issues\n\nThe behaviour of `floor/2` for floats can be surprising. For example:\n\n    iex> Float.floor(12.52, 2)\n    12.51\n\nOne may have expected it to floor to 12.52. This is not a bug.\nMost decimal fractions cannot be represented as a binary floating point\nand therefore the number above is internally represented as 12.51999999,\nwhich explains the behaviour above.\n\n## Examples\n\n    iex> Float.floor(34.25)\n    34.0\n    iex> Float.floor(-56.5)\n    -57.0\n    iex> Float.floor(34.259, 2)\n    34.25","prompt":"Can you write a docstring for the following Elixir function? floor(number, precision \\\\ 0)"}
{"completion":"Returns the maximum finite value for a float.\n\n## Examples\n\n    iex> Float.max_finite()\n    1.7976931348623157e308","prompt":"Can you write a docstring for the following Elixir function? max_finite()"}
{"completion":"Returns the minimum finite value for a float.\n\n## Examples\n\n    iex> Float.min_finite()\n    -1.7976931348623157e308","prompt":"Can you write a docstring for the following Elixir function? min_finite()"}
{"completion":"Parses a binary into a float.\n\nIf successful, returns a tuple in the form of `{float, remainder_of_binary}`;\nwhen the binary cannot be coerced into a valid float, the atom `:error` is\nreturned.\n\nIf the size of float exceeds the maximum size of `1.7976931348623157e+308`,\n`:error` is returned even though the textual representation itself might be\nwell formed.\n\nIf you want to convert a string-formatted float directly to a float,\n`String.to_float/1` can be used instead.\n\n## Examples\n\n    iex> Float.parse(\"34\")\n    {34.0, \"\"}\n    iex> Float.parse(\"34.25\")\n    {34.25, \"\"}\n    iex> Float.parse(\"56.5xyz\")\n    {56.5, \"xyz\"}\n\n    iex> Float.parse(\"pi\")\n    :error\n    iex> Float.parse(\"1.7976931348623159e+308\")\n    :error","prompt":"Can you write a docstring for the following Elixir function? parse(binary)"}
{"completion":"Computes `base` raised to power of `exponent`.\n\n`base` must be a float and `exponent` can be any number.\nHowever, if a negative base and a fractional exponent\nare given, it raises `ArithmeticError`.\n\nIt always returns a float. See `Integer.pow/2` for\nexponentiation that returns integers.\n\n## Examples\n\n    iex> Float.pow(2.0, 0)\n    1.0\n    iex> Float.pow(2.0, 1)\n    2.0\n    iex> Float.pow(2.0, 10)\n    1024.0\n    iex> Float.pow(2.0, -1)\n    0.5\n    iex> Float.pow(2.0, -3)\n    0.125\n\n    iex> Float.pow(3.0, 1.5)\n    5.196152422706632\n\n    iex> Float.pow(-2.0, 3)\n    -8.0\n    iex> Float.pow(-2.0, 4)\n    16.0\n\n    iex> Float.pow(-1.0, 0.5)\n    ** (ArithmeticError) bad argument in arithmetic expression","prompt":"Can you write a docstring for the following Elixir function? pow(base, exponent)"}
{"completion":"Returns a pair of integers whose ratio is exactly equal\nto the original float and with a positive denominator.\n\n## Examples\n\n    iex> Float.ratio(0.0)\n    {0, 1}\n    iex> Float.ratio(3.14)\n    {7070651414971679, 2251799813685248}\n    iex> Float.ratio(-3.14)\n    {-7070651414971679, 2251799813685248}\n    iex> Float.ratio(1.5)\n    {3, 2}\n    iex> Float.ratio(-1.5)\n    {-3, 2}\n    iex> Float.ratio(16.0)\n    {16, 1}\n    iex> Float.ratio(-16.0)\n    {-16, 1}","prompt":"Can you write a docstring for the following Elixir function? ratio(float)"}
{"completion":"Rounds a floating-point value to an arbitrary number of fractional\ndigits (between 0 and 15).\n\nThe rounding direction always ties to half up. The operation is\nperformed on the binary floating point, without a conversion to decimal.\n\nThis function only accepts floats and always returns a float. Use\n`Kernel.round/1` if you want a function that accepts both floats\nand integers and always returns an integer.\n\n## Known issues\n\nThe behaviour of `round/2` for floats can be surprising. For example:\n\n    iex> Float.round(5.5675, 3)\n    5.567\n\nOne may have expected it to round to the half up 5.568. This is not a bug.\nMost decimal fractions cannot be represented as a binary floating point\nand therefore the number above is internally represented as 5.567499999,\nwhich explains the behaviour above. If you want exact rounding for decimals,\nyou must use a decimal library. The behaviour above is also in accordance\nto reference implementations, such as \"Correctly Rounded Binary-Decimal and\nDecimal-Binary Conversions\" by David M. Gay.\n\n## Examples\n\n    iex> Float.round(12.5)\n    13.0\n    iex> Float.round(5.5674, 3)\n    5.567\n    iex> Float.round(5.5675, 3)\n    5.567\n    iex> Float.round(-5.5674, 3)\n    -5.567\n    iex> Float.round(-5.5675)\n    -6.0\n    iex> Float.round(12.341444444444441, 15)\n    12.341444444444441","prompt":"Can you write a docstring for the following Elixir function? round(float, precision \\\\ 0)"}
{"completion":"Returns a charlist which corresponds to the shortest text representation\nof the given float.\n\nThe underlying algorithm changes depending on the Erlang/OTP version:\n\n  * For OTP >= 24, it uses the algorithm presented in \"Ry: fast\n    float-to-string conversion\" in Proceedings of the SIGPLAN '2018\n    Conference on Programming Language Design and Implementation.\n\n  * For OTP < 24, it uses the algorithm presented in \"Printing Floating-Point\n    Numbers Quickly and Accurately\" in Proceedings of the SIGPLAN '1996\n    Conference on Programming Language Design and Implementation.\n\nFor a configurable representation, use `:erlang.float_to_list/2`.\n\n## Examples\n\n    iex> Float.to_charlist(7.0)\n    '7.0'","prompt":"Can you write a docstring for the following Elixir function? to_charlist(float)"}
{"completion":"Returns a binary which corresponds to the shortest text representation\nof the given float.\n\nThe underlying algorithm changes depending on the Erlang/OTP version:\n\n  * For OTP >= 24, it uses the algorithm presented in \"Ry: fast\n    float-to-string conversion\" in Proceedings of the SIGPLAN '2018\n    Conference on Programming Language Design and Implementation.\n\n  * For OTP < 24, it uses the algorithm presented in \"Printing Floating-Point\n    Numbers Quickly and Accurately\" in Proceedings of the SIGPLAN '1996\n    Conference on Programming Language Design and Implementation.\n\nFor a configurable representation, use `:erlang.float_to_binary/2`.\n\n## Examples\n\n    iex> Float.to_string(7.0)\n    \"7.0\"","prompt":"Can you write a docstring for the following Elixir function? to_string(float)"}
{"completion":"Functions for working with floating-point numbers.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Float"}
{"completion":"Kernel functions\n\nThere are functions related to floating-point numbers on the `Kernel` module\ntoo. Here is a list of them:\n\n  * `Kernel.round/1`: rounds a number to the nearest integer.\n  * `Kernel.trunc/1`: returns the integer part of a number.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Float"}
{"completion":"Known issues\n\nThere are some very well known problems with floating-point numbers\nand arithmetic due to the fact most decimal fractions cannot be\nrepresented by a floating-point binary and most operations are not exact,\nbut operate on approximations. Those issues are not specific\nto Elixir, they are a property of floating point representation itself.\n\nFor example, the numbers 0.1 and 0.01 are two of them, what means the result\nof squaring 0.1 does not give 0.01 neither the closest representable. Here is\nwhat happens in this case:\n\n  * The closest representable number to 0.1 is 0.1000000014\n  * The closest representable number to 0.01 is 0.0099999997\n  * Doing 0.1 * 0.1 should return 0.01, but because 0.1 is actually 0.1000000014,\n    the result is 0.010000000000000002, and because this is not the closest\n    representable number to 0.01, you'll get the wrong result for this operation\n\nThere are also other known problems like flooring or rounding numbers. See\n`round/2` and `floor/2` for more details about them.\n\nTo learn more about floating-point arithmetic visit:\n\n  * [0.30000000000000004.com](http://0.30000000000000004.com/)\n  * [What Every Programmer Should Know About Floating-Point Arithmetic](https://floating-point-gui.de/)","prompt":"Can you write a docstring for the following Elixir function? Elixir.Float"}
{"completion":"Captures the given function.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Function.capture(String, :length, 1)\n    &String.length/1","prompt":"Can you write a docstring for the following Elixir function? capture(module, function_name, arity)"}
{"completion":"Returns its input `value`. This function can be passed as an anonymous function\nto transformation functions.\n\n## Examples\n\n    iex> Function.identity(\"Hello world!\")\n    \"Hello world!\"\n\n    iex> 'abcdaabccc' |> Enum.sort() |> Enum.chunk_by(&Function.identity/1)\n    ['aaa', 'bb', 'cccc', 'd']\n\n    iex> Enum.group_by('abracadabra', &Function.identity/1)\n    %{97 => 'aaaaa', 98 => 'bb', 99 => 'c', 100 => 'd', 114 => 'rr'}\n\n    iex> Enum.map([1, 2, 3, 4], &Function.identity/1)\n    [1, 2, 3, 4]","prompt":"Can you write a docstring for the following Elixir function? identity(value)"}
{"completion":"Returns a keyword list with information about a function.\n\nThe returned keys (with the corresponding possible values) for\nall types of functions (local and external) are the following:\n\n  * `:type` - `:local` (for anonymous functions) or `:external` (for\n    named functions).\n\n  * `:module` - an atom which is the module where the function is defined when\n  anonymous or the module which the function refers to when it's a named function.\n\n  * `:arity` - (integer) the number of arguments the function is to be called with.\n\n  * `:name` - (atom) the name of the function.\n\n  * `:env` - a list of the environment or free variables. For named\n    functions, the returned list is always empty.\n\nWhen `fun` is an anonymous function (that is, the type is `:local`), the following\nadditional keys are returned:\n\n  * `:pid` - PID of the process that originally created the function.\n\n  * `:index` - (integer) an index into the module function table.\n\n  * `:new_index` - (integer) an index into the module function table.\n\n  * `:new_uniq` - (binary) a unique value for this function. It's\n    calculated from the compiled code for the entire module.\n\n  * `:uniq` - (integer) a unique value for this function. This integer is\n    calculated from the compiled code for the entire module.\n\n**Note**: this function must be used only for debugging purposes.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> fun = fn x -> x end\n    iex> info = Function.info(fun)\n    iex> Keyword.get(info, :arity)\n    1\n    iex> Keyword.get(info, :type)\n    :local\n\n    iex> fun = &String.length/1\n    iex> info = Function.info(fun)\n    iex> Keyword.get(info, :type)\n    :external\n    iex> Keyword.get(info, :name)\n    :length","prompt":"Can you write a docstring for the following Elixir function? info(fun)"}
{"completion":"Returns a specific information about the function.\n\nThe returned information is a two-element tuple in the shape of\n`{info, value}`.\n\nFor any function, the information asked for can be any of the atoms\n`:module`, `:name`, `:arity`, `:env`, or `:type`.\n\nFor anonymous functions, there is also information about any of the\natoms `:index`, `:new_index`, `:new_uniq`, `:uniq`, and `:pid`.\nFor a named function, the value of any of these items is always the\natom `:undefined`.\n\nFor more information on each of the possible returned values, see\n`info/1`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> f = fn x -> x end\n    iex> Function.info(f, :arity)\n    {:arity, 1}\n    iex> Function.info(f, :type)\n    {:type, :local}\n\n    iex> fun = &String.length/1\n    iex> Function.info(fun, :name)\n    {:name, :length}\n    iex> Function.info(fun, :pid)\n    {:pid, :undefined}","prompt":"Can you write a docstring for the following Elixir function? info(fun, item)"}
{"completion":"A set of functions for working with functions.\n\nAnonymous functions are typically created by using `fn`:\n\n    iex> add = fn a, b -> a + b end\n    iex> add.(1, 2)\n    3\n\nAnonymous functions can also have multiple clauses. All clauses\nshould expect the same number of arguments:\n\n    iex> negate = fn\n    ...>   true -> false\n    ...>   false -> true\n    ...> end\n    iex> negate.(false)\n    true","prompt":"Can you write a docstring for the following Elixir function? Elixir.Function"}
{"completion":"The capture operator\n\nIt is also possible to capture public module functions and pass them\naround as if they were anonymous functions by using the capture\noperator `&/1`:\n\n    iex> add = &Kernel.+/2\n    iex> add.(1, 2)\n    3\n\n    iex> length = &String.length/1\n    iex> length.(\"hello\")\n    5\n\nTo capture a definition within the current module, you can skip the\nmodule prefix, such as `&my_fun/2`. In those cases, the captured\nfunction can be public (`def`) or private (`defp`).\n\nThe capture operator can also be used to create anonymous functions\nthat expect at least one argument:\n\n    iex> add = &(&1 + &2)\n    iex> add.(1, 2)\n    3\n\nIn such cases, using the capture operator is no different than using `fn`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Function"}
{"completion":"Internal and external functions\n\nWe say that functions that point to definitions residing in modules, such\nas `&String.length/1`, are **external** functions. All other functions are\n**local** and they are always bound to the file or module that defined them.\n\nBesides the functions in this module to work with functions, `Kernel` also\nhas an `apply/2` function that invokes a function with a dynamic number of\narguments, as well as `is_function/1` and `is_function/2`, to check\nrespectively if a given value is a function or a function of a given arity.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Function"}
{"completion":"An event manager with event handlers behaviour.\n\nIf you are interested in implementing an event manager, please read the\n\"Alternatives\" section below. If you have to implement an event handler to\nintegrate with an existing system, such as Elixir's Logger, please use\n[`:gen_event`](`:gen_event`) instead.","prompt":"Can you write a docstring for the following Elixir function? Elixir.GenEvent"}
{"completion":"Alternatives\n\nThere are a few suitable alternatives to replace GenEvent. Each of them can be\nthe most beneficial based on the use case.","prompt":"Can you write a docstring for the following Elixir function? Elixir.GenEvent"}
{"completion":"# Supervisor and GenServers\n\nOne alternative to GenEvent is a very minimal solution consisting of using a\nsupervisor and multiple GenServers started under it. The supervisor acts as\nthe \"event manager\" and the children GenServers act as the \"event handlers\".\nThis approach has some shortcomings (it provides no backpressure for example)\nbut can still replace GenEvent for low-profile usages of it. [This blog post\nby Jos\nValim](http://blog.plataformatec.com.br/2016/11/replacing-genevent-by-a-supervisor-genserver/)\nhas more detailed information on this approach.","prompt":"Can you write a docstring for the following Elixir function? Elixir.GenEvent"}
{"completion":"# GenStage\n\nIf the use case where you were using GenEvent requires more complex logic,\n[GenStage](https://github.com/elixir-lang/gen_stage) provides a great\nalternative. GenStage is an external Elixir library maintained by the Elixir\nteam; it provides a tool to implement systems that exchange events in a\ndemand-driven way with built-in support for backpressure. See the [GenStage\ndocumentation](https://hexdocs.pm/gen_stage) for more information.","prompt":"Can you write a docstring for the following Elixir function? Elixir.GenEvent"}
{"completion":"# `:gen_event`\n\nIf your use case requires exactly what GenEvent provided, or you have to\nintegrate with an existing `:gen_event`-based system, you can still use the\n[`:gen_event`](`:gen_event`) Erlang module.","prompt":"Can you write a docstring for the following Elixir function? Elixir.GenEvent"}
{"completion":"Casts all servers locally registered as `name` at the specified nodes.\n\nThis function returns immediately and ignores nodes that do not exist, or where the\nserver name does not exist.\n\nSee `multi_call/4` for more information.","prompt":"Can you write a docstring for the following Elixir function? abcast(nodes \\\\ [node() | Node.list()], name, request)"}
{"completion":"Makes a synchronous call to the `server` and waits for its reply.\n\nThe client sends the given `request` to the server and waits until a reply\narrives or a timeout occurs. `c:handle_call/3` will be called on the server\nto handle the request.\n\n`server` can be any of the values described in the \"Name registration\"\nsection of the documentation for this module.\n\n## Timeouts\n\n`timeout` is an integer greater than zero which specifies how many\nmilliseconds to wait for a reply, or the atom `:infinity` to wait\nindefinitely. The default value is `5000`. If no reply is received within\nthe specified time, the function call fails and the caller exits. If the\ncaller catches the failure and continues running, and the server is just late\nwith the reply, it may arrive at any time later into the caller's message\nqueue. The caller must in this case be prepared for this and discard any such\ngarbage messages that are two-element tuples with a reference as the first\nelement.","prompt":"Can you write a docstring for the following Elixir function? call(server, request, timeout \\\\ 5000)"}
{"completion":"Sends an asynchronous request to the `server`.\n\nThis function always returns `:ok` regardless of whether\nthe destination `server` (or node) exists. Therefore it\nis unknown whether the destination `server` successfully\nhandled the message.\n\n`server` can be any of the values described in the \"Name registration\"\nsection of the documentation for this module.","prompt":"Can you write a docstring for the following Elixir function? cast(server, request)"}
{"completion":"Calls all servers locally registered as `name` at the specified `nodes`.\n\nFirst, the `request` is sent to every node in `nodes`; then, the caller waits\nfor the replies. This function returns a two-element tuple `{replies,\nbad_nodes}` where:\n\n  * `replies` - is a list of `{node, reply}` tuples where `node` is the node\n    that replied and `reply` is its reply\n  * `bad_nodes` - is a list of nodes that either did not exist or where a\n    server with the given `name` did not exist or did not reply\n\n`nodes` is a list of node names to which the request is sent. The default\nvalue is the list of all known nodes (including this node).\n\nTo avoid that late answers (after the timeout) pollute the caller's message\nqueue, a middleman process is used to do the actual calls. Late answers will\nthen be discarded when they arrive to a terminated process.\n\n## Examples\n\nAssuming the `Stack` GenServer mentioned in the docs for the `GenServer`\nmodule is registered as `Stack` in the `:\"foo@my-machine\"` and\n`:\"bar@my-machine\"` nodes:\n\n    GenServer.multi_call(Stack, :pop)\n    #=> {[{:\"foo@my-machine\", :hello}, {:\"bar@my-machine\", :world}], []}","prompt":"Can you write a docstring for the following Elixir function? multi_call(nodes \\\\ [node() | Node.list()], name, request, timeout \\\\ :infinity)"}
{"completion":"Replies to a client.\n\nThis function can be used to explicitly send a reply to a client that called\n`call/3` or `multi_call/4` when the reply cannot be specified in the return\nvalue of `c:handle_call/3`.\n\n`client` must be the `from` argument (the second argument) accepted by\n`c:handle_call/3` callbacks. `reply` is an arbitrary term which will be given\nback to the client as the return value of the call.\n\nNote that `reply/2` can be called from any process, not just the GenServer\nthat originally received the call (as long as that GenServer communicated the\n`from` argument somehow).\n\nThis function always returns `:ok`.\n\n## Examples\n\n    def handle_call(:reply_in_one_second, from, state) do\n      Process.send_after(self(), {:reply, from}, 1_000)\n      {:noreply, state}\n    end\n\n    def handle_info({:reply, from}, state) do\n      GenServer.reply(from, :one_second_has_passed)\n      {:noreply, state}\n    end","prompt":"Can you write a docstring for the following Elixir function? reply(client, reply)"}
{"completion":"Starts a `GenServer` process without links (outside of a supervision tree).\n\nSee `start_link/3` for more information.","prompt":"Can you write a docstring for the following Elixir function? start(module, init_arg, options \\\\ [])"}
{"completion":"Starts a `GenServer` process linked to the current process.\n\nThis is often used to start the `GenServer` as part of a supervision tree.\n\nOnce the server is started, the `c:init/1` function of the given `module` is\ncalled with `init_arg` as its argument to initialize the server. To ensure a\nsynchronized start-up procedure, this function does not return until `c:init/1`\nhas returned.\n\nNote that a `GenServer` started with `start_link/3` is linked to the\nparent process and will exit in case of crashes from the parent. The GenServer\nwill also exit due to the `:normal` reasons in case it is configured to trap\nexits in the `c:init/1` callback.\n\n## Options\n\n  * `:name` - used for name registration as described in the \"Name\n    registration\" section in the documentation for `GenServer`\n\n  * `:timeout` - if present, the server is allowed to spend the given number of\n    milliseconds initializing or it will be terminated and the start function\n    will return `{:error, :timeout}`\n\n  * `:debug` - if present, the corresponding function in the [`:sys` module](`:sys`) is invoked\n\n  * `:spawn_opt` - if present, its value is passed as options to the\n    underlying process as in `Process.spawn/4`\n\n  * `:hibernate_after` - if present, the GenServer process awaits any message for\n    the given number of milliseconds and if no message is received, the process goes\n    into hibernation automatically (by calling `:proc_lib.hibernate/3`).\n\n## Return values\n\nIf the server is successfully created and initialized, this function returns\n`{:ok, pid}`, where `pid` is the PID of the server. If a process with the\nspecified server name already exists, this function returns\n`{:error, {:already_started, pid}}` with the PID of that process.\n\nIf the `c:init/1` callback fails with `reason`, this function returns\n`{:error, reason}`. Otherwise, if it returns `{:stop, reason}`\nor `:ignore`, the process is terminated and this function returns\n`{:error, reason}` or `:ignore`, respectively.","prompt":"Can you write a docstring for the following Elixir function? start_link(module, init_arg, options \\\\ [])"}
{"completion":"Synchronously stops the server with the given `reason`.\n\nThe `c:terminate/2` callback of the given `server` will be invoked before\nexiting. This function returns `:ok` if the server terminates with the\ngiven reason; if it terminates with another reason, the call exits.\n\nThis function keeps OTP semantics regarding error reporting.\nIf the reason is any other than `:normal`, `:shutdown` or\n`{:shutdown, _}`, an error report is logged.","prompt":"Can you write a docstring for the following Elixir function? stop(server, reason \\\\ :normal, timeout \\\\ :infinity)"}
{"completion":"Returns the `pid` or `{name, node}` of a GenServer process, `nil` otherwise.\n\nTo be precise, `nil` is returned whenever a `pid` or `{name, node}` cannot\nbe returned. Note there is no guarantee the returned `pid` or `{name, node}`\nis alive, as a process could terminate immediately after it is looked up.\n\n## Examples\n\nFor example, to lookup a server process, monitor it and send a cast to it:\n\n    process = GenServer.whereis(server)\n    monitor = Process.monitor(process)\n    GenServer.cast(process, :hello)","prompt":"Can you write a docstring for the following Elixir function? whereis(server)"}
{"completion":"A behaviour module for implementing the server of a client-server relation.\n\nA GenServer is a process like any other Elixir process and it can be used\nto keep state, execute code asynchronously and so on. The advantage of using\na generic server process (GenServer) implemented using this module is that it\nwill have a standard set of interface functions and include functionality for\ntracing and error reporting. It will also fit into a supervision tree.","prompt":"Can you write a docstring for the following Elixir function? Elixir.GenServer"}
{"completion":"Example\n\nThe GenServer behaviour abstracts the common client-server interaction.\nDevelopers are only required to implement the callbacks and functionality\nthey are interested in.\n\nLet's start with a code example and then explore the available callbacks.\nImagine we want a GenServer that works like a stack, allowing us to push\nand pop elements:\n\n    defmodule Stack do\n      use GenServer\n\n      # Callbacks\n\n      @impl true\n      def init(stack) do\n        {:ok, stack}\n      end\n\n      @impl true\n      def handle_call(:pop, _from, [head | tail]) do\n        {:reply, head, tail}\n      end\n\n      @impl true\n      def handle_cast({:push, element}, state) do\n        {:noreply, [element | state]}\n      end\n    end\n\n    # Start the server\n    {:ok, pid} = GenServer.start_link(Stack, [:hello])\n\n    # This is the client\n    GenServer.call(pid, :pop)\n    #=> :hello\n\n    GenServer.cast(pid, {:push, :world})\n    #=> :ok\n\n    GenServer.call(pid, :pop)\n    #=> :world\n\nWe start our `Stack` by calling `start_link/2`, passing the module\nwith the server implementation and its initial argument (a list\nrepresenting the stack containing the element `:hello`). We can primarily\ninteract with the server by sending two types of messages. **call**\nmessages expect a reply from the server (and are therefore synchronous)\nwhile **cast** messages do not.\n\nEvery time you do a `GenServer.call/3`, the client will send a message\nthat must be handled by the `c:handle_call/3` callback in the GenServer.\nA `cast/2` message must be handled by `c:handle_cast/2`. There are 8 possible\ncallbacks to be implemented when you use a `GenServer`. The only required\ncallback is `c:init/1`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.GenServer"}
{"completion":"Client / Server APIs\n\nAlthough in the example above we have used `GenServer.start_link/3` and\nfriends to directly start and communicate with the server, most of the\ntime we don't call the `GenServer` functions directly. Instead, we wrap\nthe calls in new functions representing the public API of the server.\n\nHere is a better implementation of our Stack module:\n\n    defmodule Stack do\n      use GenServer\n\n      # Client\n\n      def start_link(default) when is_list(default) do\n        GenServer.start_link(__MODULE__, default)\n      end\n\n      def push(pid, element) do\n        GenServer.cast(pid, {:push, element})\n      end\n\n      def pop(pid) do\n        GenServer.call(pid, :pop)\n      end\n\n      # Server (callbacks)\n\n      @impl true\n      def init(stack) do\n        {:ok, stack}\n      end\n\n      @impl true\n      def handle_call(:pop, _from, [head | tail]) do\n        {:reply, head, tail}\n      end\n\n      @impl true\n      def handle_cast({:push, element}, state) do\n        {:noreply, [element | state]}\n      end\n    end\n\nIn practice, it is common to have both server and client functions in\nthe same module. If the server and/or client implementations are growing\ncomplex, you may want to have them in different modules.","prompt":"Can you write a docstring for the following Elixir function? Elixir.GenServer"}
{"completion":"How to supervise\n\nA `GenServer` is most commonly started under a supervision tree.\nWhen we invoke `use GenServer`, it automatically defines a `child_spec/1`\nfunction that allows us to start the `Stack` directly under a supervisor.\nTo start a default stack of `[:hello]` under a supervisor, one may do:\n\n    children = [\n      {Stack, [:hello]}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_all)\n\nNote you can also start it simply as `Stack`, which is the same as\n`{Stack, []}`:\n\n    children = [\n      Stack # The same as {Stack, []}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_all)\n\nIn both cases, `Stack.start_link/1` is always invoked.\n\n`use GenServer` also accepts a list of options which configures the\nchild specification and therefore how it runs under a supervisor.\nThe generated `child_spec/1` can be customized with the following options:\n\n  * `:id` - the child specification identifier, defaults to the current module\n  * `:restart` - when the child should be restarted, defaults to `:permanent`\n  * `:shutdown` - how to shut down the child, either immediately or by giving it time to shut down\n\nFor example:\n\n    use GenServer, restart: :transient, shutdown: 10_000\n\nSee the \"Child specification\" section in the `Supervisor` module for more\ndetailed information. The `@doc` annotation immediately preceding\n`use GenServer` will be attached to the generated `child_spec/1` function.\n\nWhen stopping the GenServer, for example by returning a `{:stop, reason, new_state}`\ntuple from a callback, the exit reason is used by the supervisor to determine\nwhether the GenServer needs to be restarted. See the \"Exit reasons and restarts\"\nsection in the `Supervisor` module.","prompt":"Can you write a docstring for the following Elixir function? Elixir.GenServer"}
{"completion":"Name registration\n\nBoth `start_link/3` and `start/3` support the `GenServer` to register\na name on start via the `:name` option. Registered names are also\nautomatically cleaned up on termination. The supported values are:\n\n  * an atom - the GenServer is registered locally (to the current node)\n    with the given name using `Process.register/2`.\n\n  * `{:global, term}` - the GenServer is registered globally with the given\n    term using the functions in the [`:global` module](`:global`).\n\n  * `{:via, module, term}` - the GenServer is registered with the given\n    mechanism and name. The `:via` option expects a module that exports\n    `register_name/2`, `unregister_name/1`, `whereis_name/1` and `send/2`.\n    One such example is the [`:global` module](`:global`) which uses these functions\n    for keeping the list of names of processes and their associated PIDs\n    that are available globally for a network of Elixir nodes. Elixir also\n    ships with a local, decentralized and scalable registry called `Registry`\n    for locally storing names that are generated dynamically.\n\nFor example, we could start and register our `Stack` server locally as follows:\n\n    # Start the server and register it locally with name MyStack\n    {:ok, _} = GenServer.start_link(Stack, [:hello], name: MyStack)\n\n    # Now messages can be sent directly to MyStack\n    GenServer.call(MyStack, :pop)\n    #=> :hello\n\nOnce the server is started, the remaining functions in this module (`call/3`,\n`cast/2`, and friends) will also accept an atom, or any `{:global, ...}` or\n`{:via, ...}` tuples. In general, the following formats are supported:\n\n  * a PID\n  * an atom if the server is locally registered\n  * `{atom, node}` if the server is locally registered at another node\n  * `{:global, term}` if the server is globally registered\n  * `{:via, module, name}` if the server is registered through an alternative\n    registry\n\nIf there is an interest to register dynamic names locally, do not use\natoms, as atoms are never garbage-collected and therefore dynamically\ngenerated atoms won't be garbage-collected. For such cases, you can\nset up your own local registry by using the `Registry` module.","prompt":"Can you write a docstring for the following Elixir function? Elixir.GenServer"}
{"completion":"Receiving \"regular\" messages\n\nThe goal of a `GenServer` is to abstract the \"receive\" loop for developers,\nautomatically handling system messages, supporting code change, synchronous\ncalls and more. Therefore, you should never call your own \"receive\" inside\nthe GenServer callbacks as doing so will cause the GenServer to misbehave.\n\nBesides the synchronous and asynchronous communication provided by `call/3`\nand `cast/2`, \"regular\" messages sent by functions such as `send/2`,\n`Process.send_after/4` and similar, can be handled inside the `c:handle_info/2`\ncallback.\n\n`c:handle_info/2` can be used in many situations, such as handling monitor\nDOWN messages sent by `Process.monitor/1`. Another use case for `c:handle_info/2`\nis to perform periodic work, with the help of `Process.send_after/4`:\n\n    defmodule MyApp.Periodically do\n      use GenServer\n\n      def start_link(_) do\n        GenServer.start_link(__MODULE__, %{})\n      end\n\n      @impl true\n      def init(state) do\n        # Schedule work to be performed on start\n        schedule_work()\n\n        {:ok, state}\n      end\n\n      @impl true\n      def handle_info(:work, state) do\n        # Do the desired work here\n        # ...\n\n        # Reschedule once more\n        schedule_work()\n\n        {:noreply, state}\n      end\n\n      defp schedule_work do\n        # We schedule the work to happen in 2 hours (written in milliseconds).\n        # Alternatively, one might write :timer.hours(2)\n        Process.send_after(self(), :work, 2 * 60 * 60 * 1000)\n      end\n    end","prompt":"Can you write a docstring for the following Elixir function? Elixir.GenServer"}
{"completion":"Timeouts\n\nThe return value of `c:init/1` or any of the `handle_*` callbacks may include\na timeout value in milliseconds; if not, `:infinity` is assumed.\nThe timeout can be used to detect a lull in incoming messages.\n\nThe `timeout()` value is used as follows:\n\n  * If the process has any message already waiting when the `timeout()` value\n    is returned, the timeout is ignored and the waiting message is handled as\n    usual. This means that even a timeout of `0` milliseconds is not guaranteed\n    to execute (if you want to take another action immediately and unconditionally,\n    use a `:continue` instruction instead).\n\n  * If any message arrives before the specified number of milliseconds\n    elapse, the timeout is cleared and that message is handled as usual.\n\n  * Otherwise, when the specified number of milliseconds have elapsed with no\n    message arriving, `handle_info/2` is called with `:timeout` as the first\n    argument.","prompt":"Can you write a docstring for the following Elixir function? Elixir.GenServer"}
{"completion":"When (not) to use a GenServer\n\nSo far, we have learned that a `GenServer` can be used as a supervised process\nthat handles sync and async calls. It can also handle system messages, such as\nperiodic messages and monitoring events. GenServer processes may also be named.\n\nA GenServer, or a process in general, must be used to model runtime characteristics\nof your system. A GenServer must never be used for code organization purposes.\n\nIn Elixir, code organization is done by modules and functions, processes are not\nnecessary. For example, imagine you are implementing a calculator and you decide\nto put all the calculator operations behind a GenServer:\n\n    def add(a, b) do\n      GenServer.call(__MODULE__, {:add, a, b})\n    end\n\n    def subtract(a, b) do\n      GenServer.call(__MODULE__, {:subtract, a, b})\n    end\n\n    def handle_call({:add, a, b}, _from, state) do\n      {:reply, a + b, state}\n    end\n\n    def handle_call({:subtract, a, b}, _from, state) do\n      {:reply, a - b, state}\n    end\n\nThis is an anti-pattern not only because it convolutes the calculator logic but\nalso because you put the calculator logic behind a single process that will\npotentially become a bottleneck in your system, especially as the number of\ncalls grow. Instead just define the functions directly:\n\n    def add(a, b) do\n      a + b\n    end\n\n    def subtract(a, b) do\n      a - b\n    end\n\nIf you don't need a process, then you don't need a process. Use processes only to\nmodel runtime properties, such as mutable state, concurrency and failures, never\nfor code organization.","prompt":"Can you write a docstring for the following Elixir function? Elixir.GenServer"}
{"completion":"Debugging with the :sys module\n\nGenServers, as [special processes](https://www.erlang.org/doc/design_principles/spec_proc.html),\ncan be debugged using the [`:sys` module](`:sys`).\nThrough various hooks, this module allows developers to introspect the state of\nthe process and trace system events that happen during its execution, such as\nreceived messages, sent replies and state changes.\n\nLet's explore the basic functions from the\n[`:sys` module](`:sys`) used for debugging:\n\n  * `:sys.get_state/2` - allows retrieval of the state of the process.\n    In the case of a GenServer process, it will be the callback module state,\n    as passed into the callback functions as last argument.\n  * `:sys.get_status/2` - allows retrieval of the status of the process.\n    This status includes the process dictionary, if the process is running\n    or is suspended, the parent PID, the debugger state, and the state of\n    the behaviour module, which includes the callback module state\n    (as returned by `:sys.get_state/2`). It's possible to change how this\n    status is represented by defining the optional `c:GenServer.format_status/2`\n    callback.\n  * `:sys.trace/3` - prints all the system events to `:stdio`.\n  * `:sys.statistics/3` - manages collection of process statistics.\n  * `:sys.no_debug/2` - turns off all debug handlers for the given process.\n    It is very important to switch off debugging once we're done. Excessive\n    debug handlers or those that should be turned off, but weren't, can\n    seriously damage the performance of the system.\n  * `:sys.suspend/2` - allows to suspend a process so that it only\n    replies to system messages but no other messages. A suspended process\n    can be reactivated via `:sys.resume/2`.\n\nLet's see how we could use those functions for debugging the stack server\nwe defined earlier.\n\n    iex> {:ok, pid} = Stack.start_link([])\n    iex> :sys.statistics(pid, true) # turn on collecting process statistics\n    iex> :sys.trace(pid, true) # turn on event printing\n    iex> Stack.push(pid, 1)\n    *DBG* <0.122.0> got cast {push,1}\n    *DBG* <0.122.0> new state [1]\n    :ok\n\n    iex> :sys.get_state(pid)\n    [1]\n\n    iex> Stack.pop(pid)\n    *DBG* <0.122.0> got call pop from <0.80.0>\n    *DBG* <0.122.0> sent 1 to <0.80.0>, new state []\n    1\n\n    iex> :sys.statistics(pid, :get)\n    {:ok,\n     [\n       start_time: {{2016, 7, 16}, {12, 29, 41}},\n       current_time: {{2016, 7, 16}, {12, 29, 50}},\n       reductions: 117,\n       messages_in: 2,\n       messages_out: 0\n     ]}\n\n    iex> :sys.no_debug(pid) # turn off all debug handlers\n    :ok\n\n    iex> :sys.get_status(pid)\n    {:status, #PID<0.122.0>, {:module, :gen_server},\n     [\n       [\n         \"$initial_call\": {Stack, :init, 1},            # process dictionary\n         \"$ancestors\": [#PID<0.80.0>, #PID<0.51.0>]\n       ],\n       :running,                                        # :running | :suspended\n       #PID<0.80.0>,                                    # parent\n       [],                                              # debugger state\n       [\n         header: 'Status for generic server <0.122.0>', # module status\n         data: [\n           {'Status', :running},\n           {'Parent', #PID<0.80.0>},\n           {'Logged events', []}\n         ],\n         data: [{'State', [1]}]\n       ]\n     ]}","prompt":"Can you write a docstring for the following Elixir function? Elixir.GenServer"}
{"completion":"Learn more\n\nIf you wish to find out more about GenServers, the Elixir Getting Started\nguide provides a tutorial-like introduction. The documentation and links\nin Erlang can also provide extra insight.\n\n  * [GenServer - Elixir's Getting Started Guide](https://elixir-lang.org/getting-started/mix-otp/genserver.html)\n  * [`:gen_server` module documentation](`:gen_server`)\n  * [gen_server Behaviour - OTP Design Principles](https://www.erlang.org/doc/design_principles/gen_server_concepts.html)\n  * [Clients and Servers - Learn You Some Erlang for Great Good!](http://learnyousomeerlang.com/clients-and-servers)","prompt":"Can you write a docstring for the following Elixir function? Elixir.GenServer"}
{"completion":"Creates a new empty dict.","prompt":"Can you write a docstring for the following Elixir function? new()"}
{"completion":"Tuple-based HashDict implementation.\n\nThis module is deprecated. Use the `Map` module instead.","prompt":"Can you write a docstring for the following Elixir function? Elixir.HashDict"}
{"completion":"Tuple-based HashSet implementation.\n\nThis module is deprecated. Use the `MapSet` module instead.","prompt":"Can you write a docstring for the following Elixir function? Elixir.HashSet"}
{"completion":"The default options used by this module.\n\nThe supported keys are:\n\n  * `:enabled`           - toggles coloring on and off (true)\n  * `:doc_bold`          - bold text (bright)\n  * `:doc_code`          - code blocks (cyan)\n  * `:doc_headings`      - h1, h2, h3, h4, h5, h6 headings (yellow)\n  * `:doc_metadata`      - documentation metadata keys (yellow)\n  * `:doc_quote`         - leading quote character `> ` (light black)\n  * `:doc_inline_code`   - inline code (cyan)\n  * `:doc_table_heading` - the style for table headings\n  * `:doc_title`         - top level heading (reverse, yellow)\n  * `:doc_underline`     - underlined text (underline)\n  * `:width`             - the width to format the text (80)\n\nValues for the color settings are strings with\ncomma-separated ANSI values.","prompt":"Can you write a docstring for the following Elixir function? default_options()"}
{"completion":"Prints the documentation body `doc` according to `format`.\n\nIt takes a set of `options` defined in `default_options/0`.","prompt":"Can you write a docstring for the following Elixir function? print(doc, format, options \\\\ [])"}
{"completion":"Prints the head of the documentation (i.e. the function signature).\n\nSee `default_options/0` for docs on the supported options.","prompt":"Can you write a docstring for the following Elixir function? print_headings(headings, options \\\\ [])"}
{"completion":"Prints documentation metadata (only `delegate_to`, `deprecated`, `guard`, and `since` for now).\n\nSee `default_options/0` for docs on the supported options.","prompt":"Can you write a docstring for the following Elixir function? print_metadata(metadata, options \\\\ [])"}
{"completion":"Sets foreground color to black.","prompt":"Can you write a docstring for the following Elixir function? black()"}
{"completion":"Sets background color to black.","prompt":"Can you write a docstring for the following Elixir function? black_background()"}
{"completion":"Blink: off.","prompt":"Can you write a docstring for the following Elixir function? blink_off()"}
{"completion":"Blink: rapid. MS-DOS ANSI.SYS; 150 per minute or more; not widely supported.","prompt":"Can you write a docstring for the following Elixir function? blink_rapid()"}
{"completion":"Blink: slow. Less than 150 per minute.","prompt":"Can you write a docstring for the following Elixir function? blink_slow()"}
{"completion":"Sets foreground color to blue.","prompt":"Can you write a docstring for the following Elixir function? blue()"}
{"completion":"Sets background color to blue.","prompt":"Can you write a docstring for the following Elixir function? blue_background()"}
{"completion":"Bright (increased intensity) or bold.","prompt":"Can you write a docstring for the following Elixir function? bright()"}
{"completion":"Clears screen.","prompt":"Can you write a docstring for the following Elixir function? clear()"}
{"completion":"Clears line.","prompt":"Can you write a docstring for the following Elixir function? clear_line()"}
{"completion":"Sets foreground color.","prompt":"Can you write a docstring for the following Elixir function? color(code)"}
{"completion":"Sets the foreground color from individual RGB values.\n\nValid values for each color are in the range 0 to 5.","prompt":"Can you write a docstring for the following Elixir function? color(r, g, b)"}
{"completion":"Sets background color.","prompt":"Can you write a docstring for the following Elixir function? color_background(code)"}
{"completion":"Sets the background color from individual RGB values.\n\nValid values for each color are in the range 0 to 5.","prompt":"Can you write a docstring for the following Elixir function? color_background(r, g, b)"}
{"completion":"Conceal. Not widely supported.","prompt":"Can you write a docstring for the following Elixir function? conceal()"}
{"completion":"Crossed-out. Characters legible, but marked for deletion. Not widely supported.","prompt":"Can you write a docstring for the following Elixir function? crossed_out()"}
{"completion":"Sends cursor to the absolute position specified by `line` and `column`.\n\nLine `0` and column `0` would mean the top left corner.","prompt":"Can you write a docstring for the following Elixir function? cursor(line, column)"}
{"completion":"Sends cursor `lines` down.","prompt":"Can you write a docstring for the following Elixir function? cursor_down(lines \\\\ 1)"}
{"completion":"Sends cursor `columns` to the left.","prompt":"Can you write a docstring for the following Elixir function? cursor_left(columns \\\\ 1)"}
{"completion":"Sends cursor `columns` to the right.","prompt":"Can you write a docstring for the following Elixir function? cursor_right(columns \\\\ 1)"}
{"completion":"Sends cursor `lines` up.","prompt":"Can you write a docstring for the following Elixir function? cursor_up(lines \\\\ 1)"}
{"completion":"Sets foreground color to cyan.","prompt":"Can you write a docstring for the following Elixir function? cyan()"}
{"completion":"Sets background color to cyan.","prompt":"Can you write a docstring for the following Elixir function? cyan_background()"}
{"completion":"Default background color.","prompt":"Can you write a docstring for the following Elixir function? default_background()"}
{"completion":"Default text color.","prompt":"Can you write a docstring for the following Elixir function? default_color()"}
{"completion":"Checks if ANSI coloring is supported and enabled on this machine.\n\nThis function simply reads the configuration value for\n`:ansi_enabled` in the `:elixir` application. The value is by\ndefault `false` unless Elixir can detect during startup that\nboth `stdout` and `stderr` are terminals.","prompt":"Can you write a docstring for the following Elixir function? enabled?()"}
{"completion":"Encircled.","prompt":"Can you write a docstring for the following Elixir function? encircled()"}
{"completion":"Faint (decreased intensity). Not widely supported.","prompt":"Can you write a docstring for the following Elixir function? faint()"}
{"completion":"Sets alternative font 1.","prompt":"Can you write a docstring for the following Elixir function? font_1()"}
{"completion":"Sets alternative font 2.","prompt":"Can you write a docstring for the following Elixir function? font_2()"}
{"completion":"Sets alternative font 3.","prompt":"Can you write a docstring for the following Elixir function? font_3()"}
{"completion":"Sets alternative font 4.","prompt":"Can you write a docstring for the following Elixir function? font_4()"}
{"completion":"Sets alternative font 5.","prompt":"Can you write a docstring for the following Elixir function? font_5()"}
{"completion":"Sets alternative font 6.","prompt":"Can you write a docstring for the following Elixir function? font_6()"}
{"completion":"Sets alternative font 7.","prompt":"Can you write a docstring for the following Elixir function? font_7()"}
{"completion":"Sets alternative font 8.","prompt":"Can you write a docstring for the following Elixir function? font_8()"}
{"completion":"Sets alternative font 9.","prompt":"Can you write a docstring for the following Elixir function? font_9()"}
{"completion":"Formats a chardata-like argument by converting named ANSI sequences into actual\nANSI codes.\n\nThe named sequences are represented by atoms.\n\nIt will also append an `IO.ANSI.reset/0` to the chardata when a conversion is\nperformed. If you don't want this behaviour, use `format_fragment/2`.\n\nAn optional boolean parameter can be passed to enable or disable\nemitting actual ANSI codes. When `false`, no ANSI codes will be emitted.\nBy default checks if ANSI is enabled using the `enabled?/0` function.\n\n## Examples\n\n    iex> IO.ANSI.format([\"Hello, \", :red, :bright, \"world!\"], true)\n    [[[[[[], \"Hello, \"] | \"\\e[31m\"] | \"\\e[1m\"], \"world!\"] | \"\\e[0m\"]","prompt":"Can you write a docstring for the following Elixir function? format(ansidata, emit? \\\\ enabled?())"}
{"completion":"Formats a chardata-like argument by converting named ANSI sequences into actual\nANSI codes.\n\nThe named sequences are represented by atoms.\n\nAn optional boolean parameter can be passed to enable or disable\nemitting actual ANSI codes. When `false`, no ANSI codes will be emitted.\nBy default checks if ANSI is enabled using the `enabled?/0` function.\n\n## Examples\n\n    iex> IO.ANSI.format_fragment([:bright, 'Word'], true)\n    [[[[[[] | \"\\e[1m\"], 87], 111], 114], 100]","prompt":"Can you write a docstring for the following Elixir function? format_fragment(ansidata, emit? \\\\ enabled?())"}
{"completion":"Framed.","prompt":"Can you write a docstring for the following Elixir function? framed()"}
{"completion":"Sets foreground color to green.","prompt":"Can you write a docstring for the following Elixir function? green()"}
{"completion":"Sets background color to green.","prompt":"Can you write a docstring for the following Elixir function? green_background()"}
{"completion":"Sends cursor home.","prompt":"Can you write a docstring for the following Elixir function? home()"}
{"completion":"Image: negative. Swap foreground and background.","prompt":"Can you write a docstring for the following Elixir function? inverse()"}
{"completion":"Image: positive. Normal foreground and background.","prompt":"Can you write a docstring for the following Elixir function? inverse_off()"}
{"completion":"Italic: on. Not widely supported. Sometimes treated as inverse.","prompt":"Can you write a docstring for the following Elixir function? italic()"}
{"completion":"Sets foreground color to light black.","prompt":"Can you write a docstring for the following Elixir function? light_black()"}
{"completion":"Sets background color to light black.","prompt":"Can you write a docstring for the following Elixir function? light_black_background()"}
{"completion":"Sets foreground color to light blue.","prompt":"Can you write a docstring for the following Elixir function? light_blue()"}
{"completion":"Sets background color to light blue.","prompt":"Can you write a docstring for the following Elixir function? light_blue_background()"}
{"completion":"Sets foreground color to light cyan.","prompt":"Can you write a docstring for the following Elixir function? light_cyan()"}
{"completion":"Sets background color to light cyan.","prompt":"Can you write a docstring for the following Elixir function? light_cyan_background()"}
{"completion":"Sets foreground color to light green.","prompt":"Can you write a docstring for the following Elixir function? light_green()"}
{"completion":"Sets background color to light green.","prompt":"Can you write a docstring for the following Elixir function? light_green_background()"}
{"completion":"Sets foreground color to light magenta.","prompt":"Can you write a docstring for the following Elixir function? light_magenta()"}
{"completion":"Sets background color to light magenta.","prompt":"Can you write a docstring for the following Elixir function? light_magenta_background()"}
{"completion":"Sets foreground color to light red.","prompt":"Can you write a docstring for the following Elixir function? light_red()"}
{"completion":"Sets background color to light red.","prompt":"Can you write a docstring for the following Elixir function? light_red_background()"}
{"completion":"Sets foreground color to light white.","prompt":"Can you write a docstring for the following Elixir function? light_white()"}
{"completion":"Sets background color to light white.","prompt":"Can you write a docstring for the following Elixir function? light_white_background()"}
{"completion":"Sets foreground color to light yellow.","prompt":"Can you write a docstring for the following Elixir function? light_yellow()"}
{"completion":"Sets background color to light yellow.","prompt":"Can you write a docstring for the following Elixir function? light_yellow_background()"}
{"completion":"Sets foreground color to magenta.","prompt":"Can you write a docstring for the following Elixir function? magenta()"}
{"completion":"Sets background color to magenta.","prompt":"Can you write a docstring for the following Elixir function? magenta_background()"}
{"completion":"Underline: none.","prompt":"Can you write a docstring for the following Elixir function? no_underline()"}
{"completion":"Normal color or intensity.","prompt":"Can you write a docstring for the following Elixir function? normal()"}
{"completion":"Not framed or encircled.","prompt":"Can you write a docstring for the following Elixir function? not_framed_encircled()"}
{"completion":"Not italic.","prompt":"Can you write a docstring for the following Elixir function? not_italic()"}
{"completion":"Not overlined.","prompt":"Can you write a docstring for the following Elixir function? not_overlined()"}
{"completion":"Overlined.","prompt":"Can you write a docstring for the following Elixir function? overlined()"}
{"completion":"Sets primary (default) font.","prompt":"Can you write a docstring for the following Elixir function? primary_font()"}
{"completion":"Sets foreground color to red.","prompt":"Can you write a docstring for the following Elixir function? red()"}
{"completion":"Sets background color to red.","prompt":"Can you write a docstring for the following Elixir function? red_background()"}
{"completion":"Resets all attributes.","prompt":"Can you write a docstring for the following Elixir function? reset()"}
{"completion":"Image: negative. Swap foreground and background.","prompt":"Can you write a docstring for the following Elixir function? reverse()"}
{"completion":"Image: positive. Normal foreground and background.","prompt":"Can you write a docstring for the following Elixir function? reverse_off()"}
{"completion":"Syntax colors to be used by `Inspect`.\n\nThose colors are used throughout Elixir's standard library,\nsuch as `dbg/2` and `IEx`.\n\nThe colors can be changed by setting the `:ansi_syntax_colors`\nin the `:elixir` application configuration. Configuration for\nmost built-in data types are supported: `:atom`, `:binary`,\n`:boolean`, `:charlist`, `:list`, `:map`, `:nil`, `:number`,\n`:string`, and `:tuple`. The default is:\n\n    [\n      atom: :cyan\n      boolean: :magenta,\n      charlist: :yellow,\n      nil: :magenta,\n      number: :yellow,\n      string: :green\n    ]","prompt":"Can you write a docstring for the following Elixir function? syntax_colors()"}
{"completion":"Underline: single.","prompt":"Can you write a docstring for the following Elixir function? underline()"}
{"completion":"Sets foreground color to white.","prompt":"Can you write a docstring for the following Elixir function? white()"}
{"completion":"Sets background color to white.","prompt":"Can you write a docstring for the following Elixir function? white_background()"}
{"completion":"Sets foreground color to yellow.","prompt":"Can you write a docstring for the following Elixir function? yellow()"}
{"completion":"Sets background color to yellow.","prompt":"Can you write a docstring for the following Elixir function? yellow_background()"}
{"completion":"Functionality to render ANSI escape sequences.\n\n[ANSI escape sequences](https://en.wikipedia.org/wiki/ANSI_escape_code)\nare characters embedded in text used to control formatting, color, and\nother output options on video text terminals.\n\nANSI escapes are typically enabled on all Unix terminals. They are also\navailable on Windows consoles from Windows 10, although it must be\nexplicitly enabled for the current user in the registry by running the\nfollowing command:\n\n    reg add HKCU\\Console /v VirtualTerminalLevel /t REG_DWORD /d 1\n\nAfter running the command above, you must restart your current console.","prompt":"Can you write a docstring for the following Elixir function? Elixir.IO.ANSI"}
{"completion":"Examples\n\nBecause the ANSI escape sequences are embedded in text, the normal usage of\nthese functions is to concatenate their output with text.\n\n    formatted_text = IO.ANSI.blue_background() <> \"Example\" <> IO.ANSI.reset()\n    IO.puts(formatted_text)\n\nA higher level and more convenient API is also available via `IO.ANSI.format/1`,\nwhere you use atoms to represent each ANSI escape sequence and by default\nchecks if ANSI is enabled:\n\n    IO.puts(IO.ANSI.format([:blue_background, \"Example\"]))\n\nIn case ANSI is disabled, the ANSI escape sequences are simply discarded.","prompt":"Can you write a docstring for the following Elixir function? Elixir.IO.ANSI"}
{"completion":"Defines an `IO.Stream` struct returned by `IO.stream/2` and `IO.binstream/2`.\n\nThe following fields are public:\n\n  * `device`        - the IO device\n  * `raw`           - a boolean indicating if bin functions should be used\n  * `line_or_bytes` - if reading should read lines or a given number of bytes\n\nIt is worth noting that an IO stream has side effects and every time you go\nover the stream you may get different results.","prompt":"Can you write a docstring for the following Elixir function? Elixir.IO.Stream"}
{"completion":"Reads from the IO `device`. The operation is Unicode unsafe.\n\nThe `device` is iterated as specified by the `line_or_chars` argument:\n\n  * if `line_or_chars` is an integer, it represents a number of bytes. The device is\n    iterated by that number of bytes.\n\n  * if `line_or_chars` is `:line`, the device is iterated line by line.\n\n  * if `line_or_chars` is `:eof`, the device is iterated until `:eof`. `line_or_chars`\n    can only be `:eof` since Elixir 1.13.0. `:eof` replaces the deprecated `:all`,\n    with the difference that `:all` returns `\"\"` on end of file, while `:eof` returns\n    `:eof` itself.\n\nIt returns:\n\n  * `data` - the output bytes\n\n  * `:eof` - end of file was encountered\n\n  * `{:error, reason}` - other (rare) error condition;\n    for instance, `{:error, :estale}` if reading from an\n    NFS volume\n\nNote: do not use this function on IO devices in Unicode mode\nas it will return the wrong result.","prompt":"Can you write a docstring for the following Elixir function? binread(device \\\\ :stdio, line_or_chars)"}
{"completion":"Returns a raw, line-based `IO.Stream` on `:stdio`. The operation is Unicode unsafe.\n\nThis is equivalent to:\n\n    IO.binstream(:stdio, :line)","prompt":"Can you write a docstring for the following Elixir function? binstream()"}
{"completion":"Converts the IO `device` into an `IO.Stream`. The operation is Unicode unsafe.\n\nAn `IO.Stream` implements both `Enumerable` and\n`Collectable`, allowing it to be used for both read\nand write.\n\nThe `device` is iterated by the given number of bytes or line by line if\n`:line` is given. This reads from the IO device as a raw binary.\n\nNote that an IO stream has side effects and every time\nyou go over the stream you may get different results.\n\nFinally, do not use this function on IO devices in Unicode\nmode as it will return the wrong result.\n\n`binstream/0` has been introduced in Elixir v1.12.0,\nwhile `binstream/2` has been available since v1.0.0.","prompt":"Can you write a docstring for the following Elixir function? binstream(device \\\\ :stdio, line_or_bytes)"}
{"completion":"Writes `iodata` to the given `device`.\n\nThis operation is meant to be used with \"raw\" devices\nthat are started without an encoding. The given `iodata`\nis written as is to the device, without conversion. For\nmore information on IO data, see the \"IO data\" section in\nthe module documentation.\n\nUse `write/2` for devices with encoding.\n\nImportant: do **not** use this function on IO devices in\nUnicode mode as it will write the wrong data. In particular,\nthe standard IO device is set to Unicode by default, so writing\nto stdio with this function will likely result in the wrong data\nbeing sent down the wire.","prompt":"Can you write a docstring for the following Elixir function? binwrite(device \\\\ :stdio, iodata)"}
{"completion":"Converts chardata into a string.\n\nFor more information about chardata, see the [\"Chardata\"](#module-chardata)\nsection in the module documentation.\n\nIn case the conversion fails, it raises an `UnicodeConversionError`.\nIf a string is given, it returns the string itself.\n\n## Examples\n\n    iex> IO.chardata_to_string([0x00E6, 0x00DF])\n    \"\"\n\n    iex> IO.chardata_to_string([0x0061, \"bc\"])\n    \"abc\"\n\n    iex> IO.chardata_to_string(\"string\")\n    \"string\"","prompt":"Can you write a docstring for the following Elixir function? chardata_to_string(chardata)"}
{"completion":"Gets a number of bytes from IO device `:stdio`.\n\nIf `:stdio` is a Unicode device, `count` implies\nthe number of Unicode code points to be retrieved.\nOtherwise, `count` is the number of raw bytes to be retrieved.\n\nSee `IO.getn/3` for a description of return values.","prompt":"Can you write a docstring for the following Elixir function? getn(prompt, count \\\\ 1)"}
{"completion":"Gets a number of bytes from the IO `device`.\n\nIf the IO `device` is a Unicode device, `count` implies\nthe number of Unicode code points to be retrieved.\nOtherwise, `count` is the number of raw bytes to be retrieved.\n\nIt returns:\n\n  * `data` - the input characters\n\n  * `:eof` - end of file was encountered\n\n  * `{:error, reason}` - other (rare) error condition;\n    for instance, `{:error, :estale}` if reading from an\n    NFS volume","prompt":"Can you write a docstring for the following Elixir function? getn(device, prompt, count)"}
{"completion":"Reads a line from the IO `device`.\n\nIt returns:\n\n  * `data` - the characters in the line terminated\n    by a line-feed (LF) or end of file (EOF)\n\n  * `:eof` - end of file was encountered\n\n  * `{:error, reason}` - other (rare) error condition;\n    for instance, `{:error, :estale}` if reading from an\n    NFS volume\n\n## Examples\n\nTo display \"What is your name?\" as a prompt and await user input:\n\n    IO.gets(\"What is your name?\\n\")","prompt":"Can you write a docstring for the following Elixir function? gets(device \\\\ :stdio, prompt)"}
{"completion":"Inspects and writes the given `item` to the device.\n\nIt's important to note that it returns the given `item` unchanged.\nThis makes it possible to \"spy\" on values by inserting an\n`IO.inspect/2` call almost anywhere in your code, for example,\nin the middle of a pipeline.\n\nIt enables pretty printing by default with width of\n80 characters. The width can be changed by explicitly\npassing the `:width` option.\n\nThe output can be decorated with a label, by providing the `:label`\noption to easily distinguish it from other `IO.inspect/2` calls.\nThe label will be printed before the inspected `item`.\n\nSee `Inspect.Opts` for a full list of remaining formatting options.\n\n## Examples\n\n    IO.inspect(<<0, 1, 2>>, width: 40)\n\nPrints:\n\n    <<0, 1, 2>>\n\nWe can use the `:label` option to decorate the output:\n\n    IO.inspect(1..100, label: \"a wonderful range\")\n\nPrints:\n\n    a wonderful range: 1..100\n\nThe `:label` option is especially useful with pipelines:\n\n    [1, 2, 3]\n    |> IO.inspect(label: \"before\")\n    |> Enum.map(&(&1 * 2))\n    |> IO.inspect(label: \"after\")\n    |> Enum.sum()\n\nPrints:\n\n    before: [1, 2, 3]\n    after: [2, 4, 6]","prompt":"Can you write a docstring for the following Elixir function? inspect(item, opts \\\\ [])"}
{"completion":"Inspects `item` according to the given options using the IO `device`.\n\nSee `inspect/2` for a full list of options.","prompt":"Can you write a docstring for the following Elixir function? inspect(device, item, opts)"}
{"completion":"Returns the size of an IO data.\n\nFor more information about IO data, see the [\"IO data\"](#module-io-data)\nsection in the module documentation.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> IO.iodata_length([1, 2 | <<3, 4>>])\n    4","prompt":"Can you write a docstring for the following Elixir function? iodata_length(iodata)"}
{"completion":"Converts IO data into a binary\n\nThe operation is Unicode unsafe.\n\nNote that this function treats integers in the given IO data as\nraw bytes and does not perform any kind of encoding conversion.\nIf you want to convert from a charlist to a UTF-8-encoded string,\nuse `chardata_to_string/1` instead. For more information about\nIO data and chardata, see the [\"IO data\"](#module-io-data) section in the\nmodule documentation.\n\nIf this function receives a binary, the same binary is returned.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> bin1 = <<1, 2, 3>>\n    iex> bin2 = <<4, 5>>\n    iex> bin3 = <<6>>\n    iex> IO.iodata_to_binary([bin1, 1, [2, 3, bin2], 4 | bin3])\n    <<1, 2, 3, 1, 2, 3, 4, 5, 4, 6>>\n\n    iex> bin = <<1, 2, 3>>\n    iex> IO.iodata_to_binary(bin)\n    <<1, 2, 3>>","prompt":"Can you write a docstring for the following Elixir function? iodata_to_binary(iodata)"}
{"completion":"Writes `item` to the given `device`, similar to `write/2`,\nbut adds a newline at the end.\n\nBy default, the `device` is the standard output. It returns `:ok`\nif it succeeds.\n\n## Examples\n\n    IO.puts(\"Hello World!\")\n    #=> Hello World!\n\n    IO.puts(:stderr, \"error\")\n    #=> error","prompt":"Can you write a docstring for the following Elixir function? puts(device \\\\ :stdio, item)"}
{"completion":"Reads from the IO `device`.\n\nThe `device` is iterated by the given number of characters, line by line if\n`:line` is given, or until `:eof`.\n\nIt returns:\n\n  * `data` - the output characters\n\n  * `:eof` - end of file was encountered\n\n  * `{:error, reason}` - other (rare) error condition;\n    for instance, `{:error, :estale}` if reading from an\n    NFS volume","prompt":"Can you write a docstring for the following Elixir function? read(device \\\\ :stdio, line_or_chars)"}
{"completion":"Returns a line-based `IO.Stream` on `:stdio`.\n\nThis is equivalent to:\n\n    IO.stream(:stdio, :line)","prompt":"Can you write a docstring for the following Elixir function? stream()"}
{"completion":"Converts the IO `device` into an `IO.Stream`.\n\nAn `IO.Stream` implements both `Enumerable` and\n`Collectable`, allowing it to be used for both read\nand write.\n\nThe `device` is iterated by the given number of characters or line by line if\n`:line` is given.\n\nThis reads from the IO as UTF-8. Check out\n`IO.binstream/2` to handle the IO as a raw binary.\n\nNote that an IO stream has side effects and every time\nyou go over the stream you may get different results.\n\n`stream/0` has been introduced in Elixir v1.12.0,\nwhile `stream/2` has been available since v1.0.0.\n\n## Examples\n\nHere is an example on how we mimic an echo server\nfrom the command line:\n\n    Enum.each(IO.stream(:stdio, :line), &IO.write(&1))","prompt":"Can you write a docstring for the following Elixir function? stream(device \\\\ :stdio, line_or_codepoints)"}
{"completion":"Writes a `message` to stderr, along with the current stacktrace.\n\nIt returns `:ok` if it succeeds.\n\nDo not call this function at the tail of another function. Due to tail\ncall optimization, a stacktrace entry would not be added and the\nstacktrace would be incorrectly trimmed. Therefore make sure at least\none expression (or an atom such as `:ok`) follows the `IO.warn/1` call.\n\n## Examples\n\n    IO.warn(\"variable bar is unused\")\n    #=> warning: variable bar is unused\n    #=>   (iex) evaluator.ex:108: IEx.Evaluator.eval/4","prompt":"Can you write a docstring for the following Elixir function? warn(message)"}
{"completion":"Writes a `message` to stderr, along with the given `stacktrace_info`.\n\nThe `stacktrace_info` must be one of:\n\n  * a `__STACKTRACE__`, where all entries in the stacktrace will be\n    included in the error message\n\n  * a `Macro.Env` structure (since v1.14.0), where a single stacktrace\n    entry from the compilation environment will be used\n\n  * a keyword list with at least the `:file` option representing\n    a single stacktrace entry (since v1.14.0). The `:line`, `:module`,\n    `:function` options are also supported\n\nThis function also notifies the compiler a warning was printed\n(in case --warnings-as-errors was enabled). It returns `:ok`\nif it succeeds.\n\n## Examples\n\n    stacktrace = [{MyApp, :main, 1, [file: 'my_app.ex', line: 4]}]\n    IO.warn(\"variable bar is unused\", stacktrace)\n    #=> warning: variable bar is unused\n    #=>   my_app.ex:4: MyApp.main/1","prompt":"Can you write a docstring for the following Elixir function? warn(message, stacktrace_info)"}
{"completion":"Writes `chardata` to the given `device`.\n\nBy default, the `device` is the standard output.\n\n## Examples\n\n    IO.write(\"sample\")\n    #=> sample\n\n    IO.write(:stderr, \"error\")\n    #=> error","prompt":"Can you write a docstring for the following Elixir function? write(device \\\\ :stdio, chardata)"}
{"completion":"Functions handling input/output (IO).\n\nMany functions in this module expect an IO device as an argument.\nAn IO device must be a PID or an atom representing a process.\nFor convenience, Elixir provides `:stdio` and `:stderr` as\nshortcuts to Erlang's `:standard_io` and `:standard_error`.\n\nThe majority of the functions expect chardata. In case another type is given,\nfunctions will convert those types to string via the `String.Chars` protocol\n(as shown in typespecs). For more information on chardata, see the\n\"IO data\" section below.","prompt":"Can you write a docstring for the following Elixir function? Elixir.IO"}
{"completion":"IO devices\n\nAn IO device may be an atom or a PID. In case it is an atom,\nthe atom must be the name of a registered process. In addition,\nElixir provides two shortcuts:\n\n  * `:stdio` - a shortcut for `:standard_io`, which maps to\n    the current `Process.group_leader/0` in Erlang\n\n  * `:stderr` - a shortcut for the named process `:standard_error`\n    provided in Erlang\n\nIO devices maintain their position, which means subsequent calls to any\nreading or writing functions will start from the place where the device\nwas last accessed. The position of files can be changed using the\n`:file.position/2` function.","prompt":"Can you write a docstring for the following Elixir function? Elixir.IO"}
{"completion":"IO data\n\nIO data is a data type that can be used as a more efficient alternative to binaries\nin certain situations.\n\nA term of type **IO data** is a binary or a list containing bytes (integers within the `0..255` range)\nor nested IO data. The type is recursive. Let's see an example of one of\nthe possible IO data representing the binary `\"hello\"`:\n\n    [?h, \"el\", [\"l\", [?o]]]\n\nThe built-in `t:iodata/0` type is defined in terms of `t:iolist/0`. An IO list is\nthe same as IO data but it doesn't allow for a binary at the top level (but binaries\nare still allowed in the list itself).","prompt":"Can you write a docstring for the following Elixir function? Elixir.IO"}
{"completion":"# Use cases for IO data\n\nIO data exists because often you need to do many append operations\non smaller chunks of binaries in order to create a bigger binary. However, in\nErlang and Elixir concatenating binaries will copy the concatenated binaries\ninto a new binary.\n\n    def email(username, domain) do\n      username <> \"@\" <> domain\n    end\n\nIn this function, creating the email address will copy the `username` and `domain`\nbinaries. Now imagine you want to use the resulting email inside another binary:\n\n    def welcome_message(name, username, domain) do\n      \"Welcome #{name}, your email is: #{email(username, domain)}\"\n    end\n\n    IO.puts(welcome_message(\"Meg\", \"meg\", \"example.com\"))\n    #=> \"Welcome Meg, your email is: meg@example.com\"\n\nEvery time you concatenate binaries or use interpolation (`#{}`) you are making\ncopies of those binaries. However, in many cases you don't need the complete\nbinary while you create it, but only at the end to print it out or send it\nsomewhere. In such cases, you can construct the binary by creating IO data:\n\n    def email(username, domain) do\n      [username, ?@, domain]\n    end\n\n    def welcome_message(name, username, domain) do\n      [\"Welcome \", name, \", your email is: \", email(username, domain)]\n    end\n\n    IO.puts(welcome_message(\"Meg\", \"meg\", \"example.com\"))\n    #=> \"Welcome Meg, your email is: meg@example.com\"\n\nBuilding IO data is cheaper than concatenating binaries. Concatenating multiple\npieces of IO data just means putting them together inside a list since IO data\ncan be arbitrarily nested, and that's a cheap and efficient operation. Most of\nthe IO-based APIs, such as `:gen_tcp` and `IO`, receive IO data and write it\nto the socket directly without converting it to binary.\n\nOne drawback of IO data is that you can't do things like pattern match on the\nfirst part of a piece of IO data like you can with a binary, because you usually\ndon't know the shape of the IO data. In those cases, you may need to convert it\nto a binary by calling `iodata_to_binary/1`, which is reasonably efficient\nsince it's implemented natively in C. Other functionality, like computing the\nlength of IO data, can be computed directly on the iodata by calling `iodata_length/1`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.IO"}
{"completion":"# Chardata\n\nErlang and Elixir also have the idea of `t:chardata/0`. Chardata is very\nsimilar to IO data: the only difference is that integers in IO data represent\nbytes while integers in chardata represent Unicode code points. Bytes\n(`t:byte/0`) are integers within the `0..255` range, while Unicode code points\n(`t:char/0`) are integers within the `0..0x10FFFF` range. The `IO` module provides\nthe `chardata_to_string/1` function for chardata as the \"counter-part\" of the\n`iodata_to_binary/1` function for IO data.\n\nIf you try to use `iodata_to_binary/1` on chardata, it will result in an\nargument error. For example, let's try to put a code point that is not\nrepresentable with one byte, like `?`, inside IO data:\n\n    IO.iodata_to_binary([\"The symbol for pi is: \", ?])\n    #=> ** (ArgumentError) argument error\n\nIf we use chardata instead, it will work as expected:\n\n    iex> IO.chardata_to_string([\"The symbol for pi is: \", ?])\n    \"The symbol for pi is: \"","prompt":"Can you write a docstring for the following Elixir function? Elixir.IO"}
{"completion":"Returns a break document based on the given `string`.\n\nThis break can be rendered as a linebreak or as the given `string`,\ndepending on the `mode` of the chosen layout.\n\n## Examples\n\nLet's create a document by concatenating two strings with a break between\nthem:\n\n    iex> doc = Inspect.Algebra.concat([\"a\", Inspect.Algebra.break(\"\\t\"), \"b\"])\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"a\", \"\\t\", \"b\"]\n\nNote that the break was represented with the given string, because we didn't\nreach a line limit. Once we do, it is replaced by a newline:\n\n    iex> break = Inspect.Algebra.break(\"\\t\")\n    iex> doc = Inspect.Algebra.concat([String.duplicate(\"a\", 20), break, \"b\"])\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> Inspect.Algebra.format(doc, 10)\n    [\"aaaaaaaaaaaaaaaaaaaa\", \"\\n\", \"b\"]","prompt":"Can you write a docstring for the following Elixir function? break(string \\\\ \" \")"}
{"completion":"Collapse any new lines and whitespace following this\nnode, emitting up to `max` new lines.","prompt":"Can you write a docstring for the following Elixir function? collapse_lines(max)"}
{"completion":"Colors a document if the `color_key` has a color in the options.","prompt":"Can you write a docstring for the following Elixir function? color(doc, color_key, opts)"}
{"completion":"Concatenates a list of documents returning a new document.\n\n## Examples\n\n    iex> doc = Inspect.Algebra.concat([\"a\", \"b\", \"c\"])\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"a\", \"b\", \"c\"]","prompt":"Can you write a docstring for the following Elixir function? concat(docs)"}
{"completion":"Concatenates two document entities returning a new document.\n\n## Examples\n\n    iex> doc = Inspect.Algebra.concat(\"hello\", \"world\")\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"hello\", \"world\"]","prompt":"Can you write a docstring for the following Elixir function? concat(doc1, doc2)"}
{"completion":"Wraps `collection` in `left` and `right` according to limit and contents.\n\nIt uses the given `left` and `right` documents as surrounding and the\nseparator document `separator` to separate items in `docs`. If all entries\nin the collection are simple documents (texts or strings), then this function\nattempts to put as much as possible on the same line. If they are not simple,\nonly one entry is shown per line if they do not fit.\n\nThe limit in the given `inspect_opts` is respected and when reached this\nfunction stops processing and outputs `\"...\"` instead.\n\n## Options\n\n  * `:separator` - the separator used between each doc\n  * `:break` - If `:strict`, always break between each element. If `:flex`,\n    breaks only when necessary. If `:maybe`, chooses `:flex` only if all\n    elements are text-based, otherwise is `:strict`\n\n## Examples\n\n    iex> inspect_opts = %Inspect.Opts{limit: :infinity}\n    iex> fun = fn i, _opts -> to_string(i) end\n    iex> doc = Inspect.Algebra.container_doc(\"[\", Enum.to_list(1..5), \"]\", inspect_opts, fun)\n    iex> Inspect.Algebra.format(doc, 5) |> IO.iodata_to_binary()\n    \"[1,\\n 2,\\n 3,\\n 4,\\n 5]\"\n\n    iex> inspect_opts = %Inspect.Opts{limit: 3}\n    iex> fun = fn i, _opts -> to_string(i) end\n    iex> doc = Inspect.Algebra.container_doc(\"[\", Enum.to_list(1..5), \"]\", inspect_opts, fun)\n    iex> Inspect.Algebra.format(doc, 20) |> IO.iodata_to_binary()\n    \"[1, 2, 3, ...]\"\n\n    iex> inspect_opts = %Inspect.Opts{limit: 3}\n    iex> fun = fn i, _opts -> to_string(i) end\n    iex> opts = [separator: \"!\"]\n    iex> doc = Inspect.Algebra.container_doc(\"[\", Enum.to_list(1..5), \"]\", inspect_opts, fun, opts)\n    iex> Inspect.Algebra.format(doc, 20) |> IO.iodata_to_binary()\n    \"[1! 2! 3! ...]\"","prompt":"Can you write a docstring for the following Elixir function? container_doc(left, collection, right, inspect_opts, fun, opts \\\\ [])"}
{"completion":"Returns a document entity used to represent nothingness.\n\n## Examples\n\n    iex> Inspect.Algebra.empty()\n    :doc_nil","prompt":"Can you write a docstring for the following Elixir function? empty()"}
{"completion":"Returns a flex break document based on the given `string`.\n\nA flex break still causes a group to break, like `break/1`,\nbut it is re-evaluated when the documented is rendered.\n\nFor example, take a group document represented as `[1, 2, 3]`\nwhere the space after every comma is a break. When the document\nabove does not fit a single line, all breaks are enabled,\ncausing the document to be rendered as:\n\n    [1,\n     2,\n     3]\n\nHowever, if flex breaks are used, then each break is re-evaluated\nwhen rendered, so the document could be possible rendered as:\n\n    [1, 2,\n     3]\n\nHence the name \"flex\". they are more flexible when it comes\nto the document fitting. On the other hand, they are more expensive\nsince each break needs to be re-evaluated.\n\nThis function is used by `container_doc/6` and friends to the\nmaximum number of entries on the same line.","prompt":"Can you write a docstring for the following Elixir function? flex_break(string \\\\ \" \")"}
{"completion":"Glues two documents (`doc1` and `doc2`) inserting a\n`flex_break/1` given by `break_string` between them.\n\nThis function is used by `container_doc/6` and friends\nto the maximum number of entries on the same line.","prompt":"Can you write a docstring for the following Elixir function? flex_glue(doc1, break_string \\\\ \" \", doc2)"}
{"completion":"Folds a list of documents into a document using the given folder function.\n\nThe list of documents is folded \"from the right\"; in that, this function is\nsimilar to `List.foldr/3`, except that it doesn't expect an initial\naccumulator and uses the last element of `docs` as the initial accumulator.\n\n## Examples\n\n    iex> docs = [\"A\", \"B\", \"C\"]\n    iex> docs =\n    ...>   Inspect.Algebra.fold_doc(docs, fn doc, acc ->\n    ...>     Inspect.Algebra.concat([doc, \"!\", acc])\n    ...>   end)\n    iex> Inspect.Algebra.format(docs, 80)\n    [\"A\", \"!\", \"B\", \"!\", \"C\"]","prompt":"Can you write a docstring for the following Elixir function? fold_doc(docs, folder_fun)"}
{"completion":"Forces the current group to be unfit.","prompt":"Can you write a docstring for the following Elixir function? force_unfit(doc)"}
{"completion":"Formats a given document for a given width.\n\nTakes the maximum width and a document to print as its arguments\nand returns an IO data representation of the best layout for the\ndocument to fit in the given width.\n\nThe document starts flat (without breaks) until a group is found.\n\n## Examples\n\n    iex> doc = Inspect.Algebra.glue(\"hello\", \" \", \"world\")\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> doc |> Inspect.Algebra.format(30) |> IO.iodata_to_binary()\n    \"hello world\"\n    iex> doc |> Inspect.Algebra.format(10) |> IO.iodata_to_binary()\n    \"hello\\nworld\"","prompt":"Can you write a docstring for the following Elixir function? format(doc, width)"}
{"completion":"Glues two documents (`doc1` and `doc2`) inserting the given\nbreak `break_string` between them.\n\nFor more information on how the break is inserted, see `break/1`.\n\n## Examples\n\n    iex> doc = Inspect.Algebra.glue(\"hello\", \"world\")\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"hello\", \" \", \"world\"]\n\n    iex> doc = Inspect.Algebra.glue(\"hello\", \"\\t\", \"world\")\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"hello\", \"\\t\", \"world\"]","prompt":"Can you write a docstring for the following Elixir function? glue(doc1, break_string \\\\ \" \", doc2)"}
{"completion":"Returns a group containing the specified document `doc`.\n\nDocuments in a group are attempted to be rendered together\nto the best of the renderer ability.\n\nThe group mode can also be set to `:inherit`, which means it\nautomatically breaks if the parent group has broken too.\n\n## Examples\n\n    iex> doc =\n    ...>   Inspect.Algebra.group(\n    ...>     Inspect.Algebra.concat(\n    ...>       Inspect.Algebra.group(\n    ...>         Inspect.Algebra.concat(\n    ...>           \"Hello,\",\n    ...>           Inspect.Algebra.concat(\n    ...>             Inspect.Algebra.break(),\n    ...>             \"A\"\n    ...>           )\n    ...>         )\n    ...>       ),\n    ...>       Inspect.Algebra.concat(\n    ...>         Inspect.Algebra.break(),\n    ...>         \"B\"\n    ...>       )\n    ...>     )\n    ...>   )\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"Hello,\", \" \", \"A\", \" \", \"B\"]\n    iex> Inspect.Algebra.format(doc, 6)\n    [\"Hello,\", \"\\n\", \"A\", \"\\n\", \"B\"]","prompt":"Can you write a docstring for the following Elixir function? group(doc, mode \\\\ :self)"}
{"completion":"A mandatory linebreak.\n\nA group with linebreaks will fit if all lines in the group fit.\n\n## Examples\n\n    iex> doc =\n    ...>   Inspect.Algebra.concat(\n    ...>     Inspect.Algebra.concat(\n    ...>       \"Hughes\",\n    ...>       Inspect.Algebra.line()\n    ...>     ),\n    ...>     \"Wadler\"\n    ...>   )\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"Hughes\", \"\\n\", \"Wadler\"]","prompt":"Can you write a docstring for the following Elixir function? line()"}
{"completion":"Inserts a mandatory linebreak between two documents.\n\nSee `line/0`.\n\n## Examples\n\n    iex> doc = Inspect.Algebra.line(\"Hughes\", \"Wadler\")\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"Hughes\", \"\\n\", \"Wadler\"]","prompt":"Can you write a docstring for the following Elixir function? line(doc1, doc2)"}
{"completion":"Nests the given document at the given `level`.\n\nIf `level` is an integer, that's the indentation appended\nto line breaks whenever they occur. If the level is `:cursor`,\nthe current position of the \"cursor\" in the document becomes\nthe nesting. If the level is `:reset`, it is set back to 0.\n\n`mode` can be `:always`, which means nesting always happen,\nor `:break`, which means nesting only happens inside a group\nthat has been broken.\n\n## Examples\n\n    iex> doc = Inspect.Algebra.nest(Inspect.Algebra.glue(\"hello\", \"world\"), 5)\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> Inspect.Algebra.format(doc, 5)\n    [\"hello\", \"\\n     \", \"world\"]","prompt":"Can you write a docstring for the following Elixir function? nest(doc, level, mode \\\\ :always)"}
{"completion":"Considers the next break as fit.\n\n`mode` can be `:enabled` or `:disabled`. When `:enabled`,\nit will consider the document as fit as soon as it finds\nthe next break, effectively cancelling the break. It will\nalso ignore any `force_unfit/1` in search of the next break.\n\nWhen disabled, it behaves as usual and it will ignore\nany further `next_break_fits/2` instruction.\n\n## Examples\n\nThis is used by Elixir's code formatter to avoid breaking\ncode at some specific locations. For example, consider this\ncode:\n\n    some_function_call(%{..., key: value, ...})\n\nNow imagine that this code does not fit its line. The code\nformatter introduces breaks inside `(` and `)` and inside\n`%{` and `}`. Therefore the document would break as:\n\n    some_function_call(\n      %{\n        ...,\n        key: value,\n        ...\n      }\n    )\n\nThe formatter wraps the algebra document representing the\nmap in `next_break_fits/1` so the code is formatted as:\n\n    some_function_call(%{\n      ...,\n      key: value,\n      ...\n    })","prompt":"Can you write a docstring for the following Elixir function? next_break_fits(doc, mode \\\\ :enabled)"}
{"completion":"Inserts a mandatory single space between two documents.\n\n## Examples\n\n    iex> doc = Inspect.Algebra.space(\"Hughes\", \"Wadler\")\n    iex> Inspect.Algebra.format(doc, 5)\n    [\"Hughes\", \" \", \"Wadler\"]","prompt":"Can you write a docstring for the following Elixir function? space(doc1, doc2)"}
{"completion":"Creates a document represented by string.\n\nWhile `Inspect.Algebra` accepts binaries as documents,\nthose are counted by binary size. On the other hand,\n`string` documents are measured in terms of graphemes\ntowards the document size.\n\n## Examples\n\nThe following document has 10 bytes and therefore it\ndoes not format to width 9 without breaks:\n\n    iex> doc = Inspect.Algebra.glue(\"ol\", \" \", \"mundo\")\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> Inspect.Algebra.format(doc, 9)\n    [\"ol\", \"\\n\", \"mundo\"]\n\nHowever, if we use `string`, then the string length is\nused, instead of byte size, correctly fitting:\n\n    iex> string = Inspect.Algebra.string(\"ol\")\n    iex> doc = Inspect.Algebra.glue(string, \" \", \"mundo\")\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> Inspect.Algebra.format(doc, 9)\n    [\"ol\", \" \", \"mundo\"]","prompt":"Can you write a docstring for the following Elixir function? string(string)"}
{"completion":"Converts an Elixir term to an algebra document\naccording to the `Inspect` protocol.","prompt":"Can you write a docstring for the following Elixir function? to_doc(term, opts)"}
{"completion":"A set of functions for creating and manipulating algebra\ndocuments.\n\nThis module implements the functionality described in\n[\"Strictly Pretty\" (2000) by Christian Lindig][0] with small\nadditions, like support for binary nodes and a break mode that\nmaximises use of horizontal space.\n\n    iex> Inspect.Algebra.empty()\n    :doc_nil\n\n    iex> \"foo\"\n    \"foo\"\n\nWith the functions in this module, we can concatenate different\nelements together and render them:\n\n    iex> doc = Inspect.Algebra.concat(Inspect.Algebra.empty(), \"foo\")\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"foo\"]\n\nThe functions `nest/2`, `space/2` and `line/2` help you put the\ndocument together into a rigid structure. However, the document\nalgebra gets interesting when using functions like `glue/3` and\n`group/1`. A glue inserts a break between two documents. A group\nindicates a document that must fit the current line, otherwise\nbreaks are rendered as new lines. Let's glue two docs together\nwith a break, group it and then render it:\n\n    iex> doc = Inspect.Algebra.glue(\"a\", \" \", \"b\")\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"a\", \" \", \"b\"]\n\nNote that the break was represented as is, because we haven't reached\na line limit. Once we do, it is replaced by a newline:\n\n    iex> doc = Inspect.Algebra.glue(String.duplicate(\"a\", 20), \" \", \"b\")\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> Inspect.Algebra.format(doc, 10)\n    [\"aaaaaaaaaaaaaaaaaaaa\", \"\\n\", \"b\"]\n\nThis module uses the byte size to compute how much space there is\nleft. If your document contains strings, then those need to be\nwrapped in `string/1`, which then relies on `String.length/1` to\nprecompute the document size.\n\nFinally, this module also contains Elixir related functions, a bit\ntied to Elixir formatting, such as `to_doc/2`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Inspect.Algebra"}
{"completion":"Implementation details\n\nThe implementation of `Inspect.Algebra` is based on the Strictly Pretty\npaper by [Lindig][0] which builds on top of previous pretty printing\nalgorithms but is tailored to strict languages, such as Elixir.\nThe core idea in the paper is the use of explicit document groups which\nare rendered as flat (breaks as spaces) or as break (breaks as newlines).\n\nThis implementation provides two types of breaks: `:strict` and `:flex`.\nWhen a group does not fit, all strict breaks are treated as newlines.\nFlex breaks however are re-evaluated on every occurrence and may still\nbe rendered flat. See `break/1` and `flex_break/1` for more information.\n\nThis implementation also adds `force_unfit/1` and `next_break_fits/2` which\ngive more control over the document fitting.\n\n  [0]: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200","prompt":"Can you write a docstring for the following Elixir function? Elixir.Inspect.Algebra"}
{"completion":"Raised when a struct cannot be inspected.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Inspect.Error"}
{"completion":"Returns the default inspect function.","prompt":"Can you write a docstring for the following Elixir function? default_inspect_fun()"}
{"completion":"Sets the default inspect function.\n\nSet this option with care as it will change how all values\nin the system are inspected. The main use of this functionality\nis to provide an entry point to filter inspected values,\nin order for entities to comply with rules and legislations\non data security and data privacy.\n\nIt is **extremely discouraged** for libraries to set their own\nfunction as this must be controlled by applications. Libraries\nshould instead define their own structs with custom inspect\nimplementations. If a library must change the default inspect\nfunction, then it is best to define to ask users of your library\nto explicitly call `default_inspect_fun/1` with your function of\nchoice.\n\nThe default is `Inspect.inspect/2`.\n\n## Examples\n\n    previous_fun = Inspect.Opts.default_inspect_fun()\n\n    Inspect.Opts.default_inspect_fun(fn\n      %{address: _} = map, opts ->\n        previous_fun.(%{map | address: \"[REDACTED]\"}, opts)\n\n      value, opts ->\n        previous_fun.(value, opts)\n    end)","prompt":"Can you write a docstring for the following Elixir function? default_inspect_fun(fun)"}
{"completion":"Builds an `Inspect.Opts` struct.","prompt":"Can you write a docstring for the following Elixir function? new(opts)"}
{"completion":"Defines the options used by the `Inspect` protocol.\n\nThe following fields are available:\n\n  * `:base` - prints integers as `:binary`, `:octal`, `:decimal`, or `:hex`,\n    defaults to `:decimal`. When inspecting binaries any `:base` other than\n    `:decimal` implies `binaries: :as_binaries`.\n\n  * `:binaries` - when `:as_binaries` all binaries will be printed in bit\n    syntax.\n\n    When `:as_strings` all binaries will be printed as strings, non-printable\n    bytes will be escaped.\n\n    When the default `:infer`, the binary will be printed as a string if it\n    is printable, otherwise in bit syntax. See `String.printable?/1` to learn\n    when a string is printable.\n\n  * `:charlists` - when `:as_charlists` all lists will be printed as charlists,\n    non-printable elements will be escaped.\n\n    When `:as_lists` all lists will be printed as lists.\n\n    When the default `:infer`, the list will be printed as a charlist if it\n    is printable, otherwise as list. See `List.ascii_printable?/1` to learn\n    when a charlist is printable.\n\n  * `:custom_options` (since v1.9.0) - a keyword list storing custom user-defined\n    options. Useful when implementing the `Inspect` protocol for nested structs\n    to pass the custom options through.\n\n  * `:inspect_fun` (since v1.9.0) - a function to build algebra documents.\n    Defaults to `Inspect.Opts.default_inspect_fun/0`.\n\n  * `:limit` - limits the number of items that are inspected for tuples,\n    bitstrings, maps, lists and any other collection of items, with the exception of\n    printable strings and printable charlists which use the `:printable_limit` option.\n    If you don't want to limit the number of items to a particular number,\n    use `:infinity`. It accepts a positive integer or `:infinity`.\n    Defaults to `50`.\n\n  * `:pretty` - if set to `true` enables pretty printing. Defaults to `false`.\n\n  * `:printable_limit` - limits the number of characters that are inspected\n    on printable strings and printable charlists. You can use `String.printable?/1`\n    and `List.ascii_printable?/1` to check if a given string or charlist is\n    printable. If you don't want to limit the number of characters to a particular\n    number, use `:infinity`. It accepts a positive integer or `:infinity`.\n    Defaults to `4096`.\n\n  * `:safe` - when `false`, failures while inspecting structs will be raised\n    as errors instead of being wrapped in the `Inspect.Error` exception. This\n    is useful when debugging failures and crashes for custom inspect\n    implementations. Defaults to `true`.\n\n  * `:structs` - when `false`, structs are not formatted by the inspect\n    protocol, they are instead printed as maps. Defaults to `true`.\n\n  * `:syntax_colors` - when set to a keyword list of colors the output is\n    colorized. The keys are types and the values are the colors to use for\n    each type (for example, `[number: :red, atom: :blue]`). Types can include\n    `:atom`, `:binary`, `:boolean`, `:list`, `:map`, `:number`, `:regex`,\n    `:string`, and `:tuple`. Custom data types may provide their own options.\n    Colors can be any `t:IO.ANSI.ansidata/0` as accepted by `IO.ANSI.format/1`.\n    A default list of colors can be retrieved from `IO.ANSI.syntax_colors/0`.\n\n  * `:width` - number of characters per line used when pretty is `true` or when\n    printing to IO devices. Set to `0` to force each item to be printed on its\n    own line. If you don't want to limit the number of items to a particular\n    number, use `:infinity`. Defaults to `80`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Inspect.Opts"}
{"completion":"Converts `term` into an algebra document.\n\nThis function shouldn't be invoked directly, unless when implementing\na custom `inspect_fun` to be given to `Inspect.Opts`. Everywhere else,\n`Inspect.Algebra.to_doc/2` should be preferred as it handles structs\nand exceptions.","prompt":"Can you write a docstring for the following Elixir function? inspect(term, opts)"}
{"completion":"The `Inspect` protocol converts an Elixir data structure into an\nalgebra document.\n\nThis is typically done when you want to customize how your own\nstructs are inspected in logs and the terminal.\n\nThis documentation refers to implementing the `Inspect` protocol\nfor your own data structures. To learn more about using inspect,\nsee `Kernel.inspect/2` and `IO.inspect/2`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Inspect"}
{"completion":"Inspect representation\n\nThere are typically three choices of inspect representation. In order\nto understand them, let's imagine we have the following `User` struct:\n\n    defmodule User do\n      defstruct [:id, :name, :address]\n    end\n\nOur choices are:\n\n  1. Print the struct using Elixir's struct syntax, for example:\n     `%User{address: \"Earth\", id: 13, name: \"Jane\"}`. This is the\n     default representation and best choice if all struct fields\n     are public.\n\n  2. Print using the `#User<...>` notation, for example: `#User<id: 13, name: \"Jane\", ...>`.\n     This notation does not emit valid Elixir code and is typically\n     used when the struct has private fields (for example, you may want\n     to hide the field `:address` to redact person identifiable information).\n\n  3. Print the struct using the expression syntax, for example:\n     `User.new(13, \"Jane\", \"Earth\")`. This assumes there is a `User.new/3`\n     function. This option is mostly used as an alternative to option 2\n     for representing custom data structures, such as `MapSet`, `Date.Range`,\n     and others.\n\nYou can implement the Inspect protocol for your own structs while\nadhering to the conventions above. Option 1 is the default representation\nand you can quickly achieve option 2 by deriving the `Inspect` protocol.\nFor option 3, you need your custom implementation.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Inspect"}
{"completion":"Deriving\n\nThe `Inspect` protocol can be derived to customize the order of fields\n(the default is alphabetical) and hide certain fields from structs,\nso they don't show up in logs, inspects and similar. The latter is\nespecially useful for fields containing private information.\n\nThe supported options are:\n\n  * `:only` - only include the given fields when inspecting.\n\n  * `:except` - remove the given fields when inspecting.\n\n  * `:optional` - (since v1.14.0) do not include a field if it\n    matches its default value. This can be used to simplify the\n    struct representation at the cost of hiding information.\n\nWhenever `:only` or `:except` are used to restrict fields,\nthe struct will be printed using the `#User<...>` notation,\nas the struct can no longer be copy and pasted as valid Elixir\ncode. Let's see an example:\n\n    defmodule User do\n      @derive {Inspect, only: [:id, :name]}\n      defstruct [:id, :name, :address]\n    end\n\n    inspect(%User{id: 1, name: \"Jane\", address: \"Earth\"})\n    #=> #User<id: 1, name: \"Jane\", ...>\n\nIf you use only the `:optional` option, the struct will still be\nprinted as `%User{...}`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Inspect"}
{"completion":"Custom implementation\n\nYou can also define your custom protocol implementation by\ndefining the `inspect/2` function. The function receives the\nentity to be inspected followed by the inspecting options,\nrepresented by the struct `Inspect.Opts`. Building of the\nalgebra document is done with `Inspect.Algebra`.\n\nMany times, inspecting a structure can be implemented in function\nof existing entities. For example, here is `MapSet`'s `inspect/2`\nimplementation:\n\n    defimpl Inspect, for: MapSet do\n      import Inspect.Algebra\n\n      def inspect(map_set, opts) do\n        concat([\"MapSet.new(\", Inspect.List.inspect(MapSet.to_list(map_set), opts), \")\"])\n      end\n    end\n\nThe [`concat/1`](`Inspect.Algebra.concat/1`) function comes from\n`Inspect.Algebra` and it concatenates algebra documents together.\nIn the example above it is concatenating the string `\"MapSet.new(\"`,\nthe document returned by `Inspect.Algebra.to_doc/2`, and the final\nstring `\")\"`. Therefore, the MapSet with the numbers 1, 2, and 3\nwill be printed as:\n\n    iex> MapSet.new([1, 2, 3], fn x -> x * 2 end)\n    MapSet.new([2, 4, 6])\n\nIn other words, `MapSet`'s inspect representation returns an expression\nthat, when evaluated, builds the `MapSet` itself.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Inspect"}
{"completion":"# Error handling\n\nIn case there is an error while your structure is being inspected,\nElixir will raise an `ArgumentError` error and will automatically fall back\nto a raw representation for printing the structure.\n\nYou can however access the underlying error by invoking the `Inspect`\nimplementation directly. For example, to test `Inspect.MapSet` above,\nyou can invoke it as:\n\n    Inspect.MapSet.inspect(MapSet.new(), %Inspect.Opts{})","prompt":"Can you write a docstring for the following Elixir function? Elixir.Inspect"}
{"completion":"Returns the ordered digits for the given `integer`.\n\nAn optional `base` value may be provided representing the radix for the returned\ndigits. This one must be an integer >= 2.\n\n## Examples\n\n    iex> Integer.digits(123)\n    [1, 2, 3]\n\n    iex> Integer.digits(170, 2)\n    [1, 0, 1, 0, 1, 0, 1, 0]\n\n    iex> Integer.digits(-170, 2)\n    [-1, 0, -1, 0, -1, 0, -1, 0]","prompt":"Can you write a docstring for the following Elixir function? digits(integer, base \\\\ 10)"}
{"completion":"Returns the extended greatest common divisor of the two given integers.\n\nThis function uses the extended Euclidean algorithm to return a three-element tuple with the `gcd`\nand the coefficients `m` and `n` of Bzout's identity such that:\n\n    gcd(a, b) = m*a + n*b\n\nBy convention, `extended_gcd(0, 0)` returns `{0, 0, 0}`.\n\n## Examples\n\n    iex> Integer.extended_gcd(240, 46)\n    {2, -9, 47}\n    iex> Integer.extended_gcd(46, 240)\n    {2, 47, -9}\n    iex> Integer.extended_gcd(-46, 240)\n    {2, -47, -9}\n    iex> Integer.extended_gcd(-46, -240)\n    {2, -47, 9}\n\n    iex> Integer.extended_gcd(14, 21)\n    {7, -1, 1}\n\n    iex> Integer.extended_gcd(10, 0)\n    {10, 1, 0}\n    iex> Integer.extended_gcd(0, 10)\n    {10, 0, 1}\n    iex> Integer.extended_gcd(0, 0)\n    {0, 0, 0}","prompt":"Can you write a docstring for the following Elixir function? extended_gcd(a, b)"}
{"completion":"Performs a floored integer division.\n\nRaises an `ArithmeticError` exception if one of the arguments is not an\ninteger, or when the `divisor` is `0`.\n\nThis function performs a *floored* integer division, which means that\nthe result will always be rounded towards negative infinity.\n\nIf you want to perform truncated integer division (rounding towards zero),\nuse `Kernel.div/2` instead.\n\n## Examples\n\n    iex> Integer.floor_div(5, 2)\n    2\n    iex> Integer.floor_div(6, -4)\n    -2\n    iex> Integer.floor_div(-99, 2)\n    -50","prompt":"Can you write a docstring for the following Elixir function? floor_div(dividend, divisor)"}
{"completion":"Returns the greatest common divisor of the two given integers.\n\nThe greatest common divisor (GCD) of `integer1` and `integer2` is the largest positive\ninteger that divides both `integer1` and `integer2` without leaving a remainder.\n\nBy convention, `gcd(0, 0)` returns `0`.\n\n## Examples\n\n    iex> Integer.gcd(2, 3)\n    1\n\n    iex> Integer.gcd(8, 12)\n    4\n\n    iex> Integer.gcd(8, -12)\n    4\n\n    iex> Integer.gcd(10, 0)\n    10\n\n    iex> Integer.gcd(7, 7)\n    7\n\n    iex> Integer.gcd(0, 0)\n    0","prompt":"Can you write a docstring for the following Elixir function? gcd(integer1, integer2)"}
{"completion":"Computes the modulo remainder of an integer division.\n\nThis function performs a [floored division](`floor_div/2`), which means that\nthe result will always have the sign of the `divisor`.\n\nRaises an `ArithmeticError` exception if one of the arguments is not an\ninteger, or when the `divisor` is `0`.\n\n## Examples\n\n    iex> Integer.mod(5, 2)\n    1\n    iex> Integer.mod(6, -4)\n    -2","prompt":"Can you write a docstring for the following Elixir function? mod(dividend, divisor)"}
{"completion":"Parses a text representation of an integer.\n\nAn optional `base` to the corresponding integer can be provided.\nIf `base` is not given, 10 will be used.\n\nIf successful, returns a tuple in the form of `{integer, remainder_of_binary}`.\nOtherwise `:error`.\n\nRaises an error if `base` is less than 2 or more than 36.\n\nIf you want to convert a string-formatted integer directly to an integer,\n`String.to_integer/1` or `String.to_integer/2` can be used instead.\n\n## Examples\n\n    iex> Integer.parse(\"34\")\n    {34, \"\"}\n\n    iex> Integer.parse(\"34.5\")\n    {34, \".5\"}\n\n    iex> Integer.parse(\"three\")\n    :error\n\n    iex> Integer.parse(\"34\", 10)\n    {34, \"\"}\n\n    iex> Integer.parse(\"f4\", 16)\n    {244, \"\"}\n\n    iex> Integer.parse(\"Awww++\", 36)\n    {509216, \"++\"}\n\n    iex> Integer.parse(\"fab\", 10)\n    :error\n\n    iex> Integer.parse(\"a2\", 38)\n    ** (ArgumentError) invalid base 38","prompt":"Can you write a docstring for the following Elixir function? parse(binary, base \\\\ 10)"}
{"completion":"Computes `base` raised to power of `exponent`.\n\nBoth `base` and `exponent` must be integers.\nThe exponent must be zero or positive.\n\nSee `Float.pow/2` for exponentiation of negative\nexponents as well as floats.\n\n## Examples\n\n    iex> Integer.pow(2, 0)\n    1\n    iex> Integer.pow(2, 1)\n    2\n    iex> Integer.pow(2, 10)\n    1024\n    iex> Integer.pow(2, 11)\n    2048\n    iex> Integer.pow(2, 64)\n    0x10000000000000000\n\n    iex> Integer.pow(3, 4)\n    81\n    iex> Integer.pow(4, 3)\n    64\n\n    iex> Integer.pow(-2, 3)\n    -8\n    iex> Integer.pow(-2, 4)\n    16\n\n    iex> Integer.pow(2, -2)\n    ** (ArithmeticError) bad argument in arithmetic expression","prompt":"Can you write a docstring for the following Elixir function? pow(base, exponent)"}
{"completion":"Returns a charlist which corresponds to the text representation\nof `integer` in the given `base`.\n\n`base` can be an integer between 2 and 36. If no `base` is given,\nit defaults to `10`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Integer.to_charlist(123)\n    '123'\n\n    iex> Integer.to_charlist(+456)\n    '456'\n\n    iex> Integer.to_charlist(-789)\n    '-789'\n\n    iex> Integer.to_charlist(0123)\n    '123'\n\n    iex> Integer.to_charlist(100, 16)\n    '64'\n\n    iex> Integer.to_charlist(-100, 16)\n    '-64'\n\n    iex> Integer.to_charlist(882_681_651, 36)\n    'ELIXIR'","prompt":"Can you write a docstring for the following Elixir function? to_charlist(integer, base \\\\ 10)"}
{"completion":"Returns a binary which corresponds to the text representation\nof `integer` in the given `base`.\n\n`base` can be an integer between 2 and 36. If no `base` is given,\nit defaults to `10`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Integer.to_string(123)\n    \"123\"\n\n    iex> Integer.to_string(+456)\n    \"456\"\n\n    iex> Integer.to_string(-789)\n    \"-789\"\n\n    iex> Integer.to_string(0123)\n    \"123\"\n\n    iex> Integer.to_string(100, 16)\n    \"64\"\n\n    iex> Integer.to_string(-100, 16)\n    \"-64\"\n\n    iex> Integer.to_string(882_681_651, 36)\n    \"ELIXIR\"","prompt":"Can you write a docstring for the following Elixir function? to_string(integer, base \\\\ 10)"}
{"completion":"Returns the integer represented by the ordered `digits`.\n\nAn optional `base` value may be provided representing the radix for the `digits`.\nBase has to be an integer greater than or equal to `2`.\n\n## Examples\n\n    iex> Integer.undigits([1, 2, 3])\n    123\n\n    iex> Integer.undigits([1, 4], 16)\n    20\n\n    iex> Integer.undigits([])\n    0","prompt":"Can you write a docstring for the following Elixir function? undigits(digits, base \\\\ 10)"}
{"completion":"Functions for working with integers.\n\nSome functions that work on integers are found in `Kernel`:\n\n  * `Kernel.abs/1`\n  * `Kernel.div/2`\n  * `Kernel.max/2`\n  * `Kernel.min/2`\n  * `Kernel.rem/2`","prompt":"Can you write a docstring for the following Elixir function? Elixir.Integer"}
{"completion":"Shared helper for error formatting on CLI tools.","prompt":"Can you write a docstring for the following Elixir function? format_error(kind, reason, stacktrace)"}
{"completion":"This is the API invoked by Elixir boot process.","prompt":"Can you write a docstring for the following Elixir function? main(argv)"}
{"completion":"Parses the CLI arguments. Made public for testing.","prompt":"Can you write a docstring for the following Elixir function? parse_argv(argv)"}
{"completion":"Process CLI commands. Made public for testing.","prompt":"Can you write a docstring for the following Elixir function? process_commands(config)"}
{"completion":"Function invoked across nodes for `--rpc-eval`.","prompt":"Can you write a docstring for the following Elixir function? rpc_eval(expr)"}
{"completion":"Runs the given function by catching any failure\nand printing them to stdout. `at_exit` hooks are\nalso invoked before exiting.\n\nThis function is used by Elixir's CLI and also\nby escripts generated by Elixir.","prompt":"Can you write a docstring for the following Elixir function? run(fun)"}
{"completion":"Returns all references in this lexical scope.","prompt":"Can you write a docstring for the following Elixir function? references(pid)"}
{"completion":"Starts a task for parallel compilation.\n\nIf you have a file that needs to compile other modules in parallel,\nthe spawned processes need to be aware of the compiler environment.\nThis function allows a developer to create a task that is aware of\nthose environments.\n\nSee `Task.async/1` for more information. The task spawned must be\nalways awaited on by calling `Task.await/1`","prompt":"Can you write a docstring for the following Elixir function? async(fun)"}
{"completion":"Compiles the given files.\n\nThose files are compiled in parallel and can automatically\ndetect dependencies between them. Once a dependency is found,\nthe current file stops being compiled until the dependency is\nresolved.\n\nIt returns `{:ok, modules, warnings}` or `{:error, errors, warnings}`.\n\nBoth errors and warnings are a list of three-element tuples containing\nthe file, line and the formatted error/warning.\n\n## Options\n\n  * `:each_file` - for each file compiled, invokes the callback passing the\n    file\n\n  * `:each_long_compilation` - for each file that takes more than a given\n    timeout (see the `:long_compilation_threshold` option) to compile, invoke\n    this callback passing the file as its argument\n\n  * `:each_module` - for each module compiled, invokes the callback passing\n    the file, module and the module bytecode\n\n  * `:each_cycle` - after the given files are compiled, invokes this function\n    that should return the following values:\n    * `{:compile, modules, warnings}` - to continue compilation with a list of\n      further modules to compile\n    * `{:runtime, modules, warnings}` - to stop compilation and verify the list\n      of modules because dependent modules have changed\n\n  * `:long_compilation_threshold` - the timeout (in seconds) to check for modules\n    taking too long to compile. For each file that exceeds the threshold, the\n    `:each_long_compilation` callback is invoked. From Elixir v1.11, only the time\n    spent compiling the actual module is taken into account by the threshold, the\n    time spent waiting is not considered. Defaults to `10` seconds.\n\n  * `:profile` - if set to `:time` measure the compilation time of each compilation cycle\n     and group pass checker\n\n  * `:dest` - the destination directory for the BEAM files. When using `compile/2`,\n    this information is only used to properly annotate the BEAM files before\n    they are loaded into memory. If you want a file to actually be written to\n    `dest`, use `compile_to_path/3` instead.\n\n  * `:beam_timestamp` - the modification timestamp to give all BEAM files","prompt":"Can you write a docstring for the following Elixir function? compile(files, options \\\\ [])"}
{"completion":"Compiles the given files and writes resulting BEAM files into path.\n\nSee `compile/2` for more information.","prompt":"Can you write a docstring for the following Elixir function? compile_to_path(files, path, options \\\\ [])"}
{"completion":"Prints a warning returned by the compiler.","prompt":"Can you write a docstring for the following Elixir function? print_warning(arg)"}
{"completion":"Requires the given files in parallel.\n\nOpposite to compile, dependencies are not attempted to be\nautomatically solved between files.\n\nIt returns `{:ok, modules, warnings}` or `{:error, errors, warnings}`.\n\nBoth errors and warnings are a list of three-element tuples containing\nthe file, line and the formatted error/warning.\n\n## Options\n\n  * `:each_file` - for each file compiled, invokes the callback passing the\n    file\n\n  * `:each_module` - for each module compiled, invokes the callback passing\n    the file, module and the module bytecode","prompt":"Can you write a docstring for the following Elixir function? require(files, options \\\\ [])"}
{"completion":"A module responsible for compiling and requiring files in parallel.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Kernel.ParallelCompiler"}
{"completion":"Special forms are the basic building blocks of Elixir, and therefore\ncannot be overridden by the developer.\n\nThe `Kernel.SpecialForms` module consists solely of macros that can be\ninvoked anywhere in Elixir code without the use of the\n`Kernel.SpecialForms.` prefix. This is possible because they all have\nbeen automatically imported, in the same fashion as the functions and\nmacros from the `Kernel` module.\n\nThese building blocks are defined in this module. Some of these special forms are lexical (such as\n`alias/2` and `case/2`). The macros `{}/1` and `<<>>/1` are also special\nforms used to define tuple and binary data structures respectively.\n\nThis module also documents macros that return information about Elixir's\ncompilation environment, such as (`__ENV__/0`, `__MODULE__/0`, `__DIR__/0`,\n`__STACKTRACE__/0`, and `__CALLER__/0`).\n\nAdditionally, it documents two special forms, `__block__/1` and\n`__aliases__/1`, which are not intended to be called directly by the\ndeveloper but they appear in quoted contents since they are essential\nin Elixir's constructs.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Kernel.SpecialForms"}
{"completion":"Defines a typespec.\n\nInvoked by `@/1` expansion.","prompt":"Can you write a docstring for the following Elixir function? deftypespec(kind, expr, line, file, module, pos)"}
{"completion":"Announcing callback for defstruct.","prompt":"Can you write a docstring for the following Elixir function? announce_struct(module)"}
{"completion":"Callback for defdelegate entry point.","prompt":"Can you write a docstring for the following Elixir function? defdelegate_all(funs, opts, env)"}
{"completion":"Callback for each function in defdelegate.","prompt":"Can you write a docstring for the following Elixir function? defdelegate_each(fun, opts)"}
{"completion":"Callback for defstruct.","prompt":"Can you write a docstring for the following Elixir function? defstruct(module, fields, bootstrapped?)"}
{"completion":"Callback for destructure.","prompt":"Can you write a docstring for the following Elixir function? destructure(list, count)"}
{"completion":"Callback for raise.","prompt":"Can you write a docstring for the following Elixir function? raise(msg)"}
{"completion":"Not equal to operator.\n\nReturns `true` if the two terms are not equal.\n\nThis operator considers 1 and 1.0 to be equal. For match\ncomparison, use `!==/2` instead.\n\nAll terms in Elixir can be compared with each other.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 != 2\n    true\n\n    iex> 1 != 1.0\n    false","prompt":"Can you write a docstring for the following Elixir function? left != right"}
{"completion":"Strictly not equal to operator.\n\nReturns `true` if the two terms are not exactly equal.\nSee `===/2` for a definition of what is considered \"exactly equal\".\n\nAll terms in Elixir can be compared with each other.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 !== 2\n    true\n\n    iex> 1 !== 1.0\n    true","prompt":"Can you write a docstring for the following Elixir function? left !== right"}
{"completion":"Arithmetic multiplication operator.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 * 2\n    2","prompt":"Can you write a docstring for the following Elixir function? left * right"}
{"completion":"Power operator.\n\nIt expects two numbers are input. If the left-hand side is an integer\nand the right-hand side is more than or equal to 0, then the result is\ninteger. Otherwise it returns a float.\n\n## Examples\n\n    iex> 2 ** 2\n    4\n    iex> 2 ** -4\n    0.0625\n\n    iex> 2.0 ** 2\n    4.0\n    iex> 2 ** 2.0\n    4.0","prompt":"Can you write a docstring for the following Elixir function? base ** exponent"}
{"completion":"Arithmetic positive unary operator.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> +1\n    1","prompt":"Can you write a docstring for the following Elixir function? +value"}
{"completion":"Arithmetic addition operator.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 + 2\n    3","prompt":"Can you write a docstring for the following Elixir function? left + right"}
{"completion":"List concatenation operator. Concatenates a proper list and a term, returning a list.\n\nThe complexity of `a ++ b` is proportional to `length(a)`, so avoid repeatedly\nappending to lists of arbitrary length, for example, `list ++ [element]`.\nInstead, consider prepending via `[element | rest]` and then reversing.\n\nIf the `right` operand is not a proper list, it returns an improper list.\nIf the `left` operand is not a proper list, it raises `ArgumentError`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> [1] ++ [2, 3]\n    [1, 2, 3]\n\n    iex> 'foo' ++ 'bar'\n    'foobar'\n\n    # returns an improper list\n    iex> [1] ++ 2\n    [1 | 2]\n\n    # returns a proper list\n    iex> [1] ++ [2]\n    [1, 2]\n\n    # improper list on the right will return an improper list\n    iex> [1] ++ [2 | 3]\n    [1, 2 | 3]","prompt":"Can you write a docstring for the following Elixir function? left ++ right"}
{"completion":"Arithmetic negative unary operator.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> -2\n    -2","prompt":"Can you write a docstring for the following Elixir function? -value"}
{"completion":"Arithmetic subtraction operator.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 - 2\n    -1","prompt":"Can you write a docstring for the following Elixir function? left - right"}
{"completion":"List subtraction operator. Removes the first occurrence of an element\non the left list for each element on the right.\n\nThis function is optimized so the complexity of `a -- b` is proportional\nto `length(a) * log(length(b))`. See also the [Erlang efficiency\nguide](https://www.erlang.org/doc/efficiency_guide/retired_myths.html).\n\nInlined by the compiler.\n\n## Examples\n\n    iex> [1, 2, 3] -- [1, 2]\n    [3]\n\n    iex> [1, 2, 3, 2, 1] -- [1, 2, 2]\n    [3, 1]\n\nThe `--/2` operator is right associative, meaning:\n\n    iex> [1, 2, 3] -- [2] -- [3]\n    [1, 3]\n\nAs it is equivalent to:\n\n    iex> [1, 2, 3] -- ([2] -- [3])\n    [1, 3]","prompt":"Can you write a docstring for the following Elixir function? left -- right"}
{"completion":"Arithmetic division operator.\n\nThe result is always a float. Use `div/2` and `rem/2` if you want\nan integer division or the remainder.\n\nRaises `ArithmeticError` if `right` is 0 or 0.0.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    1 / 2\n    #=> 0.5\n\n    -3.0 / 2.0\n    #=> -1.5\n\n    5 / 1\n    #=> 5.0\n\n    7 / 0\n    ** (ArithmeticError) bad argument in arithmetic expression","prompt":"Can you write a docstring for the following Elixir function? left / right"}
{"completion":"Less-than operator.\n\nReturns `true` if `left` is less than `right`.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\" section](#module-structural-comparison) section\nfor more information.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 < 2\n    true","prompt":"Can you write a docstring for the following Elixir function? left < right"}
{"completion":"Less-than or equal to operator.\n\nReturns `true` if `left` is less than or equal to `right`.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\" section](#module-structural-comparison) section\nfor more information.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 <= 2\n    true","prompt":"Can you write a docstring for the following Elixir function? left <= right"}
{"completion":"Equal to operator. Returns `true` if the two terms are equal.\n\nThis operator considers 1 and 1.0 to be equal. For stricter\nsemantics, use `===/2` instead.\n\nAll terms in Elixir can be compared with each other.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 == 2\n    false\n\n    iex> 1 == 1.0\n    true","prompt":"Can you write a docstring for the following Elixir function? left == right"}
{"completion":"Strictly equal to operator.\n\nReturns `true` if the two terms are exactly equal.\n\nThe terms are only considered to be exactly equal if they\nhave the same value and are of the same type. For example,\n`1 == 1.0` returns `true`, but since they are of different\ntypes, `1 === 1.0` returns `false`.\n\nAll terms in Elixir can be compared with each other.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 === 2\n    false\n\n    iex> 1 === 1.0\n    false","prompt":"Can you write a docstring for the following Elixir function? left === right"}
{"completion":"Text-based match operator. Matches the term on the `left`\nagainst the regular expression or string on the `right`.\n\nIf `right` is a regular expression, returns `true` if `left` matches right.\n\nIf `right` is a string, returns `true` if `left` contains `right`.\n\n## Examples\n\n    iex> \"abcd\" =~ ~r/c(d)/\n    true\n\n    iex> \"abcd\" =~ ~r/e/\n    false\n\n    iex> \"abcd\" =~ ~r//\n    true\n\n    iex> \"abcd\" =~ \"bc\"\n    true\n\n    iex> \"abcd\" =~ \"ad\"\n    false\n\n    iex> \"abcd\" =~ \"abcd\"\n    true\n\n    iex> \"abcd\" =~ \"\"\n    true\n\nFor more information about regular expressions, please check the `Regex` module.","prompt":"Can you write a docstring for the following Elixir function? left =~ right"}
{"completion":"Greater-than operator.\n\nReturns `true` if `left` is more than `right`.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\" section](#module-structural-comparison) section\nfor more information.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 > 2\n    false","prompt":"Can you write a docstring for the following Elixir function? left > right"}
{"completion":"Greater-than or equal to operator.\n\nReturns `true` if `left` is more than or equal to `right`.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\" section](#module-structural-comparison) section\nfor more information.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 >= 2\n    false","prompt":"Can you write a docstring for the following Elixir function? left >= right"}
{"completion":"Returns an integer or float which is the arithmetical absolute value of `number`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> abs(-3.33)\n    3.33\n\n    iex> abs(-3)\n    3","prompt":"Can you write a docstring for the following Elixir function? abs(number)"}
{"completion":"Invokes the given anonymous function `fun` with the list of\narguments `args`.\n\nIf the number of arguments is known at compile time, prefer\n`fun.(arg_1, arg_2, ..., arg_n)` as it is clearer than\n`apply(fun, [arg_1, arg_2, ..., arg_n])`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> apply(fn x -> x * 2 end, [2])\n    4","prompt":"Can you write a docstring for the following Elixir function? apply(fun, args)"}
{"completion":"Invokes the given function from `module` with the list of\narguments `args`.\n\n`apply/3` is used to invoke functions where the module, function\nname or arguments are defined dynamically at runtime. For this\nreason, you can't invoke macros using `apply/3`, only functions.\n\nIf the number of arguments and the function name are known at compile time,\nprefer `module.function(arg_1, arg_2, ..., arg_n)` as it is clearer than\n`apply(module, :function, [arg_1, arg_2, ..., arg_n])`.\n\n`apply/3` cannot be used to call private functions.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> apply(Enum, :reverse, [[1, 2, 3]])\n    [3, 2, 1]","prompt":"Can you write a docstring for the following Elixir function? apply(module, function_name, args)"}
{"completion":"Extracts the part of the binary starting at `start` with length `length`.\nBinaries are zero-indexed.\n\nIf `start` or `length` reference in any way outside the binary, an\n`ArgumentError` exception is raised.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> binary_part(\"foo\", 1, 2)\n    \"oo\"\n\nA negative `length` can be used to extract bytes that come *before* the byte\nat `start`:\n\n    iex> binary_part(\"Hello\", 5, -3)\n    \"llo\"\n\nAn `ArgumentError` is raised when the length is outside of the binary:\n\n    binary_part(\"Hello\", 0, 10)\n    ** (ArgumentError) argument error","prompt":"Can you write a docstring for the following Elixir function? binary_part(binary, start, length)"}
{"completion":"Returns a binary from the offset given by the start of the\nrange to the offset given by the end of the range.\n\nIf the start or end of the range are negative, they are converted\ninto positive indices based on the binary size. For example,\n`-1` means the last byte of the binary.\n\nThis is similar to `binary_part/3` except that it works with ranges\nand it is not allowed in guards.\n\nThis function works with bytes. For a slicing operation that\nconsiders characters, see `String.slice/2`.\n\n## Examples\n\n    iex> binary_slice(\"elixir\", 0..5)\n    \"elixir\"\n    iex> binary_slice(\"elixir\", 1..3)\n    \"lix\"\n    iex> binary_slice(\"elixir\", 1..10)\n    \"lixir\"\n\n    iex> binary_slice(\"elixir\", -4..-1)\n    \"ixir\"\n    iex> binary_slice(\"elixir\", -4..6)\n    \"ixir\"\n    iex> binary_slice(\"elixir\", -10..10)\n    \"elixir\"\n\nFor ranges where `start > stop`, you need to explicitly\nmark them as increasing:\n\n    iex> binary_slice(\"elixir\", 2..-1//1)\n    \"ixir\"\n    iex> binary_slice(\"elixir\", 1..-2//1)\n    \"lixi\"\n\nYou can use `../0` as a shortcut for `0..-1//1`, which returns\nthe whole binary as is:\n\n    iex> binary_slice(\"elixir\", ..)\n    \"elixir\"\n\nThe step can be any positive number. For example, to\nget every 2 characters of the binary:\n\n    iex> binary_slice(\"elixir\", 0..-1//2)\n    \"eii\"\n\nIf the first position is after the string ends or after\nthe last position of the range, it returns an empty string:\n\n    iex> binary_slice(\"elixir\", 10..3//1)\n    \"\"\n    iex> binary_slice(\"elixir\", -10..-7)\n    \"\"\n    iex> binary_slice(\"a\", 1..1500)\n    \"\"","prompt":"Can you write a docstring for the following Elixir function? binary_slice(binary, range)"}
{"completion":"Returns a binary starting at the offset `start` and of the given `size`.\n\nThis is similar to `binary_part/3` except that if `start + size`\nis greater than the binary size, it automatically clips it to\nthe binary size instead of raising. Opposite to `binary_part/3`,\nthis function is not allowed in guards.\n\nThis function works with bytes. For a slicing operation that\nconsiders characters, see `String.slice/3`.\n\n## Examples\n\n    iex> binary_slice(\"elixir\", 0, 6)\n    \"elixir\"\n    iex> binary_slice(\"elixir\", 0, 5)\n    \"elixi\"\n    iex> binary_slice(\"elixir\", 1, 4)\n    \"lixi\"\n    iex> binary_slice(\"elixir\", 0, 10)\n    \"elixir\"\n\nIf `start` is negative, it is normalized against the binary\nsize and clamped to 0:\n\n    iex> binary_slice(\"elixir\", -3, 10)\n    \"xir\"\n    iex> binary_slice(\"elixir\", -10, 10)\n    \"elixir\"\n\nIf the `size` is zero, an empty binary is returned:\n\n    iex> binary_slice(\"elixir\", 1, 0)\n    \"\"\n\nIf `start` is greater than or equal to the binary size,\nan empty binary is returned:\n\n    iex> binary_slice(\"elixir\", 10, 10)\n    \"\"","prompt":"Can you write a docstring for the following Elixir function? binary_slice(binary, start, size)"}
{"completion":"Returns an integer which is the size in bits of `bitstring`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> bit_size(<<433::16, 3::3>>)\n    19\n\n    iex> bit_size(<<1, 2, 3>>)\n    24","prompt":"Can you write a docstring for the following Elixir function? bit_size(bitstring)"}
{"completion":"Returns the number of bytes needed to contain `bitstring`.\n\nThat is, if the number of bits in `bitstring` is not divisible by 8, the\nresulting number of bytes will be rounded up (by excess). This operation\nhappens in constant time.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> byte_size(<<433::16, 3::3>>)\n    3\n\n    iex> byte_size(<<1, 2, 3>>)\n    3","prompt":"Can you write a docstring for the following Elixir function? byte_size(bitstring)"}
{"completion":"Returns the smallest integer greater than or equal to `number`.\n\nIf you want to perform ceil operation on other decimal places,\nuse `Float.ceil/2` instead.\n\nAllowed in guard tests. Inlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? ceil(number)"}
{"completion":"Performs an integer division.\n\nRaises an `ArithmeticError` exception if one of the arguments is not an\ninteger, or when the `divisor` is `0`.\n\n`div/2` performs *truncated* integer division. This means that\nthe result is always rounded towards zero.\n\nIf you want to perform floored integer division (rounding towards negative infinity),\nuse `Integer.floor_div/2` instead.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    div(5, 2)\n    #=> 2\n\n    div(6, -4)\n    #=> -1\n\n    div(-99, 2)\n    #=> -49\n\n    div(100, 0)\n    ** (ArithmeticError) bad argument in arithmetic expression","prompt":"Can you write a docstring for the following Elixir function? div(dividend, divisor)"}
{"completion":"Gets the element at the zero-based `index` in `tuple`.\n\nIt raises `ArgumentError` when index is negative or it is out of range of the tuple elements.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    tuple = {:foo, :bar, 3}\n    elem(tuple, 1)\n    #=> :bar\n\n    elem({}, 0)\n    ** (ArgumentError) argument error\n\n    elem({:foo, :bar}, 2)\n    ** (ArgumentError) argument error","prompt":"Can you write a docstring for the following Elixir function? elem(tuple, index)"}
{"completion":"Stops the execution of the calling process with the given reason.\n\nSince evaluating this function causes the process to terminate,\nit has no return value.\n\nInlined by the compiler.\n\n## Examples\n\nWhen a process reaches its end, by default it exits with\nreason `:normal`. You can also call `exit/1` explicitly if you\nwant to terminate a process but not signal any failure:\n\n    exit(:normal)\n\nIn case something goes wrong, you can also use `exit/1` with\na different reason:\n\n    exit(:seems_bad)\n\nIf the exit reason is not `:normal`, all the processes linked to the process\nthat exited will crash (unless they are trapping exits).\n\n## OTP exits\n\nExits are used by the OTP to determine if a process exited abnormally\nor not. The following exits are considered \"normal\":\n\n  * `exit(:normal)`\n  * `exit(:shutdown)`\n  * `exit({:shutdown, term})`\n\nExiting with any other reason is considered abnormal and treated\nas a crash. This means the default supervisor behaviour kicks in,\nerror reports are emitted, and so forth.\n\nThis behaviour is relied on in many different places. For example,\n`ExUnit` uses `exit(:shutdown)` when exiting the test process to\nsignal linked processes, supervision trees and so on to politely\nshut down too.\n\n## CLI exits\n\nBuilding on top of the exit signals mentioned above, if the\nprocess started by the command line exits with any of the three\nreasons above, its exit is considered normal and the Operating\nSystem process will exit with status 0.\n\nIt is, however, possible to customize the operating system exit\nsignal by invoking:\n\n    exit({:shutdown, integer})\n\nThis will cause the operating system process to exit with the status given by\n`integer` while signaling all linked Erlang processes to politely\nshut down.\n\nAny other exit reason will cause the operating system process to exit with\nstatus `1` and linked Erlang processes to crash.","prompt":"Can you write a docstring for the following Elixir function? exit(reason)"}
{"completion":"Returns the largest integer smaller than or equal to `number`.\n\nIf you want to perform floor operation on other decimal places,\nuse `Float.floor/2` instead.\n\nAllowed in guard tests. Inlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? floor(number)"}
{"completion":"Returns `true` if `module` is loaded and contains a\npublic `function` with the given `arity`, otherwise `false`.\n\nNote that this function does not load the module in case\nit is not loaded. Check `Code.ensure_loaded/1` for more\ninformation.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> function_exported?(Enum, :map, 2)\n    true\n\n    iex> function_exported?(Enum, :map, 10)\n    false\n\n    iex> function_exported?(List, :to_string, 1)\n    true","prompt":"Can you write a docstring for the following Elixir function? function_exported?(module, function, arity)"}
{"completion":"Gets a value and updates a nested structure.\n\n`data` is a nested structure (that is, a map, keyword\nlist, or struct that implements the `Access` behaviour).\n\nThe `fun` argument receives the value of `key` (or `nil` if `key`\nis not present) and must return one of the following values:\n\n  * a two-element tuple `{current_value, new_value}`. In this case,\n    `current_value` is the retrieved value which can possibly be operated on before\n    being returned. `new_value` is the new value to be stored under `key`.\n\n  * `:pop`, which implies that the current value under `key`\n    should be removed from the structure and returned.\n\nThis function uses the `Access` module to traverse the structures\naccording to the given `keys`, unless the `key` is a function,\nwhich is detailed in a later section.\n\n## Examples\n\nThis function is useful when there is a need to retrieve the current\nvalue (or something calculated in function of the current value) and\nupdate it at the same time. For example, it could be used to read the\ncurrent age of a user while increasing it by one in one pass:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> get_and_update_in(users, [\"john\", :age], &{&1, &1 + 1})\n    {27, %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}}\n\nNote the current value given to the anonymous function may be `nil`.\nIf any of the intermediate values are nil, it will raise:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> get_and_update_in(users, [\"jane\", :age], &{&1, &1 + 1})\n    ** (ArgumentError) could not put/update key :age on a nil value\n\n## Functions as keys\n\nIf a key is a function, the function will be invoked passing three\narguments:\n\n  * the operation (`:get_and_update`)\n  * the data to be accessed\n  * a function to be invoked next\n\nThis means `get_and_update_in/3` can be extended to provide custom\nlookups. The downside is that functions cannot be stored as keys\nin the accessed data structures.\n\nWhen one of the keys is a function, the function is invoked.\nIn the example below, we use a function to get and increment all\nages inside a list:\n\n    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n    iex> all = fn :get_and_update, data, next ->\n    ...>   data |> Enum.map(next) |> Enum.unzip()\n    ...> end\n    iex> get_and_update_in(users, [all, :age], &{&1, &1 + 1})\n    {[27, 23], [%{name: \"john\", age: 28}, %{name: \"meg\", age: 24}]}\n\nIf the previous value before invoking the function is `nil`,\nthe function *will* receive `nil` as a value and must handle it\naccordingly (be it by failing or providing a sane default).\n\nThe `Access` module ships with many convenience accessor functions,\nlike the `all` anonymous function defined above. See `Access.all/0`,\n`Access.key/2`, and others as examples.","prompt":"Can you write a docstring for the following Elixir function? get_and_update_in(data, keys, fun)"}
{"completion":"Gets a value from a nested structure.\n\nUses the `Access` module to traverse the structures\naccording to the given `keys`, unless the `key` is a\nfunction, which is detailed in a later section.\n\nNote that if none of the given keys are functions,\nthere is rarely a reason to use `get_in` over\nwriting \"regular\" Elixir code using `[]`.\n\n## Examples\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> get_in(users, [\"john\", :age])\n    27\n    iex> # Equivalent to:\n    iex> users[\"john\"][:age]\n    27\n\n`get_in/2` can also use the accessors in the `Access` module\nto traverse more complex data structures. For example, here we\nuse `Access.all/0` to traverse a list:\n\n    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n    iex> get_in(users, [Access.all(), :age])\n    [27, 23]\n\nIn case any of the components returns `nil`, `nil` will be returned\nand `get_in/2` won't traverse any further:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> get_in(users, [\"unknown\", :age])\n    nil\n    iex> # Equivalent to:\n    iex> users[\"unknown\"][:age]\n    nil\n\n    iex> users = nil\n    iex> get_in(users, [Access.all(), :age])\n    nil\n\nAlternatively, if you need to access complex data-structures, you can\nuse pattern matching:\n\n    case users do\n      %{\"john\" => %{age: age}} -> age\n      _ -> default_value\n    end\n\n## Functions as keys\n\nIf a key given to `get_in/2` is a function, the function will be invoked\npassing three arguments:\n\n  * the operation (`:get`)\n  * the data to be accessed\n  * a function to be invoked next\n\nThis means `get_in/2` can be extended to provide custom lookups.\nThat's precisely how the `Access.all/0` key in the previous section\nbehaves. For example, we can manually implement such traversal as\nfollows:\n\n    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n    iex> all = fn :get, data, next -> Enum.map(data, next) end\n    iex> get_in(users, [all, :age])\n    [27, 23]\n\nThe `Access` module ships with many convenience accessor functions.\nSee `Access.all/0`, `Access.key/2`, and others as examples.\n\n## Working with structs\n\nBy default, structs do not implement the `Access` behaviour required\nby this function. Therefore, you can't do this:\n\n    get_in(some_struct, [:some_key, :nested_key])\n\nThe good news is that structs have predefined shape. Therefore,\nyou can write instead:\n\n    some_struct.some_key.nested_key\n\nIf, by any chance, `some_key` can return nil, you can always\nfallback to pattern matching to provide nested struct handling:\n\n    case some_struct do\n      %{some_key: %{nested_key: value}} -> value\n      %{} -> nil\n    end","prompt":"Can you write a docstring for the following Elixir function? get_in(data, keys)"}
{"completion":"Returns the head of a list. Raises `ArgumentError` if the list is empty.\n\nThe head of a list is its first element.\n\nIt works with improper lists.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    hd([1, 2, 3, 4])\n    #=> 1\n\n    hd([1 | 2])\n    #=> 1\n\nGiving it an empty list raises:\n\n    hd([])\n    #=> ** (ArgumentError) argument error","prompt":"Can you write a docstring for the following Elixir function? hd(list)"}
{"completion":"Inspects the given argument according to the `Inspect` protocol.\nThe second argument is a keyword list with options to control\ninspection.\n\n## Options\n\n`inspect/2` accepts a list of options that are internally\ntranslated to an `Inspect.Opts` struct. Check the docs for\n`Inspect.Opts` to see the supported options.\n\n## Examples\n\n    iex> inspect(:foo)\n    \":foo\"\n\n    iex> inspect([1, 2, 3, 4, 5], limit: 3)\n    \"[1, 2, 3, ...]\"\n\n    iex> inspect([1, 2, 3], pretty: true, width: 0)\n    \"[1,\\n 2,\\n 3]\"\n\n    iex> inspect(\"ol\" <> <<0>>)\n    \"<<111, 108, 195, 161, 0>>\"\n\n    iex> inspect(\"ol\" <> <<0>>, binaries: :as_strings)\n    \"\\\"ol\\\\0\\\"\"\n\n    iex> inspect(\"ol\", binaries: :as_binaries)\n    \"<<111, 108, 195, 161>>\"\n\n    iex> inspect('bar')\n    \"'bar'\"\n\n    iex> inspect([0 | 'bar'])\n    \"[0, 98, 97, 114]\"\n\n    iex> inspect(100, base: :octal)\n    \"0o144\"\n\n    iex> inspect(100, base: :hex)\n    \"0x64\"\n\nNote that the `Inspect` protocol does not necessarily return a valid\nrepresentation of an Elixir term. In such cases, the inspected result\nmust start with `#`. For example, inspecting a function will return:\n\n    inspect(fn a, b -> a + b end)\n    #=> #Function<...>\n\nThe `Inspect` protocol can be derived to hide certain fields\nfrom structs, so they don't show up in logs, inspects and similar.\nSee the \"Deriving\" section of the documentation of the `Inspect`\nprotocol for more information.","prompt":"Can you write a docstring for the following Elixir function? inspect(term, opts \\\\ [])"}
{"completion":"Returns `true` if `term` is an atom; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> is_atom(false)\n    true\n\n    iex> is_atom(:name)\n    true\n\n    iex> is_atom(AnAtom)\n    true\n\n    iex> is_atom(\"true\")\n    false","prompt":"Can you write a docstring for the following Elixir function? is_atom(term)"}
{"completion":"Returns `true` if `term` is a binary; otherwise returns `false`.\n\nA binary always contains a complete number of bytes.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> is_binary(\"foo\")\n    true\n    iex> is_binary(<<1::3>>)\n    false","prompt":"Can you write a docstring for the following Elixir function? is_binary(term)"}
{"completion":"Returns `true` if `term` is a bitstring (including a binary); otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> is_bitstring(\"foo\")\n    true\n    iex> is_bitstring(<<1::3>>)\n    true","prompt":"Can you write a docstring for the following Elixir function? is_bitstring(term)"}
{"completion":"Returns `true` if `term` is either the atom `true` or the atom `false` (i.e.,\na boolean); otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> is_boolean(false)\n    true\n\n    iex> is_boolean(true)\n    true\n\n    iex> is_boolean(:test)\n    false","prompt":"Can you write a docstring for the following Elixir function? is_boolean(term)"}
{"completion":"Returns `true` if `term` is a floating-point number; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? is_float(term)"}
{"completion":"Returns `true` if `term` is a function; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> is_function(fn x -> x + x end)\n    true\n\n    iex> is_function(\"not a function\")\n    false","prompt":"Can you write a docstring for the following Elixir function? is_function(term)"}
{"completion":"Returns `true` if `term` is a function that can be applied with `arity` number of arguments;\notherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> is_function(fn x -> x * 2 end, 1)\n    true\n    iex> is_function(fn x -> x * 2 end, 2)\n    false","prompt":"Can you write a docstring for the following Elixir function? is_function(term, arity)"}
{"completion":"Returns `true` if `term` is an integer; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? is_integer(term)"}
{"completion":"Returns `true` if `term` is a list with zero or more elements; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? is_list(term)"}
{"completion":"Returns `true` if `term` is a map; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? is_map(term)"}
{"completion":"Returns `true` if `key` is a key in `map`; otherwise returns `false`.\n\nIt raises `BadMapError` if the first element is not a map.\n\nAllowed in guard tests. Inlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? is_map_key(map, key)"}
{"completion":"Returns `true` if `term` is either an integer or a floating-point number;\notherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? is_number(term)"}
{"completion":"Returns `true` if `term` is a PID (process identifier); otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? is_pid(term)"}
{"completion":"Returns `true` if `term` is a port identifier; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? is_port(term)"}
{"completion":"Returns `true` if `term` is a reference; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? is_reference(term)"}
{"completion":"Returns `true` if `term` is a tuple; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? is_tuple(term)"}
{"completion":"Returns the length of `list`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> length([1, 2, 3, 4, 5, 6, 7, 8, 9])\n    9","prompt":"Can you write a docstring for the following Elixir function? length(list)"}
{"completion":"Returns `true` if `module` is loaded and contains a\npublic `macro` with the given `arity`, otherwise `false`.\n\nNote that this function does not load the module in case\nit is not loaded. Check `Code.ensure_loaded/1` for more\ninformation.\n\nIf `module` is an Erlang module (as opposed to an Elixir module), this\nfunction always returns `false`.\n\n## Examples\n\n    iex> macro_exported?(Kernel, :use, 2)\n    true\n\n    iex> macro_exported?(:erlang, :abs, 1)\n    false","prompt":"Can you write a docstring for the following Elixir function? macro_exported?(module, macro, arity)"}
{"completion":"Returns an almost unique reference.\n\nThe returned reference will re-occur after approximately 2^82 calls;\ntherefore it is unique enough for practical purposes.\n\nInlined by the compiler.\n\n## Examples\n\n    make_ref()\n    #=> #Reference<0.0.0.135>","prompt":"Can you write a docstring for the following Elixir function? make_ref()"}
{"completion":"Returns the size of a map.\n\nThe size of a map is the number of key-value pairs that the map contains.\n\nThis operation happens in constant time.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> map_size(%{a: \"foo\", b: \"bar\"})\n    2","prompt":"Can you write a docstring for the following Elixir function? map_size(map)"}
{"completion":"Returns the biggest of the two given terms according to\ntheir structural comparison.\n\nIf the terms compare equal, the first one is returned.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\" section](#module-structural-comparison) section\nfor more information.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> max(1, 2)\n    2\n    iex> max(:a, :b)\n    :b","prompt":"Can you write a docstring for the following Elixir function? max(first, second)"}
{"completion":"Returns the smallest of the two given terms according to\ntheir structural comparison.\n\nIf the terms compare equal, the first one is returned.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\" section](#module-structural-comparison) section\nfor more information.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> min(1, 2)\n    1\n    iex> min(\"foo\", \"bar\")\n    \"bar\"","prompt":"Can you write a docstring for the following Elixir function? min(first, second)"}
{"completion":"Returns an atom representing the name of the local node.\nIf the node is not alive, `:nonode@nohost` is returned instead.\n\nAllowed in guard tests. Inlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? node()"}
{"completion":"Returns the node where the given argument is located.\nThe argument can be a PID, a reference, or a port.\nIf the local node is not alive, `:nonode@nohost` is returned.\n\nAllowed in guard tests. Inlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? node(arg)"}
{"completion":"Strictly boolean \"not\" operator.\n\n`value` must be a boolean; if it's not, an `ArgumentError` exception is raised.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> not false\n    true","prompt":"Can you write a docstring for the following Elixir function? not value"}
{"completion":"Pops a key from the given nested structure.\n\nUses the `Access` protocol to traverse the structures\naccording to the given `keys`, unless the `key` is a\nfunction. If the key is a function, it will be invoked\nas specified in `get_and_update_in/3`.\n\n## Examples\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> pop_in(users, [\"john\", :age])\n    {27, %{\"john\" => %{}, \"meg\" => %{age: 23}}}\n\nIn case any entry returns `nil`, its key will be removed\nand the deletion will be considered a success.\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> pop_in(users, [\"jane\", :age])\n    {nil, %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}}","prompt":"Can you write a docstring for the following Elixir function? pop_in(data, keys)"}
{"completion":"Puts `value` at the given zero-based `index` in `tuple`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> tuple = {:foo, :bar, 3}\n    iex> put_elem(tuple, 0, :baz)\n    {:baz, :bar, 3}","prompt":"Can you write a docstring for the following Elixir function? put_elem(tuple, index, value)"}
{"completion":"Puts a value in a nested structure.\n\nUses the `Access` module to traverse the structures\naccording to the given `keys`, unless the `key` is a\nfunction. If the key is a function, it will be invoked\nas specified in `get_and_update_in/3`.\n\n## Examples\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> put_in(users, [\"john\", :age], 28)\n    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n\nIf any of the intermediate values are nil, it will raise:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> put_in(users, [\"jane\", :age], \"oops\")\n    ** (ArgumentError) could not put/update key :age on a nil value","prompt":"Can you write a docstring for the following Elixir function? put_in(data, keys, value)"}
{"completion":"Computes the remainder of an integer division.\n\n`rem/2` uses truncated division, which means that\nthe result will always have the sign of the `dividend`.\n\nRaises an `ArithmeticError` exception if one of the arguments is not an\ninteger, or when the `divisor` is `0`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> rem(5, 2)\n    1\n    iex> rem(6, -4)\n    2","prompt":"Can you write a docstring for the following Elixir function? rem(dividend, divisor)"}
{"completion":"Rounds a number to the nearest integer.\n\nIf the number is equidistant to the two nearest integers, rounds away from zero.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> round(5.6)\n    6\n\n    iex> round(5.2)\n    5\n\n    iex> round(-9.9)\n    -10\n\n    iex> round(-9)\n    -9\n\n    iex> round(2.5)\n    3\n\n    iex> round(-2.5)\n    -3","prompt":"Can you write a docstring for the following Elixir function? round(number)"}
{"completion":"Returns the PID (process identifier) of the calling process.\n\nAllowed in guard clauses. Inlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? self()"}
{"completion":"Sends a message to the given `dest` and returns the message.\n\n`dest` may be a remote or local PID, a local port, a locally\nregistered name, or a tuple in the form of `{registered_name, node}` for a\nregistered name at another node.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> send(self(), :hello)\n    :hello","prompt":"Can you write a docstring for the following Elixir function? send(dest, message)"}
{"completion":"Spawns the given function and returns its PID.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions.\n\nThe anonymous function receives 0 arguments, and may return any value.\n\nInlined by the compiler.\n\n## Examples\n\n    current = self()\n    child = spawn(fn -> send(current, {self(), 1 + 2}) end)\n\n    receive do\n      {^child, 3} -> IO.puts(\"Received 3 back\")\n    end","prompt":"Can you write a docstring for the following Elixir function? spawn(fun)"}
{"completion":"Spawns the given function `fun` from the given `module` passing it the given\n`args` and returns its PID.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions.\n\nInlined by the compiler.\n\n## Examples\n\n    spawn(SomeModule, :function, [1, 2, 3])","prompt":"Can you write a docstring for the following Elixir function? spawn(module, fun, args)"}
{"completion":"Spawns the given function, links it to the current process, and returns its PID.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions. For more\ninformation on linking, check `Process.link/1`.\n\nThe anonymous function receives 0 arguments, and may return any value.\n\nInlined by the compiler.\n\n## Examples\n\n    current = self()\n    child = spawn_link(fn -> send(current, {self(), 1 + 2}) end)\n\n    receive do\n      {^child, 3} -> IO.puts(\"Received 3 back\")\n    end","prompt":"Can you write a docstring for the following Elixir function? spawn_link(fun)"}
{"completion":"Spawns the given function `fun` from the given `module` passing it the given\n`args`, links it to the current process, and returns its PID.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions. For more\ninformation on linking, check `Process.link/1`.\n\nInlined by the compiler.\n\n## Examples\n\n    spawn_link(SomeModule, :function, [1, 2, 3])","prompt":"Can you write a docstring for the following Elixir function? spawn_link(module, fun, args)"}
{"completion":"Spawns the given function, monitors it and returns its PID\nand monitoring reference.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions.\n\nThe anonymous function receives 0 arguments, and may return any value.\n\nInlined by the compiler.\n\n## Examples\n\n    current = self()\n    spawn_monitor(fn -> send(current, {self(), 1 + 2}) end)","prompt":"Can you write a docstring for the following Elixir function? spawn_monitor(fun)"}
{"completion":"Spawns the given module and function passing the given args,\nmonitors it and returns its PID and monitoring reference.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions.\n\nInlined by the compiler.\n\n## Examples\n\n    spawn_monitor(SomeModule, :function, [1, 2, 3])","prompt":"Can you write a docstring for the following Elixir function? spawn_monitor(module, fun, args)"}
{"completion":"Creates and updates a struct.\n\nThe `struct` argument may be an atom (which defines `defstruct`)\nor a `struct` itself. The second argument is any `Enumerable` that\nemits two-element tuples (key-value pairs) during enumeration.\n\nKeys in the `Enumerable` that don't exist in the struct are automatically\ndiscarded. Note that keys must be atoms, as only atoms are allowed when\ndefining a struct. If keys in the `Enumerable` are duplicated, the last\nentry will be taken (same behaviour as `Map.new/1`).\n\nThis function is useful for dynamically creating and updating structs, as\nwell as for converting maps to structs; in the latter case, just inserting\nthe appropriate `:__struct__` field into the map may not be enough and\n`struct/2` should be used instead.\n\n## Examples\n\n    defmodule User do\n      defstruct name: \"john\"\n    end\n\n    struct(User)\n    #=> %User{name: \"john\"}\n\n    opts = [name: \"meg\"]\n    user = struct(User, opts)\n    #=> %User{name: \"meg\"}\n\n    struct(user, unknown: \"value\")\n    #=> %User{name: \"meg\"}\n\n    struct(User, %{name: \"meg\"})\n    #=> %User{name: \"meg\"}\n\n    # String keys are ignored\n    struct(User, %{\"name\" => \"meg\"})\n    #=> %User{name: \"john\"}","prompt":"Can you write a docstring for the following Elixir function? struct(struct, fields \\\\ [])"}
{"completion":"Similar to `struct/2` but checks for key validity.\n\nThe function `struct!/2` emulates the compile time behaviour\nof structs. This means that:\n\n  * when building a struct, as in `struct!(SomeStruct, key: :value)`,\n    it is equivalent to `%SomeStruct{key: :value}` and therefore this\n    function will check if every given key-value belongs to the struct.\n    If the struct is enforcing any key via `@enforce_keys`, those will\n    be enforced as well;\n\n  * when updating a struct, as in `struct!(%SomeStruct{}, key: :value)`,\n    it is equivalent to `%SomeStruct{struct | key: :value}` and therefore this\n    function will check if every given key-value belongs to the struct.\n    However, updating structs does not enforce keys, as keys are enforced\n    only when building;","prompt":"Can you write a docstring for the following Elixir function? struct!(struct, fields \\\\ [])"}
{"completion":"A non-local return from a function.\n\nUsing `throw/1` is generally discouraged, as it allows a function\nto escape from its regular execution flow, which can make the code\nharder to read. Furthermore, all thrown values must be caught by\n`try/catch`. See `try/1` for more information.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? throw(term)"}
{"completion":"Returns the tail of a list. Raises `ArgumentError` if the list is empty.\n\nThe tail of a list is the list without its first element.\n\nIt works with improper lists.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    tl([1, 2, 3, :go])\n    #=> [2, 3, :go]\n\n    tl([:one])\n    #=> []\n\n    tl([:a, :b | :improper_end])\n    #=> [:b | :improper_end]\n\n    tl([:a | %{b: 1}])\n    #=> %{b: 1}\n\nGiving it an empty list raises:\n\n    tl([])\n    #=> ** (ArgumentError) argument error","prompt":"Can you write a docstring for the following Elixir function? tl(list)"}
{"completion":"Returns the integer part of `number`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> trunc(5.4)\n    5\n\n    iex> trunc(-5.99)\n    -5\n\n    iex> trunc(-5)\n    -5","prompt":"Can you write a docstring for the following Elixir function? trunc(number)"}
{"completion":"Returns the size of a tuple.\n\nThis operation happens in constant time.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> tuple_size({:a, :b, :c})\n    3","prompt":"Can you write a docstring for the following Elixir function? tuple_size(tuple)"}
{"completion":"Updates a key in a nested structure.\n\nUses the `Access` module to traverse the structures\naccording to the given `keys`, unless the `key` is a\nfunction. If the key is a function, it will be invoked\nas specified in `get_and_update_in/3`.\n\n`data` is a nested structure (that is, a map, keyword\nlist, or struct that implements the `Access` behaviour).\nThe `fun` argument receives the value of `key` (or `nil`\nif `key` is not present) and the result replaces the value\nin the structure.\n\n## Examples\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> update_in(users, [\"john\", :age], &(&1 + 1))\n    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n\nNote the current value given to the anonymous function may be `nil`.\nIf any of the intermediate values are nil, it will raise:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> update_in(users, [\"jane\", :age], & &1 + 1)\n    ** (ArgumentError) could not put/update key :age on a nil value","prompt":"Can you write a docstring for the following Elixir function? update_in(data, keys, fun)"}
{"completion":"`Kernel` is Elixir's default environment.\n\nIt mainly consists of:\n\n  * basic language primitives, such as arithmetic operators, spawning of processes,\n    data type handling, and others\n  * macros for control-flow and defining new functionality (modules, functions, and the like)\n  * guard checks for augmenting pattern matching\n\nYou can invoke `Kernel` functions and macros anywhere in Elixir code\nwithout the use of the `Kernel.` prefix since they have all been\nautomatically imported. For example, in IEx, you can call:\n\n    iex> is_number(13)\n    true\n\nIf you don't want to import a function or macro from `Kernel`, use the `:except`\noption and then list the function/macro by arity:\n\n    import Kernel, except: [if: 2, unless: 2]\n\nSee `Kernel.SpecialForms.import/2` for more information on importing.\n\nElixir also has special forms that are always imported and\ncannot be skipped. These are described in `Kernel.SpecialForms`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Kernel"}
{"completion":"The standard library\n\n`Kernel` provides the basic capabilities the Elixir standard library\nis built on top of. It is recommended to explore the standard library\nfor advanced functionality. Here are the main groups of modules in the\nstandard library (this list is not a complete reference, see the\ndocumentation sidebar for all entries).","prompt":"Can you write a docstring for the following Elixir function? Elixir.Kernel"}
{"completion":"# Built-in types\n\nThe following modules handle Elixir built-in data types:\n\n  * `Atom` - literal constants with a name (`true`, `false`, and `nil` are atoms)\n  * `Float` - numbers with floating point precision\n  * `Function` - a reference to code chunk, created with the `fn/1` special form\n  * `Integer` - whole numbers (not fractions)\n  * `List` - collections of a variable number of elements (linked lists)\n  * `Map` - collections of key-value pairs\n  * `Process` - light-weight threads of execution\n  * `Port` - mechanisms to interact with the external world\n  * `Tuple` - collections of a fixed number of elements\n\nThere are two data types without an accompanying module:\n\n  * Bitstring - a sequence of bits, created with `Kernel.SpecialForms.<<>>/1`.\n    When the number of bits is divisible by 8, they are called binaries and can\n    be manipulated with Erlang's `:binary` module\n  * Reference - a unique value in the runtime system, created with `make_ref/0`","prompt":"Can you write a docstring for the following Elixir function? Elixir.Kernel"}
{"completion":"# Data types\n\nElixir also provides other data types that are built on top of the types\nlisted above. Some of them are:\n\n  * `Date` - `year-month-day` structs in a given calendar\n  * `DateTime` - date and time with time zone in a given calendar\n  * `Exception` - data raised from errors and unexpected scenarios\n  * `MapSet` - unordered collections of unique elements\n  * `NaiveDateTime` - date and time without time zone in a given calendar\n  * `Keyword` - lists of two-element tuples, often representing optional values\n  * `Range` - inclusive ranges between two integers\n  * `Regex` - regular expressions\n  * `String` - UTF-8 encoded binaries representing characters\n  * `Time` - `hour:minute:second` structs in a given calendar\n  * `URI` - representation of URIs that identify resources\n  * `Version` - representation of versions and requirements","prompt":"Can you write a docstring for the following Elixir function? Elixir.Kernel"}
{"completion":"# System modules\n\nModules that interface with the underlying system, such as:\n\n  * `IO` - handles input and output\n  * `File` - interacts with the underlying file system\n  * `Path` - manipulates file system paths\n  * `System` - reads and writes system information","prompt":"Can you write a docstring for the following Elixir function? Elixir.Kernel"}
{"completion":"# Protocols\n\nProtocols add polymorphic dispatch to Elixir. They are contracts\nimplementable by data types. See `Protocol` for more information on\nprotocols. Elixir provides the following protocols in the standard library:\n\n  * `Collectable` - collects data into a data type\n  * `Enumerable` - handles collections in Elixir. The `Enum` module\n    provides eager functions for working with collections, the `Stream`\n    module provides lazy functions\n  * `Inspect` - converts data types into their programming language\n    representation\n  * `List.Chars` - converts data types to their outside world\n    representation as charlists (non-programming based)\n  * `String.Chars` - converts data types to their outside world\n    representation as strings (non-programming based)","prompt":"Can you write a docstring for the following Elixir function? Elixir.Kernel"}
{"completion":"# Process-based and application-centric functionality\n\nThe following modules build on top of processes to provide concurrency,\nfault-tolerance, and more.\n\n  * `Agent` - a process that encapsulates mutable state\n  * `Application` - functions for starting, stopping and configuring\n    applications\n  * `GenServer` - a generic client-server API\n  * `Registry` - a key-value process-based storage\n  * `Supervisor` - a process that is responsible for starting,\n    supervising and shutting down other processes\n  * `Task` - a process that performs computations\n  * `Task.Supervisor` - a supervisor for managing tasks exclusively","prompt":"Can you write a docstring for the following Elixir function? Elixir.Kernel"}
{"completion":"# Supporting documents\n\nElixir documentation also includes supporting documents under the\n\"Pages\" section. Those are:\n\n  * [Compatibility and deprecations](compatibility-and-deprecations.md) - lists\n    compatibility between every Elixir version and Erlang/OTP, release schema;\n    lists all deprecated functions, when they were deprecated and alternatives\n  * [Library guidelines](library-guidelines.md) - general guidelines, anti-patterns,\n    and rules for those writing libraries\n  * [Naming conventions](naming-conventions.md) - naming conventions for Elixir code\n  * [Operators](operators.md) - lists all Elixir operators and their precedences\n  * [Patterns and guards](patterns-and-guards.md) - an introduction to patterns,\n    guards, and extensions\n  * [Syntax reference](syntax-reference.md) - the language syntax reference\n  * [Typespecs](typespecs.md)- types and function specifications, including list of types\n  * [Unicode syntax](unicode-syntax.md) - outlines Elixir support for Unicode\n  * [Writing documentation](writing-documentation.md) - guidelines for writing\n    documentation in Elixir","prompt":"Can you write a docstring for the following Elixir function? Elixir.Kernel"}
{"completion":"Guards\n\nThis module includes the built-in guards used by Elixir developers.\nThey are a predefined set of functions and macros that augment pattern\nmatching, typically invoked after the `when` operator. For example:\n\n    def drive(%User{age: age}) when age >= 16 do\n      ...\n    end\n\nThe clause above will only be invoked if the user's age is more than\nor equal to 16. Guards also support joining multiple conditions with\n`and` and `or`. The whole guard is true if all guard expressions will\nevaluate to `true`. A more complete introduction to guards is available\nin the [Patterns and guards](patterns-and-guards.md) page.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Kernel"}
{"completion":"Structural comparison\n\nThe comparison functions in this module perform structural comparison.\nThis means structures are compared based on their representation and\nnot on their semantic value. This is specially important for functions\nthat are meant to provide ordering, such as `>/2`, `</2`, `>=/2`,\n`<=/2`, `min/2`, and `max/2`. For example:\n\n    ~D[2017-03-31] > ~D[2017-04-01]\n\nwill return `true` because structural comparison compares the `:day`\nfield before `:month` or `:year`. Therefore, when comparing structs,\nyou often use the `compare/2` function made available by the structs\nmodules themselves:\n\n    iex> Date.compare(~D[2017-03-31], ~D[2017-04-01])\n    :lt\n\nAlternatively, you can use the functions in the `Enum` module to\nsort or compute a maximum/minimum:\n\n    iex> Enum.sort([~D[2017-03-31], ~D[2017-04-01]], Date)\n    [~D[2017-03-31], ~D[2017-04-01]]\n    iex> Enum.max([~D[2017-03-31], ~D[2017-04-01]], Date)\n    ~D[2017-04-01]","prompt":"Can you write a docstring for the following Elixir function? Elixir.Kernel"}
{"completion":"Truthy and falsy values\n\nBesides the booleans `true` and `false`, Elixir has the\nconcept of a \"truthy\" or \"falsy\" value.\n\n  *  a value is truthy when it is neither `false` nor `nil`\n  *  a value is falsy when it is either `false` or `nil`\n\nElixir has functions, like `and/2`, that *only* work with\nbooleans, but also functions that work with these\ntruthy/falsy values, like `&&/2` and `!/1`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Kernel"}
{"completion":"# Examples\n\nWe can check the truthiness of a value by using the `!/1`\nfunction twice.\n\nTruthy values:\n\n    iex> !!true\n    true\n    iex> !!5\n    true\n    iex> !![1,2]\n    true\n    iex> !!\"foo\"\n    true\n\nFalsy values (of which there are exactly two):\n\n    iex> !!false\n    false\n    iex> !!nil\n    false","prompt":"Can you write a docstring for the following Elixir function? Elixir.Kernel"}
{"completion":"Inlining\n\nSome of the functions described in this module are inlined by\nthe Elixir compiler into their Erlang counterparts in the\n[`:erlang`](`:erlang`) module.\nThose functions are called BIFs (built-in internal functions)\nin Erlang-land and they exhibit interesting properties, as some\nof them are allowed in guards and others are used for compiler\noptimizations.\n\nMost of the inlined functions can be seen in effect when\ncapturing the function:\n\n    iex> &Kernel.is_atom/1\n    &:erlang.is_atom/1\n\nThose functions will be explicitly marked in their docs as\n\"inlined by the compiler\".","prompt":"Can you write a docstring for the following Elixir function? Elixir.Kernel"}
{"completion":"Deletes the entries in the keyword list under a specific `key`.\n\nIf the `key` does not exist, it returns the keyword list unchanged.\nUse `delete_first/2` to delete just the first entry in case of\nduplicate keys.\n\n## Examples\n\n    iex> Keyword.delete([a: 1, b: 2], :a)\n    [b: 2]\n    iex> Keyword.delete([a: 1, b: 2, a: 3], :a)\n    [b: 2]\n    iex> Keyword.delete([b: 2], :a)\n    [b: 2]","prompt":"Can you write a docstring for the following Elixir function? delete(keywords, key)"}
{"completion":"Deletes the first entry in the keyword list under a specific `key`.\n\nIf the `key` does not exist, it returns the keyword list unchanged.\n\n## Examples\n\n    iex> Keyword.delete_first([a: 1, b: 2, a: 3], :a)\n    [b: 2, a: 3]\n    iex> Keyword.delete_first([b: 2], :a)\n    [b: 2]","prompt":"Can you write a docstring for the following Elixir function? delete_first(keywords, key)"}
{"completion":"Drops the given `keys` from the keyword list.\n\nRemoves duplicate keys from the new keyword list.\n\n## Examples\n\n    iex> Keyword.drop([a: 1, a: 2], [:a])\n    []\n    iex> Keyword.drop([a: 1, b: 2, c: 3], [:b, :d])\n    [a: 1, c: 3]\n    iex> Keyword.drop([a: 1, b: 2, b: 3, c: 3, a: 5], [:b, :d])\n    [a: 1, c: 3, a: 5]","prompt":"Can you write a docstring for the following Elixir function? drop(keywords, keys)"}
{"completion":"Checks if two keywords are equal.\n\nConsiders two keywords to be equal if they contain\nthe same keys and those keys contain the same values.\n\n## Examples\n\n    iex> Keyword.equal?([a: 1, b: 2], [b: 2, a: 1])\n    true\n    iex> Keyword.equal?([a: 1, b: 2], [b: 1, a: 2])\n    false\n    iex> Keyword.equal?([a: 1, b: 2, a: 3], [b: 2, a: 3, a: 1])\n    true\n\nComparison between values is done with `===/3`,\nwhich means integers are not equivalent to floats:\n\n    iex> Keyword.equal?([a: 1.0], [a: 1])\n    false","prompt":"Can you write a docstring for the following Elixir function? equal?(left, right)"}
{"completion":"Fetches the value for a specific `key` and returns it in a tuple.\n\nIf the `key` does not exist, it returns `:error`.\n\n## Examples\n\n    iex> Keyword.fetch([a: 1], :a)\n    {:ok, 1}\n    iex> Keyword.fetch([a: 1], :b)\n    :error","prompt":"Can you write a docstring for the following Elixir function? fetch(keywords, key)"}
{"completion":"Fetches the value for specific `key`.\n\nIf the `key` does not exist, it raises a `KeyError`.\n\n## Examples\n\n    iex> Keyword.fetch!([a: 1], :a)\n    1\n    iex> Keyword.fetch!([a: 1], :b)\n    ** (KeyError) key :b not found in: [a: 1]","prompt":"Can you write a docstring for the following Elixir function? fetch!(keywords, key)"}
{"completion":"Returns a keyword list containing only the entries from `keywords`\nfor which the function `fun` returns a truthy value.\n\nSee also `reject/2` which discards all entries where the function\nreturns a truthy value.\n\n## Examples\n\n    iex> Keyword.filter([one: 1, two: 2, three: 3], fn {_key, val} -> rem(val, 2) == 1 end)\n    [one: 1, three: 3]","prompt":"Can you write a docstring for the following Elixir function? filter(keywords, fun)"}
{"completion":"Builds a keyword from the given `keys` and the fixed `value`.\n\n## Examples\n\n    iex> Keyword.from_keys([:foo, :bar, :baz], :atom)\n    [foo: :atom, bar: :atom, baz: :atom]","prompt":"Can you write a docstring for the following Elixir function? from_keys(keys, value)"}
{"completion":"Gets the value under the given `key`.\n\nReturns the default value if `key` does not exist\n(`nil` if no default value is provided).\n\nIf duplicate entries exist, it returns the first one.\nUse `get_values/2` to retrieve all entries.\n\n## Examples\n\n    iex> Keyword.get([], :a)\n    nil\n    iex> Keyword.get([a: 1], :a)\n    1\n    iex> Keyword.get([a: 1], :b)\n    nil\n    iex> Keyword.get([a: 1], :b, 3)\n    3\n\nWith duplicate keys:\n\n    iex> Keyword.get([a: 1, a: 2], :a, 3)\n    1\n    iex> Keyword.get([a: 1, a: 2], :b, 3)\n    3","prompt":"Can you write a docstring for the following Elixir function? get(keywords, key, default \\\\ nil)"}
{"completion":"Gets the value from `key` and updates it, all in one pass.\n\nThe `fun` argument receives the value of `key` (or `nil` if `key`\nis not present) and must return a two-element tuple: the current value\n(the retrieved value, which can be operated on before being returned)\nand the new value to be stored under `key`. The `fun` may also\nreturn `:pop`, implying the current value shall be removed from the\nkeyword list and returned.\n\nReturns a tuple that contains the current value returned by\n`fun` and a new keyword list with the updated value under `key`.\n\n## Examples\n\n    iex> Keyword.get_and_update([a: 1], :a, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {1, [a: \"new value!\"]}\n\n    iex> Keyword.get_and_update([a: 1], :b, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {nil, [b: \"new value!\", a: 1]}\n\n    iex> Keyword.get_and_update([a: 2], :a, fn number ->\n    ...>   {2 * number, 3 * number}\n    ...> end)\n    {4, [a: 6]}\n\n    iex> Keyword.get_and_update([a: 1], :a, fn _ -> :pop end)\n    {1, []}\n\n    iex> Keyword.get_and_update([a: 1], :b, fn _ -> :pop end)\n    {nil, [a: 1]}","prompt":"Can you write a docstring for the following Elixir function? get_and_update(keywords, key, fun)"}
{"completion":"Gets the value under `key` and updates it. Raises if there is no `key`.\n\nThe `fun` argument receives the value under `key` and must return a\ntwo-element tuple: the current value (the retrieved value, which can be\noperated on before being returned) and the new value to be stored under\n`key`.\n\nReturns a tuple that contains the current value returned by\n`fun` and a new keyword list with the updated value under `key`.\n\n## Examples\n\n    iex> Keyword.get_and_update!([a: 1], :a, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {1, [a: \"new value!\"]}\n\n    iex> Keyword.get_and_update!([a: 1], :b, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    ** (KeyError) key :b not found in: [a: 1]\n\n    iex> Keyword.get_and_update!([a: 1], :a, fn _ ->\n    ...>   :pop\n    ...> end)\n    {1, []}","prompt":"Can you write a docstring for the following Elixir function? get_and_update!(keywords, key, fun)"}
{"completion":"Gets the value under the given `key`.\n\nIf `key` does not exist, lazily evaluates `fun` and returns its result.\n\nThis is useful if the default value is very expensive to calculate or\ngenerally difficult to set up and tear down again.\n\nIf duplicate entries exist, it returns the first one.\nUse `get_values/2` to retrieve all entries.\n\n## Examples\n\n    iex> keyword = [a: 1]\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   13\n    ...> end\n    iex> Keyword.get_lazy(keyword, :a, fun)\n    1\n    iex> Keyword.get_lazy(keyword, :b, fun)\n    13","prompt":"Can you write a docstring for the following Elixir function? get_lazy(keywords, key, fun)"}
{"completion":"Gets all values under a specific `key`.\n\n## Examples\n\n    iex> Keyword.get_values([], :a)\n    []\n    iex> Keyword.get_values([a: 1], :a)\n    [1]\n    iex> Keyword.get_values([a: 1, a: 2], :a)\n    [1, 2]","prompt":"Can you write a docstring for the following Elixir function? get_values(keywords, key)"}
{"completion":"Returns whether a given `key` exists in the given `keywords`.\n\n## Examples\n\n    iex> Keyword.has_key?([a: 1], :a)\n    true\n    iex> Keyword.has_key?([a: 1], :b)\n    false","prompt":"Can you write a docstring for the following Elixir function? has_key?(keywords, key)"}
{"completion":"Returns all keys from the keyword list.\n\nKeeps duplicate keys in the resulting list of keys.\n\n## Examples\n\n    iex> Keyword.keys(a: 1, b: 2)\n    [:a, :b]\n\n    iex> Keyword.keys(a: 1, b: 2, a: 3)\n    [:a, :b, :a]\n\n    iex> Keyword.keys([{:a, 1}, {\"b\", 2}, {:c, 3}])\n    ** (ArgumentError) expected a keyword list, but an entry in the list is not a two-element tuple with an atom as its first element, got: {\"b\", 2}","prompt":"Can you write a docstring for the following Elixir function? keys(keywords)"}
{"completion":"Returns `true` if `term` is a keyword list, otherwise `false`.\n\nWhen `term` is a list it is traversed to the end.\n\n## Examples\n\n    iex> Keyword.keyword?([])\n    true\n    iex> Keyword.keyword?(a: 1)\n    true\n    iex> Keyword.keyword?([{Foo, 1}])\n    true\n    iex> Keyword.keyword?([{}])\n    false\n    iex> Keyword.keyword?([:key])\n    false\n    iex> Keyword.keyword?(%{})\n    false","prompt":"Can you write a docstring for the following Elixir function? keyword?(term)"}
{"completion":"Merges two keyword lists into one.\n\nAdds all keys, including duplicate keys, given in `keywords2`\nto `keywords1`, overriding any existing ones.\n\nThere are no guarantees about the order of the keys in the returned keyword.\n\n## Examples\n\n    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4])\n    [b: 2, a: 3, d: 4]\n\n    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4, a: 5])\n    [b: 2, a: 3, d: 4, a: 5]\n\n    iex> Keyword.merge([a: 1], [2, 3])\n    ** (ArgumentError) expected a keyword list as the second argument, got: [2, 3]","prompt":"Can you write a docstring for the following Elixir function? merge(keywords1, keywords2)"}
{"completion":"Merges two keyword lists into one.\n\nAdds all keys, including duplicate keys, given in `keywords2`\nto `keywords1`. Invokes the given function to solve conflicts.\n\nIf `keywords2` has duplicate keys, it invokes the given function\nfor each matching pair in `keywords1`.\n\nThere are no guarantees about the order of the keys in the returned keyword.\n\n## Examples\n\n    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4], fn _k, v1, v2 ->\n    ...>   v1 + v2\n    ...> end)\n    [b: 2, a: 4, d: 4]\n\n    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4, a: 5], fn :a, v1, v2 ->\n    ...>   v1 + v2\n    ...> end)\n    [b: 2, a: 4, d: 4, a: 5]\n\n    iex> Keyword.merge([a: 1, b: 2, a: 3], [a: 3, d: 4, a: 5], fn :a, v1, v2 ->\n    ...>   v1 + v2\n    ...> end)\n    [b: 2, a: 4, d: 4, a: 8]\n\n    iex> Keyword.merge([a: 1, b: 2], [:a, :b], fn :a, v1, v2 ->\n    ...>   v1 + v2\n    ...> end)\n    ** (ArgumentError) expected a keyword list as the second argument, got: [:a, :b]","prompt":"Can you write a docstring for the following Elixir function? merge(keywords1, keywords2, fun)"}
{"completion":"Returns an empty keyword list, i.e. an empty list.\n\n## Examples\n\n    iex> Keyword.new()\n    []","prompt":"Can you write a docstring for the following Elixir function? new()"}
{"completion":"Creates a keyword list from an enumerable.\n\nRemoves duplicate entries and the last one prevails.\nUnlike `Enum.into(enumerable, [])`, `Keyword.new(enumerable)`\nguarantees the keys are unique.\n\n## Examples\n\n    iex> Keyword.new([{:b, 1}, {:a, 2}])\n    [b: 1, a: 2]\n\n    iex> Keyword.new([{:a, 1}, {:a, 2}, {:a, 3}])\n    [a: 3]","prompt":"Can you write a docstring for the following Elixir function? new(pairs)"}
{"completion":"Creates a keyword list from an enumerable via the transformation function.\n\nRemoves duplicate entries and the last one prevails.\nUnlike `Enum.into(enumerable, [], fun)`,\n`Keyword.new(enumerable, fun)` guarantees the keys are unique.\n\n## Examples\n\n    iex> Keyword.new([:a, :b], fn x -> {x, x} end)\n    [a: :a, b: :b]","prompt":"Can you write a docstring for the following Elixir function? new(pairs, transform)"}
{"completion":"Returns the first value for `key` and removes all associated entries in the keyword list.\n\nIt returns a tuple where the first element is the first value for `key` and the\nsecond element is a keyword list with all entries associated with `key` removed.\nIf the `key` is not present in the keyword list, it returns `{default, keyword_list}`.\n\nIf you don't want to remove all the entries associated with `key` use `pop_first/3`\ninstead, which will remove only the first entry.\n\n## Examples\n\n    iex> Keyword.pop([a: 1], :a)\n    {1, []}\n    iex> Keyword.pop([a: 1], :b)\n    {nil, [a: 1]}\n    iex> Keyword.pop([a: 1], :b, 3)\n    {3, [a: 1]}\n    iex> Keyword.pop([a: 1, a: 2], :a)\n    {1, []}","prompt":"Can you write a docstring for the following Elixir function? pop(keywords, key, default \\\\ nil)"}
{"completion":"Returns the first value for `key` and removes all associated entries in the keyword list,\nraising if `key` is not present.\n\nThis function behaves like `pop/3`, but raises in case the `key` is not present in the\ngiven `keywords`.\n\n## Examples\n\n    iex> Keyword.pop!([a: 1], :a)\n    {1, []}\n    iex> Keyword.pop!([a: 1, a: 2], :a)\n    {1, []}\n    iex> Keyword.pop!([a: 1], :b)\n    ** (KeyError) key :b not found in: [a: 1]","prompt":"Can you write a docstring for the following Elixir function? pop!(keywords, key)"}
{"completion":"Returns and removes the first value associated with `key` in the keyword list.\n\nKeeps duplicate keys in the resulting keyword list.\n\n## Examples\n\n    iex> Keyword.pop_first([a: 1], :a)\n    {1, []}\n    iex> Keyword.pop_first([a: 1], :b)\n    {nil, [a: 1]}\n    iex> Keyword.pop_first([a: 1], :b, 3)\n    {3, [a: 1]}\n    iex> Keyword.pop_first([a: 1, a: 2], :a)\n    {1, [a: 2]}","prompt":"Can you write a docstring for the following Elixir function? pop_first(keywords, key, default \\\\ nil)"}
{"completion":"Lazily returns and removes all values associated with `key` in the keyword list.\n\nThis is useful if the default value is very expensive to calculate or\ngenerally difficult to set up and tear down again.\n\nRemoves all duplicate keys. See `pop_first/3` for removing only the first entry.\n\n## Examples\n\n    iex> keyword = [a: 1]\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   13\n    ...> end\n    iex> Keyword.pop_lazy(keyword, :a, fun)\n    {1, []}\n    iex> Keyword.pop_lazy(keyword, :b, fun)\n    {13, [a: 1]}","prompt":"Can you write a docstring for the following Elixir function? pop_lazy(keywords, key, fun)"}
{"completion":"Returns all values for `key` and removes all associated entries in the keyword list.\n\nIt returns a tuple where the first element is a list of values for `key` and the\nsecond element is a keyword list with all entries associated with `key` removed.\nIf the `key` is not present in the keyword list, it returns `{[], keyword_list}`.\n\nIf you don't want to remove all the entries associated with `key` use `pop_first/3`\ninstead, which will remove only the first entry.\n\n## Examples\n\n    iex> Keyword.pop_values([a: 1], :a)\n    {[1], []}\n    iex> Keyword.pop_values([a: 1], :b)\n    {[], [a: 1]}\n    iex> Keyword.pop_values([a: 1, a: 2], :a)\n    {[1, 2], []}","prompt":"Can you write a docstring for the following Elixir function? pop_values(keywords, key)"}
{"completion":"Puts the given `value` under the specified `key`.\n\nIf a value under `key` already exists, it overrides the value\nand removes all duplicate entries.\n\n## Examples\n\n    iex> Keyword.put([a: 1], :b, 2)\n    [b: 2, a: 1]\n    iex> Keyword.put([a: 1, b: 2], :a, 3)\n    [a: 3, b: 2]\n    iex> Keyword.put([a: 1, b: 2, a: 4], :a, 3)\n    [a: 3, b: 2]","prompt":"Can you write a docstring for the following Elixir function? put(keywords, key, value)"}
{"completion":"Puts the given `value` under `key`, unless the entry `key` already exists.\n\n## Examples\n\n    iex> Keyword.put_new([a: 1], :b, 2)\n    [b: 2, a: 1]\n    iex> Keyword.put_new([a: 1, b: 2], :a, 3)\n    [a: 1, b: 2]","prompt":"Can you write a docstring for the following Elixir function? put_new(keywords, key, value)"}
{"completion":"Evaluates `fun` and puts the result under `key`\nin keyword list unless `key` is already present.\n\nThis is useful if the value is very expensive to calculate or\ngenerally difficult to set up and tear down again.\n\n## Examples\n\n    iex> keyword = [a: 1]\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   13\n    ...> end\n    iex> Keyword.put_new_lazy(keyword, :a, fun)\n    [a: 1]\n    iex> Keyword.put_new_lazy(keyword, :b, fun)\n    [b: 13, a: 1]","prompt":"Can you write a docstring for the following Elixir function? put_new_lazy(keywords, key, fun)"}
{"completion":"Returns a keyword list excluding the entries from `keywords`\nfor which the function `fun` returns a truthy value.\n\nSee also `filter/2`.\n\n## Examples\n\n    iex> Keyword.reject([one: 1, two: 2, three: 3], fn {_key, val} -> rem(val, 2) == 1 end)\n    [two: 2]","prompt":"Can you write a docstring for the following Elixir function? reject(keywords, fun)"}
{"completion":"Puts a value under `key` only if the `key` already exists in `keywords`.\n\nIn case a key exists multiple times in the keyword list,\nit removes later occurrences.\n\n## Examples\n\n    iex> Keyword.replace([a: 1, b: 2, a: 4], :a, 3)\n    [a: 3, b: 2]\n\n    iex> Keyword.replace([a: 1], :b, 2)\n    [a: 1]","prompt":"Can you write a docstring for the following Elixir function? replace(keywords, key, value)"}
{"completion":"Puts a value under `key` only if the `key` already exists in `keywords`.\n\nIf `key` is not present in `keywords`, it raises a `KeyError`.\n\n## Examples\n\n    iex> Keyword.replace!([a: 1, b: 2, a: 3], :a, :new)\n    [a: :new, b: 2]\n    iex> Keyword.replace!([a: 1, b: 2, c: 3, b: 4], :b, :new)\n    [a: 1, b: :new, c: 3]\n\n    iex> Keyword.replace!([a: 1], :b, 2)\n    ** (KeyError) key :b not found in: [a: 1]","prompt":"Can you write a docstring for the following Elixir function? replace!(keywords, key, value)"}
{"completion":"Replaces the value under `key` using the given function only if\n`key` already exists in `keywords`.\n\nIn comparison to `replace/3`, this can be useful when it's expensive to calculate the value.\n\nIf `key` does not exist, the original keyword list is returned unchanged.\n\n## Examples\n\n    iex> Keyword.replace_lazy([a: 1, b: 2], :a, fn v -> v * 4 end)\n    [a: 4, b: 2]\n\n    iex> Keyword.replace_lazy([a: 2, b: 2, a: 1], :a, fn v -> v * 4 end)\n    [a: 8, b: 2]\n\n    iex> Keyword.replace_lazy([a: 1, b: 2], :c, fn v -> v * 4 end)\n    [a: 1, b: 2]","prompt":"Can you write a docstring for the following Elixir function? replace_lazy(keywords, key, fun)"}
{"completion":"Takes all entries corresponding to the given `keys` and extracts them into a\nseparate keyword list.\n\nReturns a tuple with the new list and the old list with removed keys.\n\nIgnores keys for which there are no entries in the keyword list.\n\nEntries with duplicate keys end up in the same keyword list.\n\n## Examples\n\n    iex> Keyword.split([a: 1, b: 2, c: 3], [:a, :c, :e])\n    {[a: 1, c: 3], [b: 2]}\n    iex> Keyword.split([a: 1, b: 2, c: 3, a: 4], [:a, :c, :e])\n    {[a: 1, c: 3, a: 4], [b: 2]}","prompt":"Can you write a docstring for the following Elixir function? split(keywords, keys)"}
{"completion":"Takes all entries corresponding to the given `keys` and returns them as a new\nkeyword list.\n\nPreserves duplicate keys in the new keyword list.\n\n## Examples\n\n    iex> Keyword.take([a: 1, b: 2, c: 3], [:a, :c, :e])\n    [a: 1, c: 3]\n    iex> Keyword.take([a: 1, b: 2, c: 3, a: 5], [:a, :c, :e])\n    [a: 1, c: 3, a: 5]","prompt":"Can you write a docstring for the following Elixir function? take(keywords, keys)"}
{"completion":"Returns the keyword list itself.\n\n## Examples\n\n    iex> Keyword.to_list(a: 1)\n    [a: 1]","prompt":"Can you write a docstring for the following Elixir function? to_list(keywords)"}
{"completion":"Updates the value under `key` in `keywords` using the given function.\n\nIf the `key` does not exist, it inserts the given `default` value.\nDoes not pass the `default` value through the update function.\n\nRemoves all duplicate keys and only updates the first one.\n\n## Examples\n\n    iex> Keyword.update([a: 1], :a, 13, fn existing_value -> existing_value * 2 end)\n    [a: 2]\n\n    iex> Keyword.update([a: 1, a: 2], :a, 13, fn existing_value -> existing_value * 2 end)\n    [a: 2]\n\n    iex> Keyword.update([a: 1], :b, 11, fn existing_value -> existing_value * 2 end)\n    [a: 1, b: 11]","prompt":"Can you write a docstring for the following Elixir function? update(keywords, key, default, fun)"}
{"completion":"Updates the value under `key` using the given function.\n\nRaises `KeyError` if the `key` does not exist.\n\nRemoves all duplicate keys and only updates the first one.\n\n## Examples\n\n    iex> Keyword.update!([a: 1, b: 2, a: 3], :a, &(&1 * 2))\n    [a: 2, b: 2]\n    iex> Keyword.update!([a: 1, b: 2, c: 3], :b, &(&1 * 2))\n    [a: 1, b: 4, c: 3]\n\n    iex> Keyword.update!([a: 1], :b, &(&1 * 2))\n    ** (KeyError) key :b not found in: [a: 1]","prompt":"Can you write a docstring for the following Elixir function? update!(keywords, key, fun)"}
{"completion":"Ensures the given `keyword` has only the keys given in `values`.\n\nThe second argument must be a list of atoms, specifying\na given key, or tuples specifying a key and a default value.\n\nIf the keyword list has only the given keys, it returns\n`{:ok, keyword}` with default values applied. Otherwise it\nreturns `{:error, invalid_keys}` with invalid keys.\n\nSee also: `validate!/2`.\n\n## Examples\n\n    iex> {:ok, result} = Keyword.validate([], [one: 1, two: 2])\n    iex> Enum.sort(result)\n    [one: 1, two: 2]\n\n    iex> {:ok, result} = Keyword.validate([two: 3], [one: 1, two: 2])\n    iex> Enum.sort(result)\n    [one: 1, two: 3]\n\nIf atoms are given, they are supported as keys but do not\nprovide a default value:\n\n    iex> {:ok, result} = Keyword.validate([], [:one, two: 2])\n    iex> Enum.sort(result)\n    [two: 2]\n\n    iex> {:ok, result} = Keyword.validate([one: 1], [:one, two: 2])\n    iex> Enum.sort(result)\n    [one: 1, two: 2]\n\nPassing unknown keys returns an error:\n\n    iex> Keyword.validate([three: 3, four: 4], [one: 1, two: 2])\n    {:error, [:four, :three]}\n\nPassing the same key multiple times also errors:\n\n    iex> Keyword.validate([one: 1, two: 2, one: 1], [:one, :two])\n    {:error, [:one]}","prompt":"Can you write a docstring for the following Elixir function? validate(keyword, values)"}
{"completion":"Similar to `validate/2` but returns the keyword or raises an error.\n\n## Examples\n\n    iex> Keyword.validate!([], [one: 1, two: 2]) |> Enum.sort()\n    [one: 1, two: 2]\n    iex> Keyword.validate!([two: 3], [one: 1, two: 2]) |> Enum.sort()\n    [one: 1, two: 3]\n\nIf atoms are given, they are supported as keys but do not\nprovide a default value:\n\n    iex> Keyword.validate!([], [:one, two: 2]) |> Enum.sort()\n    [two: 2]\n    iex> Keyword.validate!([one: 1], [:one, two: 2]) |> Enum.sort()\n    [one: 1, two: 2]\n\nPassing unknown keys raises an error:\n\n    iex> Keyword.validate!([three: 3], [one: 1, two: 2])\n    ** (ArgumentError) unknown keys [:three] in [three: 3], the allowed keys are: [:one, :two]\n\nPassing the same key multiple times also errors:\n\n    iex> Keyword.validate!([one: 1, two: 2, one: 1], [:one, :two])\n    ** (ArgumentError) duplicate keys [:one] in [one: 1, two: 2, one: 1]","prompt":"Can you write a docstring for the following Elixir function? validate!(keyword, values)"}
{"completion":"Returns all values from the keyword list.\n\nKeeps values from duplicate keys in the resulting list of values.\n\n## Examples\n\n    iex> Keyword.values(a: 1, b: 2)\n    [1, 2]\n    iex> Keyword.values(a: 1, b: 2, a: 3)\n    [1, 2, 3]","prompt":"Can you write a docstring for the following Elixir function? values(keywords)"}
{"completion":"A keyword list is a list that consists exclusively of two-element tuples.\n\nThe first element of these tuples is known as the *key*, and it must be an atom.\nThe second element, known as the *value*, can be any term.\n\nKeywords are mostly used to work with optional values.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Keyword"}
{"completion":"Examples\n\nFor example, the following is a keyword list:\n\n    [{:exit_on_close, true}, {:active, :once}, {:packet_size, 1024}]\n\nElixir provides a special and more concise syntax for keyword lists:\n\n    [exit_on_close: true, active: :once, packet_size: 1024]\n\nThe two syntaxes return the exact same value.\n\nA *key* can be any atom, consisting of Unicode letters, numbers,\nan underscore or the `@` sign. If the *key* should have any other\ncharacters, such as spaces, you can wrap it in quotes:\n\n    iex> [\"exit on close\": true]\n    [\"exit on close\": true]\n\nWrapping an atom in quotes does not make it a string. Keyword list\n*keys* are always atoms. Quotes should only be used when necessary\nor Elixir will issue a warning.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Keyword"}
{"completion":"Duplicate keys and ordering\n\nA keyword may have duplicate keys so it is not strictly a key-value\ndata type. However most of the functions in this module work on a\nkey-value structure and behave similar to the functions you would\nfind in the `Map` module. For example, `Keyword.get/3` will get the first\nentry matching the given key, regardless if duplicate entries exist.\nSimilarly, `Keyword.put/3` and `Keyword.delete/2` ensure all duplicate\nentries for a given key are removed when invoked. Note, however, that\nkeyword list operations need to traverse the whole list in order to find\nkeys, so these operations are slower than their map counterparts.\n\nA handful of functions exist to handle duplicate keys, for example,\n`get_values/2` returns all values for a given key and `delete_first/2`\ndeletes just the first entry of the existing ones.\n\nEven though lists preserve the existing order, the functions in\n`Keyword` do not guarantee any ordering. For example, if you invoke\n`Keyword.put(opts, new_key, new_value)`, there is no guarantee for\nwhere `new_key` will be added to (the front, the end or anywhere else).\n\nGiven ordering is not guaranteed, it is not recommended to pattern\nmatch on keyword lists either. For example, a function such as:\n\n    def my_function([some_key: value, another_key: another_value])\n\nwill match\n\n    my_function([some_key: :foo, another_key: :bar])\n\nbut it won't match\n\n    my_function([another_key: :bar, some_key: :foo])\n\nMost of the functions in this module work in linear time. This means\nthat the time it takes to perform an operation grows at the same\nrate as the length of the list.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Keyword"}
{"completion":"Call syntax\n\nWhen keyword lists are passed as the last argument to a function,\nthe square brackets around the keyword list can be omitted. For\nexample, the keyword list syntax:\n\n    String.split(\"1-0\", \"-\", [trim: true, parts: 2])\n\ncan be written without the enclosing brackets whenever it is the last\nargument of a function call:\n\n    String.split(\"1-0\", \"-\", trim: true, parts: 2)\n\nSince tuples, lists and maps are treated similarly to function\narguments in Elixir syntax, this property is also available to them:\n\n    iex> {1, 2, foo: :bar}\n    {1, 2, [{:foo, :bar}]}\n\n    iex> [1, 2, foo: :bar]\n    [1, 2, {:foo, :bar}]\n\n    iex> %{1 => 2, foo: :bar}\n    %{1 => 2, :foo => :bar}","prompt":"Can you write a docstring for the following Elixir function? Elixir.Keyword"}
{"completion":"Returns the given binary `term` converted to a charlist.","prompt":"Can you write a docstring for the following Elixir function? to_charlist(term)"}
{"completion":"Converts `term` to a charlist.","prompt":"Can you write a docstring for the following Elixir function? to_charlist(term)"}
{"completion":"The `List.Chars` protocol is responsible for\nconverting a structure to a charlist (only if applicable).\n\nThe only function that must be implemented is\n`to_charlist/1` which does the conversion.\n\nThe `to_charlist/1` function automatically imported\nby `Kernel` invokes this protocol.","prompt":"Can you write a docstring for the following Elixir function? Elixir.List.Chars"}
{"completion":"Checks if `list` is a charlist made only of printable ASCII characters.\n\nTakes an optional `limit` as a second argument. `ascii_printable?/2` only\nchecks the printability of the list up to the `limit`.\n\nA printable charlist in Elixir contains only the printable characters in the\nstandard seven-bit ASCII character encoding, which are characters ranging from\n32 to 126 in decimal notation, plus the following control characters:\n\n  * `?\\a` - Bell\n  * `?\\b` - Backspace\n  * `?\\t` - Horizontal tab\n  * `?\\n` - Line feed\n  * `?\\v` - Vertical tab\n  * `?\\f` - Form feed\n  * `?\\r` - Carriage return\n  * `?\\e` - Escape\n\nFor more information read the [Character groups](https://en.wikipedia.org/wiki/ASCII#Character_groups)\nsection in the Wikipedia article of the [ASCII](https://en.wikipedia.org/wiki/ASCII) standard.\n\n## Examples\n\n    iex> List.ascii_printable?('abc')\n    true\n\n    iex> List.ascii_printable?('abc' ++ [0])\n    false\n\n    iex> List.ascii_printable?('abc' ++ [0], 2)\n    true\n\nImproper lists are not printable, even if made only of ASCII characters:\n\n    iex> List.ascii_printable?('abc' ++ ?d)\n    false","prompt":"Can you write a docstring for the following Elixir function? ascii_printable?(list, limit \\\\ :infinity)"}
{"completion":"Deletes the given `element` from the `list`. Returns a new list without\nthe element.\n\nIf the `element` occurs more than once in the `list`, just\nthe first occurrence is removed.\n\n## Examples\n\n    iex> List.delete([:a, :b, :c], :a)\n    [:b, :c]\n\n    iex> List.delete([:a, :b, :c], :d)\n    [:a, :b, :c]\n\n    iex> List.delete([:a, :b, :b, :c], :b)\n    [:a, :b, :c]\n\n    iex> List.delete([], :b)\n    []","prompt":"Can you write a docstring for the following Elixir function? delete(list, element)"}
{"completion":"Produces a new list by removing the value at the specified `index`.\n\nNegative indices indicate an offset from the end of the `list`.\nIf `index` is out of bounds, the original `list` is returned.\n\n## Examples\n\n    iex> List.delete_at([1, 2, 3], 0)\n    [2, 3]\n\n    iex> List.delete_at([1, 2, 3], 10)\n    [1, 2, 3]\n\n    iex> List.delete_at([1, 2, 3], -1)\n    [1, 2]","prompt":"Can you write a docstring for the following Elixir function? delete_at(list, index)"}
{"completion":"Duplicates the given element `n` times in a list.\n\n`n` is an integer greater than or equal to `0`.\n\nIf `n` is `0`, an empty list is returned.\n\n## Examples\n\n    iex> List.duplicate(\"hello\", 0)\n    []\n\n    iex> List.duplicate(\"hi\", 1)\n    [\"hi\"]\n\n    iex> List.duplicate(\"bye\", 2)\n    [\"bye\", \"bye\"]\n\n    iex> List.duplicate([1, 2], 3)\n    [[1, 2], [1, 2], [1, 2]]","prompt":"Can you write a docstring for the following Elixir function? duplicate(elem, n)"}
{"completion":"Returns the first element in `list` or `default` if `list` is empty.\n\n`first/2` has been introduced in Elixir v1.12.0, while `first/1` has been available since v1.0.0.\n\n## Examples\n\n    iex> List.first([])\n    nil\n\n    iex> List.first([], 1)\n    1\n\n    iex> List.first([1])\n    1\n\n    iex> List.first([1, 2, 3])\n    1","prompt":"Can you write a docstring for the following Elixir function? first(list, default \\\\ nil)"}
{"completion":"Flattens the given `list` of nested lists.\n\nEmpty list elements are discarded.\n\n## Examples\n\n    iex> List.flatten([1, [[2], 3]])\n    [1, 2, 3]\n\n    iex> List.flatten([[], [[], []]])\n    []","prompt":"Can you write a docstring for the following Elixir function? flatten(list)"}
{"completion":"Flattens the given `list` of nested lists.\nThe list `tail` will be added at the end of\nthe flattened list.\n\nEmpty list elements from `list` are discarded,\nbut not the ones from `tail`.\n\n## Examples\n\n    iex> List.flatten([1, [[2], 3]], [4, 5])\n    [1, 2, 3, 4, 5]\n\n    iex> List.flatten([1, [], 2], [3, [], 4])\n    [1, 2, 3, [], 4]","prompt":"Can you write a docstring for the following Elixir function? flatten(list, tail)"}
{"completion":"Folds (reduces) the given list from the left with\na function. Requires an accumulator, which can be any value.\n\n## Examples\n\n    iex> List.foldl([5, 5], 10, fn x, acc -> x + acc end)\n    20\n\n    iex> List.foldl([1, 2, 3, 4], 0, fn x, acc -> x - acc end)\n    2\n\n    iex> List.foldl([1, 2, 3], {0, 0}, fn x, {a1, a2} -> {a1 + x, a2 - x} end)\n    {6, -6}","prompt":"Can you write a docstring for the following Elixir function? foldl(list, acc, fun)"}
{"completion":"Folds (reduces) the given list from the right with\na function. Requires an accumulator, which can be any value.\n\n## Examples\n\n    iex> List.foldr([1, 2, 3, 4], 0, fn x, acc -> x - acc end)\n    -2\n\n    iex> List.foldr([1, 2, 3, 4], %{sum: 0, product: 1}, fn x, %{sum: a1, product: a2} -> %{sum: a1 + x, product: a2 * x} end)\n    %{product: 24, sum: 10}","prompt":"Can you write a docstring for the following Elixir function? foldr(list, acc, fun)"}
{"completion":"Returns `true` if `list` is an improper list. Otherwise returns `false`.\n\n## Examples\n\n    iex> List.improper?([1, 2 | 3])\n    true\n\n    iex> List.improper?([1, 2, 3])\n    false","prompt":"Can you write a docstring for the following Elixir function? improper?(list)"}
{"completion":"Returns a list with `value` inserted at the specified `index`.\n\nNote that `index` is capped at the list length. Negative indices\nindicate an offset from the end of the `list`.\n\n## Examples\n\n    iex> List.insert_at([1, 2, 3, 4], 2, 0)\n    [1, 2, 0, 3, 4]\n\n    iex> List.insert_at([1, 2, 3], 10, 0)\n    [1, 2, 3, 0]\n\n    iex> List.insert_at([1, 2, 3], -1, 0)\n    [1, 2, 3, 0]\n\n    iex> List.insert_at([1, 2, 3], -10, 0)\n    [0, 1, 2, 3]","prompt":"Can you write a docstring for the following Elixir function? insert_at(list, index, value)"}
{"completion":"Receives a `list` of tuples and deletes the first tuple\nwhere the element at `position` matches the\ngiven `key`. Returns the new list.\n\n## Examples\n\n    iex> List.keydelete([a: 1, b: 2], :a, 0)\n    [b: 2]\n\n    iex> List.keydelete([a: 1, b: 2], 2, 1)\n    [a: 1]\n\n    iex> List.keydelete([a: 1, b: 2], :c, 0)\n    [a: 1, b: 2]\n\nThis function works for any list of tuples:\n\n    iex> List.keydelete([{22, \"SSH\"}, {80, \"HTTP\"}], 80, 0)\n    [{22, \"SSH\"}]","prompt":"Can you write a docstring for the following Elixir function? keydelete(list, key, position)"}
{"completion":"Receives a list of tuples and returns the first tuple\nwhere the element at `position` in the tuple matches the\ngiven `key`.\n\nIf no matching tuple is found, `default` is returned.\n\n## Examples\n\n    iex> List.keyfind([a: 1, b: 2], :a, 0)\n    {:a, 1}\n\n    iex> List.keyfind([a: 1, b: 2], 2, 1)\n    {:b, 2}\n\n    iex> List.keyfind([a: 1, b: 2], :c, 0)\n    nil\n\nThis function works for any list of tuples:\n\n    iex> List.keyfind([{22, \"SSH\"}, {80, \"HTTP\"}], 22, 0)\n    {22, \"SSH\"}","prompt":"Can you write a docstring for the following Elixir function? keyfind(list, key, position, default \\\\ nil)"}
{"completion":"Receives a list of tuples and returns the first tuple\nwhere the element at `position` in the tuple matches the\ngiven `key`.\n\nIf no matching tuple is found, an error is raised.\n\n## Examples\n\n    iex> List.keyfind!([a: 1, b: 2], :a, 0)\n    {:a, 1}\n\n    iex> List.keyfind!([a: 1, b: 2], 2, 1)\n    {:b, 2}\n\n    iex> List.keyfind!([a: 1, b: 2], :c, 0)\n    ** (KeyError) key :c at position 0 not found in: [a: 1, b: 2]\n\nThis function works for any list of tuples:\n\n    iex> List.keyfind!([{22, \"SSH\"}, {80, \"HTTP\"}], 22, 0)\n    {22, \"SSH\"}","prompt":"Can you write a docstring for the following Elixir function? keyfind!(list, key, position)"}
{"completion":"Receives a list of tuples and returns `true` if there is\na tuple where the element at `position` in the tuple matches\nthe given `key`.\n\n## Examples\n\n    iex> List.keymember?([a: 1, b: 2], :a, 0)\n    true\n\n    iex> List.keymember?([a: 1, b: 2], 2, 1)\n    true\n\n    iex> List.keymember?([a: 1, b: 2], :c, 0)\n    false\n\nThis function works for any list of tuples:\n\n    iex> List.keymember?([{22, \"SSH\"}, {80, \"HTTP\"}], 22, 0)\n    true","prompt":"Can you write a docstring for the following Elixir function? keymember?(list, key, position)"}
{"completion":"Receives a list of tuples and if the identified element by `key` at `position`\nexists, it is replaced with `new_tuple`.\n\n## Examples\n\n    iex> List.keyreplace([a: 1, b: 2], :a, 0, {:a, 3})\n    [a: 3, b: 2]\n\n    iex> List.keyreplace([a: 1, b: 2], :a, 1, {:a, 3})\n    [a: 1, b: 2]\n\nThis function works for any list of tuples:\n\n    iex> List.keyreplace([{22, \"SSH\"}, {80, \"HTTP\"}], 22, 0, {22, \"Secure Shell\"})\n    [{22, \"Secure Shell\"}, {80, \"HTTP\"}]","prompt":"Can you write a docstring for the following Elixir function? keyreplace(list, key, position, new_tuple)"}
{"completion":"Receives a list of tuples and sorts the elements\nat `position` of the tuples.\n\nThe sort is stable.\n\nA `sorter` argument is available since Elixir v1.14.0. Similar to\n`Enum.sort/2`, the sorter can be an anonymous function, the atoms\n`:asc` or `:desc`, or module that implements a compare function.\n\n## Examples\n\n    iex> List.keysort([a: 5, b: 1, c: 3], 1)\n    [b: 1, c: 3, a: 5]\n\n    iex> List.keysort([a: 5, c: 1, b: 3], 0)\n    [a: 5, b: 3, c: 1]\n\nTo sort in descending order:\n\n    iex> List.keysort([a: 5, c: 1, b: 3], 0, :desc)\n    [c: 1, b: 3, a: 5]\n\nAs in `Enum.sort/2`, avoid using the default sorting function to sort\nstructs, as by default it performs structural comparison instead of a\nsemantic one. In such cases, you shall pass a sorting function as third\nelement or any module that implements a `compare/2` function. For example,\nif you have tuples with user names and their birthday, and you want to\nsort on their birthday, in both ascending and descending order, you should\ndo:\n\n    iex> users = [\n    ...>   {\"Ellis\", ~D[1943-05-11]},\n    ...>   {\"Lovelace\", ~D[1815-12-10]},\n    ...>   {\"Turing\", ~D[1912-06-23]}\n    ...> ]\n    iex> List.keysort(users, 1, Date)\n    [\n      {\"Lovelace\", ~D[1815-12-10]},\n      {\"Turing\", ~D[1912-06-23]},\n      {\"Ellis\", ~D[1943-05-11]}\n    ]\n    iex> List.keysort(users, 1, {:desc, Date})\n    [\n      {\"Ellis\", ~D[1943-05-11]},\n      {\"Turing\", ~D[1912-06-23]},\n      {\"Lovelace\", ~D[1815-12-10]}\n    ]","prompt":"Can you write a docstring for the following Elixir function? keysort(list, position, sorter \\\\ :asc)"}
{"completion":"Receives a `list` of tuples and replaces the element\nidentified by `key` at `position` with `new_tuple`.\n\nIf the element does not exist, it is added to the end of the `list`.\n\n## Examples\n\n    iex> List.keystore([a: 1, b: 2], :a, 0, {:a, 3})\n    [a: 3, b: 2]\n\n    iex> List.keystore([a: 1, b: 2], :c, 0, {:c, 3})\n    [a: 1, b: 2, c: 3]\n\nThis function works for any list of tuples:\n\n    iex> List.keystore([{22, \"SSH\"}], 80, 0, {80, \"HTTP\"})\n    [{22, \"SSH\"}, {80, \"HTTP\"}]","prompt":"Can you write a docstring for the following Elixir function? keystore(list, key, position, new_tuple)"}
{"completion":"Receives a `list` of tuples and returns the first tuple\nwhere the element at `position` in the tuple matches the\ngiven `key`, as well as the `list` without found tuple.\n\nIf such a tuple is not found, `nil` will be returned.\n\n## Examples\n\n    iex> List.keytake([a: 1, b: 2], :a, 0)\n    {{:a, 1}, [b: 2]}\n\n    iex> List.keytake([a: 1, b: 2], 2, 1)\n    {{:b, 2}, [a: 1]}\n\n    iex> List.keytake([a: 1, b: 2], :c, 0)\n    nil\n\nThis function works for any list of tuples:\n\n    iex> List.keytake([{22, \"SSH\"}, {80, \"HTTP\"}], 80, 0)\n    {{80, \"HTTP\"}, [{22, \"SSH\"}]}","prompt":"Can you write a docstring for the following Elixir function? keytake(list, key, position)"}
{"completion":"Returns the last element in `list` or `default` if `list` is empty.\n\n`last/2` has been introduced in Elixir v1.12.0, while `last/1` has been available since v1.0.0.\n\n## Examples\n\n    iex> List.last([])\n    nil\n\n    iex> List.last([], 1)\n    1\n\n    iex> List.last([1])\n    1\n\n    iex> List.last([1, 2, 3])\n    3","prompt":"Can you write a docstring for the following Elixir function? last(list, default \\\\ nil)"}
{"completion":"Returns a keyword list that represents an *edit script*.\n\nThe algorithm is outlined in the\n\"An O(ND) Difference Algorithm and Its Variations\" paper by E. Myers.\n\nAn *edit script* is a keyword list. Each key describes the \"editing action\" to\ntake in order to bring `list1` closer to being equal to `list2`; a key can be\n`:eq`, `:ins`, or `:del`. Each value is a sublist of either `list1` or `list2`\nthat should be inserted (if the corresponding key `:ins`), deleted (if the\ncorresponding key is `:del`), or left alone (if the corresponding key is\n`:eq`) in `list1` in order to be closer to `list2`.\n\nSee `myers_difference/3` if you want to handle nesting in the diff scripts.\n\n## Examples\n\n    iex> List.myers_difference([1, 4, 2, 3], [1, 2, 3, 4])\n    [eq: [1], del: [4], eq: [2, 3], ins: [4]]","prompt":"Can you write a docstring for the following Elixir function? myers_difference(list1, list2)"}
{"completion":"Returns a keyword list that represents an *edit script* with nested diffs.\n\nThis is an extension of `myers_difference/2` where a `diff_script` function\ncan be given in case it is desired to compute nested differences. The function\nmay return a list with the inner edit script or `nil` in case there is no\nsuch script. The returned inner edit script will be under the `:diff` key.\n\n## Examples\n\n    iex> List.myers_difference([\"a\", \"db\", \"c\"], [\"a\", \"bc\"], &String.myers_difference/2)\n    [eq: [\"a\"], diff: [del: \"d\", eq: \"b\", ins: \"c\"], del: [\"c\"]]","prompt":"Can you write a docstring for the following Elixir function? myers_difference(list1, list2, diff_script)"}
{"completion":"Returns and removes the value at the specified `index` in the `list`.\n\nNegative indices indicate an offset from the end of the `list`.\nIf `index` is out of bounds, the original `list` is returned.\n\n## Examples\n\n    iex> List.pop_at([1, 2, 3], 0)\n    {1, [2, 3]}\n    iex> List.pop_at([1, 2, 3], 5)\n    {nil, [1, 2, 3]}\n    iex> List.pop_at([1, 2, 3], 5, 10)\n    {10, [1, 2, 3]}\n    iex> List.pop_at([1, 2, 3], -1)\n    {3, [1, 2]}","prompt":"Can you write a docstring for the following Elixir function? pop_at(list, index, default \\\\ nil)"}
{"completion":"Returns a list with a replaced value at the specified `index`.\n\nNegative indices indicate an offset from the end of the `list`.\nIf `index` is out of bounds, the original `list` is returned.\n\n## Examples\n\n    iex> List.replace_at([1, 2, 3], 0, 0)\n    [0, 2, 3]\n\n    iex> List.replace_at([1, 2, 3], 10, 0)\n    [1, 2, 3]\n\n    iex> List.replace_at([1, 2, 3], -1, 0)\n    [1, 2, 0]\n\n    iex> List.replace_at([1, 2, 3], -10, 0)\n    [1, 2, 3]","prompt":"Can you write a docstring for the following Elixir function? replace_at(list, index, value)"}
{"completion":"Returns `true` if `list` starts with the given `prefix` list; otherwise returns `false`.\n\nIf `prefix` is an empty list, it returns `true`.\n\n### Examples\n\n    iex> List.starts_with?([1, 2, 3], [1, 2])\n    true\n\n    iex> List.starts_with?([1, 2], [1, 2, 3])\n    false\n\n    iex> List.starts_with?([:alpha], [])\n    true\n\n    iex> List.starts_with?([], [:alpha])\n    false","prompt":"Can you write a docstring for the following Elixir function? starts_with?(list, prefix)"}
{"completion":"Converts a charlist to an atom.\n\nElixir supports conversions from charlists which contains any Unicode\ncode point.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> List.to_atom('Elixir')\n    :Elixir\n\n    iex> List.to_atom(' Elixir')\n    :\" Elixir\"","prompt":"Can you write a docstring for the following Elixir function? to_atom(charlist)"}
{"completion":"Converts a list of integers representing Unicode code points, lists or\nstrings into a charlist.\n\nNote that this function expects a list of integers representing\nUnicode code points. If you have a list of bytes, you must instead use\nthe [`:binary` module](`:binary`).\n\n## Examples\n\n    iex> List.to_charlist([0x00E6, 0x00DF])\n    ''\n\n    iex> List.to_charlist([0x0061, \"bc\"])\n    'abc'\n\n    iex> List.to_charlist([0x0064, \"ee\", ['p']])\n    'deep'","prompt":"Can you write a docstring for the following Elixir function? to_charlist(list)"}
{"completion":"Converts a charlist to an existing atom.\n\nElixir supports conversions from charlists which contains any Unicode\ncode point. Raises an `ArgumentError` if the atom does not exist.\n\nInlined by the compiler.\n\n> #### Atoms and modules {: .info}\n>\n> Since Elixir is a compiled language, the atoms defined in a module\n> will only exist after said module is loaded, which typically happens\n> whenever a function in the module is executed. Therefore, it is\n> generally recommended to call `List.to_existing_atom/1` only to\n> convert atoms defined within the module making the function call\n> to `to_existing_atom/1`.\n\n## Examples\n\n    iex> _ = :my_atom\n    iex> List.to_existing_atom('my_atom')\n    :my_atom\n\n    iex> _ = :\" Elixir\"\n    iex> List.to_existing_atom(' Elixir')\n    :\" Elixir\"","prompt":"Can you write a docstring for the following Elixir function? to_existing_atom(charlist)"}
{"completion":"Returns the float whose text representation is `charlist`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> List.to_float('2.2017764e+0')\n    2.2017764","prompt":"Can you write a docstring for the following Elixir function? to_float(charlist)"}
{"completion":"Returns an integer whose text representation is `charlist`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> List.to_integer('123')\n    123","prompt":"Can you write a docstring for the following Elixir function? to_integer(charlist)"}
{"completion":"Returns an integer whose text representation is `charlist` in base `base`.\n\nInlined by the compiler.\n\nThe base needs to be between `2` and `36`.\n\n## Examples\n\n    iex> List.to_integer('3FF', 16)\n    1023","prompt":"Can you write a docstring for the following Elixir function? to_integer(charlist, base)"}
{"completion":"Converts a list of integers representing code points, lists or\nstrings into a string.\n\nTo be converted to a string, a list must either be empty or only\ncontain the following elements:\n\n  * strings\n  * integers representing Unicode code points\n  * a list containing one of these three elements\n\nNote that this function expects a list of integers representing\nUnicode code points. If you have a list of bytes, you must instead use\nthe [`:binary` module](`:binary`).\n\n## Examples\n\n    iex> List.to_string([0x00E6, 0x00DF])\n    \"\"\n\n    iex> List.to_string([0x0061, \"bc\"])\n    \"abc\"\n\n    iex> List.to_string([0x0064, \"ee\", ['p']])\n    \"deep\"\n\n    iex> List.to_string([])\n    \"\"","prompt":"Can you write a docstring for the following Elixir function? to_string(list)"}
{"completion":"Converts a list to a tuple.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> List.to_tuple([:share, [:elixir, 163]])\n    {:share, [:elixir, 163]}","prompt":"Can you write a docstring for the following Elixir function? to_tuple(list)"}
{"completion":"Returns a list with an updated value at the specified `index`.\n\nNegative indices indicate an offset from the end of the `list`.\nIf `index` is out of bounds, the original `list` is returned.\n\n## Examples\n\n    iex> List.update_at([1, 2, 3], 0, &(&1 + 10))\n    [11, 2, 3]\n\n    iex> List.update_at([1, 2, 3], 10, &(&1 + 10))\n    [1, 2, 3]\n\n    iex> List.update_at([1, 2, 3], -1, &(&1 + 10))\n    [1, 2, 13]\n\n    iex> List.update_at([1, 2, 3], -10, &(&1 + 10))\n    [1, 2, 3]","prompt":"Can you write a docstring for the following Elixir function? update_at(list, index, fun)"}
{"completion":"Wraps `term` in a list if this is not list.\n\nIf `term` is already a list, it returns the list.\nIf `term` is `nil`, it returns an empty list.\n\n## Examples\n\n    iex> List.wrap(\"hello\")\n    [\"hello\"]\n\n    iex> List.wrap([1, 2, 3])\n    [1, 2, 3]\n\n    iex> List.wrap(nil)\n    []","prompt":"Can you write a docstring for the following Elixir function? wrap(term)"}
{"completion":"Zips corresponding elements from each list in `list_of_lists`.\n\nThe zipping finishes as soon as any list terminates.\n\n## Examples\n\n    iex> List.zip([[1, 2], [3, 4], [5, 6]])\n    [{1, 3, 5}, {2, 4, 6}]\n\n    iex> List.zip([[1, 2], [3], [5, 6]])\n    [{1, 3, 5}]","prompt":"Can you write a docstring for the following Elixir function? zip(list_of_lists)"}
{"completion":"Linked lists hold zero, one, or more elements in the chosen order.\n\nLists in Elixir are specified between square brackets:\n\n    iex> [1, \"two\", 3, :four]\n    [1, \"two\", 3, :four]\n\nTwo lists can be concatenated and subtracted using the\n`++/2` and `--/2` operators:\n\n    iex> [1, 2, 3] ++ [4, 5, 6]\n    [1, 2, 3, 4, 5, 6]\n    iex> [1, true, 2, false, 3, true] -- [true, false]\n    [1, 2, 3, true]\n\nAn element can be prepended to a list using `|`:\n\n    iex> new = 0\n    iex> list = [1, 2, 3]\n    iex> [new | list]\n    [0, 1, 2, 3]\n\nLists in Elixir are effectively linked lists, which means\nthey are internally represented in pairs containing the\nhead and the tail of a list:\n\n    iex> [head | tail] = [1, 2, 3]\n    iex> head\n    1\n    iex> tail\n    [2, 3]\n\nSimilarly, we could write the list `[1, 2, 3]` using only\nsuch pairs (called cons cells):\n\n    iex> [1 | [2 | [3 | []]]]\n    [1, 2, 3]\n\nSome lists, called improper lists, do not have an empty list as\nthe second element in the last cons cell:\n\n    iex> [1 | [2 | [3 | 4]]]\n    [1, 2, 3 | 4]\n\nAlthough improper lists are generally avoided, they are used in some\nspecial circumstances like iodata and chardata entities (see the `IO` module).\n\nDue to their cons cell based representation, prepending an element\nto a list is always fast (constant time), while appending becomes\nslower as the list grows in size (linear time):\n\n    iex> list = [1, 2, 3]\n    iex> [0 | list] # fast\n    [0, 1, 2, 3]\n    iex> list ++ [4] # slow\n    [1, 2, 3, 4]\n\nMost of the functions in this module work in linear time. This means that,\nthat the time it takes to perform an operation grows at the same rate as the\nlength of the list. For example `length/1` and `last/1` will run in linear\ntime because they need to iterate through every element of the list, but\n`first/1` will run in constant time because it only needs the first element.\n\nLists also implement the `Enumerable` protocol, so many functions to work with\nlists are found in the `Enum` module. Additionally, the following functions and\noperators for lists are found in `Kernel`:\n\n  * `++/2`\n  * `--/2`\n  * `hd/1`\n  * `tl/1`\n  * `in/2`\n  * `length/1`","prompt":"Can you write a docstring for the following Elixir function? Elixir.List"}
{"completion":"Charlists\n\nIf a list is made of non-negative integers, where each integer represents a\nUnicode code point, the list can also be called a charlist. These integers\nmust:\n\n  * be within the range `0..0x10FFFF` (`0..1_114_111`);\n  * and be out of the range `0xD800..0xDFFF` (`55_296..57_343`), which is\n    reserved in Unicode for UTF-16 surrogate pairs.\n\nElixir uses single quotes to define charlists:\n\n    iex> 'hllo'\n    [104, 233, 108, 108, 111]\n\nIn particular, charlists will be printed back by default in single\nquotes if they contain only printable ASCII characters:\n\n    iex> 'abc'\n    'abc'\n\nEven though the representation changed, the raw data does remain a list of\nnumbers, which can be handled as such:\n\n    iex> inspect('abc', charlists: :as_list)\n    \"[97, 98, 99]\"\n    iex> Enum.map('abc', fn num -> 1000 + num end)\n    [1097, 1098, 1099]\n\nYou can use the `IEx.Helpers.i/1` helper to get a condensed rundown on\ncharlists in IEx when you encounter them, which shows you the type, description\nand also the raw representation in one single summary.\n\nThe rationale behind this behaviour is to better support\nErlang libraries which may return text as charlists\ninstead of Elixir strings. In Erlang, charlists are the default\nway of handling strings, while in Elixir it's binaries. One\nexample of such functions is `Application.loaded_applications/0`:\n\n    Application.loaded_applications()\n    #=>  [\n    #=>    {:stdlib, 'ERTS  CXC 138 10', '2.6'},\n    #=>    {:compiler, 'ERTS  CXC 138 10', '6.0.1'},\n    #=>    {:elixir, 'elixir', '1.0.0'},\n    #=>    {:kernel, 'ERTS  CXC 138 10', '4.1'},\n    #=>    {:logger, 'logger', '1.0.0'}\n    #=>  ]\n\nA list can be checked if it is made of only printable ASCII\ncharacters with `ascii_printable?/2`.\n\nImproper lists are never deemed as charlists.","prompt":"Can you write a docstring for the following Elixir function? Elixir.List"}
{"completion":"Fetches the alias for the given atom.\n\nReturns `{:ok, alias}` if the alias exists, `:error`\notherwise.\n\n## Examples\n\n    iex> alias Foo.Bar, as: Baz\n    iex> Baz\n    Foo.Bar\n    iex> Macro.Env.fetch_alias(__ENV__, :Baz)\n    {:ok, Foo.Bar}\n    iex> Macro.Env.fetch_alias(__ENV__, :Unknown)\n    :error","prompt":"Can you write a docstring for the following Elixir function? fetch_alias(map, atom)"}
{"completion":"Fetches the macro alias for the given atom.\n\nReturns `{:ok, macro_alias}` if the alias exists, `:error`\notherwise.\n\nA macro alias is only used inside quoted expansion. See\n`fetch_alias/2` for a more general example.","prompt":"Can you write a docstring for the following Elixir function? fetch_macro_alias(map, atom)"}
{"completion":"Checks if a variable belongs to the environment.\n\n## Examples\n\n    iex> x = 13\n    iex> x\n    13\n    iex> Macro.Env.has_var?(__ENV__, {:x, nil})\n    true\n    iex> Macro.Env.has_var?(__ENV__, {:unknown, nil})\n    false","prompt":"Can you write a docstring for the following Elixir function? has_var?(env, var)"}
{"completion":"Returns whether the compilation environment is currently\ninside a guard.","prompt":"Can you write a docstring for the following Elixir function? in_guard?(env)"}
{"completion":"Returns whether the compilation environment is currently\ninside a match clause.","prompt":"Can you write a docstring for the following Elixir function? in_match?(env)"}
{"completion":"Returns a keyword list containing the file and line\ninformation as keys.","prompt":"Can you write a docstring for the following Elixir function? location(env)"}
{"completion":"Returns the modules from which the given `{name, arity}` was\nimported.\n\nIt returns a list of two element tuples in the shape of\n`{:function | :macro, module}`. The elements in the list\nare in no particular order and the order is not guaranteed.\n\n## Examples\n\n    iex> Macro.Env.lookup_import(__ENV__, {:duplicate, 2})\n    []\n    iex> import Tuple, only: [duplicate: 2], warn: false\n    iex> Macro.Env.lookup_import(__ENV__, {:duplicate, 2})\n    [{:function, Tuple}]\n    iex> import List, only: [duplicate: 2], warn: false\n    iex> Macro.Env.lookup_import(__ENV__, {:duplicate, 2})\n    [{:function, List}, {:function, Tuple}]\n\n    iex> Macro.Env.lookup_import(__ENV__, {:def, 1})\n    [{:macro, Kernel}]","prompt":"Can you write a docstring for the following Elixir function? lookup_import(map, pair)"}
{"completion":"Prepend a tracer to the list of tracers in the environment.\n\n## Examples\n\n    Macro.Env.prepend_tracer(__ENV__, MyCustomTracer)","prompt":"Can you write a docstring for the following Elixir function? prepend_tracer(env, tracer)"}
{"completion":"Prunes compile information from the environment.\n\nThis happens when the environment is captured at compilation\ntime, for example, in the module body, and then used to\nevaluate code after the module has been defined.","prompt":"Can you write a docstring for the following Elixir function? prune_compile_info(env)"}
{"completion":"Returns true if the given module has been required.\n\n## Examples\n\n    iex> Macro.Env.required?(__ENV__, Integer)\n    false\n    iex> require Integer\n    iex> Macro.Env.required?(__ENV__, Integer)\n    true\n\n    iex> Macro.Env.required?(__ENV__, Kernel)\n    true","prompt":"Can you write a docstring for the following Elixir function? required?(map, mod)"}
{"completion":"Returns the environment stacktrace.","prompt":"Can you write a docstring for the following Elixir function? stacktrace(env)"}
{"completion":"Returns a `Macro.Env` in the match context.","prompt":"Can you write a docstring for the following Elixir function? to_match(env)"}
{"completion":"Returns a list of variables in the current environment.\n\nEach variable is identified by a tuple of two elements,\nwhere the first element is the variable name as an atom\nand the second element is its context, which may be an\natom or an integer.","prompt":"Can you write a docstring for the following Elixir function? vars(env)"}
{"completion":"A struct that holds compile time environment information.\n\nThe current environment can be accessed at any time as\n`__ENV__/0`. Inside macros, the caller environment can be\naccessed as `__CALLER__/0`.\n\nAn instance of `Macro.Env` must not be modified by hand. If you need to\ncreate a custom environment to pass to `Code.eval_quoted/3`, use the\nfollowing trick:\n\n    def make_custom_env do\n      import SomeModule, only: [some_function: 2]\n      alias A.B.C\n      __ENV__\n    end\n\nYou may then call `make_custom_env()` to get a struct with the desired\nimports and aliases included.\n\nIt contains the following fields:\n\n  * `context` - the context of the environment; it can be `nil`\n    (default context), `:guard` (inside a guard) or `:match` (inside a match)\n  * `context_modules` - a list of modules defined in the current context\n  * `file` - the current absolute file name as a binary\n  * `function` - a tuple as `{atom, integer}`, where the first\n    element is the function name and the second its arity; returns\n    `nil` if not inside a function\n  * `line` - the current line as an integer\n  * `module` - the current module name\n\nThe following fields are private to Elixir's macro expansion mechanism and\nmust not be accessed directly:\n\n  * `aliases`\n  * `functions`\n  * `macro_aliases`\n  * `macros`\n  * `lexical_tracker`\n  * `requires`\n  * `tracers`\n  * `versioned_vars`","prompt":"Can you write a docstring for the following Elixir function? Elixir.Macro.Env"}
{"completion":"Converts the given string to CamelCase format.\n\nThis function was designed to camelize language identifiers/tokens,\nthat's why it belongs to the `Macro` module. Do not use it as a general\nmechanism for camelizing strings as it does not support Unicode or\ncharacters that are not valid in Elixir identifiers.\n\n## Examples\n\n    iex> Macro.camelize(\"foo_bar\")\n    \"FooBar\"\n\n    iex> Macro.camelize(\"foo/bar\")\n    \"Foo.Bar\"\n\nIf uppercase characters are present, they are not modified in any way\nas a mechanism to preserve acronyms:\n\n    iex> Macro.camelize(\"API.V1\")\n    \"API.V1\"\n    iex> Macro.camelize(\"API_SPEC\")\n    \"API_SPEC\"","prompt":"Can you write a docstring for the following Elixir function? camelize(string)"}
{"completion":"Classifies a runtime `atom` based on its possible AST placement.\n\nIt returns one of the following atoms:\n\n  * `:alias` - the atom represents an alias\n\n  * `:identifier` - the atom can be used as a variable or local function\n    call (as well as be an unquoted atom)\n\n  * `:unquoted` - the atom can be used in its unquoted form,\n    includes operators and atoms with `@` in them\n\n  * `:quoted` - all other atoms which can only be used in their quoted form\n\nMost operators are going to be `:unquoted`, such as `:+`, with\nsome exceptions returning `:quoted` due to ambiguity, such as\n`:\"::\"`. Use `operator?/2` to check if a given atom is an operator.\n\n## Examples\n\n    iex> Macro.classify_atom(:foo)\n    :identifier\n    iex> Macro.classify_atom(Foo)\n    :alias\n    iex> Macro.classify_atom(:foo@bar)\n    :unquoted\n    iex> Macro.classify_atom(:+)\n    :unquoted\n    iex> Macro.classify_atom(:Foo)\n    :unquoted\n    iex> Macro.classify_atom(:\"with spaces\")\n    :quoted","prompt":"Can you write a docstring for the following Elixir function? classify_atom(atom)"}
{"completion":"Default backend for `Kernel.dbg/2`.\n\nThis function provides a default backend for `Kernel.dbg/2`. See the\n`Kernel.dbg/2` documentation for more information.\n\nThis function:\n\n  * prints information about the given `env`\n  * prints information about `code` and its returned value (using `opts` to inspect terms)\n  * returns the value returned by evaluating `code`\n\nYou can call this function directly to build `Kernel.dbg/2` backends that fall back\nto this function.","prompt":"Can you write a docstring for the following Elixir function? dbg(code, options, env)"}
{"completion":"Decomposes a local or remote call into its remote part (when provided),\nfunction name and argument list.\n\nReturns `:error` when an invalid call syntax is provided.\n\n## Examples\n\n    iex> Macro.decompose_call(quote(do: foo))\n    {:foo, []}\n\n    iex> Macro.decompose_call(quote(do: foo()))\n    {:foo, []}\n\n    iex> Macro.decompose_call(quote(do: foo(1, 2, 3)))\n    {:foo, [1, 2, 3]}\n\n    iex> Macro.decompose_call(quote(do: Elixir.M.foo(1, 2, 3)))\n    {{:__aliases__, [], [:Elixir, :M]}, :foo, [1, 2, 3]}\n\n    iex> Macro.decompose_call(quote(do: 42))\n    :error\n\n    iex> Macro.decompose_call(quote(do: {:foo, [], []}))\n    :error","prompt":"Can you write a docstring for the following Elixir function? decompose_call(ast)"}
{"completion":"Recursively escapes a value so it can be inserted into a syntax tree.\n\n## Examples\n\n    iex> Macro.escape(:foo)\n    :foo\n\n    iex> Macro.escape({:a, :b, :c})\n    {:{}, [], [:a, :b, :c]}\n\n    iex> Macro.escape({:unquote, [], [1]}, unquote: true)\n    1\n\n## Options\n\n  * `:unquote` - when true, this function leaves `unquote/1` and\n    `unquote_splicing/1` statements unescaped, effectively unquoting\n    the contents on escape. This option is useful only when escaping\n    ASTs which may have quoted fragments in them. Defaults to false.\n\n  * `:prune_metadata` - when true, removes metadata from escaped AST\n    nodes. Note this option changes the semantics of escaped code and\n    it should only be used when escaping ASTs. Defaults to false.\n\n    As an example, `ExUnit` stores the AST of every assertion, so when\n    an assertion fails we can show code snippets to users. Without this\n    option, each time the test module is compiled, we get a different\n    MD5 of the module bytecode, because the AST contains metadata,\n    such as counters, specific to the compilation environment. By pruning\n    the metadata, we ensure that the module is deterministic and reduce\n    the amount of data `ExUnit` needs to keep around. Only the minimal\n    amount of metadata is kept, such as `:line` and `:no_parens`.\n\n## Comparison to `quote/2`\n\nThe `escape/2` function is sometimes confused with `quote/2`,\nbecause the above examples behave the same with both. The key difference is\nbest illustrated when the value to escape is stored in a variable.\n\n    iex> Macro.escape({:a, :b, :c})\n    {:{}, [], [:a, :b, :c]}\n    iex> quote do: {:a, :b, :c}\n    {:{}, [], [:a, :b, :c]}\n\n    iex> value = {:a, :b, :c}\n    iex> Macro.escape(value)\n    {:{}, [], [:a, :b, :c]}\n\n    iex> quote do: value\n    {:value, [], __MODULE__}\n\n    iex> value = {:a, :b, :c}\n    iex> quote do: unquote(value)\n    {:a, :b, :c}\n\n`escape/2` is used to escape *values* (either directly passed or variable\nbound), while `quote/2` produces syntax trees for\nexpressions.","prompt":"Can you write a docstring for the following Elixir function? escape(expr, opts \\\\ [])"}
{"completion":"Receives an AST node and expands it until it can no longer\nbe expanded.\n\nNote this function does not traverse the AST, only the root\nnode is expanded.\n\nThis function uses `expand_once/2` under the hood. Check\nit out for more information and examples.","prompt":"Can you write a docstring for the following Elixir function? expand(ast, env)"}
{"completion":"Expands all literals in `ast` with the given `env`.\n\nThis function is mostly used to remove compile-time dependencies\nfrom AST nodes. In such cases, the given environment is usually\nmanipulated to represent a function:\n\n    Macro.expand_literals(ast, %{env | function: {:my_code, 1}})\n\nAt the moment, the only expandable literal nodes in an AST are\naliases, so this function only expands aliases.\n\nHowever, be careful when removing compile-time dependencies between\nmodules. If you remove them but you still invoke the module at\ncompile-time, Elixir will be unable to properly recompile modules\nwhen they change.","prompt":"Can you write a docstring for the following Elixir function? expand_literals(ast, env)"}
{"completion":"Expands all literals in `ast` with the given `acc` and `fun`.\n\n`fun` will be invoked with an expandable AST node and `acc` and\nmust return a new node with `acc`. This is a general version of\n`expand_literals/2` which supports a custom expansion function.\nPlease check `expand_literals/2` for use cases and pitfalls.","prompt":"Can you write a docstring for the following Elixir function? expand_literals(ast, acc, fun)"}
{"completion":"Receives an AST node and expands it once.\n\nThe following contents are expanded:\n\n  * Macros (local or remote)\n  * Aliases are expanded (if possible) and return atoms\n  * Compilation environment macros (`__CALLER__/0`, `__DIR__/0`, `__ENV__/0` and `__MODULE__/0`)\n  * Module attributes reader (`@foo`)\n\nIf the expression cannot be expanded, it returns the expression\nitself. This function does not traverse the AST, only the root\nnode is expanded.\n\n`expand_once/2` performs the expansion just once. Check `expand/2`\nto perform expansion until the node can no longer be expanded.\n\n## Examples\n\nIn the example below, we have a macro that generates a module\nwith a function named `name_length` that returns the length\nof the module name. The value of this function will be calculated\nat compilation time and not at runtime.\n\nConsider the implementation below:\n\n    defmacro defmodule_with_length(name, do: block) do\n      length = length(Atom.to_charlist(name))\n\n      quote do\n        defmodule unquote(name) do\n          def name_length, do: unquote(length)\n          unquote(block)\n        end\n      end\n    end\n\nWhen invoked like this:\n\n    defmodule_with_length My.Module do\n      def other_function, do: ...\n    end\n\nThe compilation will fail because `My.Module` when quoted\nis not an atom, but a syntax tree as follows:\n\n    {:__aliases__, [], [:My, :Module]}\n\nThat said, we need to expand the aliases node above to an\natom, so we can retrieve its length. Expanding the node is\nnot straightforward because we also need to expand the\ncaller aliases. For example:\n\n    alias MyHelpers, as: My\n\n    defmodule_with_length My.Module do\n      def other_function, do: ...\n    end\n\nThe final module name will be `MyHelpers.Module` and not\n`My.Module`. With `Macro.expand/2`, such aliases are taken\ninto consideration. Local and remote macros are also\nexpanded. We could rewrite our macro above to use this\nfunction as:\n\n    defmacro defmodule_with_length(name, do: block) do\n      expanded = Macro.expand(name, __CALLER__)\n      length = length(Atom.to_charlist(expanded))\n\n      quote do\n        defmodule unquote(name) do\n          def name_length, do: unquote(length)\n          unquote(block)\n        end\n      end\n    end","prompt":"Can you write a docstring for the following Elixir function? expand_once(ast, env)"}
{"completion":"Generates AST nodes for a given number of required argument\nvariables using `Macro.var/2`.\n\nNote the arguments are not unique. If you later on want\nto access the same variables, you can invoke this function\nwith the same inputs. Use `generate_unique_arguments/2` to\ngenerate a unique arguments that can't be overridden.\n\n## Examples\n\n    iex> Macro.generate_arguments(2, __MODULE__)\n    [{:arg1, [], __MODULE__}, {:arg2, [], __MODULE__}]","prompt":"Can you write a docstring for the following Elixir function? generate_arguments(amount, context)"}
{"completion":"Generates AST nodes for a given number of required argument\nvariables using `Macro.unique_var/2`.\n\n## Examples\n\n    iex> [var1, var2] = Macro.generate_unique_arguments(2, __MODULE__)\n    iex> {:arg1, [counter: c1], __MODULE__} = var1\n    iex> {:arg2, [counter: c2], __MODULE__} = var2\n    iex> is_integer(c1) and is_integer(c2)\n    true","prompt":"Can you write a docstring for the following Elixir function? generate_unique_arguments(amount, context)"}
{"completion":"Inspects `atom` according to different source formats.\n\nThe atom can be inspected according to the three different\nformats it appears in the AST: as a literal (`:literal`),\nas a key (`:key`), or as the function name of a remote call\n(`:remote_call`).\n\n## Examples\n\n### As a literal\n\nLiterals include regular atoms, quoted atoms, operators,\naliases, and the special `nil`, `true`, and `false` atoms.\n\n    iex> Macro.inspect_atom(:literal, nil)\n    \"nil\"\n    iex> Macro.inspect_atom(:literal, :foo)\n    \":foo\"\n    iex> Macro.inspect_atom(:literal, :<>)\n    \":<>\"\n    iex> Macro.inspect_atom(:literal, :Foo)\n    \":Foo\"\n    iex> Macro.inspect_atom(:literal, Foo.Bar)\n    \"Foo.Bar\"\n    iex> Macro.inspect_atom(:literal, :\"with spaces\")\n    \":\\\"with spaces\\\"\"\n\n### As a key\n\nInspect an atom as a key of a keyword list or a map.\n\n    iex> Macro.inspect_atom(:key, :foo)\n    \"foo:\"\n    iex> Macro.inspect_atom(:key, :<>)\n    \"<>:\"\n    iex> Macro.inspect_atom(:key, :Foo)\n    \"Foo:\"\n    iex> Macro.inspect_atom(:key, :\"with spaces\")\n    \"\\\"with spaces\\\":\"\n\n### As a remote call\n\nInspect an atom the function name of a remote call.\n\n    iex> Macro.inspect_atom(:remote_call, :foo)\n    \"foo\"\n    iex> Macro.inspect_atom(:remote_call, :<>)\n    \"<>\"\n    iex> Macro.inspect_atom(:remote_call, :Foo)\n    \"\\\"Foo\\\"\"\n    iex> Macro.inspect_atom(:remote_call, :\"with spaces\")\n    \"\\\"with spaces\\\"\"","prompt":"Can you write a docstring for the following Elixir function? inspect_atom(source_format, atom)"}
{"completion":"Returns `true` if the given name and arity is an operator.\n\n## Examples\n\n    iex> Macro.operator?(:not_an_operator, 3)\n    false\n    iex> Macro.operator?(:.., 0)\n    true\n    iex> Macro.operator?(:+, 1)\n    true\n    iex> Macro.operator?(:++, 2)\n    true\n    iex> Macro.operator?(:..//, 3)\n    true","prompt":"Can you write a docstring for the following Elixir function? operator?(name, arity)"}
{"completion":"Returns the path to the node in `ast` which `fun` returns true.\n\nThe path is a list, starting with the node in which `fun` returns\ntrue, followed by all of its parents.\n\nComputing the path can be an efficient operation when you want\nto find a particular node in the AST within its context and then\nassert something about it.\n\n## Examples\n\n    iex> Macro.path(quote(do: [1, 2, 3]), & &1 == 3)\n    [3, [1, 2, 3]]\n\n    iex> Macro.path(quote(do: Foo.bar(3)), & &1 == 3)\n    [3, quote(do: Foo.bar(3))]\n\n    iex> Macro.path(quote(do: %{foo: [bar: :baz]}), & &1 == :baz)\n    [\n      :baz,\n      {:bar, :baz},\n      [bar: :baz],\n      {:foo, [bar: :baz]},\n      {:%{}, [], [foo: [bar: :baz]]}\n    ]","prompt":"Can you write a docstring for the following Elixir function? path(ast, fun)"}
{"completion":"Pipes `expr` into the `call_args` at the given `position`.\n\nThis function can be used to implement `|>` like functionality. For example,\n`|>` itself is implemented as:\n\n    defmacro left |> right do\n      Macro.pipe(left, right, 0)\n    end\n\n`expr` is the AST of an expression. `call_args` must be the AST *of a call*,\notherwise this function will raise an error. As an example, consider the pipe\noperator `|>/2`, which uses this function to build pipelines.\n\nEven if the expression is piped into the AST, it doesn't necessarily mean that\nthe AST is valid. For example, you could pipe an argument to `div/2`, effectively\nturning it into a call to `div/3`, which is a function that doesn't exist by\ndefault. The code will raise unless a `div/3` function is locally defined.","prompt":"Can you write a docstring for the following Elixir function? pipe(expr, call_args, position)"}
{"completion":"This function behaves like `prewalk/2`, but performs a depth-first,\npost-order traversal of quoted expressions.","prompt":"Can you write a docstring for the following Elixir function? postwalk(ast, fun)"}
{"completion":"This functions behaves like `prewalk/3`, but performs a depth-first,\npost-order traversal of quoted expressions using an accumulator.","prompt":"Can you write a docstring for the following Elixir function? postwalk(ast, acc, fun)"}
{"completion":"Returns an enumerable that traverses the  `ast` in depth-first,\npost-order traversal.\n\n## Examples\n\n    iex> ast = quote do: foo(1, \"abc\")\n    iex> Enum.map(Macro.postwalker(ast), & &1)\n    [1, \"abc\", {:foo, [], [1, \"abc\"]}]","prompt":"Can you write a docstring for the following Elixir function? postwalker(ast)"}
{"completion":"Performs a depth-first, pre-order traversal of quoted expressions.\n\nReturns a new AST where each node is the result of invoking `fun` on each\ncorresponding node of `ast`.\n\n## Examples\n\n    iex> ast = quote do: 5 + 3 * 7\n    iex> {:+, _, [5, {:*, _, [3, 7]}]} = ast\n    iex> new_ast = Macro.prewalk(ast, fn\n    ...>   {:+, meta, children} -> {:*, meta, children}\n    ...>   {:*, meta, children} -> {:+, meta, children}\n    ...>   other -> other\n    ...> end)\n    iex> {:*, _, [5, {:+, _, [3, 7]}]} = new_ast\n    iex> Code.eval_quoted(ast)\n    {26, []}\n    iex> Code.eval_quoted(new_ast)\n    {50, []}","prompt":"Can you write a docstring for the following Elixir function? prewalk(ast, fun)"}
{"completion":"Performs a depth-first, pre-order traversal of quoted expressions\nusing an accumulator.\n\nReturns a tuple where the first element is a new AST where each node is the\nresult of invoking `fun` on each corresponding node and the second one is the\nfinal accumulator.\n\n## Examples\n\n    iex> ast = quote do: 5 + 3 * 7\n    iex> {:+, _, [5, {:*, _, [3, 7]}]} = ast\n    iex> {new_ast, acc} = Macro.prewalk(ast, [], fn\n    ...>   {:+, meta, children}, acc -> {{:*, meta, children}, [:+ | acc]}\n    ...>   {:*, meta, children}, acc -> {{:+, meta, children}, [:* | acc]}\n    ...>   other, acc -> {other, acc}\n    ...> end)\n    iex> {{:*, _, [5, {:+, _, [3, 7]}]}, [:*, :+]} = {new_ast, acc}\n    iex> Code.eval_quoted(ast)\n    {26, []}\n    iex> Code.eval_quoted(new_ast)\n    {50, []}","prompt":"Can you write a docstring for the following Elixir function? prewalk(ast, acc, fun)"}
{"completion":"Returns an enumerable that traverses the  `ast` in depth-first,\npre-order traversal.\n\n## Examples\n\n    iex> ast = quote do: foo(1, \"abc\")\n    iex> Enum.map(Macro.prewalker(ast), & &1)\n    [{:foo, [], [1, \"abc\"]}, 1, \"abc\"]","prompt":"Can you write a docstring for the following Elixir function? prewalker(ast)"}
{"completion":"Returns `true` if the given quoted expression represents a quoted literal.\n\nAtoms and numbers are always literals. Binaries, lists, tuples,\nmaps, and structs are only literals if all of their terms are also literals.\n\n## Examples\n\n    iex> Macro.quoted_literal?(quote(do: \"foo\"))\n    true\n    iex> Macro.quoted_literal?(quote(do: {\"foo\", 1}))\n    true\n    iex> Macro.quoted_literal?(quote(do: {\"foo\", 1, :baz}))\n    true\n    iex> Macro.quoted_literal?(quote(do: %{foo: \"bar\"}))\n    true\n    iex> Macro.quoted_literal?(quote(do: %URI{path: \"/\"}))\n    true\n    iex> Macro.quoted_literal?(quote(do: URI.parse(\"/\")))\n    false\n    iex> Macro.quoted_literal?(quote(do: {foo, var}))\n    false","prompt":"Can you write a docstring for the following Elixir function? quoted_literal?(term)"}
{"completion":"Returns `true` if the given name and arity is a special form.","prompt":"Can you write a docstring for the following Elixir function? special_form?(name, arity)"}
{"completion":"Expands the struct given by `module` in the given `env`.\n\nThis is useful when a struct needs to be expanded at\ncompilation time and the struct being expanded may or may\nnot have been compiled. This function is also capable of\nexpanding structs defined under the module being compiled.\n\nIt will raise `CompileError` if the struct is not available.\nFrom Elixir v1.12, calling this function also adds an export\ndependency on the given struct.","prompt":"Can you write a docstring for the following Elixir function? struct!(module, env)"}
{"completion":"Converts the given expression AST to a string.\n\nThis is a convenience function for converting AST into\na string, which discards all formatting of the original\ncode and wraps newlines around 98 characters. See\n`Code.quoted_to_algebra/2` as a lower level function\nwith more control around formatting.\n\n## Examples\n\n    iex> Macro.to_string(quote(do: foo.bar(1, 2, 3)))\n    \"foo.bar(1, 2, 3)\"","prompt":"Can you write a docstring for the following Elixir function? to_string(tree)"}
{"completion":"Converts the given expression AST to a string.\n\nThe given `fun` is called for every node in the AST with two arguments: the\nAST of the node being printed and the string representation of that same\nnode. The return value of this function is used as the final string\nrepresentation for that AST node.\n\nThis function discards all formatting of the original code.\n\n## Examples\n\n    Macro.to_string(quote(do: 1 + 2), fn\n      1, _string -> \"one\"\n      2, _string -> \"two\"\n      _ast, string -> string\n    end)\n    #=> \"one + two\"","prompt":"Can you write a docstring for the following Elixir function? to_string(tree, fun)"}
{"completion":"Performs a depth-first traversal of quoted expressions\nusing an accumulator.\n\nReturns a tuple where the first element is a new AST and the second one is\nthe final accumulator. The new AST is the result of invoking `pre` on each\nnode of `ast` during the pre-order phase and `post` during the post-order\nphase.\n\n## Examples\n\n    iex> ast = quote do: 5 + 3 * 7\n    iex> {:+, _, [5, {:*, _, [3, 7]}]} = ast\n    iex> {new_ast, acc} =\n    ...>  Macro.traverse(\n    ...>    ast,\n    ...>    [],\n    ...>    fn\n    ...>      {:+, meta, children}, acc -> {{:-, meta, children}, [:- | acc]}\n    ...>      {:*, meta, children}, acc -> {{:/, meta, children}, [:/ | acc]}\n    ...>      other, acc -> {other, acc}\n    ...>    end,\n    ...>    fn\n    ...>      {:-, meta, children}, acc -> {{:min, meta, children}, [:min | acc]}\n    ...>      {:/, meta, children}, acc -> {{:max, meta, children}, [:max | acc]}\n    ...>      other, acc -> {other, acc}\n    ...>    end\n    ...>  )\n    iex> {:min, _, [5, {:max, _, [3, 7]}]} = new_ast\n    iex> [:min, :max, :/, :-] = acc\n    iex> Code.eval_quoted(new_ast)\n    {5, []}","prompt":"Can you write a docstring for the following Elixir function? traverse(ast, acc, pre, post)"}
{"completion":"Converts the given argument to a string with the underscore-slash format.\n\nThe argument must either be an atom or a string.\nIf an atom is given, it is assumed to be an Elixir module,\nso it is converted to a string and then processed.\n\nThis function was designed to format language identifiers/tokens with the underscore-slash format,\nthat's why it belongs to the `Macro` module. Do not use it as a general\nmechanism for underscoring strings as it does not support Unicode or\ncharacters that are not valid in Elixir identifiers.\n\n## Examples\n\n    iex> Macro.underscore(\"FooBar\")\n    \"foo_bar\"\n\n    iex> Macro.underscore(\"Foo.Bar\")\n    \"foo/bar\"\n\n    iex> Macro.underscore(Foo.Bar)\n    \"foo/bar\"\n\nIn general, `underscore` can be thought of as the reverse of\n`camelize`, however, in some cases formatting may be lost:\n\n    iex> Macro.underscore(\"SAPExample\")\n    \"sap_example\"\n\n    iex> Macro.camelize(\"sap_example\")\n    \"SapExample\"\n\n    iex> Macro.camelize(\"hello_10\")\n    \"Hello10\"\n\n    iex> Macro.camelize(\"foo/bar\")\n    \"Foo.Bar\"","prompt":"Can you write a docstring for the following Elixir function? underscore(atom_or_string)"}
{"completion":"Unescapes characters in a string.\n\nThis is the unescaping behaviour used by default in Elixir\nsingle- and double-quoted strings. Check `unescape_string/2`\nfor information on how to customize the escaping map.\n\nIn this setup, Elixir will escape the following: `\\0`, `\\a`, `\\b`,\n`\\d`, `\\e`, `\\f`, `\\n`, `\\r`, `\\s`, `\\t` and `\\v`. Bytes can be\ngiven as hexadecimals via `\\xNN` and Unicode code points as\n`\\uNNNN` escapes.\n\nThis function is commonly used on sigil implementations\n(like `~r`, `~s` and others), which receive a raw, unescaped\nstring, and it can be used anywhere that needs to mimic how\nElixir parses strings.\n\n## Examples\n\n    iex> Macro.unescape_string(\"example\\\\n\")\n    \"example\\n\"\n\nIn the example above, we pass a string with `\\n` escaped\nand return a version with it unescaped.","prompt":"Can you write a docstring for the following Elixir function? unescape_string(string)"}
{"completion":"Unescapes characters in a string according to the given mapping.\n\nCheck `unescape_string/1` if you want to use the same mapping\nas Elixir single- and double-quoted strings.\n\n## Mapping function\n\nThe mapping function receives an integer representing the code point\nof the character it wants to unescape. There are also the special atoms\n`:newline`, `:unicode`, and `:hex`, which control newline, unicode,\nand escaping respectively.\n\nHere is the default mapping function implemented by Elixir:\n\n    def unescape_map(:newline), do: true\n    def unescape_map(:unicode), do: true\n    def unescape_map(:hex), do: true\n    def unescape_map(?0), do: ?0\n    def unescape_map(?a), do: ?\\a\n    def unescape_map(?b), do: ?\\b\n    def unescape_map(?d), do: ?\\d\n    def unescape_map(?e), do: ?\\e\n    def unescape_map(?f), do: ?\\f\n    def unescape_map(?n), do: ?\\n\n    def unescape_map(?r), do: ?\\r\n    def unescape_map(?s), do: ?\\s\n    def unescape_map(?t), do: ?\\t\n    def unescape_map(?v), do: ?\\v\n    def unescape_map(e), do: e\n\nIf the `unescape_map/1` function returns `false`, the char is\nnot escaped and the backslash is kept in the string.\n\n## Examples\n\nUsing the `unescape_map/1` function defined above is easy:\n\n    Macro.unescape_string(\"example\\\\n\", &unescape_map(&1))","prompt":"Can you write a docstring for the following Elixir function? unescape_string(string, map)"}
{"completion":"Generates an AST node representing a unique variable\ngiven by the atoms `var` and `context`.\n\nCalling this function with the same arguments will\ngenerate another variable, with its own unique counter.\nSee `var/2` for an alternative.\n\n## Examples\n\n    iex> {:foo, [counter: c], __MODULE__} = Macro.unique_var(:foo, __MODULE__)\n    iex> is_integer(c)\n    true","prompt":"Can you write a docstring for the following Elixir function? unique_var(var, context)"}
{"completion":"Breaks a pipeline expression into a list.\n\nThe AST for a pipeline (a sequence of applications of `|>/2`) is similar to the\nAST of a sequence of binary operators or function applications: the top-level\nexpression is the right-most `:|>` (which is the last one to be executed), and\nits left-hand and right-hand sides are its arguments:\n\n    quote do: 100 |> div(5) |> div(2)\n    #=> {:|>, _, [arg1, arg2]}\n\nIn the example above, the `|>/2` pipe is the right-most pipe; `arg1` is the AST\nfor `100 |> div(5)`, and `arg2` is the AST for `div(2)`.\n\nIt's often useful to have the AST for such a pipeline as a list of function\napplications. This function does exactly that:\n\n    Macro.unpipe(quote do: 100 |> div(5) |> div(2))\n    #=> [{100, 0}, {{:div, [], [5]}, 0}, {{:div, [], [2]}, 0}]\n\nWe get a list that follows the pipeline directly: first the `100`, then the\n`div(5)` (more precisely, its AST), then `div(2)`. The `0` as the second\nelement of the tuples is the position of the previous element in the pipeline\ninside the current function application: `{{:div, [], [5]}, 0}` means that the\nprevious element (`100`) will be inserted as the 0th (first) argument to the\n`div/2` function, so that the AST for that function will become `{:div, [],\n[100, 5]}` (`div(100, 5)`).","prompt":"Can you write a docstring for the following Elixir function? unpipe(expr)"}
{"completion":"Applies the given function to the node metadata if it contains one.\n\nThis is often useful when used with `Macro.prewalk/2` to remove\ninformation like lines and hygienic counters from the expression\nfor either storage or comparison.\n\n## Examples\n\n    iex> quoted = quote line: 10, do: sample()\n    {:sample, [line: 10], []}\n    iex> Macro.update_meta(quoted, &Keyword.delete(&1, :line))\n    {:sample, [], []}","prompt":"Can you write a docstring for the following Elixir function? update_meta(quoted, fun)"}
{"completion":"Validates the given expressions are valid quoted expressions.\n\nCheck the type `t:Macro.t/0` for a complete specification of a\nvalid quoted expression.\n\nIt returns `:ok` if the expression is valid. Otherwise it returns\na tuple in the form of `{:error, remainder}` where `remainder` is\nthe invalid part of the quoted expression.\n\n## Examples\n\n    iex> Macro.validate({:two_element, :tuple})\n    :ok\n    iex> Macro.validate({:three, :element, :tuple})\n    {:error, {:three, :element, :tuple}}\n\n    iex> Macro.validate([1, 2, 3])\n    :ok\n    iex> Macro.validate([1, 2, 3, {4}])\n    {:error, {4}}","prompt":"Can you write a docstring for the following Elixir function? validate(expr)"}
{"completion":"Generates an AST node representing the variable given\nby the atoms `var` and `context`.\n\nNote this variable is not unique. If you later on want\nto access this same variable, you can invoke `var/2`\nagain with the same arguments. Use `unique_var/2` to\ngenerate a unique variable that can't be overridden.\n\n## Examples\n\nIn order to build a variable, a context is expected.\nMost of the times, in order to preserve hygiene, the\ncontext must be `__MODULE__/0`:\n\n    iex> Macro.var(:foo, __MODULE__)\n    {:foo, [], __MODULE__}\n\nHowever, if there is a need to access the user variable,\nnil can be given:\n\n    iex> Macro.var(:foo, nil)\n    {:foo, [], nil}","prompt":"Can you write a docstring for the following Elixir function? var(var, context)"}
{"completion":"Functions for manipulating AST and implementing macros.\n\nMacros are compile-time constructs that receive Elixir's AST as input\nand return Elixir's AST as output.\n\nMany of the functions in this module exist precisely to work with Elixir\nAST, to traverse, query, and transform it.\n\nLet's see a simple example that shows the difference between functions\nand macros:\n\n    defmodule Example do\n      defmacro macro_inspect(value) do\n        IO.inspect(value)\n        value\n      end\n\n      def fun_inspect(value) do\n        IO.inspect(value)\n        value\n      end\n    end\n\nNow let's give it a try:\n\n    import Example\n\n    macro_inspect(1)\n    #=> 1\n    #=> 1\n\n    fun_inspect(1)\n    #=> 1\n    #=> 1\n\nSo far they behave the same, as we are passing an integer as argument.\nBut let's see what happens when we pass an expression:\n\n    macro_inspect(1 + 2)\n    #=> {:+, [line: 3], [1, 2]}\n    #=> 3\n\n    fun_inspect(1 + 2)\n    #=> 3\n    #=> 3\n\nThe macro receives the representation of the code given as argument,\nwhile a function receives the result of the code given as argument.\nA macro must return a superset of the code representation. See\n`t:input/0` and `t:output/0` for more information.\n\nTo learn more about Elixir's AST and how to build them programmatically,\nsee `quote/2`.\n\n> Note: the functions in this module do not evaluate code. In fact,\n> evaluating code from macros is often an anti-pattern. For code\n> evaluation, see the `Code` module.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Macro"}
{"completion":"Custom Sigils\n\nMacros are also commonly used to implement custom sigils. To create a custom\nsigil, define a macro with the name `sigil_{identifier}` that takes two\narguments. The first argument will be the string, the second will be a charlist\ncontaining any modifiers. If the sigil is lower case (such as `sigil_x`) then\nthe string argument will allow interpolation. If the sigil is upper case\n(such as `sigil_X`) then the string will not be interpolated.\n\nValid modifiers include only lower and upper case letters. Other characters\nwill cause a syntax error.\n\nThe module containing the custom sigil must be imported before the sigil\nsyntax can be used.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Macro"}
{"completion":"# Examples\n\n    defmodule MySigils do\n      defmacro sigil_x(term, [?r]) do\n        quote do\n          unquote(term) |> String.reverse()\n        end\n      end\n      defmacro sigil_x(term, _modifiers) do\n        term\n      end\n      defmacro sigil_X(term, [?r]) do\n        quote do\n          unquote(term) |> String.reverse()\n        end\n      end\n      defmacro sigil_X(term, _modifiers) do\n        term\n      end\n    end\n\n    import MySigils\n\n    ~x(with #{\"inter\" <> \"polation\"})\n    #=>\"with interpolation\"\n\n    ~x(with #{\"inter\" <> \"polation\"})r\n    #=>\"noitalopretni htiw\"\n\n    ~X(without #{\"interpolation\"})\n    #=>\"without \\#{\"interpolation\"}\"\n\n    ~X(without #{\"interpolation\"})r\n    #=>\"}\\\"noitalopretni\\\"{# tuohtiw\"","prompt":"Can you write a docstring for the following Elixir function? Elixir.Macro"}
{"completion":"Deletes the entry in `map` for a specific `key`.\n\nIf the `key` does not exist, returns `map` unchanged.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.delete(%{a: 1, b: 2}, :a)\n    %{b: 2}\n    iex> Map.delete(%{b: 2}, :a)\n    %{b: 2}","prompt":"Can you write a docstring for the following Elixir function? delete(map, key)"}
{"completion":"Drops the given `keys` from `map`.\n\nIf `keys` contains keys that are not in `map`, they're simply ignored.\n\n## Examples\n\n    iex> Map.drop(%{a: 1, b: 2, c: 3}, [:b, :d])\n    %{a: 1, c: 3}","prompt":"Can you write a docstring for the following Elixir function? drop(map, keys)"}
{"completion":"Checks if two maps are equal.\n\nTwo maps are considered to be equal if they contain\nthe same keys and those keys contain the same values.\n\nNote this function exists for completeness so the `Map`\nand `Keyword` modules provide similar APIs. In practice,\ndevelopers often compare maps using `==/2` or `===/2`\ndirectly.\n\n## Examples\n\n    iex> Map.equal?(%{a: 1, b: 2}, %{b: 2, a: 1})\n    true\n    iex> Map.equal?(%{a: 1, b: 2}, %{b: 1, a: 2})\n    false\n\nComparison between keys and values is done with `===/3`,\nwhich means integers are not equivalent to floats:\n\n    iex> Map.equal?(%{a: 1.0}, %{a: 1})\n    false","prompt":"Can you write a docstring for the following Elixir function? equal?(map1, map2)"}
{"completion":"Fetches the value for a specific `key` in the given `map`.\n\nIf `map` contains the given `key` then its value is returned in the shape of `{:ok, value}`.\nIf `map` doesn't contain `key`, `:error` is returned.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.fetch(%{a: 1}, :a)\n    {:ok, 1}\n    iex> Map.fetch(%{a: 1}, :b)\n    :error","prompt":"Can you write a docstring for the following Elixir function? fetch(map, key)"}
{"completion":"Fetches the value for a specific `key` in the given `map`, erroring out if\n`map` doesn't contain `key`.\n\nIf `map` contains `key`, the corresponding value is returned. If\n`map` doesn't contain `key`, a `KeyError` exception is raised.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.fetch!(%{a: 1}, :a)\n    1","prompt":"Can you write a docstring for the following Elixir function? fetch!(map, key)"}
{"completion":"Returns a map containing only those pairs from `map`\nfor which `fun` returns a truthy value.\n\n`fun` receives the key and value of each of the\nelements in the map as a key-value pair.\n\nSee also `reject/2` which discards all elements where the\nfunction returns a truthy value.\n\n> Note: if you find yourself doing multiple calls to `Map.filter/2`\n> and `Map.reject/2` in a pipeline, it is likely more efficient\n> to use `Enum.map/2` and `Enum.filter/2` instead and convert to\n> a map at the end using `Map.new/1`.\n\n## Examples\n\n    iex> Map.filter(%{one: 1, two: 2, three: 3}, fn {_key, val} -> rem(val, 2) == 1 end)\n    %{one: 1, three: 3}","prompt":"Can you write a docstring for the following Elixir function? filter(map, fun)"}
{"completion":"Builds a map from the given `keys` and the fixed `value`.\n\n## Examples\n\n    iex> Map.from_keys([1, 2, 3], :number)\n    %{1 => :number, 2 => :number, 3 => :number}","prompt":"Can you write a docstring for the following Elixir function? from_keys(keys, value)"}
{"completion":"Converts a `struct` to map.\n\nIt accepts the struct module or a struct itself and\nsimply removes the `__struct__` field from the given struct\nor from a new struct generated from the given module.\n\n## Example\n\n    defmodule User do\n      defstruct [:name]\n    end\n\n    Map.from_struct(User)\n    #=> %{name: nil}\n\n    Map.from_struct(%User{name: \"john\"})\n    #=> %{name: \"john\"}","prompt":"Can you write a docstring for the following Elixir function? from_struct(struct)"}
{"completion":"Gets the value for a specific `key` in `map`.\n\nIf `key` is present in `map` then its value `value` is\nreturned. Otherwise, `default` is returned.\n\nIf `default` is not provided, `nil` is used.\n\n## Examples\n\n    iex> Map.get(%{}, :a)\n    nil\n    iex> Map.get(%{a: 1}, :a)\n    1\n    iex> Map.get(%{a: 1}, :b)\n    nil\n    iex> Map.get(%{a: 1}, :b, 3)\n    3","prompt":"Can you write a docstring for the following Elixir function? get(map, key, default \\\\ nil)"}
{"completion":"Gets the value from `key` and updates it, all in one pass.\n\n`fun` is called with the current value under `key` in `map` (or `nil` if `key`\nis not present in `map`) and must return a two-element tuple: the current value\n(the retrieved value, which can be operated on before being returned) and the\nnew value to be stored under `key` in the resulting new map. `fun` may also\nreturn `:pop`, which means the current value shall be removed from `map` and\nreturned (making this function behave like `Map.pop(map, key)`).\n\nThe returned value is a two-element tuple with the current value returned by\n`fun` and a new map with the updated value under `key`.\n\n## Examples\n\n    iex> Map.get_and_update(%{a: 1}, :a, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {1, %{a: \"new value!\"}}\n\n    iex> Map.get_and_update(%{a: 1}, :b, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {nil, %{a: 1, b: \"new value!\"}}\n\n    iex> Map.get_and_update(%{a: 1}, :a, fn _ -> :pop end)\n    {1, %{}}\n\n    iex> Map.get_and_update(%{a: 1}, :b, fn _ -> :pop end)\n    {nil, %{a: 1}}","prompt":"Can you write a docstring for the following Elixir function? get_and_update(map, key, fun)"}
{"completion":"Gets the value from `key` and updates it, all in one pass. Raises if there is no `key`.\n\nBehaves exactly like `get_and_update/3`, but raises a `KeyError` exception if\n`key` is not present in `map`.\n\n## Examples\n\n    iex> Map.get_and_update!(%{a: 1}, :a, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {1, %{a: \"new value!\"}}\n\n    iex> Map.get_and_update!(%{a: 1}, :b, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    ** (KeyError) key :b not found in: %{a: 1}\n\n    iex> Map.get_and_update!(%{a: 1}, :a, fn _ ->\n    ...>   :pop\n    ...> end)\n    {1, %{}}","prompt":"Can you write a docstring for the following Elixir function? get_and_update!(map, key, fun)"}
{"completion":"Gets the value for a specific `key` in `map`.\n\nIf `key` is present in `map` then its value `value` is\nreturned. Otherwise, `fun` is evaluated and its result is returned.\n\nThis is useful if the default value is very expensive to calculate or\ngenerally difficult to setup and teardown again.\n\n## Examples\n\n    iex> map = %{a: 1}\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   13\n    ...> end\n    iex> Map.get_lazy(map, :a, fun)\n    1\n    iex> Map.get_lazy(map, :b, fun)\n    13","prompt":"Can you write a docstring for the following Elixir function? get_lazy(map, key, fun)"}
{"completion":"Returns whether the given `key` exists in the given `map`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.has_key?(%{a: 1}, :a)\n    true\n    iex> Map.has_key?(%{a: 1}, :b)\n    false","prompt":"Can you write a docstring for the following Elixir function? has_key?(map, key)"}
{"completion":"Returns all keys from `map`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.keys(%{a: 1, b: 2})\n    [:a, :b]","prompt":"Can you write a docstring for the following Elixir function? keys(map)"}
{"completion":"Merges two maps into one.\n\nAll keys in `map2` will be added to `map1`, overriding any existing one\n(i.e., the keys in `map2` \"have precedence\" over the ones in `map1`).\n\nIf you have a struct and you would like to merge a set of keys into the\nstruct, do not use this function, as it would merge all keys on the right\nside into the struct, even if the key is not part of the struct. Instead,\nuse `struct/2`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4})\n    %{a: 3, b: 2, d: 4}","prompt":"Can you write a docstring for the following Elixir function? merge(map1, map2)"}
{"completion":"Merges two maps into one, resolving conflicts through the given `fun`.\n\nAll keys in `map2` will be added to `map1`. The given function will be invoked\nwhen there are duplicate keys; its arguments are `key` (the duplicate key),\n`value1` (the value of `key` in `map1`), and `value2` (the value of `key` in\n`map2`). The value returned by `fun` is used as the value under `key` in\nthe resulting map.\n\n## Examples\n\n    iex> Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4}, fn _k, v1, v2 ->\n    ...>   v1 + v2\n    ...> end)\n    %{a: 4, b: 2, d: 4}","prompt":"Can you write a docstring for the following Elixir function? merge(map1, map2, fun)"}
{"completion":"Returns a new empty map.\n\n## Examples\n\n    iex> Map.new()\n    %{}","prompt":"Can you write a docstring for the following Elixir function? new()"}
{"completion":"Creates a map from an `enumerable`.\n\nDuplicated keys are removed; the latest one prevails.\n\n## Examples\n\n    iex> Map.new([{:b, 1}, {:a, 2}])\n    %{a: 2, b: 1}\n    iex> Map.new(a: 1, a: 2, a: 3)\n    %{a: 3}","prompt":"Can you write a docstring for the following Elixir function? new(enumerable)"}
{"completion":"Creates a map from an `enumerable` via the given transformation function.\n\nDuplicated keys are removed; the latest one prevails.\n\n## Examples\n\n    iex> Map.new([:a, :b], fn x -> {x, x} end)\n    %{a: :a, b: :b}","prompt":"Can you write a docstring for the following Elixir function? new(enumerable, transform)"}
{"completion":"Removes the value associated with `key` in `map` and returns the value and the updated map.\n\nIf `key` is present in `map`, it returns `{value, updated_map}` where `value` is the value of\nthe key and `updated_map` is the result of removing `key` from `map`. If `key`\nis not present in `map`, `{default, map}` is returned.\n\n## Examples\n\n    iex> Map.pop(%{a: 1}, :a)\n    {1, %{}}\n    iex> Map.pop(%{a: 1}, :b)\n    {nil, %{a: 1}}\n    iex> Map.pop(%{a: 1}, :b, 3)\n    {3, %{a: 1}}","prompt":"Can you write a docstring for the following Elixir function? pop(map, key, default \\\\ nil)"}
{"completion":"Removes the value associated with `key` in `map` and returns the value\nand the updated map, or it raises if `key` is not present.\n\nBehaves the same as `pop/3` but raises if `key` is not present in `map`.\n\n## Examples\n\n    iex> Map.pop!(%{a: 1}, :a)\n    {1, %{}}\n    iex> Map.pop!(%{a: 1, b: 2}, :a)\n    {1, %{b: 2}}\n    iex> Map.pop!(%{a: 1}, :b)\n    ** (KeyError) key :b not found in: %{a: 1}","prompt":"Can you write a docstring for the following Elixir function? pop!(map, key)"}
{"completion":"Lazily returns and removes the value associated with `key` in `map`.\n\nIf `key` is present in `map`, it returns `{value, new_map}` where `value` is the value of\nthe key and `new_map` is the result of removing `key` from `map`. If `key`\nis not present in `map`, `{fun_result, map}` is returned, where `fun_result`\nis the result of applying `fun`.\n\nThis is useful if the default value is very expensive to calculate or\ngenerally difficult to setup and teardown again.\n\n## Examples\n\n    iex> map = %{a: 1}\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   13\n    ...> end\n    iex> Map.pop_lazy(map, :a, fun)\n    {1, %{}}\n    iex> Map.pop_lazy(map, :b, fun)\n    {13, %{a: 1}}","prompt":"Can you write a docstring for the following Elixir function? pop_lazy(map, key, fun)"}
{"completion":"Puts the given `value` under `key` in `map`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.put(%{a: 1}, :b, 2)\n    %{a: 1, b: 2}\n    iex> Map.put(%{a: 1, b: 2}, :a, 3)\n    %{a: 3, b: 2}","prompt":"Can you write a docstring for the following Elixir function? put(map, key, value)"}
{"completion":"Puts the given `value` under `key` unless the entry `key`\nalready exists in `map`.\n\n## Examples\n\n    iex> Map.put_new(%{a: 1}, :b, 2)\n    %{a: 1, b: 2}\n    iex> Map.put_new(%{a: 1, b: 2}, :a, 3)\n    %{a: 1, b: 2}","prompt":"Can you write a docstring for the following Elixir function? put_new(map, key, value)"}
{"completion":"Evaluates `fun` and puts the result under `key`\nin `map` unless `key` is already present.\n\nThis function is useful in case you want to compute the value to put under\n`key` only if `key` is not already present, as for example, when the value is expensive to\ncalculate or generally difficult to setup and teardown again.\n\n## Examples\n\n    iex> map = %{a: 1}\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   3\n    ...> end\n    iex> Map.put_new_lazy(map, :a, fun)\n    %{a: 1}\n    iex> Map.put_new_lazy(map, :b, fun)\n    %{a: 1, b: 3}","prompt":"Can you write a docstring for the following Elixir function? put_new_lazy(map, key, fun)"}
{"completion":"Returns map excluding the pairs from `map` for which `fun` returns\na truthy value.\n\nSee also `filter/2`.\n\n## Examples\n\n    iex> Map.reject(%{one: 1, two: 2, three: 3}, fn {_key, val} -> rem(val, 2) == 1 end)\n    %{two: 2}","prompt":"Can you write a docstring for the following Elixir function? reject(map, fun)"}
{"completion":"Puts a value under `key` only if the `key` already exists in `map`.\n\n## Examples\n\n    iex> Map.replace(%{a: 1, b: 2}, :a, 3)\n    %{a: 3, b: 2}\n\n    iex> Map.replace(%{a: 1}, :b, 2)\n    %{a: 1}","prompt":"Can you write a docstring for the following Elixir function? replace(map, key, value)"}
{"completion":"Puts a value under `key` only if the `key` already exists in `map`.\n\nIf `key` is not present in `map`, a `KeyError` exception is raised.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.replace!(%{a: 1, b: 2}, :a, 3)\n    %{a: 3, b: 2}\n\n    iex> Map.replace!(%{a: 1}, :b, 2)\n    ** (KeyError) key :b not found in: %{a: 1}","prompt":"Can you write a docstring for the following Elixir function? replace!(map, key, value)"}
{"completion":"Replaces the value under `key` using the given function only if\n`key` already exists in `map`.\n\nIn comparison to `replace/3`, this can be useful when it's expensive to calculate the value.\n\nIf `key` does not exist, the original map is returned unchanged.\n\n## Examples\n\n    iex> Map.replace_lazy(%{a: 1, b: 2}, :a, fn v -> v * 4 end)\n    %{a: 4, b: 2}\n\n    iex> Map.replace_lazy(%{a: 1, b: 2}, :c, fn v -> v * 4 end)\n    %{a: 1, b: 2}","prompt":"Can you write a docstring for the following Elixir function? replace_lazy(map, key, fun)"}
{"completion":"Takes all entries corresponding to the given `keys` in `map` and extracts\nthem into a separate map.\n\nReturns a tuple with the new map and the old map with removed keys.\n\nKeys for which there are no entries in `map` are ignored.\n\n## Examples\n\n    iex> Map.split(%{a: 1, b: 2, c: 3}, [:a, :c, :e])\n    {%{a: 1, c: 3}, %{b: 2}}","prompt":"Can you write a docstring for the following Elixir function? split(map, keys)"}
{"completion":"Returns a new map with all the key-value pairs in `map` where the key\nis in `keys`.\n\nIf `keys` contains keys that are not in `map`, they're simply ignored.\n\n## Examples\n\n    iex> Map.take(%{a: 1, b: 2, c: 3}, [:a, :c, :e])\n    %{a: 1, c: 3}","prompt":"Can you write a docstring for the following Elixir function? take(map, keys)"}
{"completion":"Converts `map` to a list.\n\nEach key-value pair in the map is converted to a two-element tuple `{key,\nvalue}` in the resulting list.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.to_list(%{a: 1})\n    [a: 1]\n    iex> Map.to_list(%{1 => 2})\n    [{1, 2}]","prompt":"Can you write a docstring for the following Elixir function? to_list(map)"}
{"completion":"Updates the `key` in `map` with the given function.\n\nIf `key` is present in `map` then the existing value is passed to `fun` and its result is\nused as the updated value of `key`. If `key` is\nnot present in `map`, `default` is inserted as the value of `key`. The default\nvalue will not be passed through the update function.\n\n## Examples\n\n    iex> Map.update(%{a: 1}, :a, 13, fn existing_value -> existing_value * 2 end)\n    %{a: 2}\n    iex> Map.update(%{a: 1}, :b, 11, fn existing_value -> existing_value * 2 end)\n    %{a: 1, b: 11}","prompt":"Can you write a docstring for the following Elixir function? update(map, key, default, fun)"}
{"completion":"Updates `key` with the given function.\n\nIf `key` is present in `map` then the existing value is passed to `fun` and its result is\nused as the updated value of `key`. If `key` is\nnot present in `map`, a `KeyError` exception is raised.\n\n## Examples\n\n    iex> Map.update!(%{a: 1}, :a, &(&1 * 2))\n    %{a: 2}\n\n    iex> Map.update!(%{a: 1}, :b, &(&1 * 2))\n    ** (KeyError) key :b not found in: %{a: 1}","prompt":"Can you write a docstring for the following Elixir function? update!(map, key, fun)"}
{"completion":"Returns all values from `map`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.values(%{a: 1, b: 2})\n    [1, 2]","prompt":"Can you write a docstring for the following Elixir function? values(map)"}
{"completion":"Maps are the \"go to\" key-value data structure in Elixir.\n\nMaps can be created with the `%{}` syntax, and key-value pairs can be\nexpressed as `key => value`:\n\n    iex> %{}\n    %{}\n    iex> %{\"one\" => :two, 3 => \"four\"}\n    %{3 => \"four\", \"one\" => :two}\n\nKey-value pairs in a map do not follow any order (that's why the printed map\nin the example above has a different order than the map that was created).\n\nMaps do not impose any restriction on the key type: anything can be a key in a\nmap. As a key-value structure, maps do not allow duplicated keys. Keys are\ncompared using the exact-equality operator (`===/2`). If colliding keys are defined\nin a map literal, the last one prevails.\n\nWhen the key in a key-value pair is an atom, the `key: value` shorthand syntax\ncan be used (as in many other special forms):\n\n    iex> %{a: 1, b: 2}\n    %{a: 1, b: 2}\n\nIf you want to mix the shorthand syntax with `=>`, the shorthand syntax must come\nat the end:\n\n    iex> %{\"hello\" => \"world\", a: 1, b: 2}\n    %{:a => 1, :b => 2, \"hello\" => \"world\"}\n\nKeys in maps can be accessed through some of the functions in this module\n(such as `Map.get/3` or `Map.fetch/2`) or through the `map[]` syntax provided\nby the `Access` module:\n\n    iex> map = %{a: 1, b: 2}\n    iex> Map.fetch(map, :a)\n    {:ok, 1}\n    iex> map[:b]\n    2\n    iex> map[\"non_existing_key\"]\n    nil\n\nTo access atom keys, one may also use the `map.key` notation. Note that `map.key`\nwill raise a `KeyError` if the `map` doesn't contain the key `:key`, compared to\n`map[:key]`, that would return `nil`.\n\n    map = %{foo: \"bar\", baz: \"bong\"}\n    map.foo\n    #=> \"bar\"\n    map.non_existing_key\n    ** (KeyError) key :non_existing_key not found in: %{baz: \"bong\", foo: \"bar\"}\n\n> Note: do not add parens when accessing fields, such as in `data.key()`.\n> If parenthesis are used, Elixir will expect `data` to be an atom representing\n> a module and attempt to call the *function* `key/0` in it.\n\nThe two syntaxes for accessing keys reveal the dual nature of maps. The `map[key]`\nsyntax is used for dynamically created maps that may have any key, of any type.\n`map.key` is used with maps that hold a predetermined set of atoms keys, which are\nexpected to always be present. Structs, defined via `defstruct/1`, are one example\nof such \"static maps\", where the keys can also be checked during compile time.\n\nMaps can be pattern matched on. When a map is on the left-hand side of a\npattern match, it will match if the map on the right-hand side contains the\nkeys on the left-hand side and their values match the ones on the left-hand\nside. This means that an empty map matches every map.\n\n    iex> %{} = %{foo: \"bar\"}\n    %{foo: \"bar\"}\n    iex> %{a: a} = %{:a => 1, \"b\" => 2, [:c, :e, :e] => 3}\n    iex> a\n    1\n\nBut this will raise a `MatchError` exception:\n\n    %{:c => 3} = %{:a => 1, 2 => :b}\n\nVariables can be used as map keys both when writing map literals as well as\nwhen matching:\n\n    iex> n = 1\n    1\n    iex> %{n => :one}\n    %{1 => :one}\n    iex> %{^n => :one} = %{1 => :one, 2 => :two, 3 => :three}\n    %{1 => :one, 2 => :two, 3 => :three}\n\nMaps also support a specific update syntax to update the value stored under\n*existing* keys. You can update using the atom keys syntax:\n\n    iex> map = %{one: 1, two: 2}\n    iex> %{map | one: \"one\"}\n    %{one: \"one\", two: 2}\n\nOr any other key:\n\n    iex> other_map = %{\"three\" => 3, \"four\" => 4}\n    iex> %{other_map | \"three\" => \"three\"}\n    %{\"four\" => 4, \"three\" => \"three\"}\n\nWhen a key that does not exist in the map is updated a `KeyError` exception will be raised:\n\n    %{map | three: 3}\n\nThe functions in this module that need to find a specific key work in logarithmic time.\nThis means that the time it takes to find keys grows as the map grows, but it's not\ndirectly proportional to the map size. In comparison to finding an element in a list,\nit performs better because lists have a linear time complexity. Some functions,\nsuch as `keys/1` and `values/1`, run in linear time because they need to get to every\nelement in the map.\n\nMaps also implement the `Enumerable` protocol, so many functions to work with maps\nare found in the `Enum` module. Additionally, the following functions for maps are\nfound in `Kernel`:\n\n  * `map_size/1`","prompt":"Can you write a docstring for the following Elixir function? Elixir.Map"}
{"completion":"Deletes `value` from `map_set`.\n\nReturns a new set which is a copy of `map_set` but without `value`.\n\n## Examples\n\n    iex> map_set = MapSet.new([1, 2, 3])\n    iex> MapSet.delete(map_set, 4)\n    MapSet.new([1, 2, 3])\n    iex> MapSet.delete(map_set, 2)\n    MapSet.new([1, 3])","prompt":"Can you write a docstring for the following Elixir function? delete(map_set, value)"}
{"completion":"Returns a set that is `map_set1` without the members of `map_set2`.\n\n## Examples\n\n    iex> MapSet.difference(MapSet.new([1, 2]), MapSet.new([2, 3, 4]))\n    MapSet.new([1])","prompt":"Can you write a docstring for the following Elixir function? difference(map_set1, map_set2)"}
{"completion":"Checks if `map_set1` and `map_set2` have no members in common.\n\n## Examples\n\n    iex> MapSet.disjoint?(MapSet.new([1, 2]), MapSet.new([3, 4]))\n    true\n    iex> MapSet.disjoint?(MapSet.new([1, 2]), MapSet.new([2, 3]))\n    false","prompt":"Can you write a docstring for the following Elixir function? disjoint?(map_set1, map_set2)"}
{"completion":"Checks if two sets are equal.\n\nThe comparison between elements is done using `===/2`,\nwhich a set with `1` is not equivalent to a set with\n`1.0`.\n\n## Examples\n\n    iex> MapSet.equal?(MapSet.new([1, 2]), MapSet.new([2, 1, 1]))\n    true\n    iex> MapSet.equal?(MapSet.new([1, 2]), MapSet.new([3, 4]))\n    false\n    iex> MapSet.equal?(MapSet.new([1]), MapSet.new([1.0]))\n    false","prompt":"Can you write a docstring for the following Elixir function? equal?(map_set1, map_set2)"}
{"completion":"Filters the set by returning only the elements from `set` for which invoking\n`fun` returns a truthy value.\n\nAlso see `reject/2` which discards all elements where the function returns\na truthy value.\n\n> Note: if you find yourself doing multiple calls to `MapSet.filter/2`\n> and `MapSet.reject/2` in a pipeline, it is likely more efficient\n> to use `Enum.map/2` and `Enum.filter/2` instead and convert to\n> a map at the end using `Map.new/1`.\n\n## Examples\n\n    iex> MapSet.filter(MapSet.new(1..5), fn x -> x > 3 end)\n    MapSet.new([4, 5])\n\n    iex> MapSet.filter(MapSet.new([\"a\", :b, \"c\"]), &is_atom/1)\n    MapSet.new([:b])","prompt":"Can you write a docstring for the following Elixir function? filter(map_set, fun)"}
{"completion":"Returns a set containing only members that `map_set1` and `map_set2` have in common.\n\n## Examples\n\n    iex> MapSet.intersection(MapSet.new([1, 2]), MapSet.new([2, 3, 4]))\n    MapSet.new([2])\n\n    iex> MapSet.intersection(MapSet.new([1, 2]), MapSet.new([3, 4]))\n    MapSet.new([])","prompt":"Can you write a docstring for the following Elixir function? intersection(map_set, map_set)"}
{"completion":"Checks if `map_set` contains `value`.\n\n## Examples\n\n    iex> MapSet.member?(MapSet.new([1, 2, 3]), 2)\n    true\n    iex> MapSet.member?(MapSet.new([1, 2, 3]), 4)\n    false","prompt":"Can you write a docstring for the following Elixir function? member?(map_set, value)"}
{"completion":"Returns a new set.\n\n## Examples\n\n    iex> MapSet.new()\n    MapSet.new([])","prompt":"Can you write a docstring for the following Elixir function? new()"}
{"completion":"Creates a set from an enumerable.\n\n## Examples\n\n    iex> MapSet.new([:b, :a, 3])\n    MapSet.new([3, :a, :b])\n    iex> MapSet.new([3, 3, 3, 2, 2, 1])\n    MapSet.new([1, 2, 3])","prompt":"Can you write a docstring for the following Elixir function? new(enumerable)"}
{"completion":"Creates a set from an enumerable via the transformation function.\n\n## Examples\n\n    iex> MapSet.new([1, 2, 1], fn x -> 2 * x end)\n    MapSet.new([2, 4])","prompt":"Can you write a docstring for the following Elixir function? new(enumerable, transform)"}
{"completion":"Inserts `value` into `map_set` if `map_set` doesn't already contain it.\n\n## Examples\n\n    iex> MapSet.put(MapSet.new([1, 2, 3]), 3)\n    MapSet.new([1, 2, 3])\n    iex> MapSet.put(MapSet.new([1, 2, 3]), 4)\n    MapSet.new([1, 2, 3, 4])","prompt":"Can you write a docstring for the following Elixir function? put(map_set, value)"}
{"completion":"Returns a set by excluding the elements from `set` for which invoking `fun`\nreturns a truthy value.\n\nSee also `filter/2`.\n\n## Examples\n\n    iex> MapSet.reject(MapSet.new(1..5), fn x -> rem(x, 2) != 0 end)\n    MapSet.new([2, 4])\n\n    iex> MapSet.reject(MapSet.new([\"a\", :b, \"c\"]), &is_atom/1)\n    MapSet.new([\"a\", \"c\"])","prompt":"Can you write a docstring for the following Elixir function? reject(map_set, fun)"}
{"completion":"Returns the number of elements in `map_set`.\n\n## Examples\n\n    iex> MapSet.size(MapSet.new([1, 2, 3]))\n    3","prompt":"Can you write a docstring for the following Elixir function? size(map_set)"}
{"completion":"Checks if `map_set1`'s members are all contained in `map_set2`.\n\nThis function checks if `map_set1` is a subset of `map_set2`.\n\n## Examples\n\n    iex> MapSet.subset?(MapSet.new([1, 2]), MapSet.new([1, 2, 3]))\n    true\n    iex> MapSet.subset?(MapSet.new([1, 2, 3]), MapSet.new([1, 2]))\n    false","prompt":"Can you write a docstring for the following Elixir function? subset?(map_set1, map_set2)"}
{"completion":"Returns a set with elements that are present in only one but not both sets.\n\n## Examples\n\n    iex> MapSet.symmetric_difference(MapSet.new([1, 2, 3]), MapSet.new([2, 3, 4]))\n    MapSet.new([1, 4])","prompt":"Can you write a docstring for the following Elixir function? symmetric_difference(map_set1, map_set2)"}
{"completion":"Converts `map_set` to a list.\n\n## Examples\n\n    iex> MapSet.to_list(MapSet.new([1, 2, 3]))\n    [1, 2, 3]","prompt":"Can you write a docstring for the following Elixir function? to_list(map_set)"}
{"completion":"Returns a set containing all members of `map_set1` and `map_set2`.\n\n## Examples\n\n    iex> MapSet.union(MapSet.new([1, 2]), MapSet.new([2, 3, 4]))\n    MapSet.new([1, 2, 3, 4])","prompt":"Can you write a docstring for the following Elixir function? union(map_set1, map_set2)"}
{"completion":"Functions that work on sets.\n\nA set is a data structure that can contain unique elements of any kind,\nwithout any particular order. `MapSet` is the \"go to\" set data structure in Elixir.\n\nA set can be constructed using `MapSet.new/0`:\n\n    iex> MapSet.new()\n    MapSet.new([])\n\nElements in a set don't have to be of the same type and they can be\npopulated from an [enumerable](`t:Enumerable.t/0`) using `MapSet.new/1`:\n\n    iex> MapSet.new([1, :two, {\"three\"}])\n    MapSet.new([1, :two, {\"three\"}])\n\nElements can be inserted using `MapSet.put/2`:\n\n    iex> MapSet.new([2]) |> MapSet.put(4) |> MapSet.put(0)\n    MapSet.new([0, 2, 4])\n\nBy definition, sets can't contain duplicate elements: when\ninserting an element in a set where it's already present, the insertion is\nsimply a no-op.\n\n    iex> map_set = MapSet.new()\n    iex> MapSet.put(map_set, \"foo\")\n    MapSet.new([\"foo\"])\n    iex> map_set |> MapSet.put(\"foo\") |> MapSet.put(\"foo\")\n    MapSet.new([\"foo\"])\n\nA `MapSet` is represented internally using the `%MapSet{}` struct. This struct\ncan be used whenever there's a need to pattern match on something being a `MapSet`:\n\n    iex> match?(%MapSet{}, MapSet.new())\n    true\n\nNote that, however, the struct fields are private and must not be accessed\ndirectly; use the functions in this module to perform operations on sets.\n\n`MapSet`s can also be constructed starting from other collection-type data\nstructures: for example, see `MapSet.new/1` or `Enum.into/2`.\n\n`MapSet` is built on top of `Map`, this means that they share many properties,\nincluding logarithmic time complexity. See the documentation for `Map` for more\ninformation on its execution time complexity.","prompt":"Can you write a docstring for the following Elixir function? Elixir.MapSet"}
{"completion":"Adds and tracks defaults for a definition into the tracker.","prompt":"Can you write a docstring for the following Elixir function? add_defaults(arg, kind, pair, defaults, meta)"}
{"completion":"Adds an import dispatch to the given target.","prompt":"Can you write a docstring for the following Elixir function? add_import(arg, function, module, imported)"}
{"completion":"Adds a local dispatch from-to the given target.","prompt":"Can you write a docstring for the following Elixir function? add_local(arg, from, to, meta, macro_dispatch?)"}
{"completion":"Collect all conflicting imports with the given functions","prompt":"Can you write a docstring for the following Elixir function? collect_imports_conflicts(arg, all_defined)"}
{"completion":"Collect undefined functions based on local calls and existing definitions.","prompt":"Can you write a docstring for the following Elixir function? collect_undefined_locals(arg, all_defined)"}
{"completion":"Collect all unused definitions based on the private\ngiven, also accounting the expected number of default\nclauses a private function have.","prompt":"Can you write a docstring for the following Elixir function? collect_unused_locals(arg, all_defined, private)"}
{"completion":"Returns all local nodes reachable from `vertex`.\n\nBy default, all public functions are reachable.\nA private function is only reachable if it has\na public function that it invokes directly.","prompt":"Can you write a docstring for the following Elixir function? reachable_from(arg, local)"}
{"completion":"Reattach a previously yanked node.","prompt":"Can you write a docstring for the following Elixir function? reattach(arg, tuple, kind, function, out_neighbours, meta)"}
{"completion":"Yanks a local node. Returns its in and out vertices in a tuple.","prompt":"Can you write a docstring for the following Elixir function? yank(arg, local)"}
{"completion":"Returns all exported functions and macros for the given module from\nthe cache.","prompt":"Can you write a docstring for the following Elixir function? all_exports(arg, module)"}
{"completion":"Returns the export kind and deprecation reason for the given MFA from\nthe cache. If the module does not exist return `{:error, :module}`,\nor if the function does not exist return `{:error, :function}`.","prompt":"Can you write a docstring for the following Elixir function? fetch_export(arg, module, fun, arity)"}
{"completion":"Gets the parallel checker data from pdict.","prompt":"Can you write a docstring for the following Elixir function? get()"}
{"completion":"Preloads a module into the cache. Call this function before any other\ncache lookups for the module.","prompt":"Can you write a docstring for the following Elixir function? preload_module(arg, module)"}
{"completion":"Stores the parallel checker information.","prompt":"Can you write a docstring for the following Elixir function? put(pid, checker)"}
{"completion":"Spawns a process that runs the parallel checker.","prompt":"Can you write a docstring for the following Elixir function? spawn(arg, module, info)"}
{"completion":"Initializes the parallel checker process.","prompt":"Can you write a docstring for the following Elixir function? start_link(schedulers \\\\ nil)"}
{"completion":"Stops the parallel checker process.","prompt":"Can you write a docstring for the following Elixir function? stop(checker)"}
{"completion":"Test cache.","prompt":"Can you write a docstring for the following Elixir function? test_cache()"}
{"completion":"Verifies the given compilation function\nby starting a checker if one does not exist.\nSee `verify/3`.","prompt":"Can you write a docstring for the following Elixir function? verify(fun)"}
{"completion":"Receives pairs of module maps and BEAM binaries. In parallel it verifies\nthe modules and adds the ExCk chunk to the binaries. Returns the updated\nlist of warnings from the verification.","prompt":"Can you write a docstring for the following Elixir function? verify(checker, runtime_files)"}
{"completion":"Like `Enum.flat_map/2` but only continues while `fun` returns `{:ok, list}`\nand stops on `{:error, reason}`.","prompt":"Can you write a docstring for the following Elixir function? flat_map_ok(list, fun)"}
{"completion":"Like `Enum.flat_map_reduce/3` but only continues while `fun` returns `{:ok, list, acc}`\nand stops on `{:error, reason}`.","prompt":"Can you write a docstring for the following Elixir function? flat_map_reduce_ok(list, acc, fun)"}
{"completion":"Returns the AST metadata.","prompt":"Can you write a docstring for the following Elixir function? get_meta(arg1)"}
{"completion":"Combines a list of guard expressions `when x when y when z` to an expression\ncombined with `or`, `x or y or z`.","prompt":"Can you write a docstring for the following Elixir function? guards_to_or(guards)"}
{"completion":"Like `Enum.map/2` but only continues while `fun` returns `{:ok, elem}`\nand stops on `{:error, reason}`.","prompt":"Can you write a docstring for the following Elixir function? map_ok(list, fun)"}
{"completion":"Like `Enum.map_reduce/3` but only continues while `fun` returns `{:ok, elem, acc}`\nand stops on `{:error, reason}`.","prompt":"Can you write a docstring for the following Elixir function? map_reduce_ok(list, acc, fun)"}
{"completion":"Given a list of `[{:ok, term()} | {:error, term()}]` it returns a list of\nerrors `{:error, [term()]}` in case of at least one error or `{:ok, [term()]}`\nif there are no errors.","prompt":"Can you write a docstring for the following Elixir function? oks_or_errors(list)"}
{"completion":"Like `Enum.reduce/3` but only continues while `fun` returns `{:ok, acc}`\nand stops on `{:error, reason}`.","prompt":"Can you write a docstring for the following Elixir function? reduce_ok(list, acc, fun)"}
{"completion":"Like `Enum.unzip/1` but only continues while `fun` returns `{:ok, elem1, elem2}`\nand stops on `{:error, reason}`.","prompt":"Can you write a docstring for the following Elixir function? unzip_ok(list)"}
{"completion":"Returns unique identifier for the current assignment of the variable.","prompt":"Can you write a docstring for the following Elixir function? var_name(arg)"}
{"completion":"Like `Enum.zip/1` but will zip multiple lists together instead of only two.","prompt":"Can you write a docstring for the following Elixir function? zip_many(lists)"}
{"completion":"Handles binaries.\n\nIn the stack, we add nodes such as <<expr>>, <<..., expr>>, etc,\nbased on the position of the expression within the binary.","prompt":"Can you write a docstring for the following Elixir function? binary(list, stack, context, of_fun)"}
{"completion":"Handles closed maps (without dynamic => dynamic).","prompt":"Can you write a docstring for the following Elixir function? closed_map(args, stack, context, of_fun)"}
{"completion":"Handles open maps (with dynamic => dynamic).","prompt":"Can you write a docstring for the following Elixir function? open_map(args, stack, context, of_fun)"}
{"completion":"Handles remote calls.","prompt":"Can you write a docstring for the following Elixir function? remote(module, fun, arity, meta, context)"}
{"completion":"Handles structs.","prompt":"Can you write a docstring for the following Elixir function? struct(struct, meta, context)"}
{"completion":"Refines the type variables in the typing context using type check guards\nsuch as `is_integer/1`.","prompt":"Can you write a docstring for the following Elixir function? of_guard(expr, expected, stack, context)"}
{"completion":"Handles patterns and guards at once.","prompt":"Can you write a docstring for the following Elixir function? of_head(patterns, guards, stack, context)"}
{"completion":"Return the type and typing context of a pattern expression or an error\nin case of a typing conflict.","prompt":"Can you write a docstring for the following Elixir function? of_pattern(pattern, stack, context)"}
{"completion":"Adds an internal variable to the typing context and returns its type variable.\nAn internal variable is used to help unify complex expressions,\nit does not belong to a specific AST expression.","prompt":"Can you write a docstring for the following Elixir function? add_var(context)"}
{"completion":"Collects all type vars recursively.","prompt":"Can you write a docstring for the following Elixir function? collect_var_indexes(type, context, acc \\\\ %{})"}
{"completion":"Expand unions so that all unions are at the top level.\n\n    {integer() | float()} => {integer()} | {float()}","prompt":"Can you write a docstring for the following Elixir function? flatten_union(type, context)"}
{"completion":"Formats types.\n\nThe second argument says when complex types such as maps and\nstructs should be simplified and not shown.","prompt":"Can you write a docstring for the following Elixir function? format_type(atom, simplify?)"}
{"completion":"Gets a variable.","prompt":"Can you write a docstring for the following Elixir function? get_var!(var, context)"}
{"completion":"Checks if the type has a type var.","prompt":"Can you write a docstring for the following Elixir function? has_unbound_var?(type, context)"}
{"completion":"Lifts type variables to their inferred types from the context.","prompt":"Can you write a docstring for the following Elixir function? lift_types(types, context)"}
{"completion":"Adds a variable to the typing context and returns its type variable.\nIf the variable has already been added, return the existing type variable.","prompt":"Can you write a docstring for the following Elixir function? new_var(var, context)"}
{"completion":"Push expression to stack.\n\nThe expression stack is used to give the context where a type variable\nwas refined when show a type conflict error.","prompt":"Can you write a docstring for the following Elixir function? push_expr_stack(expr, stack)"}
{"completion":"Set the type for a variable and add trace.","prompt":"Can you write a docstring for the following Elixir function? refine_var!(var, type, stack, context)"}
{"completion":"Remove type variable and all its traces.","prompt":"Can you write a docstring for the following Elixir function? remove_var(var, context)"}
{"completion":"Maybe resolves a variable.","prompt":"Can you write a docstring for the following Elixir function? resolve_var(other, context)"}
{"completion":"Restores the variable information from the old context into new context.","prompt":"Can you write a docstring for the following Elixir function? restore_var!(var, new_context, old_context)"}
{"completion":"Returns true if it is a singleton type.\n\nOnly atoms are singleton types. Unbound vars are not\nconsidered singleton types.","prompt":"Can you write a docstring for the following Elixir function? singleton?(arg1, context)"}
{"completion":"Checks if the first argument is a subtype of the second argument.\n\nThis function assumes that:\n\n  * unbound variables are not subtype of anything\n\n  * dynamic is not considered a subtype of all other types but the top type.\n    This allows this function can be used for ordering, in other cases, you\n    may need to check for both sides","prompt":"Can you write a docstring for the following Elixir function? subtype?(type, type, context)"}
{"completion":"Returns a \"simplified\" union using `subtype?/3` to remove redundant types.\n\nDue to limitations in `subtype?/3` some overlapping types may still be\nincluded. For example unions with overlapping non-concrete types such as\n`{boolean()} | {atom()}` will not be merged or types with variables that\nare distinct but equivalent such as `a | b when a ~ b`.","prompt":"Can you write a docstring for the following Elixir function? to_union(types, context)"}
{"completion":"Unifies two types and returns the unified type and an updated typing context\nor an error in case of a typing conflict.","prompt":"Can you write a docstring for the following Elixir function? unify(same, same, stack, context)"}
{"completion":"Performs a depth-first, pre-order traversal of the type tree using an accumulator.","prompt":"Can you write a docstring for the following Elixir function? walk(type, acc, fun)"}
{"completion":"Returns all module attributes names defined in `module`.\n\nThis function can only be used on modules that have not yet been compiled.\n\n## Examples\n\n    defmodule Example do\n      @foo 1\n      Module.register_attribute(__MODULE__, :bar, accumulate: true)\n\n      :foo in Module.attributes_in(__MODULE__)\n      #=> true\n\n      :bar in Module.attributes_in(__MODULE__)\n      #=> true\n    end","prompt":"Can you write a docstring for the following Elixir function? attributes_in(module)"}
{"completion":"Concatenates a list of aliases and returns a new alias.\n\nIt handles binaries and atoms.\n\n## Examples\n\n    iex> Module.concat([Foo, Bar])\n    Foo.Bar\n\n    iex> Module.concat([Foo, \"Bar\"])\n    Foo.Bar","prompt":"Can you write a docstring for the following Elixir function? concat(list)"}
{"completion":"Concatenates two aliases and returns a new alias.\n\nIt handles binaries and atoms.\n\n## Examples\n\n    iex> Module.concat(Foo, Bar)\n    Foo.Bar\n\n    iex> Module.concat(Foo, \"Bar\")\n    Foo.Bar","prompt":"Can you write a docstring for the following Elixir function? concat(left, right)"}
{"completion":"Creates a module with the given name and defined by\nthe given quoted expressions.\n\nThe line where the module is defined and its file **must**\nbe passed as options.\n\nIt returns a tuple of shape `{:module, module, binary, term}`\nwhere `module` is the module name, `binary` is the module\nbytecode and `term` is the result of the last expression in\n`quoted`.\n\nSimilar to `Kernel.defmodule/2`, the binary will only be\nwritten to disk as a `.beam` file if `Module.create/3` is\ninvoked in a file that is currently being compiled.\n\n## Examples\n\n    contents =\n      quote do\n        def world, do: true\n      end\n\n    Module.create(Hello, contents, Macro.Env.location(__ENV__))\n\n    Hello.world()\n    #=> true\n\n## Differences from `defmodule`\n\n`Module.create/3` works similarly to `Kernel.defmodule/2`\nand return the same results. While one could also use\n`Kernel.defmodule/2` to define modules dynamically, this function\nis preferred when the module body is given by a quoted\nexpression.\n\nAnother important distinction is that `Module.create/3`\nallows you to control the environment variables used\nwhen defining the module, while `Kernel.defmodule/2`\nautomatically uses the environment it is invoked at.","prompt":"Can you write a docstring for the following Elixir function? create(module, quoted, opts)"}
{"completion":"Checks if the module defines the given function or macro.\n\nUse `defines?/3` to assert for a specific type.\n\nThis function can only be used on modules that have not yet been compiled.\nUse `Kernel.function_exported?/3` and `Kernel.macro_exported?/3` to check for\npublic functions and macros respectively in compiled modules.\n\nNote that `defines?` returns false for functions and macros that have\nbeen defined but then marked as overridable and no other implementation\nhas been provided. You can check the overridable status by calling\n`overridable?/2`.\n\n## Examples\n\n    defmodule Example do\n      Module.defines?(__MODULE__, {:version, 0}) #=> false\n      def version, do: 1\n      Module.defines?(__MODULE__, {:version, 0}) #=> true\n    end","prompt":"Can you write a docstring for the following Elixir function? defines?(module, tuple)"}
{"completion":"Checks if the module defines a function or macro of the\ngiven `kind`.\n\n`kind` can be any of `:def`, `:defp`, `:defmacro`, or `:defmacrop`.\n\nThis function can only be used on modules that have not yet been compiled.\nUse `Kernel.function_exported?/3` and `Kernel.macro_exported?/3` to check for\npublic functions and macros respectively in compiled modules.\n\n## Examples\n\n    defmodule Example do\n      Module.defines?(__MODULE__, {:version, 0}, :def) #=> false\n      def version, do: 1\n      Module.defines?(__MODULE__, {:version, 0}, :def) #=> true\n    end","prompt":"Can you write a docstring for the following Elixir function? defines?(module, tuple, def_kind)"}
{"completion":"Checks if the current module defines the given type (private, opaque or not).\n\nThis function is only available for modules being compiled.","prompt":"Can you write a docstring for the following Elixir function? defines_type?(module, definition)"}
{"completion":"Returns all functions and macros defined in `module`.\n\nIt returns a list with all defined functions and macros, public and private,\nin the shape of `[{name, arity}, ...]`.\n\nThis function can only be used on modules that have not yet been compiled.\nUse the `c:Module.__info__/1` callback to get the public functions and macros in\ncompiled modules.\n\n## Examples\n\n    defmodule Example do\n      def version, do: 1\n      defmacrop test(arg), do: arg\n      Module.definitions_in(__MODULE__) #=> [{:version, 0}, {:test, 1}]\n    end","prompt":"Can you write a docstring for the following Elixir function? definitions_in(module)"}
{"completion":"Returns all functions defined in `module`, according\nto its kind.\n\nThis function can only be used on modules that have not yet been compiled.\nUse the `c:Module.__info__/1` callback to get the public functions and macros in\ncompiled modules.\n\n## Examples\n\n    defmodule Example do\n      def version, do: 1\n      Module.definitions_in(__MODULE__, :def)  #=> [{:version, 0}]\n      Module.definitions_in(__MODULE__, :defp) #=> []\n    end","prompt":"Can you write a docstring for the following Elixir function? definitions_in(module, kind)"}
{"completion":"Deletes the entry (or entries) for the given module attribute.\n\nIt returns the deleted attribute value. If the attribute has not\nbeen set nor configured to accumulate, it returns `nil`.\n\nIf the attribute is set to accumulate, then this function always\nreturns a list. Deleting the attribute removes existing entries\nbut the attribute will still accumulate.\n\n## Examples\n\n    defmodule MyModule do\n      Module.put_attribute(__MODULE__, :custom_threshold_for_lib, 10)\n      Module.delete_attribute(__MODULE__, :custom_threshold_for_lib)\n    end","prompt":"Can you write a docstring for the following Elixir function? delete_attribute(module, key)"}
{"completion":"Deletes a definition from a module.\n\nIt returns true if the definition exists and it was removed,\notherwise it returns false.","prompt":"Can you write a docstring for the following Elixir function? delete_definition(module, arg)"}
{"completion":"Evaluates the quoted contents in the given module's context.\n\nA list of environment options can also be given as argument.\nSee `Code.eval_string/3` for more information.\n\nRaises an error if the module was already compiled.\n\n## Examples\n\n    defmodule Foo do\n      contents =\n        quote do\n          def sum(a, b), do: a + b\n        end\n\n      Module.eval_quoted(__MODULE__, contents)\n    end\n\n    Foo.sum(1, 2)\n    #=> 3\n\nFor convenience, you can pass any `Macro.Env` struct, such\nas  `__ENV__/0`, as the first argument or as options. Both\nthe module and all options will be automatically extracted\nfrom the environment:\n\n    defmodule Foo do\n      contents =\n        quote do\n          def sum(a, b), do: a + b\n        end\n\n      Module.eval_quoted(__ENV__, contents)\n    end\n\n    Foo.sum(1, 2)\n    #=> 3\n\nNote that if you pass a `Macro.Env` struct as first argument\nwhile also passing `opts`, they will be merged with `opts`\nhaving precedence.","prompt":"Can you write a docstring for the following Elixir function? eval_quoted(module_or_env, quoted, binding \\\\ [], opts \\\\ [])"}
{"completion":"Gets the given attribute from a module.\n\nIf the attribute was marked with `accumulate` with\n`Module.register_attribute/3`, a list is always returned.\n`nil` is returned if the attribute has not been marked with\n`accumulate` and has not been set to any value.\n\nThe `@` macro compiles to a call to this function. For example,\nthe following code:\n\n    @foo\n\nExpands to something akin to:\n\n    Module.get_attribute(__MODULE__, :foo)\n\nThis function can only be used on modules that have not yet been compiled.\nUse the `c:Module.__info__/1` callback to get all persisted attributes, or\n`Code.fetch_docs/1` to retrieve all documentation related attributes in\ncompiled modules.\n\n## Examples\n\n    defmodule Foo do\n      Module.put_attribute(__MODULE__, :value, 1)\n      Module.get_attribute(__MODULE__, :value) #=> 1\n\n      Module.get_attribute(__MODULE__, :value, :default) #=> 1\n      Module.get_attribute(__MODULE__, :not_found, :default) #=> :default\n\n      Module.register_attribute(__MODULE__, :value, accumulate: true)\n      Module.put_attribute(__MODULE__, :value, 1)\n      Module.get_attribute(__MODULE__, :value) #=> [1]\n    end","prompt":"Can you write a docstring for the following Elixir function? get_attribute(module, key, default \\\\ nil)"}
{"completion":"Returns the definition for the given name-arity pair.\n\nIt returns a tuple with the `version`, the `kind`,\nthe definition `metadata`, and a list with each clause.\nEach clause is a four-element tuple with metadata,\nthe arguments, the guards, and the clause AST.\n\nThe clauses are returned in the Elixir AST but a subset\nthat has already been expanded and normalized. This makes\nit useful for analyzing code but it cannot be reinjected\ninto the module as it will have lost some of its original\ncontext. Given this AST representation is mostly internal,\nit is versioned and it may change at any time. Therefore,\n**use this API with caution**.\n\n## Options\n\n  * `:skip_clauses` (since v1.14.0) - returns `[]` instead\n    of returning the clauses. This is useful when there is\n    only an interest in fetching the kind and the metadata","prompt":"Can you write a docstring for the following Elixir function? get_definition(module, arg, options \\\\ [])"}
{"completion":"Checks if the given attribute has been defined.\n\nAn attribute is defined if it has been registered with `register_attribute/3`\nor assigned a value. If an attribute has been deleted with `delete_attribute/2`\nit is no longer considered defined.\n\nThis function can only be used on modules that have not yet been compiled.\n\n## Examples\n\n    defmodule MyModule do\n      @value 1\n      Module.register_attribute(__MODULE__, :other_value)\n      Module.put_attribute(__MODULE__, :another_value, 1)\n\n      Module.has_attribute?(__MODULE__, :value) #=> true\n      Module.has_attribute?(__MODULE__, :other_value) #=> true\n      Module.has_attribute?(__MODULE__, :another_value) #=> true\n\n      Module.has_attribute?(__MODULE__, :undefined) #=> false\n\n      Module.delete_attribute(__MODULE__, :value)\n      Module.has_attribute?(__MODULE__, :value) #=> false\n    end","prompt":"Can you write a docstring for the following Elixir function? has_attribute?(module, key)"}
{"completion":"Makes the given functions in `module` overridable.\n\nAn overridable function is lazily defined, allowing a\ndeveloper to customize it. See `Kernel.defoverridable/1` for\nmore information and documentation.\n\nOnce a function or a macro is marked as overridable, it will\nno longer be listed under `definitions_in/1` or return true\nwhen given to `defines?/2` until another implementation is\ngiven.","prompt":"Can you write a docstring for the following Elixir function? make_overridable(module, tuples)"}
{"completion":"Checks if a module is open.\n\nA module is \"open\" if it is currently being defined and its attributes and\nfunctions can be modified.","prompt":"Can you write a docstring for the following Elixir function? open?(module)"}
{"completion":"Returns `true` if `tuple` in `module` was marked as overridable\nat some point.\n\nNote `overridable?/2` returns true even if the definition was\nalready overridden. You can use `defines?/2` to see if a definition\nexists or one is pending.","prompt":"Can you write a docstring for the following Elixir function? overridable?(module, tuple)"}
{"completion":"Returns all overridable definitions in `module`.\n\nNote a definition is included even if it was was already overridden.\nYou can use `defines?/2` to see if a definition exists or one is pending.\n\nThis function can only be used on modules that have not yet been compiled.\n\n## Examples\n\n    defmodule Example do\n      def foo, do: 1\n      def bar, do: 2\n\n      defoverridable foo: 0, bar: 0\n      def foo, do: 3\n\n      [bar: 0, foo: 0] = Module.overridables_in(__MODULE__) |> Enum.sort()\n    end","prompt":"Can you write a docstring for the following Elixir function? overridables_in(module)"}
{"completion":"Puts a module attribute with `key` and `value` in the given `module`.\n\n## Examples\n\n    defmodule MyModule do\n      Module.put_attribute(__MODULE__, :custom_threshold_for_lib, 10)\n    end","prompt":"Can you write a docstring for the following Elixir function? put_attribute(module, key, value)"}
{"completion":"Registers an attribute.\n\nBy registering an attribute, a developer is able to customize\nhow Elixir will store and accumulate the attribute values.\n\n## Options\n\nWhen registering an attribute, two options can be given:\n\n  * `:accumulate` - several calls to the same attribute will\n    accumulate instead of overriding the previous one. New attributes\n    are always added to the top of the accumulated list.\n\n  * `:persist` - the attribute will be persisted in the Erlang\n    Abstract Format. Useful when interfacing with Erlang libraries.\n\nBy default, both options are `false`. Once an attribute has been\nset to accumulate or persist, the behaviour cannot be reverted.\n\n## Examples\n\n    defmodule MyModule do\n      Module.register_attribute(__MODULE__, :custom_threshold_for_lib, accumulate: true)\n\n      @custom_threshold_for_lib 10\n      @custom_threshold_for_lib 20\n      @custom_threshold_for_lib #=> [20, 10]\n    end","prompt":"Can you write a docstring for the following Elixir function? register_attribute(module, attribute, options)"}
{"completion":"Returns information about module attributes used by Elixir.\n\nSee the \"Module attributes\" section in the module documentation for more\ninformation on each attribute.\n\n## Examples\n\n    iex> map = Module.reserved_attributes()\n    iex> Map.has_key?(map, :moduledoc)\n    true\n    iex> Map.has_key?(map, :doc)\n    true","prompt":"Can you write a docstring for the following Elixir function? reserved_attributes()"}
{"completion":"Concatenates a list of aliases and returns a new alias only if the alias\nwas already referenced.\n\nIf the alias was not referenced yet, fails with `ArgumentError`.\nIt handles binaries and atoms.\n\n## Examples\n\n    iex> Module.safe_concat([List, Chars])\n    List.Chars","prompt":"Can you write a docstring for the following Elixir function? safe_concat(list)"}
{"completion":"Concatenates two aliases and returns a new alias only if the alias was\nalready referenced.\n\nIf the alias was not referenced yet, fails with `ArgumentError`.\nIt handles binaries and atoms.\n\n## Examples\n\n    iex> Module.safe_concat(List, Chars)\n    List.Chars","prompt":"Can you write a docstring for the following Elixir function? safe_concat(left, right)"}
{"completion":"Copies the given spec as a callback.\n\nReturns `true` if there is such a spec and it was copied as a callback.\nIf the function associated to the spec has documentation defined prior to\ninvoking this function, the docs are copied too.","prompt":"Can you write a docstring for the following Elixir function? spec_to_callback(module, definition)"}
{"completion":"Splits the given module name into binary parts.\n\n`module` has to be an Elixir module, as `split/1` won't work with Erlang-style\nmodules (for example, `split(:lists)` raises an error).\n\n`split/1` also supports splitting the string representation of Elixir modules\n(that is, the result of calling `Atom.to_string/1` with the module name).\n\n## Examples\n\n    iex> Module.split(Very.Long.Module.Name.And.Even.Longer)\n    [\"Very\", \"Long\", \"Module\", \"Name\", \"And\", \"Even\", \"Longer\"]\n    iex> Module.split(\"Elixir.String.Chars\")\n    [\"String\", \"Chars\"]","prompt":"Can you write a docstring for the following Elixir function? split(module)"}
{"completion":"Provides functions to deal with modules during compilation time.\n\nIt allows a developer to dynamically add, delete and register\nattributes, attach documentation and so forth.\n\nAfter a module is compiled, using many of the functions in\nthis module will raise errors, since it is out of their scope\nto inspect runtime data. Most of the runtime data can be inspected\nvia the [`__info__/1`](`c:Module.__info__/1`) function attached to\neach compiled module.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Module"}
{"completion":"Module attributes\n\nEach module can be decorated with one or more attributes. The following ones\nare currently defined by Elixir:","prompt":"Can you write a docstring for the following Elixir function? Elixir.Module"}
{"completion":"# `@after_compile`\n\nA hook that will be invoked right after the current module is compiled.\nAccepts a module or a `{module, function_name}`. See the \"Compile callbacks\"\nsection below.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Module"}
{"completion":"# `@after_verify` (since v1.14.0)\n\nA hook that will be invoked right after the current module is verified for\nundefined functions, deprecations, etc. Accepts a module or a `{module, function_name}`.\nSee the \"Compile callbacks\" section below.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Module"}
{"completion":"# `@before_compile`\n\nA hook that will be invoked before the module is compiled.\nAccepts a module or a `{module, function_or_macro_name}` tuple.\nSee the \"Compile callbacks\" section below.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Module"}
{"completion":"# `@behaviour`\n\nNote the British spelling!\n\nBehaviours can be referenced by modules to ensure they implement\nrequired specific function signatures defined by `@callback`.\n\nFor example, you could specify a `URI.Parser` behaviour as follows:\n\n    defmodule URI.Parser do\n      @doc \"Defines a default port\"\n      @callback default_port() :: integer\n\n      @doc \"Parses the given URL\"\n      @callback parse(uri_info :: URI.t()) :: URI.t()\n    end\n\nAnd then a module may use it as:\n\n    defmodule URI.HTTP do\n      @behaviour URI.Parser\n      def default_port(), do: 80\n      def parse(info), do: info\n    end\n\nIf the behaviour changes or `URI.HTTP` does not implement\none of the callbacks, a warning will be raised.\n\nFor detailed documentation, see the\n[behaviour typespec documentation](typespecs.md#behaviours).","prompt":"Can you write a docstring for the following Elixir function? Elixir.Module"}
{"completion":"# `@impl`\n\nTo aid in the correct implementation of behaviours, you may optionally declare\n`@impl` for implemented callbacks of a behaviour. This makes callbacks\nexplicit and can help you to catch errors in your code. The compiler will warn\nin these cases:\n\n  * if you mark a function with `@impl` when that function is not a callback.\n\n  * if you don't mark a function with `@impl` when other functions are marked\n    with `@impl`. If you mark one function with `@impl`, you must mark all\n    other callbacks for that behaviour as `@impl`.\n\n`@impl` works on a per-context basis. If you generate a function through a macro\nand mark it with `@impl`, that won't affect the module where that function is\ngenerated in.\n\n`@impl` also helps with maintainability by making it clear to other developers\nthat the function is implementing a callback.\n\nUsing `@impl`, the example above can be rewritten as:\n\n    defmodule URI.HTTP do\n      @behaviour URI.Parser\n\n      @impl true\n      def default_port(), do: 80\n\n      @impl true\n      def parse(info), do: info\n    end\n\nYou may pass either `false`, `true`, or a specific behaviour to `@impl`.\n\n    defmodule Foo do\n      @behaviour Bar\n      @behaviour Baz\n\n      # Will warn if neither Bar nor Baz specify a callback named bar/0.\n      @impl true\n      def bar(), do: :ok\n\n      # Will warn if Baz does not specify a callback named baz/0.\n      @impl Baz\n      def baz(), do: :ok\n    end\n\nThe code is now more readable, as it is now clear which functions are\npart of your API and which ones are callback implementations. To reinforce this\nidea, `@impl true` automatically marks the function as `@doc false`, disabling\ndocumentation unless `@doc` is explicitly set.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Module"}
{"completion":"# `@compile`\n\nDefines options for module compilation. This is used to configure\nboth Elixir and Erlang compilers, as any other compilation pass\nadded by external tools. For example:\n\n    defmodule MyModule do\n      @compile {:inline, my_fun: 1}\n\n      def my_fun(arg) do\n        to_string(arg)\n      end\n    end\n\nMultiple uses of `@compile` will accumulate instead of overriding\nprevious ones. See the \"Compile options\" section below.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Module"}
{"completion":"# `@deprecated` (since v1.6.0)\n\nProvides the deprecation reason for a function. For example:\n\n    defmodule Keyword do\n      @deprecated \"Use Kernel.length/1 instead\"\n      def size(keyword) do\n        length(keyword)\n      end\n    end\n\nThe Mix compiler automatically looks for calls to deprecated modules\nand emit warnings during compilation.\n\nUsing the `@deprecated` attribute will also be reflected in the\ndocumentation of the given function and macro. You can choose between\nthe `@deprecated` attribute and the documentation metadata to provide\nhard-deprecations (with warnings) and soft-deprecations (without warnings):\n\nThis is a soft-deprecation as it simply annotates the documentation\nas deprecated:\n\n    @doc deprecated: \"Use Kernel.length/1 instead\"\n    def size(keyword)\n\nThis is a hard-deprecation as it emits warnings and annotates the\ndocumentation as deprecated:\n\n    @deprecated \"Use Kernel.length/1 instead\"\n    def size(keyword)\n\nCurrently `@deprecated` only supports functions and macros. However\nyou can use the `:deprecated` key in the annotation metadata to\nannotate the docs of modules, types and callbacks too.\n\nWe recommend using this feature with care, especially library authors.\nDeprecating code always pushes the burden towards library users. We\nalso recommend for deprecated functionality to be maintained for long\nperiods of time, even after deprecation, giving developers plenty of\ntime to update (except for cases where keeping the deprecated API is\nundesired, such as in the presence of security issues).","prompt":"Can you write a docstring for the following Elixir function? Elixir.Module"}
{"completion":"# `@doc` and `@typedoc`\n\nProvides documentation for the entity that follows the attribute.\n`@doc` is to be used with a function, macro, callback, or\nmacrocallback, while `@typedoc` with a type (public or opaque).\n\nAccepts one of these:\n\n  * a string (often a heredoc)\n  * `false`, which will make the entity invisible to documentation-extraction\n    tools like [`ExDoc`](https://hexdocs.pm/ex_doc/)\n  * a keyword list, since Elixir 1.7.0\n\nFor example:\n\n    defmodule MyModule do\n      @typedoc \"This type\"\n      @typedoc since: \"1.1.0\"\n      @type t :: term\n\n      @doc \"Hello world\"\n      @doc since: \"1.1.0\"\n      def hello do\n        \"world\"\n      end\n\n      @doc \"\"\"\n      Sums `a` to `b`.\n      \"\"\"\n      def sum(a, b) do\n        a + b\n      end\n    end\n\nAs can be seen in the example above, since Elixir 1.7.0 `@doc` and `@typedoc`\nalso accept a keyword list that serves as a way to provide arbitrary metadata\nabout the entity. Tools like [`ExDoc`](https://hexdocs.pm/ex_doc/) and\n`IEx` may use this information to display annotations. A common use\ncase is the `:since` key, which may be used to annotate in which version the\nfunction was introduced.\n\nAs illustrated in the example, it is possible to use these attributes\nmore than once before an entity. However, the compiler will warn if\nused twice with binaries as that replaces the documentation text from\nthe preceding use. Multiple uses with keyword lists will merge the\nlists into one.\n\nNote that since the compiler also defines some additional metadata,\nthere are a few reserved keys that will be ignored and warned if used.\nCurrently these are: `:opaque` and `:defaults`.\n\nOnce this module is compiled, this information becomes available via\nthe `Code.fetch_docs/1` function.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Module"}
{"completion":"# `@dialyzer`\n\nDefines warnings to request or suppress when using `:dialyzer`.\n\nAccepts an atom, a tuple, or a list of atoms and tuples. For example:\n\n    defmodule MyModule do\n      @dialyzer {:nowarn_function, my_fun: 1}\n\n      def my_fun(arg) do\n        M.not_a_function(arg)\n      end\n    end\n\nFor the list of supported warnings, see [`:dialyzer` module](`:dialyzer`).\n\nMultiple uses of `@dialyzer` will accumulate instead of overriding\nprevious ones.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Module"}
{"completion":"# `@external_resource`\n\nSpecifies an external resource for the current module.\n\nSometimes a module embeds information from an external file. This\nattribute allows the module to annotate which external resources\nhave been used.\n\nTools may use this information to ensure the module is recompiled\nin case any of the external resources change, see for example:\n[`mix compile.elixir`](https://hexdocs.pm/mix/Mix.Tasks.Compile.Elixir.html).\n\nIf the external resource does not exist, the module still has\na dependency on it, causing the module to be recompiled as soon\nas the file is added.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Module"}
{"completion":"# `@file`\n\nChanges the filename used in stacktraces for the function or macro that\nfollows the attribute, such as:\n\n    defmodule MyModule do\n      @doc \"Hello world\"\n      @file \"hello.ex\"\n      def hello do\n        \"world\"\n      end\n    end","prompt":"Can you write a docstring for the following Elixir function? Elixir.Module"}
{"completion":"# `@moduledoc`\n\nProvides documentation for the current module.\n\n    defmodule MyModule do\n      @moduledoc \"\"\"\n      A very useful module.\n      \"\"\"\n      @moduledoc authors: [\"Alice\", \"Bob\"]\n    end\n\nAccepts a string (often a heredoc) or `false` where `@moduledoc false`\nwill make the module invisible to documentation extraction tools like\n[`ExDoc`](https://hexdocs.pm/ex_doc/).\n\nSimilarly to `@doc` also accepts a keyword list to provide metadata\nabout the module. For more details, see the documentation of `@doc`\nabove.\n\nOnce this module is compiled, this information becomes available via\nthe `Code.fetch_docs/1` function.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Module"}
{"completion":"# `@on_definition`\n\nA hook that will be invoked when each function or macro in the current\nmodule is defined. Useful when annotating functions.\n\nAccepts a module or a `{module, function_name}` tuple. The function\nmust take 6 arguments:\n\n  * the module environment\n  * the kind of the function/macro: `:def`, `:defp`, `:defmacro`, or `:defmacrop`\n  * the function/macro name\n  * the list of quoted arguments\n  * the list of quoted guards\n  * the quoted function body\n\nIf the function/macro being defined has multiple clauses, the hook will\nbe called for each clause.\n\nUnlike other hooks, `@on_definition` will only invoke functions and\nnever macros. This is to avoid `@on_definition` callbacks from\nredefining functions that have just been defined in favor of more\nexplicit approaches.\n\nWhen just a module is provided, the function is assumed to be\n`__on_definition__/6`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Module"}
{"completion":"## Example\n\n    defmodule Hooks do\n      def on_def(_env, kind, name, args, guards, body) do\n        IO.puts(\"Defining #{kind} named #{name} with args:\")\n        IO.inspect(args)\n        IO.puts(\"and guards\")\n        IO.inspect(guards)\n        IO.puts(\"and body\")\n        IO.puts(Macro.to_string(body))\n      end\n    end\n\n    defmodule MyModule do\n      @on_definition {Hooks, :on_def}\n\n      def hello(arg) when is_binary(arg) or is_list(arg) do\n        \"Hello\" <> to_string(arg)\n      end\n\n      def hello(_) do\n        :ok\n      end\n    end","prompt":"Can you write a docstring for the following Elixir function? Elixir.Module"}
{"completion":"# `@on_load`\n\nA hook that will be invoked whenever the module is loaded.\n\nAccepts the function name (as an atom) of a function in the current module.\nThe function must have an arity of 0 (no arguments). If the function does\nnot return `:ok`, the loading of the module will be aborted.\nFor example:\n\n    defmodule MyModule do\n      @on_load :load_check\n\n      def load_check do\n        if some_condition() do\n          :ok\n        else\n          :abort\n        end\n      end\n\n      def some_condition do\n        false\n      end\n    end","prompt":"Can you write a docstring for the following Elixir function? Elixir.Module"}
{"completion":"# `@vsn`\n\nSpecify the module version. Accepts any valid Elixir value, for example:\n\n    defmodule MyModule do\n      @vsn \"1.0\"\n    end","prompt":"Can you write a docstring for the following Elixir function? Elixir.Module"}
{"completion":"# Struct attributes\n\n  * `@derive` - derives an implementation for the given protocol for the\n    struct defined in the current module\n\n  * `@enforce_keys` - ensures the given keys are always set when building\n    the struct defined in the current module\n\nSee `defstruct/1` for more information on building and using structs.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Module"}
{"completion":"# Typespec attributes\n\nThe following attributes are part of typespecs and are also built-in in\nElixir:\n\n  * `@type` - defines a type to be used in `@spec`\n  * `@typep` - defines a private type to be used in `@spec`\n  * `@opaque` - defines an opaque type to be used in `@spec`\n  * `@spec` - provides a specification for a function\n  * `@callback` - provides a specification for a behaviour callback\n  * `@macrocallback` - provides a specification for a macro behaviour callback\n  * `@optional_callbacks` - specifies which behaviour callbacks and macro\n    behaviour callbacks are optional\n  * `@impl` - declares an implementation of a callback function or macro\n\nFor detailed documentation, see the [typespec documentation](typespecs.md).","prompt":"Can you write a docstring for the following Elixir function? Elixir.Module"}
{"completion":"# Custom attributes\n\nIn addition to the built-in attributes outlined above, custom attributes may\nalso be added. Custom attributes are expressed using the `@/1` operator followed\nby a valid variable name. The value given to the custom attribute must be a valid\nElixir value:\n\n    defmodule MyModule do\n      @custom_attr [some: \"stuff\"]\n    end\n\nFor more advanced options available when defining custom attributes, see\n`register_attribute/3`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Module"}
{"completion":"Compile callbacks\n\nThere are three compilation callbacks, invoked in this order:\n`@before_compile`, `@after_compile`, and `@after_verify`.\nThey are described next.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Module"}
{"completion":"# `@before_compile`\n\nA hook that will be invoked before the module is compiled. This is\noften used to change how the current module is being compiled.\n\nAccepts a module or a `{module, function_or_macro_name}` tuple. The\nfunction/macro must take one argument: the module environment. If\nit's a macro, its returned value will be injected at the end of the\nmodule definition before the compilation starts.\n\nWhen just a module is provided, the function/macro is assumed to be\n`__before_compile__/1`.\n\nCallbacks will run in the order they are registered. Any overridable\ndefinition will be made concrete before the first callback runs.\nA definition may be made overridable again in another before compile\ncallback and it will be made concrete one last time after all callbacks\nrun.\n\n*Note*: the callback function/macro must be placed in a separate module\n(because when the callback is invoked, the current module does not yet exist).","prompt":"Can you write a docstring for the following Elixir function? Elixir.Module"}
{"completion":"## Example\n\n    defmodule A do\n      defmacro __before_compile__(_env) do\n        quote do\n          def hello, do: \"world\"\n        end\n      end\n    end\n\n    defmodule B do\n      @before_compile A\n    end\n\n    B.hello()\n    #=> \"world\"","prompt":"Can you write a docstring for the following Elixir function? Elixir.Module"}
{"completion":"# `@after_compile`\n\nA hook that will be invoked right after the current module is compiled.\n\nAccepts a module or a `{module, function_name}` tuple. The function\nmust take two arguments: the module environment and its bytecode.\nWhen just a module is provided, the function is assumed to be\n`__after_compile__/2`.\n\nCallbacks will run in the order they are registered.\n\n`Module` functions expecting not yet compiled modules (such as `definitions_in/1`)\nare still available at the time `@after_compile` is invoked.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Module"}
{"completion":"## Example\n\n    defmodule MyModule do\n      @after_compile __MODULE__\n\n      def __after_compile__(env, _bytecode) do\n        IO.inspect(env)\n      end\n    end","prompt":"Can you write a docstring for the following Elixir function? Elixir.Module"}
{"completion":"# `@after_verify`\n\nA hook that will be invoked right after the current module is verified for\nundefined functions, deprecations, etc. A module is always verified after\nit is compiled. In Mix projects, a module is also verified when any of its\nruntime dependencies change. Therefore this is useful to perform verification\nof the current module while avoiding compile-time dependencies.\n\nAccepts a module or a `{module, function_name}` tuple. The function\nmust take one argument: the module name. When just a module is provided,\nthe function is assumed to be `__after_verify__/2`.\n\nCallbacks will run in the order they are registered.\n\n`Module` functions expecting not yet compiled modules are no longer available\nat the time `@after_verify` is invoked.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Module"}
{"completion":"## Example\n\n    defmodule MyModule do\n      @after_verify __MODULE__\n\n      def __after_verify__(module) do\n        IO.inspect(module)\n        :ok\n      end\n    end","prompt":"Can you write a docstring for the following Elixir function? Elixir.Module"}
{"completion":"Compile options\n\nThe `@compile` attribute accepts different options that are used by both\nElixir and Erlang compilers. Some of the common use cases are documented\nbelow:\n\n  * `@compile :debug_info` - includes `:debug_info` regardless of the\n    corresponding setting in `Code.get_compiler_option/1`\n\n  * `@compile {:debug_info, false}` - disables `:debug_info` regardless\n    of the corresponding setting in `Code.get_compiler_option/1`. Note\n    disabling `:debug_info` is not recommended as it removes the ability\n    of the Elixir compiler and other tools to static analyse the code.\n    If you want to remove the `:debug_info` while deploying, tools like\n    `mix release` already do such by default.\n\n  * `@compile {:inline, some_fun: 2, other_fun: 3}` - inlines the given\n    name/arity pairs. Inlining is applied locally, calls from another\n    module are not affected by this option\n\n  * `@compile {:autoload, false}` - disables automatic loading of\n    modules after compilation. Instead, the module will be loaded after\n    it is dispatched to\n\n  * `@compile {:no_warn_undefined, Mod}` or\n    `@compile {:no_warn_undefined, {Mod, fun, arity}}` - does not warn if\n    the given module or the given `Mod.fun/arity` are not defined","prompt":"Can you write a docstring for the following Elixir function? Elixir.Module"}
{"completion":"Adds a specified amount of time to a `NaiveDateTime`.\n\nAccepts an `amount_to_add` in any `unit`. `unit` can be `:day`,\n`:hour`, `:minute`, `:second` or any subsecond precision from\n`t:System.time_unit/0`. It defaults to `:second`. Negative values\nwill move backwards in time.\n\nThis function always consider the unit to be computed according\nto the `Calendar.ISO`.\n\n## Examples\n\nIt uses seconds by default:\n\n    # adds seconds by default\n    iex> NaiveDateTime.add(~N[2014-10-02 00:29:10], 2)\n    ~N[2014-10-02 00:29:12]\n\n    # accepts negative offsets\n    iex> NaiveDateTime.add(~N[2014-10-02 00:29:10], -2)\n    ~N[2014-10-02 00:29:08]\n\nIt can also work with subsecond precisions:\n\n    iex> NaiveDateTime.add(~N[2014-10-02 00:29:10], 2_000, :millisecond)\n    ~N[2014-10-02 00:29:12.000]\n\nAs well as days/hours/minutes:\n\n    iex> NaiveDateTime.add(~N[2015-02-28 00:29:10], 2, :day)\n    ~N[2015-03-02 00:29:10]\n    iex> NaiveDateTime.add(~N[2015-02-28 00:29:10], 36, :hour)\n    ~N[2015-03-01 12:29:10]\n    iex> NaiveDateTime.add(~N[2015-02-28 00:29:10], 60, :minute)\n    ~N[2015-02-28 01:29:10]\n\nThis operation merges the precision of the naive date time with the given unit:\n\n    iex> result = NaiveDateTime.add(~N[2014-10-02 00:29:10], 21, :millisecond)\n    ~N[2014-10-02 00:29:10.021]\n    iex> result.microsecond\n    {21000, 3}\n\nOperations on top of gregorian seconds or the Unix epoch are optimized:\n\n    # from Gregorian seconds\n    iex> NaiveDateTime.add(~N[0000-01-01 00:00:00], 63_579_428_950)\n    ~N[2014-10-02 00:29:10]\n\nPassing a `DateTime` automatically converts it to `NaiveDateTime`,\ndiscarding the time zone information:\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> NaiveDateTime.add(dt, 21, :second)\n    ~N[2000-02-29 23:00:28]","prompt":"Can you write a docstring for the following Elixir function? add(naive_datetime, amount_to_add, unit \\\\ :second)"}
{"completion":"Compares two `NaiveDateTime` structs.\n\nReturns `:gt` if first is later than the second\nand `:lt` for vice versa. If the two NaiveDateTime\nare equal `:eq` is returned.\n\n## Examples\n\n    iex> NaiveDateTime.compare(~N[2016-04-16 13:30:15], ~N[2016-04-28 16:19:25])\n    :lt\n    iex> NaiveDateTime.compare(~N[2016-04-16 13:30:15.1], ~N[2016-04-16 13:30:15.01])\n    :gt\n\nThis function can also be used to compare a DateTime without\nthe time zone information:\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> NaiveDateTime.compare(dt, ~N[2000-02-29 23:00:07])\n    :eq\n    iex> NaiveDateTime.compare(dt, ~N[2000-01-29 23:00:07])\n    :gt\n    iex> NaiveDateTime.compare(dt, ~N[2000-03-29 23:00:07])\n    :lt","prompt":"Can you write a docstring for the following Elixir function? compare(naive_datetime1, naive_datetime2)"}
{"completion":"Converts the given `naive_datetime` from one calendar to another.\n\nIf it is not possible to convert unambiguously between the calendars\n(see `Calendar.compatible_calendars?/2`), an `{:error, :incompatible_calendars}` tuple\nis returned.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> NaiveDateTime.convert(~N[2000-01-01 13:30:15], Calendar.Holocene)\n    {:ok, %NaiveDateTime{calendar: Calendar.Holocene, year: 12000, month: 1, day: 1,\n                         hour: 13, minute: 30, second: 15, microsecond: {0, 0}}}","prompt":"Can you write a docstring for the following Elixir function? convert(naive_datetime, calendar)"}
{"completion":"Converts the given `naive_datetime` from one calendar to another.\n\nIf it is not possible to convert unambiguously between the calendars\n(see `Calendar.compatible_calendars?/2`), an ArgumentError is raised.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> NaiveDateTime.convert!(~N[2000-01-01 13:30:15], Calendar.Holocene)\n    %NaiveDateTime{calendar: Calendar.Holocene, year: 12000, month: 1, day: 1,\n                   hour: 13, minute: 30, second: 15, microsecond: {0, 0}}","prompt":"Can you write a docstring for the following Elixir function? convert!(naive_datetime, calendar)"}
{"completion":"Subtracts `naive_datetime2` from `naive_datetime1`.\n\nThe answer can be returned in any `:day`, `:hour`, `:minute`, or any `unit`\navailable from `t:System.time_unit/0`. The unit is measured according to\n`Calendar.ISO` and defaults to `:second`.\n\nFractional results are not supported and are truncated.\n\n## Examples\n\n    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:12], ~N[2014-10-02 00:29:10])\n    2\n    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:12], ~N[2014-10-02 00:29:10], :microsecond)\n    2_000_000\n\n    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:10.042], ~N[2014-10-02 00:29:10.021])\n    0\n    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:10.042], ~N[2014-10-02 00:29:10.021], :millisecond)\n    21\n\n    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:10], ~N[2014-10-02 00:29:12])\n    -2\n    iex> NaiveDateTime.diff(~N[-0001-10-02 00:29:10], ~N[-0001-10-02 00:29:12])\n    -2\n\nIt can also compute the difference in days, hours, or minutes:\n\n    iex> NaiveDateTime.diff(~N[2014-10-10 00:29:10], ~N[2014-10-02 00:29:10], :day)\n    8\n    iex> NaiveDateTime.diff(~N[2014-10-02 12:29:10], ~N[2014-10-02 00:29:10], :hour)\n    12\n    iex> NaiveDateTime.diff(~N[2014-10-02 00:39:10], ~N[2014-10-02 00:29:10], :minute)\n    10\n\nBut it also rounds incomplete days to zero:\n\n    iex> NaiveDateTime.diff(~N[2014-10-10 00:29:09], ~N[2014-10-02 00:29:10], :day)\n    7","prompt":"Can you write a docstring for the following Elixir function? diff(naive_datetime1, naive_datetime2, unit \\\\ :second)"}
{"completion":"Converts an Erlang datetime tuple to a `NaiveDateTime` struct.\n\nAttempting to convert an invalid ISO calendar date will produce an error tuple.\n\n## Examples\n\n    iex> NaiveDateTime.from_erl({{2000, 1, 1}, {13, 30, 15}})\n    {:ok, ~N[2000-01-01 13:30:15]}\n    iex> NaiveDateTime.from_erl({{2000, 1, 1}, {13, 30, 15}}, {5000, 3})\n    {:ok, ~N[2000-01-01 13:30:15.005]}\n    iex> NaiveDateTime.from_erl({{2000, 13, 1}, {13, 30, 15}})\n    {:error, :invalid_date}\n    iex> NaiveDateTime.from_erl({{2000, 13, 1}, {13, 30, 15}})\n    {:error, :invalid_date}","prompt":"Can you write a docstring for the following Elixir function? from_erl(tuple, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO)"}
{"completion":"Converts an Erlang datetime tuple to a `NaiveDateTime` struct.\n\nRaises if the datetime is invalid.\nAttempting to convert an invalid ISO calendar date will produce an error tuple.\n\n## Examples\n\n    iex> NaiveDateTime.from_erl!({{2000, 1, 1}, {13, 30, 15}})\n    ~N[2000-01-01 13:30:15]\n    iex> NaiveDateTime.from_erl!({{2000, 1, 1}, {13, 30, 15}}, {5000, 3})\n    ~N[2000-01-01 13:30:15.005]\n    iex> NaiveDateTime.from_erl!({{2000, 13, 1}, {13, 30, 15}})\n    ** (ArgumentError) cannot convert {{2000, 13, 1}, {13, 30, 15}} to naive datetime, reason: :invalid_date","prompt":"Can you write a docstring for the following Elixir function? from_erl!(tuple, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO)"}
{"completion":"Converts a number of gregorian seconds to a `NaiveDateTime` struct.\n\n## Examples\n\n    iex> NaiveDateTime.from_gregorian_seconds(1)\n    ~N[0000-01-01 00:00:01]\n    iex> NaiveDateTime.from_gregorian_seconds(63_755_511_991, {5000, 3})\n    ~N[2020-05-01 00:26:31.005]\n    iex> NaiveDateTime.from_gregorian_seconds(-1)\n    ~N[-0001-12-31 23:59:59]","prompt":"Can you write a docstring for the following Elixir function? from_gregorian_seconds(seconds, arg \\\\ {0, 0}, calendar \\\\ Calendar.ISO)"}
{"completion":"Parses the extended \"Date and time of day\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nTime zone offset may be included in the string but they will be\nsimply discarded as such information is not included in naive date\ntimes.\n\nAs specified in the standard, the separator \"T\" may be omitted if\ndesired as there is no ambiguity within this function.\n\nNote leap seconds are not supported by the built-in Calendar.ISO.\n\n## Examples\n\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07\")\n    {:ok, ~N[2015-01-23 23:50:07]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07\")\n    {:ok, ~N[2015-01-23 23:50:07]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07Z\")\n    {:ok, ~N[2015-01-23 23:50:07]}\n\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07.0\")\n    {:ok, ~N[2015-01-23 23:50:07.0]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07,0123456\")\n    {:ok, ~N[2015-01-23 23:50:07.012345]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07.0123456\")\n    {:ok, ~N[2015-01-23 23:50:07.012345]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123Z\")\n    {:ok, ~N[2015-01-23 23:50:07.123]}\n\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23P23:50:07\")\n    {:error, :invalid_format}\n    iex> NaiveDateTime.from_iso8601(\"2015:01:23 23-50-07\")\n    {:error, :invalid_format}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07A\")\n    {:error, :invalid_format}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:61\")\n    {:error, :invalid_time}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-32 23:50:07\")\n    {:error, :invalid_date}\n\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123+02:30\")\n    {:ok, ~N[2015-01-23 23:50:07.123]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123+00:00\")\n    {:ok, ~N[2015-01-23 23:50:07.123]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-02:30\")\n    {:ok, ~N[2015-01-23 23:50:07.123]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-00:00\")\n    {:error, :invalid_format}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-00:60\")\n    {:error, :invalid_format}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-24:00\")\n    {:error, :invalid_format}","prompt":"Can you write a docstring for the following Elixir function? from_iso8601(string, calendar \\\\ Calendar.ISO)"}
{"completion":"Parses the extended \"Date and time of day\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nRaises if the format is invalid.\n\n## Examples\n\n    iex> NaiveDateTime.from_iso8601!(\"2015-01-23T23:50:07.123Z\")\n    ~N[2015-01-23 23:50:07.123]\n    iex> NaiveDateTime.from_iso8601!(\"2015-01-23T23:50:07,123Z\")\n    ~N[2015-01-23 23:50:07.123]\n    iex> NaiveDateTime.from_iso8601!(\"2015-01-23P23:50:07\")\n    ** (ArgumentError) cannot parse \"2015-01-23P23:50:07\" as naive datetime, reason: :invalid_format","prompt":"Can you write a docstring for the following Elixir function? from_iso8601!(string, calendar \\\\ Calendar.ISO)"}
{"completion":"Returns the \"local time\" for the machine the Elixir program is running on.\n\nWARNING: This function can cause insidious bugs. It depends on the time zone\nconfiguration at run time. This can changed and be set to a time zone that has\ndaylight saving jumps (spring forward or fall back).\n\nThis function can be used to display what the time is right now for the time\nzone configuration that the machine happens to have. An example would be a\ndesktop program displaying a clock to the user. For any other uses it is\nprobably a bad idea to use this function.\n\nFor most cases, use `DateTime.now/2` or `DateTime.utc_now/1` instead.\n\nDoes not include fractional seconds.\n\n## Examples\n\n    iex> naive_datetime = NaiveDateTime.local_now()\n    iex> naive_datetime.year >= 2019\n    true","prompt":"Can you write a docstring for the following Elixir function? local_now(calendar \\\\ Calendar.ISO)"}
{"completion":"Builds a naive datetime from date and time structs.\n\n## Examples\n\n    iex> NaiveDateTime.new(~D[2010-01-13], ~T[23:00:07.005])\n    {:ok, ~N[2010-01-13 23:00:07.005]}","prompt":"Can you write a docstring for the following Elixir function? new(date, time)"}
{"completion":"Builds a new ISO naive datetime.\n\nExpects all values to be integers. Returns `{:ok, naive_datetime}`\nif each entry fits its appropriate range, returns `{:error, reason}`\notherwise.\n\n## Examples\n\n    iex> NaiveDateTime.new(2000, 1, 1, 0, 0, 0)\n    {:ok, ~N[2000-01-01 00:00:00]}\n    iex> NaiveDateTime.new(2000, 13, 1, 0, 0, 0)\n    {:error, :invalid_date}\n    iex> NaiveDateTime.new(2000, 2, 29, 0, 0, 0)\n    {:ok, ~N[2000-02-29 00:00:00]}\n    iex> NaiveDateTime.new(2000, 2, 30, 0, 0, 0)\n    {:error, :invalid_date}\n    iex> NaiveDateTime.new(2001, 2, 29, 0, 0, 0)\n    {:error, :invalid_date}\n\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 59, {0, 1})\n    {:ok, ~N[2000-01-01 23:59:59.0]}\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 59, 999_999)\n    {:ok, ~N[2000-01-01 23:59:59.999999]}\n    iex> NaiveDateTime.new(2000, 1, 1, 24, 59, 59, 999_999)\n    {:error, :invalid_time}\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 60, 59, 999_999)\n    {:error, :invalid_time}\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 60, 999_999)\n    {:error, :invalid_time}\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 59, 1_000_000)\n    {:error, :invalid_time}\n\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 59, {0, 1}, Calendar.ISO)\n    {:ok, ~N[2000-01-01 23:59:59.0]}","prompt":"Can you write a docstring for the following Elixir function? new(year, month, day, hour, minute, second, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO)"}
{"completion":"Builds a naive datetime from date and time structs.\n\n## Examples\n\n    iex> NaiveDateTime.new!(~D[2010-01-13], ~T[23:00:07.005])\n    ~N[2010-01-13 23:00:07.005]","prompt":"Can you write a docstring for the following Elixir function? new!(date, time)"}
{"completion":"Builds a new ISO naive datetime.\n\nExpects all values to be integers. Returns `naive_datetime`\nif each entry fits its appropriate range, raises if\ntime or date is invalid.\n\n## Examples\n\n    iex> NaiveDateTime.new!(2000, 1, 1, 0, 0, 0)\n    ~N[2000-01-01 00:00:00]\n    iex> NaiveDateTime.new!(2000, 2, 29, 0, 0, 0)\n    ~N[2000-02-29 00:00:00]\n    iex> NaiveDateTime.new!(2000, 1, 1, 23, 59, 59, {0, 1})\n    ~N[2000-01-01 23:59:59.0]\n    iex> NaiveDateTime.new!(2000, 1, 1, 23, 59, 59, 999_999)\n    ~N[2000-01-01 23:59:59.999999]\n    iex> NaiveDateTime.new!(2000, 1, 1, 23, 59, 59, {0, 1}, Calendar.ISO)\n    ~N[2000-01-01 23:59:59.0]\n    iex> NaiveDateTime.new!(2000, 1, 1, 24, 59, 59, 999_999)\n    ** (ArgumentError) cannot build naive datetime, reason: :invalid_time","prompt":"Can you write a docstring for the following Elixir function? new!(year, month, day, hour, minute, second, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO)"}
{"completion":"Converts a `NaiveDateTime` into a `Date`.\n\nBecause `Date` does not hold time information,\ndata will be lost during the conversion.\n\n## Examples\n\n    iex> NaiveDateTime.to_date(~N[2002-01-13 23:00:07])\n    ~D[2002-01-13]","prompt":"Can you write a docstring for the following Elixir function? to_date(map)"}
{"completion":"Converts a `NaiveDateTime` struct to an Erlang datetime tuple.\n\nOnly supports converting naive datetimes which are in the ISO calendar,\nattempting to convert naive datetimes from other calendars will raise.\n\nWARNING: Loss of precision may occur, as Erlang time tuples only store\nhour/minute/second.\n\n## Examples\n\n    iex> NaiveDateTime.to_erl(~N[2000-01-01 13:30:15])\n    {{2000, 1, 1}, {13, 30, 15}}\n\nThis function can also be used to convert a DateTime to an Erlang\ndatetime tuple without the time zone information:\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> NaiveDateTime.to_erl(dt)\n    {{2000, 2, 29}, {23, 00, 07}}","prompt":"Can you write a docstring for the following Elixir function? to_erl(naive_datetime)"}
{"completion":"Converts a `NaiveDateTime` struct to a number of gregorian seconds and microseconds.\n\n## Examples\n\n    iex> NaiveDateTime.to_gregorian_seconds(~N[0000-01-01 00:00:01])\n    {1, 0}\n    iex> NaiveDateTime.to_gregorian_seconds(~N[2020-05-01 00:26:31.005])\n    {63_755_511_991, 5000}","prompt":"Can you write a docstring for the following Elixir function? to_gregorian_seconds(map)"}
{"completion":"Converts the given naive datetime to\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nBy default, `NaiveDateTime.to_iso8601/2` returns naive datetimes formatted in the \"extended\"\nformat, for human readability. It also supports the \"basic\" format through passing the `:basic` option.\n\nOnly supports converting naive datetimes which are in the ISO calendar,\nattempting to convert naive datetimes from other calendars will raise.\n\n### Examples\n\n    iex> NaiveDateTime.to_iso8601(~N[2000-02-28 23:00:13])\n    \"2000-02-28T23:00:13\"\n\n    iex> NaiveDateTime.to_iso8601(~N[2000-02-28 23:00:13.001])\n    \"2000-02-28T23:00:13.001\"\n\n    iex> NaiveDateTime.to_iso8601(~N[2000-02-28 23:00:13.001], :basic)\n    \"20000228T230013.001\"\n\nThis function can also be used to convert a DateTime to ISO 8601 without\nthe time zone information:\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> NaiveDateTime.to_iso8601(dt)\n    \"2000-02-29T23:00:07\"","prompt":"Can you write a docstring for the following Elixir function? to_iso8601(naive_datetime, format \\\\ :extended)"}
{"completion":"Converts the given naive datetime to a string according to its calendar.\n\n### Examples\n\n    iex> NaiveDateTime.to_string(~N[2000-02-28 23:00:13])\n    \"2000-02-28 23:00:13\"\n    iex> NaiveDateTime.to_string(~N[2000-02-28 23:00:13.001])\n    \"2000-02-28 23:00:13.001\"\n    iex> NaiveDateTime.to_string(~N[-0100-12-15 03:20:31])\n    \"-0100-12-15 03:20:31\"\n\nThis function can also be used to convert a DateTime to a string without\nthe time zone information:\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> NaiveDateTime.to_string(dt)\n    \"2000-02-29 23:00:07\"","prompt":"Can you write a docstring for the following Elixir function? to_string(naive_datetime)"}
{"completion":"Converts a `NaiveDateTime` into `Time`.\n\nBecause `Time` does not hold date information,\ndata will be lost during the conversion.\n\n## Examples\n\n    iex> NaiveDateTime.to_time(~N[2002-01-13 23:00:07])\n    ~T[23:00:07]","prompt":"Can you write a docstring for the following Elixir function? to_time(map)"}
{"completion":"Returns the given naive datetime with the microsecond field truncated to the\ngiven precision (`:microsecond`, `:millisecond` or `:second`).\n\nThe given naive datetime is returned unchanged if it already has lower precision\nthan the given precision.\n\n## Examples\n\n    iex> NaiveDateTime.truncate(~N[2017-11-06 00:23:51.123456], :microsecond)\n    ~N[2017-11-06 00:23:51.123456]\n\n    iex> NaiveDateTime.truncate(~N[2017-11-06 00:23:51.123456], :millisecond)\n    ~N[2017-11-06 00:23:51.123]\n\n    iex> NaiveDateTime.truncate(~N[2017-11-06 00:23:51.123456], :second)\n    ~N[2017-11-06 00:23:51]","prompt":"Can you write a docstring for the following Elixir function? truncate(naive_datetime, precision)"}
{"completion":"Returns the current naive datetime in UTC.\n\nPrefer using `DateTime.utc_now/0` when possible as, opposite\nto `NaiveDateTime`, it will keep the time zone information.\n\n## Examples\n\n    iex> naive_datetime = NaiveDateTime.utc_now()\n    iex> naive_datetime.year >= 2016\n    true","prompt":"Can you write a docstring for the following Elixir function? utc_now(calendar \\\\ Calendar.ISO)"}
{"completion":"A NaiveDateTime struct (without a time zone) and functions.\n\nThe NaiveDateTime struct contains the fields year, month, day, hour,\nminute, second, microsecond and calendar. New naive datetimes can be\nbuilt with the `new/2` and `new/8` functions or using the\n`~N` (see `sigil_N/2`) sigil:\n\n    iex> ~N[2000-01-01 23:00:07]\n    ~N[2000-01-01 23:00:07]\n\nThe date and time fields in the struct can be accessed directly:\n\n    iex> naive = ~N[2000-01-01 23:00:07]\n    iex> naive.year\n    2000\n    iex> naive.second\n    7\n\nWe call them \"naive\" because this datetime representation does not\nhave a time zone. This means the datetime may not actually exist in\ncertain areas in the world even though it is valid.\n\nFor example, when daylight saving changes are applied by a region,\nthe clock typically moves forward or backward by one hour. This means\ncertain datetimes never occur or may occur more than once. Since\n`NaiveDateTime` is not validated against a time zone, such errors\nwould go unnoticed.\n\nDevelopers should avoid creating the NaiveDateTime structs directly\nand instead, rely on the functions provided by this module as well\nas the ones in third-party calendar libraries.","prompt":"Can you write a docstring for the following Elixir function? Elixir.NaiveDateTime"}
{"completion":"Comparing naive date times\n\nComparisons in Elixir using `==/2`, `>/2`, `</2` and similar are structural\nand based on the `NaiveDateTime` struct fields. For proper comparison\nbetween naive datetimes, use the `compare/2` function. The existence of the\n`compare/2` function in this module also allows using `Enum.min/2` and\n`Enum.max/2` functions to get the minimum and maximum naive datetime of an\n`Enum`. For example:\n\n    iex> Enum.min([~N[2020-01-01 23:00:07], ~N[2000-01-01 23:00:07]], NaiveDateTime)\n    ~N[2000-01-01 23:00:07]","prompt":"Can you write a docstring for the following Elixir function? Elixir.NaiveDateTime"}
{"completion":"Using epochs\n\nThe `add/3` and `diff/3` functions can be used for computing date\ntimes or retrieving the number of seconds between instants.\nFor example, if there is an interest in computing the number of\nseconds from the Unix epoch (1970-01-01 00:00:00):\n\n    iex> NaiveDateTime.diff(~N[2010-04-17 14:00:00], ~N[1970-01-01 00:00:00])\n    1271512800\n\n    iex> NaiveDateTime.add(~N[1970-01-01 00:00:00], 1_271_512_800)\n    ~N[2010-04-17 14:00:00]\n\nThose functions are optimized to deal with common epochs, such\nas the Unix Epoch above or the Gregorian Epoch (0000-01-01 00:00:00).","prompt":"Can you write a docstring for the following Elixir function? Elixir.NaiveDateTime"}
{"completion":"Returns `true` if the local node is alive.\n\nThat is, if the node can be part of a distributed system.","prompt":"Can you write a docstring for the following Elixir function? alive?()"}
{"completion":"Establishes a connection to `node`.\n\nReturns `true` if successful, `false` if not, and the atom\n`:ignored` if the local node is not alive.\n\nFor more information, see `:net_kernel.connect_node/1`.","prompt":"Can you write a docstring for the following Elixir function? connect(node)"}
{"completion":"Forces the disconnection of a node.\n\nThis will appear to the `node` as if the local node has crashed.\nThis function is mainly used in the Erlang network authentication\nprotocols. Returns `true` if disconnection succeeds, otherwise `false`.\nIf the local node is not alive, the function returns `:ignored`.\n\nFor more information, see `:erlang.disconnect_node/1`.","prompt":"Can you write a docstring for the following Elixir function? disconnect(node)"}
{"completion":"Returns the magic cookie of the local node.\n\nReturns the cookie if the node is alive, otherwise `:nocookie`.","prompt":"Can you write a docstring for the following Elixir function? get_cookie()"}
{"completion":"Returns a list of all visible nodes in the system, excluding\nthe local node.\n\nSame as `list(:visible)`.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? list()"}
{"completion":"Returns a list of nodes according to argument given.\n\nThe result returned when the argument is a list, is the list of nodes\nsatisfying the disjunction(s) of the list elements.\n\nFor more information, see `:erlang.nodes/1`.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? list(args)"}
{"completion":"Monitors the status of the node.\n\nIf `flag` is `true`, monitoring is turned on.\nIf `flag` is `false`, monitoring is turned off.\n\nFor more information, see `:erlang.monitor_node/2`.\n\nFor monitoring status changes of all nodes, see `:net_kernel.monitor_nodes/2`.","prompt":"Can you write a docstring for the following Elixir function? monitor(node, flag)"}
{"completion":"Behaves as `monitor/2` except that it allows an extra\noption to be given, namely `:allow_passive_connect`.\n\nFor more information, see `:erlang.monitor_node/3`.\n\nFor monitoring status changes of all nodes, see `:net_kernel.monitor_nodes/2`.","prompt":"Can you write a docstring for the following Elixir function? monitor(node, flag, options)"}
{"completion":"Tries to set up a connection to node.\n\nReturns `:pang` if it fails, or `:pong` if it is successful.\n\n## Examples\n\n    iex> Node.ping(:unknown_node)\n    :pang","prompt":"Can you write a docstring for the following Elixir function? ping(node)"}
{"completion":"Returns the current node.\n\nIt returns the same as the built-in `node()`.","prompt":"Can you write a docstring for the following Elixir function? self()"}
{"completion":"Sets the magic cookie of `node` to the atom `cookie`.\n\nThe default node is `Node.self/0`, the local node. If `node` is the local node,\nthe function also sets the cookie of all other unknown nodes to `cookie`.\n\nThis function will raise `FunctionClauseError` if the given `node` is not alive.","prompt":"Can you write a docstring for the following Elixir function? set_cookie(node \\\\ Node.self(), cookie)"}
{"completion":"Returns the PID of a new process started by the application of `fun`\non `node`. If `node` does not exist, a useless PID is returned.\n\nFor the list of available options, see `:erlang.spawn/2`.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? spawn(node, fun)"}
{"completion":"Returns the PID of a new process started by the application of `fun`\non `node`.\n\nIf `node` does not exist, a useless PID is returned.\n\nFor the list of available options, see `:erlang.spawn_opt/3`.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? spawn(node, fun, opts)"}
{"completion":"Returns the PID of a new process started by the application of\n`module.function(args)` on `node`.\n\nIf `node` does not exist, a useless PID is returned.\n\nFor the list of available options, see `:erlang.spawn/4`.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? spawn(node, module, fun, args)"}
{"completion":"Returns the PID of a new process started by the application of\n`module.function(args)` on `node`.\n\nIf `node` does not exist, a useless PID is returned.\n\nFor the list of available options, see `:erlang.spawn/4`.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? spawn(node, module, fun, args, opts)"}
{"completion":"Returns the PID of a new linked process started by the application of `fun` on `node`.\n\nA link is created between the calling process and the new process, atomically.\nIf `node` does not exist, a useless PID is returned (and due to the link, an exit\nsignal with exit reason `:noconnection` will be received).\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? spawn_link(node, fun)"}
{"completion":"Returns the PID of a new linked process started by the application of\n`module.function(args)` on `node`.\n\nA link is created between the calling process and the new process, atomically.\nIf `node` does not exist, a useless PID is returned (and due to the link, an exit\nsignal with exit reason `:noconnection` will be received).\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? spawn_link(node, module, fun, args)"}
{"completion":"Spawns the given function on a node, monitors it and returns its PID\nand monitoring reference.\n\nThis functionality was added on Erlang/OTP 23. Using this function to\ncommunicate with nodes running on earlier versions will fail.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? spawn_monitor(node, fun)"}
{"completion":"Spawns the given module and function passing the given args on a node,\nmonitors it and returns its PID and monitoring reference.\n\nThis functionality was added on Erlang/OTP 23. Using this function\nto communicate with nodes running on earlier versions will fail.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? spawn_monitor(node, module, fun, args)"}
{"completion":"Turns a non-distributed node into a distributed node.\n\nThis functionality starts the `:net_kernel` and other related\nprocesses.\n\nThis function is rarely invoked in practice. Instead, nodes are\nnamed and started via the command line by using the `--sname` and\n`--name` flags. If you need to use this function to dynamically\nname a node, please make sure the `epmd` operating system process\nis running by calling `epmd -daemon`.\n\nInvoking this function when the distribution has already been started,\neither via the command line interface or dynamically, will return an\nerror.\n\n## Examples\n\n    {:ok, pid} = Node.start(:example, :shortnames, 15000)","prompt":"Can you write a docstring for the following Elixir function? start(name, type \\\\ :longnames, tick_time \\\\ 15000)"}
{"completion":"Turns a distributed node into a non-distributed node.\n\nFor other nodes in the network, this is the same as the node going down.\nOnly possible when the node was started with `Node.start/3`, otherwise\nreturns `{:error, :not_allowed}`. Returns `{:error, :not_found}` if the\nlocal node is not alive.","prompt":"Can you write a docstring for the following Elixir function? stop()"}
{"completion":"Functions related to VM nodes.\n\nSome of the functions in this module are inlined by the compiler,\nsimilar to functions in the `Kernel` module and they are explicitly\nmarked in their docs as \"inlined by the compiler\". For more information\nabout inlined functions, check out the `Kernel` module.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Node"}
{"completion":"Low-level function that parses one option.\n\nIt accepts the same options as `parse/2` and `parse_head/2`\nas both functions are built on top of this function. This function\nmay return:\n\n  * `{:ok, key, value, rest}` - the option `key` with `value` was\n    successfully parsed\n\n  * `{:invalid, key, value, rest}` - the option `key` is invalid with `value`\n    (returned when the value cannot be parsed according to the switch type)\n\n  * `{:undefined, key, value, rest}` - the option `key` is undefined\n    (returned in strict mode when the switch is unknown or on nonexistent atoms)\n\n  * `{:error, rest}` - there are no switches at the head of the given `argv`","prompt":"Can you write a docstring for the following Elixir function? next(argv, opts \\\\ [])"}
{"completion":"Parses `argv` into a keyword list.\n\nIt returns a three-element tuple with the form `{parsed, args, invalid}`, where:\n\n  * `parsed` is a keyword list of parsed switches with `{switch_name, value}`\n    tuples in it; `switch_name` is the atom representing the switch name while\n    `value` is the value for that switch parsed according to `opts` (see the\n    \"Examples\" section for more information)\n  * `args` is a list of the remaining arguments in `argv` as strings\n  * `invalid` is a list of invalid options as `{option_name, value}` where\n    `option_name` is the raw option and `value` is `nil` if the option wasn't\n    expected or the string value if the value didn't have the expected type for\n    the corresponding option\n\nElixir converts switches to underscored atoms, so `--source-path` becomes\n`:source_path`. This is done to better suit Elixir conventions. However, this\nmeans that switches can't contain underscores and switches that do contain\nunderscores are always returned in the list of invalid switches.\n\nWhen parsing, it is common to list switches and their expected types:\n\n    iex> OptionParser.parse([\"--debug\"], strict: [debug: :boolean])\n    {[debug: true], [], []}\n\n    iex> OptionParser.parse([\"--source\", \"lib\"], strict: [source: :string])\n    {[source: \"lib\"], [], []}\n\n    iex> OptionParser.parse(\n    ...>   [\"--source-path\", \"lib\", \"test/enum_test.exs\", \"--verbose\"],\n    ...>   strict: [source_path: :string, verbose: :boolean]\n    ...> )\n    {[source_path: \"lib\", verbose: true], [\"test/enum_test.exs\"], []}\n\nWe will explore the valid switches and operation modes of option parser below.\n\n## Options\n\nThe following options are supported:\n\n  * `:switches` or `:strict` - see the \"Switch definitions\" section below\n  * `:allow_nonexistent_atoms` - see the \"Parsing unknown switches\" section below\n  * `:aliases` - see the \"Aliases\" section below\n\n## Switch definitions\n\nSwitches can be specified via one of two options:\n\n  * `:strict` - defines strict switches and their types. Any switch\n    in `argv` that is not specified in the list is returned in the\n    invalid options list. This is the preferred way to parse options.\n\n  * `:switches` - defines switches and their types. This function\n    still attempts to parse switches that are not in this list.\n\nBoth these options accept a keyword list where the key is an atom\ndefining the name of the switch and value is the `type` of the\nswitch (see the \"Types\" section below for more information).\n\nNote that you should only supply the `:switches` or the `:strict` option.\nIf you supply both, an `ArgumentError` exception will be raised.\n\n### Types\n\nSwitches parsed by `OptionParser` may take zero or one arguments.\n\nThe following switches types take no arguments:\n\n  * `:boolean` - sets the value to `true` when given (see also the\n    \"Negation switches\" section below)\n  * `:count` - counts the number of times the switch is given\n\nThe following switches take one argument:\n\n  * `:integer` - parses the value as an integer\n  * `:float` - parses the value as a float\n  * `:string` - parses the value as a string\n\nIf a switch can't be parsed according to the given type, it is\nreturned in the invalid options list.\n\n### Modifiers\n\nSwitches can be specified with modifiers, which change how\nthey behave. The following modifiers are supported:\n\n  * `:keep` - keeps duplicated elements instead of overriding them;\n    works with all types except `:count`. Specifying `switch_name: :keep`\n    assumes the type of `:switch_name` will be `:string`.\n\nTo use `:keep` with a type other than `:string`, use a list as the type\nfor the switch. For example: `[foo: [:integer, :keep]]`.\n\n### Negation switches\n\nIn case a switch `SWITCH` is specified to have type `:boolean`, it may be\npassed as `--no-SWITCH` as well which will set the option to `false`:\n\n    iex> OptionParser.parse([\"--no-op\", \"path/to/file\"], switches: [op: :boolean])\n    {[op: false], [\"path/to/file\"], []}\n\n### Parsing unknown switches\n\nWhen the `:switches` option is given, `OptionParser` will attempt to parse\nunknown switches:\n\n    iex> OptionParser.parse([\"--debug\"], switches: [key: :string])\n    {[debug: true], [], []}\n\nEven though we haven't specified `--debug` in the list of switches, it is part\nof the returned options. This would also work:\n\n    iex> OptionParser.parse([\"--debug\", \"value\"], switches: [key: :string])\n    {[debug: \"value\"], [], []}\n\nSwitches followed by a value will be assigned the value, as a string. Switches\nwithout an argument will be set automatically to `true`. Since we cannot assert\nthe type of the switch value, it is preferred to use the `:strict` option that\naccepts only known switches and always verify their types.\n\nIf you do want to parse unknown switches, remember that Elixir converts switches\nto atoms. Since atoms are not garbage-collected, OptionParser will only parse\nswitches that translate to atoms used by the runtime to avoid leaking atoms.\nFor instance, the code below will discard the `--option-parser-example` switch\nbecause the `:option_parser_example` atom is never used anywhere:\n\n    OptionParser.parse([\"--option-parser-example\"], switches: [debug: :boolean])\n    # The :option_parser_example atom is not used anywhere below\n\nHowever, the code below would work as long as `:option_parser_example` atom is\nused at some point later (or earlier) **in the same module**. For example:\n\n    {opts, _, _} = OptionParser.parse([\"--option-parser-example\"], switches: [debug: :boolean])\n    # ... then somewhere in the same module you access it ...\n    opts[:option_parser_example]\n\nIn other words, Elixir will only parse options that are used by the runtime,\nignoring all others. If you would like to parse all switches, regardless if\nthey exist or not, you can force creation of atoms by passing\n`allow_nonexistent_atoms: true` as option. Use this option with care. It is\nonly useful when you are building command-line applications that receive\ndynamically-named arguments and must be avoided in long-running systems.\n\n## Aliases\n\nA set of aliases can be specified in the `:aliases` option:\n\n    iex> OptionParser.parse([\"-d\"], aliases: [d: :debug], strict: [debug: :boolean])\n    {[debug: true], [], []}\n\n## Examples\n\nHere are some examples of working with different types and modifiers:\n\n    iex> OptionParser.parse([\"--unlock\", \"path/to/file\"], strict: [unlock: :boolean])\n    {[unlock: true], [\"path/to/file\"], []}\n\n    iex> OptionParser.parse(\n    ...>   [\"--unlock\", \"--limit\", \"0\", \"path/to/file\"],\n    ...>   strict: [unlock: :boolean, limit: :integer]\n    ...> )\n    {[unlock: true, limit: 0], [\"path/to/file\"], []}\n\n    iex> OptionParser.parse([\"--limit\", \"3\"], strict: [limit: :integer])\n    {[limit: 3], [], []}\n\n    iex> OptionParser.parse([\"--limit\", \"xyz\"], strict: [limit: :integer])\n    {[], [], [{\"--limit\", \"xyz\"}]}\n\n    iex> OptionParser.parse([\"--verbose\"], switches: [verbose: :count])\n    {[verbose: 1], [], []}\n\n    iex> OptionParser.parse([\"-v\", \"-v\"], aliases: [v: :verbose], strict: [verbose: :count])\n    {[verbose: 2], [], []}\n\n    iex> OptionParser.parse([\"--unknown\", \"xyz\"], strict: [])\n    {[], [\"xyz\"], [{\"--unknown\", nil}]}\n\n    iex> OptionParser.parse(\n    ...>   [\"--limit\", \"3\", \"--unknown\", \"xyz\"],\n    ...>   switches: [limit: :integer]\n    ...> )\n    {[limit: 3, unknown: \"xyz\"], [], []}\n\n    iex> OptionParser.parse(\n    ...>   [\"--unlock\", \"path/to/file\", \"--unlock\", \"path/to/another/file\"],\n    ...>   strict: [unlock: :keep]\n    ...> )\n    {[unlock: \"path/to/file\", unlock: \"path/to/another/file\"], [], []}","prompt":"Can you write a docstring for the following Elixir function? parse(argv, opts \\\\ [])"}
{"completion":"The same as `parse/2` but raises an `OptionParser.ParseError`\nexception if any invalid options are given.\n\nIf there are no errors, returns a `{parsed, rest}` tuple where:\n\n  * `parsed` is the list of parsed switches (same as in `parse/2`)\n  * `rest` is the list of arguments (same as in `parse/2`)\n\n## Examples\n\n    iex> OptionParser.parse!([\"--debug\", \"path/to/file\"], strict: [debug: :boolean])\n    {[debug: true], [\"path/to/file\"]}\n\n    iex> OptionParser.parse!([\"--limit\", \"xyz\"], strict: [limit: :integer])\n    ** (OptionParser.ParseError) 1 error found!\n    --limit : Expected type integer, got \"xyz\"\n\n    iex> OptionParser.parse!([\"--unknown\", \"xyz\"], strict: [])\n    ** (OptionParser.ParseError) 1 error found!\n    --unknown : Unknown option\n\n    iex> OptionParser.parse!(\n    ...>   [\"-l\", \"xyz\", \"-f\", \"bar\"],\n    ...>   switches: [limit: :integer, foo: :integer],\n    ...>   aliases: [l: :limit, f: :foo]\n    ...> )\n    ** (OptionParser.ParseError) 2 errors found!\n    -l : Expected type integer, got \"xyz\"\n    -f : Expected type integer, got \"bar\"","prompt":"Can you write a docstring for the following Elixir function? parse!(argv, opts \\\\ [])"}
{"completion":"Similar to `parse/2` but only parses the head of `argv`;\nas soon as it finds a non-switch, it stops parsing.\n\nSee `parse/2` for more information.\n\n## Example\n\n    iex> OptionParser.parse_head(\n    ...>   [\"--source\", \"lib\", \"test/enum_test.exs\", \"--verbose\"],\n    ...>   switches: [source: :string, verbose: :boolean]\n    ...> )\n    {[source: \"lib\"], [\"test/enum_test.exs\", \"--verbose\"], []}\n\n    iex> OptionParser.parse_head(\n    ...>   [\"--verbose\", \"--source\", \"lib\", \"test/enum_test.exs\", \"--unlock\"],\n    ...>   switches: [source: :string, verbose: :boolean, unlock: :boolean]\n    ...> )\n    {[verbose: true, source: \"lib\"], [\"test/enum_test.exs\", \"--unlock\"], []}","prompt":"Can you write a docstring for the following Elixir function? parse_head(argv, opts \\\\ [])"}
{"completion":"The same as `parse_head/2` but raises an `OptionParser.ParseError`\nexception if any invalid options are given.\n\nIf there are no errors, returns a `{parsed, rest}` tuple where:\n\n  * `parsed` is the list of parsed switches (same as in `parse_head/2`)\n  * `rest` is the list of arguments (same as in `parse_head/2`)\n\n## Examples\n\n    iex> OptionParser.parse_head!(\n    ...>   [\"--source\", \"lib\", \"path/to/file\", \"--verbose\"],\n    ...>   switches: [source: :string, verbose: :boolean]\n    ...> )\n    {[source: \"lib\"], [\"path/to/file\", \"--verbose\"]}\n\n    iex> OptionParser.parse_head!(\n    ...>   [\"--number\", \"lib\", \"test/enum_test.exs\", \"--verbose\"],\n    ...>   strict: [number: :integer]\n    ...> )\n    ** (OptionParser.ParseError) 1 error found!\n    --number : Expected type integer, got \"lib\"\n\n    iex> OptionParser.parse_head!(\n    ...>   [\"--verbose\", \"--source\", \"lib\", \"test/enum_test.exs\", \"--unlock\"],\n    ...>   strict: [verbose: :integer, source: :integer]\n    ...> )\n    ** (OptionParser.ParseError) 2 errors found!\n    --verbose : Missing argument of type integer\n    --source : Expected type integer, got \"lib\"","prompt":"Can you write a docstring for the following Elixir function? parse_head!(argv, opts \\\\ [])"}
{"completion":"Splits a string into `t:argv/0` chunks.\n\nThis function splits the given `string` into a list of strings in a similar\nway to many shells.\n\n## Examples\n\n    iex> OptionParser.split(\"foo bar\")\n    [\"foo\", \"bar\"]\n\n    iex> OptionParser.split(\"foo \\\"bar baz\\\"\")\n    [\"foo\", \"bar baz\"]","prompt":"Can you write a docstring for the following Elixir function? split(string)"}
{"completion":"Receives a key-value enumerable and converts it to `t:argv/0`.\n\nKeys must be atoms. Keys with `nil` value are discarded,\nboolean values are converted to `--key` or `--no-key`\n(if the value is `true` or `false`, respectively),\nand all other values are converted using `to_string/1`.\n\nIt is advised to pass to `to_argv/2` the same set of `options`\ngiven to `parse/2`. Some switches can only be reconstructed\ncorrectly with the `:switches` information in hand.\n\n## Examples\n\n    iex> OptionParser.to_argv(foo_bar: \"baz\")\n    [\"--foo-bar\", \"baz\"]\n    iex> OptionParser.to_argv(bool: true, bool: false, discarded: nil)\n    [\"--bool\", \"--no-bool\"]\n\nSome switches will output different values based on the switches\ntypes:\n\n    iex> OptionParser.to_argv([number: 2], switches: [])\n    [\"--number\", \"2\"]\n    iex> OptionParser.to_argv([number: 2], switches: [number: :count])\n    [\"--number\", \"--number\"]","prompt":"Can you write a docstring for the following Elixir function? to_argv(enum, options \\\\ [])"}
{"completion":"Functions for parsing command line arguments.\n\nWhen calling a command, it's possible to pass command line options\nto modify what the command does. In this documentation, those are\ncalled \"switches\", in other situations they may be called \"flags\"\nor simply \"options\". A switch can be given a value, also called an\n\"argument\".\n\nThe main function in this module is `parse/2`, which parses a list\nof command line options and arguments into a keyword list:\n\n    iex> OptionParser.parse([\"--debug\"], strict: [debug: :boolean])\n    {[debug: true], [], []}\n\n`OptionParser` provides some conveniences out of the box,\nsuch as aliases and automatic handling of negation switches.\n\nThe `parse_head/2` function is an alternative to `parse/2`\nwhich stops parsing as soon as it finds a value that is not\na switch nor a value for a previous switch.\n\nThis module also provides low-level functions, such as `next/2`,\nfor parsing switches manually, as well as `split/1` and `to_argv/1`\nfor parsing from and converting switches to strings.","prompt":"Can you write a docstring for the following Elixir function? Elixir.OptionParser"}
{"completion":"Returns a map containing count values for the supervisor.\n\nThe map contains the following keys:\n\n  * `:specs` - the number of partitions (children processes)\n\n  * `:active` - the count of all actively running child processes managed by\n    this supervisor\n\n  * `:supervisors` - the count of all supervisors whether or not the child\n    process is still alive\n\n  * `:workers` - the count of all workers, whether or not the child process\n    is still alive","prompt":"Can you write a docstring for the following Elixir function? count_children(supervisor)"}
{"completion":"Returns the number of partitions for the partition supervisor.","prompt":"Can you write a docstring for the following Elixir function? partitions(name)"}
{"completion":"Starts a partition supervisor with the given options.\n\nThis function is typically not invoked directly, instead it is invoked\nwhen using a `PartitionSupervisor` as a child of another supervisor:\n\n    children = [\n      {PartitionSupervisor, child_spec: SomeChild, name: MyPartitionSupervisor}\n    ]\n\nIf the supervisor is successfully spawned, this function returns\n`{:ok, pid}`, where `pid` is the PID of the supervisor. If the given name\nfor the partition supervisor is already assigned to a process,\nthe function returns `{:error, {:already_started, pid}}`, where `pid`\nis the PID of that process.\n\nNote that a supervisor started with this function is linked to the parent\nprocess and exits not only on crashes but also if the parent process exits\nwith `:normal` reason.\n\n## Options\n\n  * `:name` - an atom or via tuple representing the name of the partition\n    supervisor (see `t:name/0`).\n\n  * `:partitions` - a positive integer with the number of partitions.\n    Defaults to `System.schedulers_online()` (typically the number of cores).\n\n  * `:strategy` - the restart strategy option, defaults to `:one_for_one`.\n    You can learn more about strategies in the `Supervisor` module docs.\n\n  * `:max_restarts` - the maximum number of restarts allowed in\n    a time frame. Defaults to `3`.\n\n  * `:max_seconds` - the time frame in which `:max_restarts` applies.\n    Defaults to `5`.\n\n  * `:with_arguments` - a two-argument anonymous function that allows\n    the partition to be given to the child starting function. See the\n    `:with_arguments` section below.\n\n## `:with_arguments`\n\nSometimes you want each partition to know their partition assigned number.\nThis can be done with the `:with_arguments` option. This function receives\nthe list of arguments of the child specification and the partition. It\nmust return a new list of arguments that will be passed to the child specification\nof children.\n\nFor example, most processes are started by calling `start_link(opts)`,\nwhere `opts` is a keyword list. You could inject the partition into the\noptions given to the child:\n\n    with_arguments: fn [opts], partition ->\n      [Keyword.put(opts, :partition, partition)]\n    end","prompt":"Can you write a docstring for the following Elixir function? start_link(opts)"}
{"completion":"Synchronously stops the given partition supervisor with the given `reason`.\n\nIt returns `:ok` if the supervisor terminates with the given\nreason. If it terminates with another reason, the call exits.\n\nThis function keeps OTP semantics regarding error reporting.\nIf the reason is any other than `:normal`, `:shutdown` or\n`{:shutdown, _}`, an error report is logged.","prompt":"Can you write a docstring for the following Elixir function? stop(supervisor, reason \\\\ :normal, timeout \\\\ :infinity)"}
{"completion":"Returns a list with information about all children.\n\nThis function returns a list of tuples containing:\n\n  * `id` - the partition number\n\n  * `child` - the PID of the corresponding child process or the\n    atom `:restarting` if the process is about to be restarted\n\n  * `type` - `:worker` or `:supervisor` as defined in the child\n    specification\n\n  * `modules` - as defined in the child specification","prompt":"Can you write a docstring for the following Elixir function? which_children(name)"}
{"completion":"A supervisor that starts multiple partitions of the same child.\n\nCertain processes may become bottlenecks in large systems.\nIf those processes can have their state trivially partitioned,\nin a way there is no dependency between them, then they can use\nthe `PartitionSupervisor` to create multiple isolated and\nindependent partitions.\n\nOnce the `PartitionSupervisor` starts, you can dispatch to its\nchildren using `{:via, PartitionSupervisor, {name, key}}`, where\n`name` is the name of the `PartitionSupervisor` and key is used\nfor routing.","prompt":"Can you write a docstring for the following Elixir function? Elixir.PartitionSupervisor"}
{"completion":"Example\n\nThe `DynamicSupervisor` is a single process responsible for starting\nother processes. In some applications, the `DynamicSupervisor` may\nbecome a bottleneck. To address this, you can start multiple instances\nof the `DynamicSupervisor` through a `PartitionSupervisor`, and then\npick a \"random\" instance to start the child on.\n\nInstead of starting a single `DynamicSupervisor`:\n\n    children = [\n      {DynamicSupervisor, name: MyApp.DynamicSupervisor}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nand starting children on that dynamic supervisor directly:\n\n    DynamicSupervisor.start_child(MyApp.DynamicSupervisor, {Agent, fn -> %{} end})\n\nYou can do start the dynamic supervisors under a `PartitionSupervisor`:\n\n    children = [\n      {PartitionSupervisor,\n       child_spec: DynamicSupervisor,\n       name: MyApp.DynamicSupervisors}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nand then:\n\n    DynamicSupervisor.start_child(\n      {:via, PartitionSupervisor, {MyApp.DynamicSupervisors, self()}},\n      {Agent, fn -> %{} end}\n    )\n\nIn the code above, we start a partition supervisor that will by default\nstart a dynamic supervisor for each core in your machine. Then, instead\nof calling the `DynamicSupervisor` by name, you call it through the\npartition supervisor using the `{:via, PartitionSupervisor, {name, key}}`\nformat. We picked `self()` as the routing key, which means each process\nwill be assigned one of the existing dynamic supervisors. See `start_link/1`\nto see all options supported by the `PartitionSupervisor`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.PartitionSupervisor"}
{"completion":"Implementation notes\n\nThe `PartitionSupervisor` uses either an ETS table or a `Registry` to\nmanage all of the partitions. Under the hood, the `PartitionSupervisor`\ngenerates a child spec for each partition and then acts as a regular\nsupervisor. The ID of each child spec is the partition number.\n\nFor routing, two strategies are used. If `key` is an integer, it is routed\nusing `rem(abs(key), partitions)` where `partitions` is the number of\npartitions. Otherwise it uses `:erlang.phash2(key, partitions)`.\nThe particular routing may change in the future, and therefore must not\nbe relied on. If you want to retrieve a particular PID for a certain key,\nyou can use `GenServer.whereis({:via, PartitionSupervisor, {name, key}})`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.PartitionSupervisor"}
{"completion":"Converts the given path to an absolute one.\n\nUnlike `expand/1`, no attempt is made to resolve `..`, `.`, or `~`.\n\n## Examples\n\n### Unix-like operating systems\n\n    Path.absname(\"foo\")\n    #=> \"/usr/local/foo\"\n\n    Path.absname(\"../x\")\n    #=> \"/usr/local/../x\"\n\n### Windows\n\n    Path.absname(\"foo\")\n    #=> \"D:/usr/local/foo\"\n\n    Path.absname(\"../x\")\n    #=> \"D:/usr/local/../x\"","prompt":"Can you write a docstring for the following Elixir function? absname(path)"}
{"completion":"Builds a path from `relative_to` to `path`.\n\nIf `path` is already an absolute path, `relative_to` is ignored. See also\n`relative_to/2`.\n\nUnlike `expand/2`, no attempt is made to\nresolve `..`, `.` or `~`.\n\n## Examples\n\n    iex> Path.absname(\"foo\", \"bar\")\n    \"bar/foo\"\n\n    iex> Path.absname(\"../x\", \"bar\")\n    \"bar/../x\"","prompt":"Can you write a docstring for the following Elixir function? absname(path, relative_to)"}
{"completion":"Returns the last component of the path or the path\nitself if it does not contain any directory separators.\n\n## Examples\n\n    iex> Path.basename(\"foo\")\n    \"foo\"\n\n    iex> Path.basename(\"foo/bar\")\n    \"bar\"\n\n    iex> Path.basename(\"lib/module/submodule.ex\")\n    \"submodule.ex\"\n\n    iex> Path.basename(\"/\")\n    \"\"","prompt":"Can you write a docstring for the following Elixir function? basename(path)"}
{"completion":"Returns the last component of `path` with the `extension`\nstripped.\n\nThis function should be used to remove a specific\nextension which may or may not be there.\n\n## Examples\n\n    iex> Path.basename(\"~/foo/bar.ex\", \".ex\")\n    \"bar\"\n\n    iex> Path.basename(\"~/foo/bar.exs\", \".ex\")\n    \"bar.exs\"\n\n    iex> Path.basename(\"~/foo/bar.old.ex\", \".ex\")\n    \"bar.old\"","prompt":"Can you write a docstring for the following Elixir function? basename(path, extension)"}
{"completion":"Returns the directory component of `path`.\n\n## Examples\n\n    iex> Path.dirname(\"/foo/bar.ex\")\n    \"/foo\"\n\n    iex> Path.dirname(\"/foo/bar/baz.ex\")\n    \"/foo/bar\"\n\n    iex> Path.dirname(\"/foo/bar/\")\n    \"/foo/bar\"\n\n    iex> Path.dirname(\"bar.ex\")\n    \".\"","prompt":"Can you write a docstring for the following Elixir function? dirname(path)"}
{"completion":"Converts the path to an absolute one, expanding\nany `.` and `..` components and a leading `~`.\n\n## Examples\n\n    Path.expand(\"/foo/bar/../baz\")\n    #=> \"/foo/baz\"","prompt":"Can you write a docstring for the following Elixir function? expand(path)"}
{"completion":"Expands the path relative to the path given as the second argument\nexpanding any `.` and `..` characters.\n\nIf the path is already an absolute path, `relative_to` is ignored.\n\nNote that this function treats a `path` with a leading `~` as\nan absolute one.\n\nThe second argument is first expanded to an absolute path.\n\n## Examples\n\n    # Assuming that the absolute path to baz is /quux/baz\n    Path.expand(\"foo/bar/../bar\", \"baz\")\n    #=> \"/quux/baz/foo/bar\"\n\n    Path.expand(\"foo/bar/../bar\", \"/baz\")\n    #=> \"/baz/foo/bar\"\n\n    Path.expand(\"/foo/bar/../bar\", \"/baz\")\n    #=> \"/foo/bar\"","prompt":"Can you write a docstring for the following Elixir function? expand(path, relative_to)"}
{"completion":"Returns the extension of the last component of `path`.\n\nThe behaviour of this function changed in Erlang/OTP 24 for filenames\nstarting with a dot and without an extension. For example, for a file\nnamed `.gitignore`, `extname/1` now returns an empty string, while it\nwould return `\".gitignore\"` in previous Erlang/OTP versions. This was\ndone to match the behaviour of `rootname/1`, which would return\n`\".gitignore\"` as its name (and therefore it cannot also be an extension).\n\nSee `basename/1` and `rootname/1` for related functions to extract\ninformation from paths.\n\n## Examples\n\n    iex> Path.extname(\"foo.erl\")\n    \".erl\"\n\n    iex> Path.extname(\"~/foo/bar\")\n    \"\"","prompt":"Can you write a docstring for the following Elixir function? extname(path)"}
{"completion":"Joins a list of paths.\n\nThis function should be used to convert a list of paths to a path.\nNote that any trailing slash is removed when joining.\n\nRaises an error if the given list of paths is empty.\n\n## Examples\n\n    iex> Path.join([\"~\", \"foo\"])\n    \"~/foo\"\n\n    iex> Path.join([\"foo\"])\n    \"foo\"\n\n    iex> Path.join([\"/\", \"foo\", \"bar/\"])\n    \"/foo/bar\"","prompt":"Can you write a docstring for the following Elixir function? join(list)"}
{"completion":"Joins two paths.\n\nThe right path will always be expanded to its relative format\nand any trailing slash will be removed when joining.\n\n## Examples\n\n    iex> Path.join(\"foo\", \"bar\")\n    \"foo/bar\"\n\n    iex> Path.join(\"/foo\", \"/bar/\")\n    \"/foo/bar\"\n\nThe functions in this module support chardata, so giving a list will\ntreat it as a single entity:\n\n    iex> Path.join(\"foo\", [\"bar\", \"fiz\"])\n    \"foo/barfiz\"\n\n    iex> Path.join([\"foo\", \"bar\"], \"fiz\")\n    \"foobar/fiz\"\n\nUse `join/1` if you need to join a list of paths instead.","prompt":"Can you write a docstring for the following Elixir function? join(left, right)"}
{"completion":"Forces the path to be a relative path.\n\n## Examples\n\n### Unix-like operating systems\n\n    Path.relative(\"/usr/local/bin\")   #=> \"usr/local/bin\"\n    Path.relative(\"usr/local/bin\")    #=> \"usr/local/bin\"\n    Path.relative(\"../usr/local/bin\") #=> \"../usr/local/bin\"\n\n### Windows\n\n    Path.relative(\"D:/usr/local/bin\") #=> \"usr/local/bin\"\n    Path.relative(\"usr/local/bin\")    #=> \"usr/local/bin\"\n    Path.relative(\"D:bar.ex\")         #=> \"bar.ex\"\n    Path.relative(\"/bar/foo.ex\")      #=> \"bar/foo.ex\"","prompt":"Can you write a docstring for the following Elixir function? relative(name)"}
{"completion":"Returns the given `path` relative to the given `from` path.\n\nIn other words, this function tries to strip the `from` prefix from `path`.\n\nThis function does not query the file system, so it assumes\nno symlinks between the paths.\n\nIn case a direct relative path cannot be found, it returns\nthe original path.\n\n## Examples\n\n    iex> Path.relative_to(\"/usr/local/foo\", \"/usr/local\")\n    \"foo\"\n\n    iex> Path.relative_to(\"/usr/local/foo\", \"/\")\n    \"usr/local/foo\"\n\n    iex> Path.relative_to(\"/usr/local/foo\", \"/etc\")\n    \"/usr/local/foo\"\n\n    iex> Path.relative_to(\"/usr/local/foo\", \"/usr/local/foo\")\n    \".\"","prompt":"Can you write a docstring for the following Elixir function? relative_to(path, from)"}
{"completion":"Convenience to get the path relative to the current working\ndirectory.\n\nIf, for some reason, the current working directory\ncannot be retrieved, this function returns the given `path`.","prompt":"Can you write a docstring for the following Elixir function? relative_to_cwd(path)"}
{"completion":"Returns the `path` with the `extension` stripped.\n\n## Examples\n\n    iex> Path.rootname(\"/foo/bar\")\n    \"/foo/bar\"\n\n    iex> Path.rootname(\"/foo/bar.ex\")\n    \"/foo/bar\"","prompt":"Can you write a docstring for the following Elixir function? rootname(path)"}
{"completion":"Returns the `path` with the `extension` stripped.\n\nThis function should be used to remove a specific extension which may\nor may not be there.\n\n## Examples\n\n    iex> Path.rootname(\"/foo/bar.erl\", \".erl\")\n    \"/foo/bar\"\n\n    iex> Path.rootname(\"/foo/bar.erl\", \".ex\")\n    \"/foo/bar.erl\"","prompt":"Can you write a docstring for the following Elixir function? rootname(path, extension)"}
{"completion":"Returns a path relative to the current working directory that is\nprotected from directory-traversal attacks.\n\nSame as `safe_relative_to/2` with the current working directory as\nthe second argument. If there is an issue retrieving the current working\ndirectory, this function raises an error.\n\n## Examples\n\n    iex> Path.safe_relative(\"foo\")\n    {:ok, \"foo\"}\n\n    iex> Path.safe_relative(\"foo/../bar\")\n    {:ok, \"bar\"}\n\n    iex> Path.safe_relative(\"foo/../..\")\n    :error\n\n    iex> Path.safe_relative(\"/usr/local\")\n    :error","prompt":"Can you write a docstring for the following Elixir function? safe_relative(path)"}
{"completion":"Returns a relative path that is protected from directory-traversal attacks.\n\nThe given relative path is sanitized by eliminating `..` and `.` components.\n\nThis function checks that, after expanding those components, the path is still \"safe\".\nPaths are considered unsafe if either of these is true:\n\n  * The path is not relative, such as `\"/foo/bar\"`.\n\n  * A `..` component would make it so that the path would travers up above\n    the root of `relative_to`.\n\n  * A symbolic link in the path points to something above the root of `relative_to`.\n\n## Examples\n\n    iex> Path.safe_relative_to(\"deps/my_dep/app.beam\", \"deps\")\n    {:ok, \"deps/my_dep/app.beam\"}\n\n    iex> Path.safe_relative_to(\"deps/my_dep/./build/../app.beam\", \"deps\")\n    {:ok, \"deps/my_dep/app.beam\"}\n\n    iex> Path.safe_relative_to(\"my_dep/../..\", \"deps\")\n    :error\n\n    iex> Path.safe_relative_to(\"/usr/local\", \".\")\n    :error","prompt":"Can you write a docstring for the following Elixir function? safe_relative_to(path, relative_to)"}
{"completion":"Splits the path into a list at the path separator.\n\nIf an empty string is given, returns an empty list.\n\nOn Windows, path is split on both `\"\\\"` and `\"/\"` separators\nand the driver letter, if there is one, is always returned\nin lowercase.\n\n## Examples\n\n    iex> Path.split(\"\")\n    []\n\n    iex> Path.split(\"foo\")\n    [\"foo\"]\n\n    iex> Path.split(\"/foo/bar\")\n    [\"/\", \"foo\", \"bar\"]","prompt":"Can you write a docstring for the following Elixir function? split(path)"}
{"completion":"Returns the path type.\n\n## Examples\n\n### Unix-like operating systems\n\n    Path.type(\"/\")                #=> :absolute\n    Path.type(\"/usr/local/bin\")   #=> :absolute\n    Path.type(\"usr/local/bin\")    #=> :relative\n    Path.type(\"../usr/local/bin\") #=> :relative\n    Path.type(\"~/file\")           #=> :relative\n\n### Windows\n\n    Path.type(\"D:/usr/local/bin\") #=> :absolute\n    Path.type(\"usr/local/bin\")    #=> :relative\n    Path.type(\"D:bar.ex\")         #=> :volumerelative\n    Path.type(\"/bar/foo.ex\")      #=> :volumerelative","prompt":"Can you write a docstring for the following Elixir function? type(name)"}
{"completion":"Traverses paths according to the given `glob` expression and returns a\nlist of matches.\n\nThe wildcard looks like an ordinary path, except that the following\n\"wildcard characters\" are interpreted in a special way:\n\n  * `?` - matches one character.\n\n  * `*` - matches any number of characters up to the end of the filename, the\n    next dot, or the next slash.\n\n  * `**` - two adjacent `*`'s used as a single pattern will match all\n    files and zero or more directories and subdirectories.\n\n  * `[char1,char2,...]` - matches any of the characters listed; two\n    characters separated by a hyphen will match a range of characters.\n    Do not add spaces before and after the comma as it would then match\n    paths containing the space character itself.\n\n  * `{item1,item2,...}` - matches one of the alternatives.\n    Do not add spaces before and after the comma as it would then match\n    paths containing the space character itself.\n\nOther characters represent themselves. Only paths that have\nexactly the same character in the same position will match. Note\nthat matching is case-sensitive: `\"a\"` will not match `\"A\"`.\n\nDirectory separators must always be written as `/`, even on Windows.\nYou may call `Path.expand/1` to normalize the path before invoking\nthis function.\n\nBy default, the patterns `*` and `?` do not match files starting\nwith a dot `.`. See the `:match_dot` option in the \"Options\" section\nbelow.\n\n## Options\n\n  * `:match_dot` - (boolean) if `false`, the special wildcard characters `*` and `?`\n    will not match files starting with a dot (`.`). If `true`, files starting with\n    a `.` will not be treated specially. Defaults to `false`.\n\n## Examples\n\nImagine you have a directory called `projects` with three Elixir projects\ninside of it: `elixir`, `ex_doc`, and `plug`. You can find all `.beam` files\ninside the `ebin` directory of each project as follows:\n\n    Path.wildcard(\"projects/*/ebin/**/*.beam\")\n\nIf you want to search for both `.beam` and `.app` files, you could do:\n\n    Path.wildcard(\"projects/*/ebin/**/*.{beam,app}\")","prompt":"Can you write a docstring for the following Elixir function? wildcard(glob, opts \\\\ [])"}
{"completion":"This module provides conveniences for manipulating or\nretrieving file system paths.\n\nThe functions in this module may receive chardata as\narguments and will always return a string encoded in UTF-8. Chardata\nis a string or a list of characters and strings, see `t:IO.chardata/0`.\nIf a binary is given, in whatever encoding, its encoding will be kept.\n\nThe majority of the functions in this module do not\ninteract with the file system, except for a few functions\nthat require it (like `wildcard/2` and `expand/1`).","prompt":"Can you write a docstring for the following Elixir function? Elixir.Path"}
{"completion":"Closes the `port`.\n\nFor more information, see `:erlang.port_close/1`.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? close(port)"}
{"completion":"Sends `data` to the port driver `port`.\n\nFor more information, see `:erlang.port_command/3`.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? command(port, data, options \\\\ [])"}
{"completion":"Associates the `port` identifier with a `pid`.\n\nFor more information, see `:erlang.port_connect/2`.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? connect(port, pid)"}
{"completion":"Demonitors the monitor identified by the given `reference`.\n\nIf `monitor_ref` is a reference which the calling process\nobtained by calling `monitor/1`, that monitoring is turned off.\nIf the monitoring is already turned off, nothing happens.\n\nSee `:erlang.demonitor/2` for more information.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? demonitor(monitor_ref, options \\\\ [])"}
{"completion":"Returns information about the `port` or `nil` if the port is closed.\n\nFor more information, see `:erlang.port_info/1`.","prompt":"Can you write a docstring for the following Elixir function? info(port)"}
{"completion":"Returns information about the `port` or `nil` if the port is closed.\n\nFor more information, see `:erlang.port_info/2`.","prompt":"Can you write a docstring for the following Elixir function? info(port, spec)"}
{"completion":"Returns a list of all ports in the current node.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? list()"}
{"completion":"Starts monitoring the given `port` from the calling process.\n\nOnce the monitored port process dies, a message is delivered to the\nmonitoring process in the shape of:\n\n    {:DOWN, ref, :port, object, reason}\n\nwhere:\n\n  * `ref` is a monitor reference returned by this function;\n  * `object` is either the `port` being monitored (when monitoring by port ID)\n  or `{name, node}` (when monitoring by a port name);\n  * `reason` is the exit reason.\n\nSee `:erlang.monitor/2` for more information.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? monitor(port)"}
{"completion":"Opens a port given a tuple `name` and a list of `options`.\n\nThe module documentation above contains documentation and examples\nfor the supported `name` values, summarized below:\n\n  * `{:spawn, command}` - runs an external program. `command` must contain\n    the program name and optionally a list of arguments separated by space.\n    If passing programs or arguments with space in their name, use the next option.\n  * `{:spawn_executable, filename}` - runs the executable given by the absolute\n    file name `filename`. Arguments can be passed via the `:args` option.\n  * `{:spawn_driver, command}` - spawns so-called port drivers.\n  * `{:fd, fd_in, fd_out}` - accesses file descriptors, `fd_in` and `fd_out`\n    opened by the VM.\n\nFor more information and the list of options, see `:erlang.open_port/2`.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? open(name, options)"}
{"completion":"Functions for interacting with the external world through ports.\n\nPorts provide a mechanism to start operating system processes external\nto the Erlang VM and communicate with them via message passing.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Port"}
{"completion":"Example\n\n    iex> port = Port.open({:spawn, \"cat\"}, [:binary])\n    iex> send(port, {self(), {:command, \"hello\"}})\n    iex> send(port, {self(), {:command, \"world\"}})\n    iex> flush()\n    {#Port<0.1444>, {:data, \"hello\"}}\n    {#Port<0.1444>, {:data, \"world\"}}\n    iex> send(port, {self(), :close})\n    :ok\n    iex> flush()\n    {#Port<0.1464>, :closed}\n    :ok\n\nIn the example above, we have created a new port that executes the\nprogram `cat`. `cat` is a program available on Unix-like operating systems that\nreceives data from multiple inputs and concatenates them in the output.\n\nAfter the port was created, we sent it two commands in the form of\nmessages using `send/2`. The first command has the binary payload\nof \"hello\" and the second has \"world\".\n\nAfter sending those two messages, we invoked the IEx helper `flush()`,\nwhich printed all messages received from the port, in this case we got\n\"hello\" and \"world\" back. Note that the messages are in binary because we\npassed the `:binary` option when opening the port in `Port.open/2`. Without\nsuch option, it would have yielded a list of bytes.\n\nOnce everything was done, we closed the port.\n\nElixir provides many conveniences for working with ports and some drawbacks.\nWe will explore those below.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Port"}
{"completion":"Message and function APIs\n\nThere are two APIs for working with ports. It can be either asynchronous via\nmessage passing, as in the example above, or by calling the functions on this\nmodule.\n\nThe messages supported by ports and their counterpart function APIs are\nlisted below:\n\n  * `{pid, {:command, binary}}` - sends the given data to the port.\n    See `command/3`.\n\n  * `{pid, :close}` - closes the port. Unless the port is already closed,\n    the port will reply with `{port, :closed}` message once it has flushed\n    its buffers and effectively closed. See `close/1`.\n\n  * `{pid, {:connect, new_pid}}` - sets the `new_pid` as the new owner of\n    the port. Once a port is opened, the port is linked and connected to the\n    caller process and communication to the port only happens through the\n    connected process. This message makes `new_pid` the new connected processes.\n    Unless the port is dead, the port will reply to the old owner with\n    `{port, :connected}`. See `connect/2`.\n\nOn its turn, the port will send the connected process the following messages:\n\n  * `{port, {:data, data}}` - data sent by the port\n  * `{port, :closed}` - reply to the `{pid, :close}` message\n  * `{port, :connected}` - reply to the `{pid, {:connect, new_pid}}` message\n  * `{:EXIT, port, reason}` - exit signals in case the port crashes. If reason\n    is not `:normal`, this message will only be received if the owner process\n    is trapping exits","prompt":"Can you write a docstring for the following Elixir function? Elixir.Port"}
{"completion":"Open mechanisms\n\nThe port can be opened through four main mechanisms.\n\nAs a short summary, prefer to using the `:spawn` and `:spawn_executable`\noptions mentioned below. The other two options, `:spawn_driver` and `:fd`\nare for advanced usage within the VM. Also consider using `System.cmd/3`\nif all you want is to execute a program and retrieve its return value.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Port"}
{"completion":"# spawn\n\nThe `:spawn` tuple receives a binary that is going to be executed as a\nfull invocation. For example, we can use it to invoke \"echo hello\" directly:\n\n    iex> port = Port.open({:spawn, \"echo hello\"}, [:binary])\n    iex> flush()\n    {#Port<0.1444>, {:data, \"hello\\n\"}}\n\n`:spawn` will retrieve the program name from the argument and traverse your\noperating system `$PATH` environment variable looking for a matching program.\n\nAlthough the above is handy, it means it is impossible to invoke an executable\nthat has whitespaces on its name or in any of its arguments. For those reasons,\nmost times it is preferable to execute `:spawn_executable`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Port"}
{"completion":"# spawn_executable\n\nSpawn executable is a more restricted and explicit version of spawn. It expects\nfull file paths to the executable you want to execute. If they are in your `$PATH`,\nthey can be retrieved by calling `System.find_executable/1`:\n\n    iex> path = System.find_executable(\"echo\")\n    iex> port = Port.open({:spawn_executable, path}, [:binary, args: [\"hello world\"]])\n    iex> flush()\n    {#Port<0.1380>, {:data, \"hello world\\n\"}}\n\nWhen using `:spawn_executable`, the list of arguments can be passed via\nthe `:args` option as done above. For the full list of options, see the\ndocumentation for the Erlang function `:erlang.open_port/2`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Port"}
{"completion":"# fd\n\nThe `:fd` name option allows developers to access `in` and `out` file\ndescriptors used by the Erlang VM. You would use those only if you are\nreimplementing core part of the Runtime System, such as the `:user` and\n`:shell` processes.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Port"}
{"completion":"Zombie operating system processes\n\nA port can be closed via the `close/1` function or by sending a `{pid, :close}`\nmessage. However, if the VM crashes, a long-running program started by the port\nwill have its stdin and stdout channels closed but **it won't be automatically\nterminated**.\n\nWhile most Unix command line tools will exit once its communication channels\nare closed, not all command line applications will do so. You can easily check\nthis by starting the port and then shutting down the VM and inspecting your\noperating system to see if the port process is still running.\n\nWhile we encourage graceful termination by detecting if stdin/stdout has been\nclosed, we do not always have control over how third-party software terminates.\nIn those cases, you can wrap the application in a script that checks for stdin.\nHere is such script that has been verified to work on bash shells:\n\n    #!/usr/bin/env bash\n\n    # Start the program in the background\n    exec \"$@\" &\n    pid1=$!\n\n    # Silence warnings from here on\n    exec >/dev/null 2>&1\n\n    # Read from stdin in the background and\n    # kill running program when stdin closes\n    exec 0<&0 $(\n      while read; do :; done\n      kill -KILL $pid1\n    ) &\n    pid2=$!\n\n    # Clean up\n    wait $pid1\n    ret=$?\n    kill -KILL $pid2\n    exit $ret\n\nNote the program above hijacks stdin, so you won't be able to communicate\nwith the underlying software via stdin (on the positive side, software that\nreads from stdin typically terminates when stdin closes).\n\nNow instead of:\n\n    Port.open(\n      {:spawn_executable, \"/path/to/program\"},\n      args: [\"a\", \"b\", \"c\"]\n    )\n\nYou may invoke:\n\n    Port.open(\n      {:spawn_executable, \"/path/to/wrapper\"},\n      args: [\"/path/to/program\", \"a\", \"b\", \"c\"]\n    )","prompt":"Can you write a docstring for the following Elixir function? Elixir.Port"}
{"completion":"Tells whether the given process is alive on the local node.\n\nIf the process identified by `pid` is alive (that is, it's not exiting and has\nnot exited yet) than this function returns `true`. Otherwise, it returns\n`false`.\n\n`pid` must refer to a process running on the local node or `ArgumentError` is raised.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? alive?(pid)"}
{"completion":"Cancels a timer returned by `send_after/3`.\n\nWhen the result is an integer, it represents the time in milliseconds\nleft until the timer would have expired.\n\nWhen the result is `false`, a timer corresponding to `timer_ref` could not be\nfound. This can happen either because the timer expired, because it has\nalready been canceled, or because `timer_ref` never corresponded to a timer.\n\nEven if the timer had expired and the message was sent, this function does not\ntell you if the timeout message has arrived at its destination yet.\n\nInlined by the compiler.\n\n## Options\n\n  * `:async` - (boolean) when `false`, the request for cancellation is\n    synchronous. When `true`, the request for cancellation is asynchronous,\n    meaning that the request to cancel the timer is issued and `:ok` is\n    returned right away. Defaults to `false`.\n\n  * `:info` - (boolean) whether to return information about the timer being\n    cancelled. When the `:async` option is `false` and `:info` is `true`, then\n    either an integer or `false` (like described above) is returned. If\n    `:async` is `false` and `:info` is `false`, `:ok` is returned. If `:async`\n    is `true` and `:info` is `true`, a message in the form `{:cancel_timer,\n    timer_ref, result}` (where `result` is an integer or `false` like\n    described above) is sent to the caller of this function when the\n    cancellation has been performed. If `:async` is `true` and `:info` is\n    `false`, no message is sent. Defaults to `true`.","prompt":"Can you write a docstring for the following Elixir function? cancel_timer(timer_ref, options \\\\ [])"}
{"completion":"Deletes the given `key` from the process dictionary.\n\nReturns the value that was under `key` in the process dictionary,\nor `nil` if `key` was not stored in the process dictionary.\n\n## Examples\n\n    iex> Process.put(:comments, [\"comment\", \"other comment\"])\n    iex> Process.delete(:comments)\n    [\"comment\", \"other comment\"]\n    iex> Process.delete(:comments)\n    nil","prompt":"Can you write a docstring for the following Elixir function? delete(key)"}
{"completion":"Demonitors the monitor identified by the given `reference`.\n\nIf `monitor_ref` is a reference which the calling process\nobtained by calling `monitor/1`, that monitoring is turned off.\nIf the monitoring is already turned off, nothing happens.\n\nSee `:erlang.demonitor/2` for more information.\n\nInlined by the compiler.\n\n## Examples\n\n    pid = spawn(fn -> 1 + 2 end)\n    ref = Process.monitor(pid)\n    Process.demonitor(ref)\n    #=> true","prompt":"Can you write a docstring for the following Elixir function? demonitor(monitor_ref, options \\\\ [])"}
{"completion":"Sends an exit signal with the given `reason` to `pid`.\n\nThe following behaviour applies if `reason` is any term except `:normal`\nor `:kill`:\n\n  1. If `pid` is not trapping exits, `pid` will exit with the given\n     `reason`.\n\n  2. If `pid` is trapping exits, the exit signal is transformed into a\n     message `{:EXIT, from, reason}` and delivered to the message queue\n     of `pid`.\n\nIf `reason` is the atom `:normal`, `pid` will not exit (unless `pid` is\nthe calling process, in which case it will exit with the reason `:normal`).\nIf it is trapping exits, the exit signal is transformed into a message\n`{:EXIT, from, :normal}` and delivered to its message queue.\n\nIf `reason` is the atom `:kill`, that is if `Process.exit(pid, :kill)` is called,\nan untrappable exit signal is sent to `pid` which will unconditionally exit\nwith reason `:killed`.\n\nInlined by the compiler.\n\n## Examples\n\n    Process.exit(pid, :kill)\n    #=> true","prompt":"Can you write a docstring for the following Elixir function? exit(pid, reason)"}
{"completion":"Sets the given `flag` to `value` for the calling process.\n\nReturns the old value of `flag`.\n\nSee `:erlang.process_flag/2` for more information.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? flag(flag, value)"}
{"completion":"Sets the given `flag` to `value` for the given process `pid`.\n\nReturns the old value of `flag`.\n\nIt raises `ArgumentError` if `pid` is not a local process.\n\nThe allowed values for `flag` are only a subset of those allowed in `flag/2`,\nnamely `:save_calls`.\n\nSee `:erlang.process_flag/3` for more information.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? flag(pid, flag, value)"}
{"completion":"Returns all key-value pairs in the process dictionary.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? get()"}
{"completion":"Returns the value for the given `key` in the process dictionary,\nor `default` if `key` is not set.\n\n## Examples\n\n    # Assuming :locale was not set\n    iex> Process.get(:locale, \"pt\")\n    \"pt\"\n    iex> Process.put(:locale, \"fr\")\n    nil\n    iex> Process.get(:locale, \"pt\")\n    \"fr\"","prompt":"Can you write a docstring for the following Elixir function? get(key, default \\\\ nil)"}
{"completion":"Returns all keys in the process dictionary.\n\nInlined by the compiler.\n\n## Examples\n\n    # Assuming :locale was not set\n    iex> :locale in Process.get_keys()\n    false\n    iex> Process.put(:locale, \"pt\")\n    nil\n    iex> :locale in Process.get_keys()\n    true","prompt":"Can you write a docstring for the following Elixir function? get_keys()"}
{"completion":"Returns all keys in the process dictionary that have the given `value`.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? get_keys(value)"}
{"completion":"Returns the PID of the group leader for the calling process.\n\nInlined by the compiler.\n\n## Examples\n\n    Process.group_leader()\n    #=> #PID<0.53.0>","prompt":"Can you write a docstring for the following Elixir function? group_leader()"}
{"completion":"Sets the group leader of the given `pid` to `leader`.\n\nTypically, this is used when a process started from a certain shell should\nhave a group leader other than `:init`.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? group_leader(pid, leader)"}
{"completion":"Puts the calling process into a \"hibernation\" state.\n\nThe calling process is put into a waiting state\nwhere its memory allocation has been reduced as much as possible,\nwhich is useful if the process does not expect to receive any messages\nin the near future.\n\nSee `:erlang.hibernate/3` for more information.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? hibernate(mod, fun_name, args)"}
{"completion":"Returns information about the process identified by `pid`, or returns `nil` if the process\nis not alive.\n\nUse this only for debugging information.\n\nSee `:erlang.process_info/1` for more information.","prompt":"Can you write a docstring for the following Elixir function? info(pid)"}
{"completion":"Returns information about the process identified by `pid`,\nor returns `nil` if the process is not alive.\n\nSee `:erlang.process_info/2` for more information.","prompt":"Can you write a docstring for the following Elixir function? info(pid, spec)"}
{"completion":"Creates a link between the calling process and the given item (process or\nport).\n\nLinks are bidirectional. Linked processes can be unlinked by using `unlink/1`.\n\nIf such a link exists already, this function does nothing since there can only\nbe one link between two given processes. If a process tries to create a link\nto itself, nothing will happen.\n\nWhen two processes are linked, each one receives exit signals from the other\n(see also `exit/2`). Let's assume `pid1` and `pid2` are linked. If `pid2`\nexits with a reason other than `:normal` (which is also the exit reason used\nwhen a process finishes its job) and `pid1` is not trapping exits (see\n`flag/2`), then `pid1` will exit with the same reason as `pid2` and in turn\nemit an exit signal to all its other linked processes. The behaviour when\n`pid1` is trapping exits is described in `exit/2`.\n\nSee `:erlang.link/1` for more information.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? link(pid_or_port)"}
{"completion":"Returns a list of PIDs corresponding to all the\nprocesses currently existing on the local node.\n\nNote that if a process is exiting, it is considered to exist but not be\nalive. This means that for such process, `alive?/1` will return `false` but\nits PID will be part of the list of PIDs returned by this function.\n\nSee `:erlang.processes/0` for more information.\n\nInlined by the compiler.\n\n## Examples\n\n    Process.list()\n    #=> [#PID<0.0.0>, #PID<0.1.0>, #PID<0.2.0>, #PID<0.3.0>, ...]","prompt":"Can you write a docstring for the following Elixir function? list()"}
{"completion":"Starts monitoring the given `item` from the calling process.\n\nOnce the monitored process dies, a message is delivered to the\nmonitoring process in the shape of:\n\n    {:DOWN, ref, :process, object, reason}\n\nwhere:\n\n  * `ref` is a monitor reference returned by this function;\n  * `object` is either a `pid` of the monitored process (if monitoring\n    a PID) or `{name, node}` (if monitoring a remote or local name);\n  * `reason` is the exit reason.\n\nIf the process is already dead when calling `Process.monitor/1`, a\n`:DOWN` message is delivered immediately.\n\nSee [\"The need for monitoring\"](https://elixir-lang.org/getting-started/mix-otp/genserver.html#the-need-for-monitoring)\nfor an example. See `:erlang.monitor/2` for more information.\n\nInlined by the compiler.\n\n## Examples\n\n    pid = spawn(fn -> 1 + 2 end)\n    #=> #PID<0.118.0>\n    Process.monitor(pid)\n    #=> #Reference<0.906660723.3006791681.40191>\n    Process.exit(pid, :kill)\n    #=> true\n    receive do\n      msg -> msg\n    end\n    #=> {:DOWN, #Reference<0.906660723.3006791681.40191>, :process, #PID<0.118.0>, :noproc}","prompt":"Can you write a docstring for the following Elixir function? monitor(item)"}
{"completion":"Stores the given `key`-`value` pair in the process dictionary.\n\nThe return value of this function is the value that was previously stored\nunder `key`, or `nil` in case no value was stored under it.\n\n## Examples\n\n    # Assuming :locale was not set\n    iex> Process.put(:locale, \"en\")\n    nil\n    iex> Process.put(:locale, \"fr\")\n    \"en\"","prompt":"Can you write a docstring for the following Elixir function? put(key, value)"}
{"completion":"Reads a timer created by `send_after/3`.\n\nWhen the result is an integer, it represents the time in milliseconds\nleft until the timer will expire.\n\nWhen the result is `false`, a timer corresponding to `timer_ref` could not be\nfound. This can be either because the timer expired, because it has already\nbeen canceled, or because `timer_ref` never corresponded to a timer.\n\nEven if the timer had expired and the message was sent, this function does not\ntell you if the timeout message has arrived at its destination yet.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? read_timer(timer_ref)"}
{"completion":"Registers the given `pid_or_port` under the given `name`.\n\n`name` must be an atom and can then be used instead of the\nPID/port identifier when sending messages with `Kernel.send/2`.\n\n`register/2` will fail with `ArgumentError` in any of the following cases:\n\n  * the PID/Port is not existing locally and alive\n  * the name is already registered\n  * the `pid_or_port` is already registered under a different `name`\n\nThe following names are reserved and cannot be assigned to\nprocesses nor ports:\n\n  * `nil`\n  * `false`\n  * `true`\n  * `:undefined`\n\n## Examples\n\n    Process.register(self(), :test)\n    #=> true\n    send(:test, :hello)\n    #=> :hello\n    send(:wrong_name, :hello)\n    ** (ArgumentError) argument error","prompt":"Can you write a docstring for the following Elixir function? register(pid_or_port, name)"}
{"completion":"Returns a list of names which have been registered using `register/2`.\n\nInlined by the compiler.\n\n## Examples\n\n    Process.register(self(), :test)\n    Process.registered()\n    #=> [:test, :elixir_config, :inet_db, ...]","prompt":"Can you write a docstring for the following Elixir function? registered()"}
{"completion":"Sends a message to the given `dest`.\n\n`dest` may be a remote or local PID, a local port, a locally\nregistered name, or a tuple in the form of `{registered_name, node}` for a\nregistered name at another node.\n\nInlined by the compiler.\n\n## Options\n\n  * `:noconnect` - when used, if sending the message would require an\n    auto-connection to another node the message is not sent and `:noconnect` is\n    returned.\n\n  * `:nosuspend` - when used, if sending the message would cause the sender to\n    be suspended the message is not sent and `:nosuspend` is returned.\n\nOtherwise the message is sent and `:ok` is returned.\n\n## Examples\n\n    iex> Process.send({:name, :node_that_does_not_exist}, :hi, [:noconnect])\n    :noconnect","prompt":"Can you write a docstring for the following Elixir function? send(dest, msg, options)"}
{"completion":"Sends `msg` to `dest` after `time` milliseconds.\n\nIf `dest` is a PID, it must be the PID of a local process, dead or alive.\nIf `dest` is an atom, it must be the name of a registered process\nwhich is looked up at the time of delivery. No error is produced if the name does\nnot refer to a process.\n\nThe message is not sent immediately. Therefore, `dest` can receive other messages\nin-between even when `time` is `0`.\n\nThis function returns a timer reference, which can be read with `read_timer/1`\nor canceled with `cancel_timer/1`.\n\nThe timer will be automatically canceled if the given `dest` is a PID\nwhich is not alive or when the given PID exits. Note that timers will not be\nautomatically canceled when `dest` is an atom (as the atom resolution is done\non delivery).\n\nInlined by the compiler.\n\n## Options\n\n  * `:abs` - (boolean) when `false`, `time` is treated as relative to the\n  current monotonic time. When `true`, `time` is the absolute value of the\n  Erlang monotonic time at which `msg` should be delivered to `dest`.\n  To read more about Erlang monotonic time and other time-related concepts,\n  look at the documentation for the `System` module. Defaults to `false`.\n\n## Examples\n\n    timer_ref = Process.send_after(pid, :hi, 1000)","prompt":"Can you write a docstring for the following Elixir function? send_after(dest, msg, time, opts \\\\ [])"}
{"completion":"Sleeps the current process for the given `timeout`.\n\n`timeout` is either the number of milliseconds to sleep as an\ninteger or the atom `:infinity`. When `:infinity` is given,\nthe current process will sleep forever, and not\nconsume or reply to messages.\n\n**Use this function with extreme care**. For almost all situations\nwhere you would use `sleep/1` in Elixir, there is likely a\nmore correct, faster and precise way of achieving the same with\nmessage passing.\n\nFor example, if you are waiting for a process to perform some\naction, it is better to communicate the progress of such action\nwith messages.\n\nIn other words, **do not**:\n\n    Task.start_link(fn ->\n      do_something()\n      ...\n    end)\n\n    # Wait until work is done\n    Process.sleep(2000)\n\nBut **do**:\n\n    parent = self()\n\n    Task.start_link(fn ->\n      do_something()\n      send(parent, :work_is_done)\n      ...\n    end)\n\n    receive do\n      :work_is_done -> :ok\n    after\n      # Optional timeout\n      30_000 -> :timeout\n    end\n\nFor cases like the one above, `Task.async/1` and `Task.await/2` are\npreferred.\n\nSimilarly, if you are waiting for a process to terminate,\nmonitor that process instead of sleeping. **Do not**:\n\n    Task.start_link(fn ->\n      ...\n    end)\n\n    # Wait until task terminates\n    Process.sleep(2000)\n\nInstead **do**:\n\n    {:ok, pid} =\n      Task.start_link(fn ->\n        ...\n      end)\n\n    ref = Process.monitor(pid)\n\n    receive do\n      {:DOWN, ^ref, _, _, _} -> :task_is_down\n    after\n      # Optional timeout\n      30_000 -> :timeout\n    end","prompt":"Can you write a docstring for the following Elixir function? sleep(timeout)"}
{"completion":"Spawns the given function according to the given options.\n\nThe result depends on the given options. In particular,\nif `:monitor` is given as an option, it will return a tuple\ncontaining the PID and the monitoring reference, otherwise\njust the spawned process PID.\n\nMore options are available; for the comprehensive list of available options\ncheck `:erlang.spawn_opt/4`.\n\nInlined by the compiler.\n\n## Examples\n\n    Process.spawn(fn -> 1 + 2 end, [:monitor])\n    #=> {#PID<0.93.0>, #Reference<0.18808174.1939079169.202418>}\n    Process.spawn(fn -> 1 + 2 end, [:link])\n    #=> #PID<0.95.0>","prompt":"Can you write a docstring for the following Elixir function? spawn(fun, opts)"}
{"completion":"Spawns the given function `fun` from module `mod`, passing the given `args`\naccording to the given options.\n\nThe result depends on the given options. In particular,\nif `:monitor` is given as an option, it will return a tuple\ncontaining the PID and the monitoring reference, otherwise\njust the spawned process PID.\n\nIt also accepts extra options, for the list of available options\ncheck `:erlang.spawn_opt/4`.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? spawn(mod, fun, args, opts)"}
{"completion":"Removes the link between the calling process and the given item (process or\nport).\n\nIf there is no such link, this function does nothing. If `pid_or_port` does\nnot exist, this function does not produce any errors and simply does nothing.\n\nThe return value of this function is always `true`.\n\nSee `:erlang.unlink/1` for more information.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? unlink(pid_or_port)"}
{"completion":"Removes the registered `name`, associated with a PID\nor a port identifier.\n\nFails with `ArgumentError` if the name is not registered\nto any PID or port.\n\nInlined by the compiler.\n\n## Examples\n\n    Process.register(self(), :test)\n    #=> true\n    Process.unregister(:test)\n    #=> true\n    Process.unregister(:wrong_name)\n    ** (ArgumentError) argument error","prompt":"Can you write a docstring for the following Elixir function? unregister(name)"}
{"completion":"Returns the PID or port identifier registered under `name` or `nil` if the\nname is not registered.\n\nSee `:erlang.whereis/1` for more information.\n\n## Examples\n\n    Process.register(self(), :test)\n    Process.whereis(:test)\n    #=> #PID<0.84.0>\n    Process.whereis(:wrong_name)\n    #=> nil","prompt":"Can you write a docstring for the following Elixir function? whereis(name)"}
{"completion":"Conveniences for working with processes and the process dictionary.\n\nBesides the functions available in this module, the `Kernel` module\nexposes and auto-imports some basic functionality related to processes\navailable through the following functions:\n\n  * `Kernel.spawn/1` and `Kernel.spawn/3`\n  * `Kernel.spawn_link/1` and `Kernel.spawn_link/3`\n  * `Kernel.spawn_monitor/1` and `Kernel.spawn_monitor/3`\n  * `Kernel.self/0`\n  * `Kernel.send/2`\n\nWhile this module provides low-level conveniences to work with processes,\ndevelopers typically use abstractions such as `Agent`, `GenServer`,\n`Registry`, `Supervisor` and `Task` for building their systems and\nresort to this module for gathering information, trapping exits, links\nand monitoring.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Process"}
{"completion":"Checks if the given module is loaded and is an implementation\nof the given protocol.\n\nReturns `:ok` if so, otherwise raises `ArgumentError`.","prompt":"Can you write a docstring for the following Elixir function? assert_impl!(protocol, base)"}
{"completion":"Checks if the given module is loaded and is protocol.\n\nReturns `:ok` if so, otherwise raises `ArgumentError`.","prompt":"Can you write a docstring for the following Elixir function? assert_protocol!(module)"}
{"completion":"Receives a protocol and a list of implementations and\nconsolidates the given protocol.\n\nConsolidation happens by changing the protocol `impl_for`\nin the abstract format to have fast lookup rules. Usually\nthe list of implementations to use during consolidation\nare retrieved with the help of `extract_impls/2`.\n\nIt returns the updated version of the protocol bytecode.\nIf the first element of the tuple is `:ok`, it means\nthe protocol was consolidated.\n\nA given bytecode or protocol implementation can be checked\nto be consolidated or not by analyzing the protocol\nattribute:\n\n    Protocol.consolidated?(Enumerable)\n\nThis function does not load the protocol at any point\nnor loads the new bytecode for the compiled module.\nHowever each implementation must be available and\nit will be loaded.","prompt":"Can you write a docstring for the following Elixir function? consolidate(protocol, types)"}
{"completion":"Returns `true` if the protocol was consolidated.","prompt":"Can you write a docstring for the following Elixir function? consolidated?(protocol)"}
{"completion":"Extracts all types implemented for the given protocol from\nthe given paths.\n\nThe paths can be either a charlist or a string. Internally\nthey are worked on as charlists, so passing them as lists\navoid extra conversion.\n\nDoes not load any of the implementations.\n\n## Examples\n\n    # Get Elixir's ebin directory path and retrieve all protocols\n    iex> path = :code.lib_dir(:elixir, :ebin)\n    iex> mods = Protocol.extract_impls(Enumerable, [path])\n    iex> List in mods\n    true","prompt":"Can you write a docstring for the following Elixir function? extract_impls(protocol, paths)"}
{"completion":"Extracts all protocols from the given paths.\n\nThe paths can be either a charlist or a string. Internally\nthey are worked on as charlists, so passing them as lists\navoid extra conversion.\n\nDoes not load any of the protocols.\n\n## Examples\n\n    # Get Elixir's ebin directory path and retrieve all protocols\n    iex> path = :code.lib_dir(:elixir, :ebin)\n    iex> mods = Protocol.extract_protocols([path])\n    iex> Enumerable in mods\n    true","prompt":"Can you write a docstring for the following Elixir function? extract_protocols(paths)"}
{"completion":"Reference and functions for working with protocols.\n\nA protocol specifies an API that should be defined by its\nimplementations. A protocol is defined with `Kernel.defprotocol/2`\nand its implementations with `Kernel.defimpl/3`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Protocol"}
{"completion":"A real case\n\nIn Elixir, we have two nouns for checking how many items there\nare in a data structure: `length` and `size`.  `length` means the\ninformation must be computed. For example, `length(list)` needs to\ntraverse the whole list to calculate its length. On the other hand,\n`tuple_size(tuple)` and `byte_size(binary)` do not depend on the\ntuple and binary size as the size information is precomputed in\nthe data structure.\n\nAlthough Elixir includes specific functions such as `tuple_size`,\n`binary_size` and `map_size`, sometimes we want to be able to\nretrieve the size of a data structure regardless of its type.\nIn Elixir we can write polymorphic code, i.e. code that works\nwith different shapes/types, by using protocols. A size protocol\ncould be implemented as follows:\n\n    defprotocol Size do\n      @doc \"Calculates the size (and not the length!) of a data structure\"\n      def size(data)\n    end\n\nNow that the protocol can be implemented for every data structure\nthe protocol may have a compliant implementation for:\n\n    defimpl Size, for: BitString do\n      def size(binary), do: byte_size(binary)\n    end\n\n    defimpl Size, for: Map do\n      def size(map), do: map_size(map)\n    end\n\n    defimpl Size, for: Tuple do\n      def size(tuple), do: tuple_size(tuple)\n    end\n\nNote that we didn't implement it for lists as we don't have the\n`size` information on lists, rather its value needs to be\ncomputed with `length`.\n\nThe data structure you are implementing the protocol for\nmust be the first argument to all functions defined in the\nprotocol.\n\nIt is possible to implement protocols for all Elixir types:\n\n  * Structs (see the \"Protocols and Structs\" section below)\n  * `Tuple`\n  * `Atom`\n  * `List`\n  * `BitString`\n  * `Integer`\n  * `Float`\n  * `Function`\n  * `PID`\n  * `Map`\n  * `Port`\n  * `Reference`\n  * `Any` (see the \"Fallback to `Any`\" section below)","prompt":"Can you write a docstring for the following Elixir function? Elixir.Protocol"}
{"completion":"Protocols and Structs\n\nThe real benefit of protocols comes when mixed with structs.\nFor instance, Elixir ships with many data types implemented as\nstructs, like `MapSet`. We can implement the `Size` protocol\nfor those types as well:\n\n    defimpl Size, for: MapSet do\n      def size(map_set), do: MapSet.size(map_set)\n    end\n\nWhen implementing a protocol for a struct, the `:for` option can\nbe omitted if the `defimpl/3` call is inside the module that defines\nthe struct:\n\n    defmodule User do\n      defstruct [:email, :name]\n\n      defimpl Size do\n        # two fields\n        def size(%User{}), do: 2\n      end\n    end\n\nIf a protocol implementation is not found for a given type,\ninvoking the protocol will raise unless it is configured to\nfall back to `Any`. Conveniences for building implementations\non top of existing ones are also available, look at `defstruct/1`\nfor more information about deriving\nprotocols.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Protocol"}
{"completion":"Fallback to `Any`\n\nIn some cases, it may be convenient to provide a default\nimplementation for all types. This can be achieved by setting\nthe `@fallback_to_any` attribute to `true` in the protocol\ndefinition:\n\n    defprotocol Size do\n      @fallback_to_any true\n      def size(data)\n    end\n\nThe `Size` protocol can now be implemented for `Any`:\n\n    defimpl Size, for: Any do\n      def size(_), do: 0\n    end\n\nAlthough the implementation above is arguably not a reasonable\none. For example, it makes no sense to say a PID or an integer\nhave a size of `0`. That's one of the reasons why `@fallback_to_any`\nis an opt-in behaviour. For the majority of protocols, raising\nan error when a protocol is not implemented is the proper behaviour.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Protocol"}
{"completion":"Multiple implementations\n\nProtocols can also be implemented for multiple types at once:\n\n    defprotocol Reversible do\n      def reverse(term)\n    end\n\n    defimpl Reversible, for: [Map, List] do\n      def reverse(term), do: Enum.reverse(term)\n    end\n\nInside `defimpl/3`, you can use `@protocol` to access the protocol\nbeing implemented and `@for` to access the module it is being\ndefined for.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Protocol"}
{"completion":"Types\n\nDefining a protocol automatically defines a zero-arity type named `t`, which\ncan be used as follows:\n\n    @spec print_size(Size.t()) :: :ok\n    def print_size(data) do\n      result =\n        case Size.size(data) do\n          0 -> \"data has no items\"\n          1 -> \"data has one item\"\n          n -> \"data has #{n} items\"\n        end\n\n      IO.puts(result)\n    end\n\nThe `@spec` above expresses that all types allowed to implement the\ngiven protocol are valid argument types for the given function.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Protocol"}
{"completion":"Reflection\n\nAny protocol module contains three extra functions:\n\n  * `__protocol__/1` - returns the protocol information. The function takes\n    one of the following atoms:\n\n    * `:consolidated?` - returns whether the protocol is consolidated\n\n    * `:functions` - returns a keyword list of protocol functions and their arities\n\n    * `:impls` - if consolidated, returns `{:consolidated, modules}` with the list of modules\n      implementing the protocol, otherwise `:not_consolidated`\n\n    * `:module` - the protocol module atom name\n\n  * `impl_for/1` - returns the module that implements the protocol for the given argument,\n    `nil` otherwise\n\n  * `impl_for!/1` - same as above but raises `Protocol.UndefinedError` if an implementation is\n    not found\n\nFor example, for the `Enumerable` protocol we have:\n\n    iex> Enumerable.__protocol__(:functions)\n    [count: 1, member?: 2, reduce: 3, slice: 1]\n\n    iex> Enumerable.impl_for([])\n    Enumerable.List\n\n    iex> Enumerable.impl_for(42)\n    nil\n\nIn addition, every protocol implementation module contains the `__impl__/1`\nfunction. The function takes one of the following atoms:\n\n  * `:for` - returns the module responsible for the data structure of the\n    protocol implementation\n\n  * `:protocol` - returns the protocol module for which this implementation\n  is provided\n\nFor example, the module implementing the `Enumerable` protocol for lists is\n`Enumerable.List`. Therefore, we can invoke `__impl__/1` on this module:\n\n    iex(1)> Enumerable.List.__impl__(:for)\n    List\n\n    iex(2)> Enumerable.List.__impl__(:protocol)\n    Enumerable","prompt":"Can you write a docstring for the following Elixir function? Elixir.Protocol"}
{"completion":"Consolidation\n\nIn order to speed up protocol dispatching, whenever all protocol implementations\nare known up-front, typically after all Elixir code in a project is compiled,\nElixir provides a feature called *protocol consolidation*. Consolidation directly\nlinks protocols to their implementations in a way that invoking a function from a\nconsolidated protocol is equivalent to invoking two remote functions.\n\nProtocol consolidation is applied by default to all Mix projects during compilation.\nThis may be an issue during test. For instance, if you want to implement a protocol\nduring test, the implementation will have no effect, as the protocol has already been\nconsolidated. One possible solution is to include compilation directories that are\nspecific to your test environment in your mix.exs:\n\n    def project do\n      ...\n      elixirc_paths: elixirc_paths(Mix.env())\n      ...\n    end\n\n    defp elixirc_paths(:test), do: [\"lib\", \"test/support\"]\n    defp elixirc_paths(_), do: [\"lib\"]\n\nAnd then you can define the implementations specific to the test environment\ninside `test/support/some_file.ex`.\n\nAnother approach is to disable protocol consolidation during tests in your\nmix.exs:\n\n    def project do\n      ...\n      consolidate_protocols: Mix.env() != :test\n      ...\n    end\n\nIf you are using `Mix.install/2`, you can do by passing the `consolidate_protocols`\noption:\n\n    Mix.install(\n      deps,\n      consolidate_protocols: false\n    )\n\nAlthough doing so is not recommended as it may affect the performance of\nyour code.\n\nFinally, note all protocols are compiled with `debug_info` set to `true`,\nregardless of the option set by the `elixirc` compiler. The debug info is\nused for consolidation and it is removed after consolidation unless\nglobally set.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Protocol"}
{"completion":"Checks if two ranges are disjoint.\n\n## Examples\n\n    iex> Range.disjoint?(1..5, 6..9)\n    true\n    iex> Range.disjoint?(5..1, 6..9)\n    true\n    iex> Range.disjoint?(1..5, 5..9)\n    false\n    iex> Range.disjoint?(1..5, 2..7)\n    false\n\nSteps are also considered when computing the ranges to be disjoint:\n\n    iex> Range.disjoint?(1..10//2, 2..10//2)\n    true\n\n    # First element in common is 29\n    iex> Range.disjoint?(1..100//14, 8..100//21)\n    false\n    iex> Range.disjoint?(57..-1//-14, 8..100//21)\n    false\n    iex> Range.disjoint?(1..100//14, 50..8//-21)\n    false\n    iex> Range.disjoint?(1..28//14, 8..28//21)\n    true\n\n    # First element in common is 14\n    iex> Range.disjoint?(2..28//3, 9..28//5)\n    false\n    iex> Range.disjoint?(26..2//-3, 29..9//-5)\n    false\n\n    # Starting from the back without alignment\n    iex> Range.disjoint?(27..11//-3, 30..0//-7)\n    true","prompt":"Can you write a docstring for the following Elixir function? disjoint?(range1, range2)"}
{"completion":"Creates a new range.\n\nIf `first` is less than `last`, the range will be increasing from\n`first` to `last`. If `first` is equal to `last`, the range will contain\none element, which is the number itself.\n\nIf `first` is greater than `last`, the range will be decreasing from `first`\nto `last`, albeit this behaviour is deprecated. Therefore, it is advised to\nexplicitly list the step with `new/3`.\n\n## Examples\n\n    iex> Range.new(-100, 100)\n    -100..100","prompt":"Can you write a docstring for the following Elixir function? new(first, last)"}
{"completion":"Creates a new range with `step`.\n\n## Examples\n\n    iex> Range.new(-100, 100, 2)\n    -100..100//2","prompt":"Can you write a docstring for the following Elixir function? new(first, last, step)"}
{"completion":"Shifts a range by the given number of steps.\n\n## Examples\n\n    iex> Range.shift(0..10, 1)\n    1..11\n    iex> Range.shift(0..10, 2)\n    2..12\n\n    iex> Range.shift(0..10//2, 2)\n    4..14//2","prompt":"Can you write a docstring for the following Elixir function? shift(arg, steps_to_shift)"}
{"completion":"Returns the size of `range`.\n\n## Examples\n\n    iex> Range.size(1..10)\n    10\n    iex> Range.size(1..10//2)\n    5\n    iex> Range.size(1..10//3)\n    4\n    iex> Range.size(1..10//-1)\n    0\n\n    iex> Range.size(10..1)\n    10\n    iex> Range.size(10..1//-1)\n    10\n    iex> Range.size(10..1//-2)\n    5\n    iex> Range.size(10..1//-3)\n    4\n    iex> Range.size(10..1//1)\n    0","prompt":"Can you write a docstring for the following Elixir function? size(range)"}
{"completion":"Ranges represent a sequence of zero, one or many, ascending\nor descending integers with a common difference called step.\n\nThe most common form of creating and matching on ranges is\nvia the [`first..last`](`../2`) and [`first..last//step`](`..///3`)\nnotations, auto-imported from `Kernel`:\n\n    iex> 1 in 1..10\n    true\n    iex> 5 in 1..10\n    true\n    iex> 10 in 1..10\n    true\n\nRanges are always inclusive in Elixir. When a step is defined,\nintegers will only belong to the range if they match the step:\n\n    iex> 5 in 1..10//2\n    true\n    iex> 4 in 1..10//2\n    false\n\nWhen defining a range without a step, the step will be\ndefined based on the first and last position of the\nrange, If `last >= first`, it will be an increasing range\nwith a step of 1. Otherwise, it is a decreasing range.\nNote however implicit decreasing ranges are deprecated.\nTherefore, if you need a decreasing range from `3` to `1`,\nprefer to write `3..1//-1` instead.\n\n`../0` can also be used as a shortcut to create the range `0..-1//1`,\nalso known as the full-slice range:\n\n    iex> ..\n    0..-1//1","prompt":"Can you write a docstring for the following Elixir function? Elixir.Range"}
{"completion":"Use cases\n\nRanges typically have two uses in Elixir: as a collection or\nto represent a slice of another data structure.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Range"}
{"completion":"# Ranges as collections\n\nRanges in Elixir are enumerables and therefore can be used\nwith the `Enum` module:\n\n    iex> Enum.to_list(1..3)\n    [1, 2, 3]\n    iex> Enum.to_list(3..1//-1)\n    [3, 2, 1]\n    iex> Enum.to_list(1..5//2)\n    [1, 3, 5]\n\nRanges may also have a single element:\n\n    iex> Enum.to_list(1..1)\n    [1]\n    iex> Enum.to_list(1..1//2)\n    [1]\n\nOr even no elements at all:\n\n    iex> Enum.to_list(10..0//1)\n    []\n    iex> Enum.to_list(0..10//-1)\n    []\n\nThe full-slice range, returned by `../0`, is an empty collection:\n\n    iex> Enum.to_list(..)\n    []","prompt":"Can you write a docstring for the following Elixir function? Elixir.Range"}
{"completion":"# Ranges as slices\n\nRanges are also frequently used to slice collections.\nYou can slice strings or any enumerable:\n\n    iex> String.slice(\"elixir\", 1..4)\n    \"lixi\"\n    iex> Enum.slice([0, 1, 2, 3, 4, 5], 1..4)\n    [1, 2, 3, 4]\n\nIn those cases, the first and last values of the range\nare mapped to positions in the collections.\n\nIf a negative number is given, it maps to a position\nfrom the back:\n\n    iex> String.slice(\"elixir\", 1..-2//1)\n    \"lixi\"\n    iex> Enum.slice([0, 1, 2, 3, 4, 5], 1..-2//1)\n    [1, 2, 3, 4]\n\nThe range `0..-1//1`, returned by `../0`, returns the\ncollection as is, which is why it is called the full-slice\nrange:\n\n    iex> String.slice(\"elixir\", ..)\n    \"elixir\"\n    iex> Enum.slice([0, 1, 2, 3, 4, 5], ..)\n    [0, 1, 2, 3, 4, 5]","prompt":"Can you write a docstring for the following Elixir function? Elixir.Range"}
{"completion":"Definition\n\nAn increasing range `first..last//step` is a range from `first`\nto `last` increasing by `step` where  `step` must be a positive\ninteger and all values `v` must be `first <= v and v <= last`.\nTherefore, a range `10..0//1` is an empty range because there\nis no value `v` that is `10 <= v and v <= 0`.\n\nSimilarly, a decreasing range `first..last//step` is a range\nfrom `first` to `last` decreasing by `step` where `step` must\nbe a negative integer and  values `v` must be `first >= v and v >= last`.\nTherefore, a range `0..10//-1` is an empty range because there\nis no value `v` that is `0 >= v and v >= 10`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Range"}
{"completion":"Representation\n\nInternally, ranges are represented as structs:\n\n    iex> range = 1..9//2\n    1..9//2\n    iex> first..last//step = range\n    iex> first\n    1\n    iex> last\n    9\n    iex> step\n    2\n    iex> range.step\n    2\n\nYou can access the range fields (`first`, `last`, and `step`)\ndirectly but you should not modify nor create ranges by hand.\nInstead use the proper operators or `new/2` and `new/3`.\n\nRanges implement the `Enumerable` protocol with memory\nefficient versions of all `Enumerable` callbacks:\n\n    iex> range = 1..10\n    1..10\n    iex> Enum.reduce(range, 0, fn i, acc -> i * i + acc end)\n    385\n    iex> Enum.count(range)\n    10\n    iex> Enum.member?(range, 11)\n    false\n    iex> Enum.member?(range, 8)\n    true\n\nSuch function calls are efficient memory-wise no matter the\nsize of the range. The implementation of the `Enumerable`\nprotocol uses logic based solely on the endpoints and does\nnot materialize the whole list of integers.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Range"}
{"completion":"Extracts record information from an Erlang file.\n\nReturns a quoted expression containing the fields as a list\nof tuples.\n\n`name`, which is the name of the extracted record, is expected to be an atom\n*at compile time*.\n\n## Options\n\nThis function requires one of the following options, which are exclusive to each\nother (i.e., only one of them can be used in the same call):\n\n  * `:from` - (binary representing a path to a file) path to the Erlang file\n    that contains the record definition to extract; with this option, this\n    function uses the same path lookup used by the `-include` attribute used in\n    Erlang modules.\n\n  * `:from_lib` - (binary representing a path to a file) path to the Erlang\n    file that contains the record definition to extract; with this option,\n    this function uses the same path lookup used by the `-include_lib`\n    attribute used in Erlang modules.\n\nIt additionally accepts the following optional, non-exclusive options:\n\n  * `:includes` - (a list of directories as binaries) if the record being\n    extracted depends on relative includes, this option allows developers\n    to specify the directory where those relative includes exist.\n\n  * `:macros` - (keyword list of macro names and values) if the record\n    being extracted depends on the values of macros, this option allows\n    the value of those macros to be set.\n\nThese options are expected to be literals (including the binary values) at\ncompile time.\n\n## Examples\n\n    iex> Record.extract(:file_info, from_lib: \"kernel/include/file.hrl\")\n    [\n      size: :undefined,\n      type: :undefined,\n      access: :undefined,\n      atime: :undefined,\n      mtime: :undefined,\n      ctime: :undefined,\n      mode: :undefined,\n      links: :undefined,\n      major_device: :undefined,\n      minor_device: :undefined,\n      inode: :undefined,\n      uid: :undefined,\n      gid: :undefined\n    ]","prompt":"Can you write a docstring for the following Elixir function? extract(name, opts)"}
{"completion":"Extracts all records information from an Erlang file.\n\nReturns a keyword list of `{record_name, fields}` tuples where `record_name`\nis the name of an extracted record and `fields` is a list of `{field, value}`\ntuples representing the fields for that record.\n\n## Options\n\nAccepts the same options as listed for `Record.extract/2`.","prompt":"Can you write a docstring for the following Elixir function? extract_all(opts)"}
{"completion":"Module to work with, define, and import records.\n\nRecords are simply tuples where the first element is an atom:\n\n    iex> Record.is_record({User, \"john\", 27})\n    true\n\nThis module provides conveniences for working with records at\ncompilation time, where compile-time field names are used to\nmanipulate the tuples, providing fast operations on top of\nthe tuples' compact structure.\n\nIn Elixir, records are used mostly in two situations:\n\n  1. to work with short, internal data\n  2. to interface with Erlang records\n\nThe macros `defrecord/3` and `defrecordp/3` can be used to create records\nwhile `extract/2` and `extract_all/1` can be used to extract records from\nErlang files.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Record"}
{"completion":"Types\n\nTypes can be defined for tuples with the `record/2` macro (only available in\ntypespecs). This macro will expand to a tuple as seen in the example below:\n\n    defmodule MyModule do\n      require Record\n      Record.defrecord(:user, name: \"john\", age: 25)\n\n      @type user :: record(:user, name: String.t(), age: integer)\n      # expands to: \"@type user :: {:user, String.t(), integer}\"\n    end","prompt":"Can you write a docstring for the following Elixir function? Elixir.Record"}
{"completion":"Reflection\n\nA list of all records in a module, if any, can be retrieved by reading the\n`@__records__` module attribute. It returns a list of maps with the record\nkind, name, tag, and fields. The attribute is only available inside the\nmodule definition.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Record"}
{"completion":"Compiles the regular expression.\n\nThe given options can either be a binary with the characters\nrepresenting the same regex options given to the\n`~r` (see `sigil_r/2`) sigil, or a list of options, as\nexpected by the Erlang's [`:re`](`:re`) module.\n\nIt returns `{:ok, regex}` in case of success,\n`{:error, reason}` otherwise.\n\n## Examples\n\n    iex> Regex.compile(\"foo\")\n    {:ok, ~r/foo/}\n\n    iex> Regex.compile(\"*foo\")\n    {:error, {'nothing to repeat', 0}}\n\n    iex> Regex.compile(\"foo\", \"i\")\n    {:ok, ~r/foo/i}\n\n    iex> Regex.compile(\"foo\", [:caseless])\n    {:ok, Regex.compile!(\"foo\", [:caseless])}","prompt":"Can you write a docstring for the following Elixir function? compile(source, options \\\\ \"\")"}
{"completion":"Compiles the regular expression and raises `Regex.CompileError` in case of errors.","prompt":"Can you write a docstring for the following Elixir function? compile!(source, options \\\\ \"\")"}
{"completion":"Escapes a string to be literally matched in a regex.\n\n## Examples\n\n    iex> Regex.escape(\".\")\n    \"\\\\.\"\n\n    iex> Regex.escape(\"\\\\what if\")\n    \"\\\\\\\\what\\\\ if\"","prompt":"Can you write a docstring for the following Elixir function? escape(string)"}
{"completion":"Returns a boolean indicating whether there was a match or not.\n\n## Examples\n\n    iex> Regex.match?(~r/foo/, \"foo\")\n    true\n\n    iex> Regex.match?(~r/foo/, \"bar\")\n    false\n\nElixir also provides text-based match operator `=~/2` and function `String.match?/2` as\nan alternative to test strings against regular expressions and\nstrings.","prompt":"Can you write a docstring for the following Elixir function? match?(regex, string)"}
{"completion":"Returns the given captures as a map or `nil` if no captures are found.\n\n## Options\n\n  * `:return` - when set to `:index`, returns byte index and match length.\n    Defaults to `:binary`.\n\n## Examples\n\n    iex> Regex.named_captures(~r/c(?<foo>d)/, \"abcd\")\n    %{\"foo\" => \"d\"}\n\n    iex> Regex.named_captures(~r/a(?<foo>b)c(?<bar>d)/, \"abcd\")\n    %{\"bar\" => \"d\", \"foo\" => \"b\"}\n\n    iex> Regex.named_captures(~r/a(?<foo>b)c(?<bar>d)/, \"efgh\")\n    nil","prompt":"Can you write a docstring for the following Elixir function? named_captures(regex, string, options \\\\ [])"}
{"completion":"Returns a list of names in the regex.\n\n## Examples\n\n    iex> Regex.names(~r/(?<foo>bar)/)\n    [\"foo\"]","prompt":"Can you write a docstring for the following Elixir function? names(regex)"}
{"completion":"Returns the regex options, as a string or list depending on how\nit was compiled.\n\nSee the documentation of `Regex.compile/2` for more information.\n\n## Examples\n\n    iex> Regex.opts(~r/foo/m)\n    \"m\"\n\n    iex> Regex.opts(Regex.compile!(\"foo\", [:caseless]))\n    [:caseless]","prompt":"Can you write a docstring for the following Elixir function? opts(regex)"}
{"completion":"Returns the underlying `re_pattern` in the regular expression.","prompt":"Can you write a docstring for the following Elixir function? re_pattern(regex)"}
{"completion":"Recompiles the existing regular expression if necessary.\n\nThis checks the version stored in the regular expression\nand recompiles the regex in case of version mismatch.","prompt":"Can you write a docstring for the following Elixir function? recompile(regex)"}
{"completion":"Recompiles the existing regular expression and raises `Regex.CompileError` in case of errors.","prompt":"Can you write a docstring for the following Elixir function? recompile!(regex)"}
{"completion":"Returns `true` if the given `term` is a regex.\nOtherwise returns `false`.","prompt":"Can you write a docstring for the following Elixir function? regex?(term)"}
{"completion":"Receives a regex, a binary and a replacement, returns a new\nbinary where all matches are replaced by the replacement.\n\nThe replacement can be either a string or a function. The string\nis used as a replacement for every match and it allows specific\ncaptures to be accessed via `\\N` or `\\g{N}`, where `N` is the\ncapture. In case `\\0` is used, the whole match is inserted. Note\nthat in regexes the backslash needs to be escaped, hence in practice\nyou'll need to use `\\\\N` and `\\\\g{N}`.\n\nWhen the replacement is a function, the function may have arity\nN where each argument maps to a capture, with the first argument\nbeing the whole match. If the function expects more arguments\nthan captures found, the remaining arguments will receive `\"\"`.\n\n## Options\n\n  * `:global` - when `false`, replaces only the first occurrence\n    (defaults to `true`)\n\n## Examples\n\n    iex> Regex.replace(~r/d/, \"abc\", \"d\")\n    \"abc\"\n\n    iex> Regex.replace(~r/b/, \"abc\", \"d\")\n    \"adc\"\n\n    iex> Regex.replace(~r/b/, \"abc\", \"[\\\\0]\")\n    \"a[b]c\"\n\n    iex> Regex.replace(~r/a(b|d)c/, \"abcadc\", \"[\\\\1]\")\n    \"[b][d]\"\n\n    iex> Regex.replace(~r/\\.(\\d)$/, \"500.5\", \".\\\\g{1}0\")\n    \"500.50\"\n\n    iex> Regex.replace(~r/a(b|d)c/, \"abcadc\", fn _, x -> \"[#{x}]\" end)\n    \"[b][d]\"\n\n    iex> Regex.replace(~r/a/, \"abcadc\", \"A\", global: false)\n    \"Abcadc\"","prompt":"Can you write a docstring for the following Elixir function? replace(regex, string, replacement, options \\\\ [])"}
{"completion":"Runs the regular expression against the given string until the first match.\nIt returns a list with all captures or `nil` if no match occurred.\n\n## Options\n\n  * `:return` - when set to `:index`, returns byte index and match length.\n    Defaults to `:binary`.\n  * `:capture` - what to capture in the result. Check the moduledoc for `Regex`\n    to see the possible capture values.\n  * `:offset` - (since v1.12.0) specifies the starting offset to match in the given string.\n    Defaults to zero.\n\n## Examples\n\n    iex> Regex.run(~r/c(d)/, \"abcd\")\n    [\"cd\", \"d\"]\n\n    iex> Regex.run(~r/e/, \"abcd\")\n    nil\n\n    iex> Regex.run(~r/c(d)/, \"abcd\", return: :index)\n    [{2, 2}, {3, 1}]","prompt":"Can you write a docstring for the following Elixir function? run(regex, string, options \\\\ [])"}
{"completion":"Same as `run/3`, but scans the target several times collecting all\nmatches of the regular expression.\n\nA list of lists is returned, where each entry in the primary list represents a\nmatch and each entry in the secondary list represents the captured contents.\n\n## Options\n\n  * `:return` - when set to `:index`, returns byte index and match length.\n    Defaults to `:binary`.\n  * `:capture` - what to capture in the result. Check the moduledoc for `Regex`\n    to see the possible capture values.\n  * `:offset` - (since v1.12.0) specifies the starting offset to match in the given string.\n    Defaults to zero.\n\n## Examples\n\n    iex> Regex.scan(~r/c(d|e)/, \"abcd abce\")\n    [[\"cd\", \"d\"], [\"ce\", \"e\"]]\n\n    iex> Regex.scan(~r/c(?:d|e)/, \"abcd abce\")\n    [[\"cd\"], [\"ce\"]]\n\n    iex> Regex.scan(~r/e/, \"abcd\")\n    []\n\n    iex> Regex.scan(~r/\\p{Sc}/u, \"$, , and \")\n    [[\"$\"], [\"\"], [\"\"]]\n\n    iex> Regex.scan(~r/=+/, \"=8===\", return: :index)\n    [[{0, 1}], [{9, 3}]]","prompt":"Can you write a docstring for the following Elixir function? scan(regex, string, options \\\\ [])"}
{"completion":"Returns the regex source as a binary.\n\n## Examples\n\n    iex> Regex.source(~r/foo/)\n    \"foo\"","prompt":"Can you write a docstring for the following Elixir function? source(regex)"}
{"completion":"Splits the given target based on the given pattern and in the given number of\nparts.\n\n## Options\n\n  * `:parts` - when specified, splits the string into the given number of\n    parts. If not specified, `:parts` defaults to `:infinity`, which will\n    split the string into the maximum number of parts possible based on the\n    given pattern.\n\n  * `:trim` - when `true`, removes empty strings (`\"\"`) from the result.\n    Defaults to `false`.\n\n  * `:on` - specifies which captures to split the string on, and in what\n    order. Defaults to `:first` which means captures inside the regex do not\n    affect the splitting process.\n\n  * `:include_captures` - when `true`, includes in the result the matches of\n    the regular expression. The matches are not counted towards the maximum\n    number of parts if combined with the `:parts` option. Defaults to `false`.\n\n## Examples\n\n    iex> Regex.split(~r{-}, \"a-b-c\")\n    [\"a\", \"b\", \"c\"]\n\n    iex> Regex.split(~r{-}, \"a-b-c\", parts: 2)\n    [\"a\", \"b-c\"]\n\n    iex> Regex.split(~r{-}, \"abc\")\n    [\"abc\"]\n\n    iex> Regex.split(~r{}, \"abc\")\n    [\"\", \"a\", \"b\", \"c\", \"\"]\n\n    iex> Regex.split(~r{a(?<second>b)c}, \"abc\")\n    [\"\", \"\"]\n\n    iex> Regex.split(~r{a(?<second>b)c}, \"abc\", on: [:second])\n    [\"a\", \"c\"]\n\n    iex> Regex.split(~r{(x)}, \"Elixir\", include_captures: true)\n    [\"Eli\", \"x\", \"ir\"]\n\n    iex> Regex.split(~r{a(?<second>b)c}, \"abc\", on: [:second], include_captures: true)\n    [\"a\", \"b\", \"c\"]","prompt":"Can you write a docstring for the following Elixir function? split(regex, string, options \\\\ [])"}
{"completion":"Returns the version of the underlying Regex engine.","prompt":"Can you write a docstring for the following Elixir function? version()"}
{"completion":"Provides regular expressions for Elixir.\n\nRegex is based on PCRE (Perl Compatible Regular Expressions) and\nbuilt on top of Erlang's `:re` module. More information can be found\nin the [`:re` module documentation](`:re`).\n\nRegular expressions in Elixir can be created using the sigils\n`~r` (see `sigil_r/2`) or `~R` (see `sigil_R/2`):\n\n    # A simple regular expression that matches foo anywhere in the string\n    ~r/foo/\n\n    # A regular expression with case insensitive and Unicode options\n    ~r/foo/iu\n\nRegular expressions created via sigils are pre-compiled and stored\nin the `.beam` file. Note that this may be a problem if you are precompiling\nElixir, see the \"Precompilation\" section for more information.\n\nA Regex is represented internally as the `Regex` struct. Therefore,\n`%Regex{}` can be used whenever there is a need to match on them.\nKeep in mind that all of the structs fields are private. There is\nalso not guarantee two regular expressions from the same source are\nequal, for example:\n\n    ~r/(?<foo>.)(?<bar>.)/ == ~r/(?<foo>.)(?<bar>.)/\n\nmay return `true` or `false` depending on your machine, endianness,\navailable optimizations and others. You can, however, retrieve the source\nof a compiled regular expression by accessing the `source` field, and then\ncompare those directly:\n\n    ~r/(?<foo>.)(?<bar>.)/.source == ~r/(?<foo>.)(?<bar>.)/.source","prompt":"Can you write a docstring for the following Elixir function? Elixir.Regex"}
{"completion":"Modifiers\n\nThe modifiers available when creating a Regex are:\n\n  * `:unicode` (u) - enables Unicode specific patterns like `\\p` and causes\n    character classes like `\\w`, `\\W`, `\\s`, and the like to also match on Unicode\n    (see examples below in \"Character classes\"). It expects valid Unicode\n    strings to be given on match\n\n  * `:caseless` (i) - adds case insensitivity\n\n  * `:dotall` (s) - causes dot to match newlines and also set newline to\n    anycrlf; the new line setting can be overridden by setting `(*CR)` or\n    `(*LF)` or `(*CRLF)` or `(*ANY)` according to `:re` documentation\n\n  * `:multiline` (m) - causes `^` and `$` to mark the beginning and end of\n    each line; use `\\A` and `\\z` to match the end or beginning of the string\n\n  * `:extended` (x) - whitespace characters are ignored except when escaped\n    and allow `#` to delimit comments\n\n  * `:firstline` (f) - forces the unanchored pattern to match before or at the\n    first newline, though the matched text may continue over the newline\n\n  * `:ungreedy` (U) - inverts the \"greediness\" of the regexp\n    (the previous `r` option is deprecated in favor of `U`)\n\nThe options not available are:\n\n  * `:anchored` - not available, use `^` or `\\A` instead\n  * `:dollar_endonly` - not available, use `\\z` instead\n  * `:no_auto_capture` - not available, use `?:` instead\n  * `:newline` - not available, use `(*CR)` or `(*LF)` or `(*CRLF)` or\n    `(*ANYCRLF)` or `(*ANY)` at the beginning of the regexp according to the\n    `:re` documentation","prompt":"Can you write a docstring for the following Elixir function? Elixir.Regex"}
{"completion":"Captures\n\nMany functions in this module handle what to capture in a regex\nmatch via the `:capture` option. The supported values are:\n\n  * `:all` - all captured subpatterns including the complete matching string\n    (this is the default)\n\n  * `:first` - only the first captured subpattern, which is always the\n    complete matching part of the string; all explicitly captured subpatterns\n    are discarded\n\n  * `:all_but_first` - all but the first matching subpattern, i.e. all\n    explicitly captured subpatterns, but not the complete matching part of\n    the string\n\n  * `:none` - does not return matching subpatterns at all\n\n  * `:all_names` - captures all named subpattern matches in the Regex as a list\n    ordered **alphabetically** by the names of the subpatterns\n\n  * `list(binary)` - a list of named captures to capture","prompt":"Can you write a docstring for the following Elixir function? Elixir.Regex"}
{"completion":"Character classes\n\nRegex supports several built in named character classes. These are used by\nenclosing the class name in `[: :]` inside a group. For example:\n\n    iex> String.match?(\"123\", ~r/^[[:alnum:]]+$/)\n    true\n    iex> String.match?(\"123 456\", ~r/^[[:alnum:][:blank:]]+$/)\n    true\n\nThe supported class names are:\n\n  * alnum - Letters and digits\n  * alpha - Letters\n  * blank - Space or tab only\n  * cntrl - Control characters\n  * digit - Decimal digits (same as \\\\d)\n  * graph - Printing characters, excluding space\n  * lower - Lowercase letters\n  * print - Printing characters, including space\n  * punct - Printing characters, excluding letters, digits, and space\n  * space - Whitespace (the same as \\s from PCRE 8.34)\n  * upper - Uppercase letters\n  * word  - \"Word\" characters (same as \\w)\n  * xdigit - Hexadecimal digits\n\nThere is another character class, `ascii`, that erroneously matches\nLatin-1 characters instead of the 0-127 range specified by POSIX. This\ncannot be fixed without altering the behaviour of other classes, so we\nrecommend matching the range with `[\\\\0-\\x7f]` instead.\n\nNote the behaviour of those classes may change according to the Unicode\nand other modifiers:\n\n    iex> String.match?(\"jos\", ~r/^[[:lower:]]+$/)\n    false\n    iex> String.match?(\"jos\", ~r/^[[:lower:]]+$/u)\n    true\n    iex> Regex.replace(~r/\\s/, \"Unicode\\u00A0spaces\", \"-\")\n    \"Unicodespaces\"\n    iex> Regex.replace(~r/\\s/u, \"Unicode\\u00A0spaces\", \"-\")\n    \"Unicode-spaces\"","prompt":"Can you write a docstring for the following Elixir function? Elixir.Regex"}
{"completion":"Precompilation\n\nRegular expressions built with sigil are precompiled and stored in `.beam`\nfiles. Precompiled regexes will be checked in runtime and may work slower\nbetween operating systems and OTP releases. This is rarely a problem, as most Elixir code\nshared during development is compiled on the target (such as dependencies,\narchives, and escripts) and, when running in production, the code must either\nbe compiled on the target (via `mix compile` or similar) or released on the\nhost (via `mix releases` or similar) with a matching OTP, operating system\nand architecture as the target.\n\nIf you know you are running on a different system than the current one and\nyou are doing multiple matches with the regex, you can manually invoke\n`Regex.recompile/1` or `Regex.recompile!/1` to perform a runtime version\ncheck and recompile the regex if necessary.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Regex"}
{"completion":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","prompt":"Can you write a docstring for the following Elixir function? child_spec(init_arg)"}
{"completion":"Returns the name of key partition table.","prompt":"Can you write a docstring for the following Elixir function? key_name(registry, partition)"}
{"completion":"Returns the name of pid partition table.","prompt":"Can you write a docstring for the following Elixir function? pid_name(name, partition)"}
{"completion":"Starts the registry partition.\n\nThe process is only responsible for monitoring, demonitoring\nand cleaning up when monitored processes crash.","prompt":"Can you write a docstring for the following Elixir function? start_link(registry, arg)"}
{"completion":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","prompt":"Can you write a docstring for the following Elixir function? child_spec(init_arg)"}
{"completion":"Returns a specification to start a registry under a supervisor.\n\nSee `Supervisor`.","prompt":"Can you write a docstring for the following Elixir function? child_spec(options)"}
{"completion":"Returns the number of registered keys in a registry.\nIt runs in constant time.\n\n## Examples\nIn the example below we register the current process and ask for the\nnumber of keys in the registry:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueCountTest)\n    iex> Registry.count(Registry.UniqueCountTest)\n    0\n    iex> {:ok, _} = Registry.register(Registry.UniqueCountTest, \"hello\", :world)\n    iex> {:ok, _} = Registry.register(Registry.UniqueCountTest, \"world\", :world)\n    iex> Registry.count(Registry.UniqueCountTest)\n    2\n\nThe same applies to duplicate registries:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateCountTest)\n    iex> Registry.count(Registry.DuplicateCountTest)\n    0\n    iex> {:ok, _} = Registry.register(Registry.DuplicateCountTest, \"hello\", :world)\n    iex> {:ok, _} = Registry.register(Registry.DuplicateCountTest, \"hello\", :world)\n    iex> Registry.count(Registry.DuplicateCountTest)\n    2","prompt":"Can you write a docstring for the following Elixir function? count(registry)"}
{"completion":"Returns the number of `{pid, value}` pairs under the given `key` in `registry`\nthat match `pattern`.\n\nPattern must be an atom or a tuple that will match the structure of the\nvalue stored in the registry. The atom `:_` can be used to ignore a given\nvalue or tuple element, while the atom `:\"$1\"` can be used to temporarily assign part\nof pattern to a variable for a subsequent comparison.\n\nOptionally, it is possible to pass a list of guard conditions for more precise matching.\nEach guard is a tuple, which describes checks that should be passed by assigned part of pattern.\nFor example the `$1 > 1` guard condition would be expressed as the `{:>, :\"$1\", 1}` tuple.\nPlease note that guard conditions will work only for assigned\nvariables like `:\"$1\"`, `:\"$2\"`, and so forth.\nAvoid usage of special match variables `:\"$_\"` and `:\"$$\"`, because it might not work as expected.\n\nZero will be returned if there is no match.\n\nFor unique registries, a single partition lookup is necessary. For\nduplicate registries, all partitions must be looked up.\n\n## Examples\n\nIn the example below we register the current process under the same\nkey in a duplicate registry but with different values:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.CountMatchTest)\n    iex> {:ok, _} = Registry.register(Registry.CountMatchTest, \"hello\", {1, :atom, 1})\n    iex> {:ok, _} = Registry.register(Registry.CountMatchTest, \"hello\", {2, :atom, 2})\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {1, :_, :_})\n    1\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {2, :_, :_})\n    1\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {:_, :atom, :_})\n    2\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {:\"$1\", :_, :\"$1\"})\n    2\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {:_, :_, :\"$1\"}, [{:>, :\"$1\", 1}])\n    1\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {:_, :\"$1\", :_}, [{:is_atom, :\"$1\"}])\n    2","prompt":"Can you write a docstring for the following Elixir function? count_match(registry, key, pattern, guards \\\\ [])"}
{"completion":"Works like `select/2`, but only returns the number of matching records.\n\n## Examples\n\nIn the example below we register the current process under different\nkeys in a unique registry but with the same value:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.CountSelectTest)\n    iex> {:ok, _} = Registry.register(Registry.CountSelectTest, \"hello\", :value)\n    iex> {:ok, _} = Registry.register(Registry.CountSelectTest, \"world\", :value)\n    iex> Registry.count_select(Registry.CountSelectTest, [{{:_, :_, :value}, [], [true]}])\n    2","prompt":"Can you write a docstring for the following Elixir function? count_select(registry, spec)"}
{"completion":"Deletes registry metadata for the given `key` in `registry`.\n\n## Examples\n\n    iex> Registry.start_link(keys: :unique, name: Registry.DeleteMetaTest)\n    iex> Registry.put_meta(Registry.DeleteMetaTest, :custom_key, \"custom_value\")\n    :ok\n    iex> Registry.meta(Registry.DeleteMetaTest, :custom_key)\n    {:ok, \"custom_value\"}\n    iex> Registry.delete_meta(Registry.DeleteMetaTest, :custom_key)\n    :ok\n    iex> Registry.meta(Registry.DeleteMetaTest, :custom_key)\n    :error","prompt":"Can you write a docstring for the following Elixir function? delete_meta(registry, key)"}
{"completion":"Invokes the callback with all entries under `key` in each partition\nfor the given `registry`.\n\nThe list of `entries` is a non-empty list of two-element tuples where\nthe first element is the PID and the second element is the value\nassociated to the PID. If there are no entries for the given key,\nthe callback is never invoked.\n\nIf the registry is partitioned, the callback is invoked multiple times\nper partition. If the registry is partitioned and `parallel: true` is\ngiven as an option, the dispatching happens in parallel. In both cases,\nthe callback is only invoked if there are entries for that partition.\n\nSee the module documentation for examples of using the `dispatch/3`\nfunction for building custom dispatching or a pubsub system.","prompt":"Can you write a docstring for the following Elixir function? dispatch(registry, key, mfa_or_fun, opts \\\\ [])"}
{"completion":"Returns the known keys for the given `pid` in `registry` in no particular order.\n\nIf the registry is unique, the keys are unique. Otherwise\nthey may contain duplicates if the process was registered\nunder the same key multiple times. The list will be empty\nif the process is dead or it has no keys in this registry.\n\n## Examples\n\nRegistering under a unique registry does not allow multiple entries:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueKeysTest)\n    iex> Registry.keys(Registry.UniqueKeysTest, self())\n    []\n    iex> {:ok, _} = Registry.register(Registry.UniqueKeysTest, \"hello\", :world)\n    iex> Registry.register(Registry.UniqueKeysTest, \"hello\", :later) # registry is :unique\n    {:error, {:already_registered, self()}}\n    iex> Registry.keys(Registry.UniqueKeysTest, self())\n    [\"hello\"]\n\nSuch is possible for duplicate registries though:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateKeysTest)\n    iex> Registry.keys(Registry.DuplicateKeysTest, self())\n    []\n    iex> {:ok, _} = Registry.register(Registry.DuplicateKeysTest, \"hello\", :world)\n    iex> {:ok, _} = Registry.register(Registry.DuplicateKeysTest, \"hello\", :world)\n    iex> Registry.keys(Registry.DuplicateKeysTest, self())\n    [\"hello\", \"hello\"]","prompt":"Can you write a docstring for the following Elixir function? keys(registry, pid)"}
{"completion":"Finds the `{pid, value}` pair for the given `key` in `registry` in no particular order.\n\nAn empty list if there is no match.\n\nFor unique registries, a single partition lookup is necessary. For\nduplicate registries, all partitions must be looked up.\n\n## Examples\n\nIn the example below we register the current process and look it up\nboth from itself and other processes:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueLookupTest)\n    iex> Registry.lookup(Registry.UniqueLookupTest, \"hello\")\n    []\n    iex> {:ok, _} = Registry.register(Registry.UniqueLookupTest, \"hello\", :world)\n    iex> Registry.lookup(Registry.UniqueLookupTest, \"hello\")\n    [{self(), :world}]\n    iex> Task.async(fn -> Registry.lookup(Registry.UniqueLookupTest, \"hello\") end) |> Task.await()\n    [{self(), :world}]\n\nThe same applies to duplicate registries:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateLookupTest)\n    iex> Registry.lookup(Registry.DuplicateLookupTest, \"hello\")\n    []\n    iex> {:ok, _} = Registry.register(Registry.DuplicateLookupTest, \"hello\", :world)\n    iex> Registry.lookup(Registry.DuplicateLookupTest, \"hello\")\n    [{self(), :world}]\n    iex> {:ok, _} = Registry.register(Registry.DuplicateLookupTest, \"hello\", :another)\n    iex> Enum.sort(Registry.lookup(Registry.DuplicateLookupTest, \"hello\"))\n    [{self(), :another}, {self(), :world}]","prompt":"Can you write a docstring for the following Elixir function? lookup(registry, key)"}
{"completion":"Returns `{pid, value}` pairs under the given `key` in `registry` that match `pattern`.\n\nPattern must be an atom or a tuple that will match the structure of the\nvalue stored in the registry. The atom `:_` can be used to ignore a given\nvalue or tuple element, while the atom `:\"$1\"` can be used to temporarily assign part\nof pattern to a variable for a subsequent comparison.\n\nOptionally, it is possible to pass a list of guard conditions for more precise matching.\nEach guard is a tuple, which describes checks that should be passed by assigned part of pattern.\nFor example the `$1 > 1` guard condition would be expressed as the `{:>, :\"$1\", 1}` tuple.\nPlease note that guard conditions will work only for assigned\nvariables like `:\"$1\"`, `:\"$2\"`, and so forth.\nAvoid usage of special match variables `:\"$_\"` and `:\"$$\"`, because it might not work as expected.\n\nAn empty list will be returned if there is no match.\n\nFor unique registries, a single partition lookup is necessary. For\nduplicate registries, all partitions must be looked up.\n\n## Examples\n\nIn the example below we register the current process under the same\nkey in a duplicate registry but with different values:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.MatchTest)\n    iex> {:ok, _} = Registry.register(Registry.MatchTest, \"hello\", {1, :atom, 1})\n    iex> {:ok, _} = Registry.register(Registry.MatchTest, \"hello\", {2, :atom, 2})\n    iex> Registry.match(Registry.MatchTest, \"hello\", {1, :_, :_})\n    [{self(), {1, :atom, 1}}]\n    iex> Registry.match(Registry.MatchTest, \"hello\", {2, :_, :_})\n    [{self(), {2, :atom, 2}}]\n    iex> Registry.match(Registry.MatchTest, \"hello\", {:_, :atom, :_}) |> Enum.sort()\n    [{self(), {1, :atom, 1}}, {self(), {2, :atom, 2}}]\n    iex> Registry.match(Registry.MatchTest, \"hello\", {:\"$1\", :_, :\"$1\"}) |> Enum.sort()\n    [{self(), {1, :atom, 1}}, {self(), {2, :atom, 2}}]\n    iex> guards = [{:>, :\"$1\", 1}]\n    iex> Registry.match(Registry.MatchTest, \"hello\", {:_, :_, :\"$1\"}, guards)\n    [{self(), {2, :atom, 2}}]\n    iex> guards = [{:is_atom, :\"$1\"}]\n    iex> Registry.match(Registry.MatchTest, \"hello\", {:_, :\"$1\", :_}, guards) |> Enum.sort()\n    [{self(), {1, :atom, 1}}, {self(), {2, :atom, 2}}]","prompt":"Can you write a docstring for the following Elixir function? match(registry, key, pattern, guards \\\\ [])"}
{"completion":"Reads registry metadata given on `start_link/1`.\n\nAtoms and tuples are allowed as keys.\n\n## Examples\n\n    iex> Registry.start_link(keys: :unique, name: Registry.MetaTest, meta: [custom_key: \"custom_value\"])\n    iex> Registry.meta(Registry.MetaTest, :custom_key)\n    {:ok, \"custom_value\"}\n    iex> Registry.meta(Registry.MetaTest, :unknown_key)\n    :error","prompt":"Can you write a docstring for the following Elixir function? meta(registry, key)"}
{"completion":"Stores registry metadata.\n\nAtoms and tuples are allowed as keys.\n\n## Examples\n\n    iex> Registry.start_link(keys: :unique, name: Registry.PutMetaTest)\n    iex> Registry.put_meta(Registry.PutMetaTest, :custom_key, \"custom_value\")\n    :ok\n    iex> Registry.meta(Registry.PutMetaTest, :custom_key)\n    {:ok, \"custom_value\"}\n    iex> Registry.put_meta(Registry.PutMetaTest, {:tuple, :key}, \"tuple_value\")\n    :ok\n    iex> Registry.meta(Registry.PutMetaTest, {:tuple, :key})\n    {:ok, \"tuple_value\"}","prompt":"Can you write a docstring for the following Elixir function? put_meta(registry, key, value)"}
{"completion":"Registers the current process under the given `key` in `registry`.\n\nA value to be associated with this registration must also be given.\nThis value will be retrieved whenever dispatching or doing a key\nlookup.\n\nThis function returns `{:ok, owner}` or `{:error, reason}`.\nThe `owner` is the PID in the registry partition responsible for\nthe PID. The owner is automatically linked to the caller.\n\nIf the registry has unique keys, it will return `{:ok, owner}` unless\nthe key is already associated to a PID, in which case it returns\n`{:error, {:already_registered, pid}}`.\n\nIf the registry has duplicate keys, multiple registrations from the\ncurrent process under the same key are allowed.\n\n## Examples\n\nRegistering under a unique registry does not allow multiple entries:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueRegisterTest)\n    iex> {:ok, _} = Registry.register(Registry.UniqueRegisterTest, \"hello\", :world)\n    iex> Registry.register(Registry.UniqueRegisterTest, \"hello\", :later)\n    {:error, {:already_registered, self()}}\n    iex> Registry.keys(Registry.UniqueRegisterTest, self())\n    [\"hello\"]\n\nSuch is possible for duplicate registries though:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateRegisterTest)\n    iex> {:ok, _} = Registry.register(Registry.DuplicateRegisterTest, \"hello\", :world)\n    iex> {:ok, _} = Registry.register(Registry.DuplicateRegisterTest, \"hello\", :world)\n    iex> Registry.keys(Registry.DuplicateRegisterTest, self())\n    [\"hello\", \"hello\"]","prompt":"Can you write a docstring for the following Elixir function? register(registry, key, value)"}
{"completion":"Select key, pid, and values registered using full match specs.\n\nThe `spec` consists of a list of three part tuples, in the shape of `[{match_pattern, guards, body}]`.\n\nThe first part, the match pattern, must be a tuple that will match the structure of the\nthe data stored in the registry, which is `{key, pid, value}`. The atom `:_` can be used to\nignore a given value or tuple element, while the atom `:\"$1\"` can be used to temporarily\nassign part of pattern to a variable for a subsequent comparison. This can be combined\nlike `{:\"$1\", :_, :_}`.\n\nThe second part, the guards, is a list of conditions that allow filtering the results.\nEach guard is a tuple, which describes checks that should be passed by assigned part of pattern.\nFor example the `$1 > 1` guard condition would be expressed as the `{:>, :\"$1\", 1}` tuple.\nPlease note that guard conditions will work only for assigned\nvariables like `:\"$1\"`, `:\"$2\"`, and so forth.\n\nThe third part, the body, is a list of shapes of the returned entries. Like guards, you have access to\nassigned variables like `:\"$1\"`, which you can combine with hardcoded values to freely shape entries\nNote that tuples have to be wrapped in an additional tuple. To get a result format like\n`%{key: key, pid: pid, value: value}`, assuming you bound those variables in order in the match part,\nyou would provide a body like `[%{key: :\"$1\", pid: :\"$2\", value: :\"$3\"}]`. Like guards, you can use\nsome operations like `:element` to modify the output format.\n\nDo not use special match variables `:\"$_\"` and `:\"$$\"`, because they might not work as expected.\n\nNote that for large registries with many partitions this will be costly as it builds the result by\nconcatenating all the partitions.\n\n## Examples\n\nThis example shows how to get everything from the registry:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.SelectAllTest)\n    iex> {:ok, _} = Registry.register(Registry.SelectAllTest, \"hello\", :value)\n    iex> {:ok, _} = Registry.register(Registry.SelectAllTest, \"world\", :value)\n    iex> Registry.select(Registry.SelectAllTest, [{{:\"$1\", :\"$2\", :\"$3\"}, [], [{{:\"$1\", :\"$2\", :\"$3\"}}]}])\n    [{\"world\", self(), :value}, {\"hello\", self(), :value}]\n\nGet all keys in the registry:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.SelectAllTest)\n    iex> {:ok, _} = Registry.register(Registry.SelectAllTest, \"hello\", :value)\n    iex> {:ok, _} = Registry.register(Registry.SelectAllTest, \"world\", :value)\n    iex> Registry.select(Registry.SelectAllTest, [{{:\"$1\", :_, :_}, [], [:\"$1\"]}])\n    [\"world\", \"hello\"]","prompt":"Can you write a docstring for the following Elixir function? select(registry, spec)"}
{"completion":"Starts the registry as a supervisor process.\n\nManually it can be started as:\n\n    Registry.start_link(keys: :unique, name: MyApp.Registry)\n\nIn your supervisor tree, you would write:\n\n    Supervisor.start_link([\n      {Registry, keys: :unique, name: MyApp.Registry}\n    ], strategy: :one_for_one)\n\nFor intensive workloads, the registry may also be partitioned (by specifying\nthe `:partitions` option). If partitioning is required then a good default is to\nset the number of partitions to the number of schedulers available:\n\n    Registry.start_link(\n      keys: :unique,\n      name: MyApp.Registry,\n      partitions: System.schedulers_online()\n    )\n\nor:\n\n    Supervisor.start_link([\n      {Registry, keys: :unique, name: MyApp.Registry, partitions: System.schedulers_online()}\n    ], strategy: :one_for_one)\n\n## Options\n\nThe registry requires the following keys:\n\n  * `:keys` - chooses if keys are `:unique` or `:duplicate`\n  * `:name` - the name of the registry and its tables\n\nThe following keys are optional:\n\n  * `:partitions` - the number of partitions in the registry. Defaults to `1`.\n  * `:listeners` - a list of named processes which are notified of `:register`\n    and `:unregister` events. The registered process must be monitored by the\n    listener if the listener wants to be notified if the registered process\n    crashes.\n  * `:meta` - a keyword list of metadata to be attached to the registry.","prompt":"Can you write a docstring for the following Elixir function? start_link(options)"}
{"completion":"Unregisters all entries for the given `key` associated to the current\nprocess in `registry`.\n\nAlways returns `:ok` and automatically unlinks the current process from\nthe owner if there are no more keys associated to the current process. See\nalso `register/3` to read more about the \"owner\".\n\n## Examples\n\nFor unique registries:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueUnregisterTest)\n    iex> Registry.register(Registry.UniqueUnregisterTest, \"hello\", :world)\n    iex> Registry.keys(Registry.UniqueUnregisterTest, self())\n    [\"hello\"]\n    iex> Registry.unregister(Registry.UniqueUnregisterTest, \"hello\")\n    :ok\n    iex> Registry.keys(Registry.UniqueUnregisterTest, self())\n    []\n\nFor duplicate registries:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateUnregisterTest)\n    iex> Registry.register(Registry.DuplicateUnregisterTest, \"hello\", :world)\n    iex> Registry.register(Registry.DuplicateUnregisterTest, \"hello\", :world)\n    iex> Registry.keys(Registry.DuplicateUnregisterTest, self())\n    [\"hello\", \"hello\"]\n    iex> Registry.unregister(Registry.DuplicateUnregisterTest, \"hello\")\n    :ok\n    iex> Registry.keys(Registry.DuplicateUnregisterTest, self())\n    []","prompt":"Can you write a docstring for the following Elixir function? unregister(registry, key)"}
{"completion":"Unregisters entries for keys matching a pattern associated to the current\nprocess in `registry`.\n\n## Examples\n\nFor unique registries it can be used to conditionally unregister a key on\nthe basis of whether or not it matches a particular value.\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueUnregisterMatchTest)\n    iex> Registry.register(Registry.UniqueUnregisterMatchTest, \"hello\", :world)\n    iex> Registry.keys(Registry.UniqueUnregisterMatchTest, self())\n    [\"hello\"]\n    iex> Registry.unregister_match(Registry.UniqueUnregisterMatchTest, \"hello\", :foo)\n    :ok\n    iex> Registry.keys(Registry.UniqueUnregisterMatchTest, self())\n    [\"hello\"]\n    iex> Registry.unregister_match(Registry.UniqueUnregisterMatchTest, \"hello\", :world)\n    :ok\n    iex> Registry.keys(Registry.UniqueUnregisterMatchTest, self())\n    []\n\nFor duplicate registries:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateUnregisterMatchTest)\n    iex> Registry.register(Registry.DuplicateUnregisterMatchTest, \"hello\", :world_a)\n    iex> Registry.register(Registry.DuplicateUnregisterMatchTest, \"hello\", :world_b)\n    iex> Registry.register(Registry.DuplicateUnregisterMatchTest, \"hello\", :world_c)\n    iex> Registry.keys(Registry.DuplicateUnregisterMatchTest, self())\n    [\"hello\", \"hello\", \"hello\"]\n    iex> Registry.unregister_match(Registry.DuplicateUnregisterMatchTest, \"hello\", :world_a)\n    :ok\n    iex> Registry.keys(Registry.DuplicateUnregisterMatchTest, self())\n    [\"hello\", \"hello\"]\n    iex> Registry.lookup(Registry.DuplicateUnregisterMatchTest, \"hello\")\n    [{self(), :world_b}, {self(), :world_c}]","prompt":"Can you write a docstring for the following Elixir function? unregister_match(registry, key, pattern, guards \\\\ [])"}
{"completion":"Updates the value for `key` for the current process in the unique `registry`.\n\nReturns a `{new_value, old_value}` tuple or `:error` if there\nis no such key assigned to the current process.\n\nIf a non-unique registry is given, an error is raised.\n\n## Examples\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UpdateTest)\n    iex> {:ok, _} = Registry.register(Registry.UpdateTest, \"hello\", 1)\n    iex> Registry.lookup(Registry.UpdateTest, \"hello\")\n    [{self(), 1}]\n    iex> Registry.update_value(Registry.UpdateTest, \"hello\", &(&1 + 1))\n    {2, 1}\n    iex> Registry.lookup(Registry.UpdateTest, \"hello\")\n    [{self(), 2}]","prompt":"Can you write a docstring for the following Elixir function? update_value(registry, key, callback)"}
{"completion":"Reads the values for the given `key` for `pid` in `registry`.\n\nFor unique registries, it is either an empty list or a list\nwith a single element. For duplicate registries, it is a list\nwith zero, one, or multiple elements.\n\n## Examples\n\nIn the example below we register the current process and look it up\nboth from itself and other processes:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueLookupTest)\n    iex> Registry.values(Registry.UniqueLookupTest, \"hello\", self())\n    []\n    iex> {:ok, _} = Registry.register(Registry.UniqueLookupTest, \"hello\", :world)\n    iex> Registry.values(Registry.UniqueLookupTest, \"hello\", self())\n    [:world]\n    iex> Task.async(fn -> Registry.values(Registry.UniqueLookupTest, \"hello\", self()) end) |> Task.await()\n    []\n    iex> parent = self()\n    iex> Task.async(fn -> Registry.values(Registry.UniqueLookupTest, \"hello\", parent) end) |> Task.await()\n    [:world]\n\nThe same applies to duplicate registries:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateLookupTest)\n    iex> Registry.values(Registry.DuplicateLookupTest, \"hello\", self())\n    []\n    iex> {:ok, _} = Registry.register(Registry.DuplicateLookupTest, \"hello\", :world)\n    iex> Registry.values(Registry.DuplicateLookupTest, \"hello\", self())\n    [:world]\n    iex> {:ok, _} = Registry.register(Registry.DuplicateLookupTest, \"hello\", :another)\n    iex> Enum.sort(Registry.values(Registry.DuplicateLookupTest, \"hello\", self()))\n    [:another, :world]","prompt":"Can you write a docstring for the following Elixir function? values(registry, key, pid)"}
{"completion":"A local, decentralized and scalable key-value process storage.\n\nIt allows developers to lookup one or more processes with a given key.\nIf the registry has `:unique` keys, a key points to 0 or 1 process.\nIf the registry allows `:duplicate` keys, a single key may point to any\nnumber of processes. In both cases, different keys could identify the\nsame process.\n\nEach entry in the registry is associated to the process that has\nregistered the key. If the process crashes, the keys associated to that\nprocess are automatically removed. All key comparisons in the registry\nare done using the match operation (`===/2`).\n\nThe registry can be used for different purposes, such as name lookups (using\nthe `:via` option), storing properties, custom dispatching rules, or a pubsub\nimplementation. We explore some of those use cases below.\n\nThe registry may also be transparently partitioned, which provides\nmore scalable behaviour for running registries on highly concurrent\nenvironments with thousands or millions of entries.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Registry"}
{"completion":"Using in `:via`\n\nOnce the registry is started with a given name using\n`Registry.start_link/1`, it can be used to register and access named\nprocesses using the `{:via, Registry, {registry, key}}` tuple:\n\n    {:ok, _} = Registry.start_link(keys: :unique, name: Registry.ViaTest)\n    name = {:via, Registry, {Registry.ViaTest, \"agent\"}}\n    {:ok, _} = Agent.start_link(fn -> 0 end, name: name)\n    Agent.get(name, & &1)\n    #=> 0\n    Agent.update(name, &(&1 + 1))\n    Agent.get(name, & &1)\n    #=> 1\n\nIn the previous example, we were not interested in associating a value to the\nprocess:\n\n    Registry.lookup(Registry.ViaTest, \"agent\")\n    #=> [{self(), nil}]\n\nHowever, in some cases it may be desired to associate a value to the process\nusing the alternate `{:via, Registry, {registry, key, value}}` tuple:\n\n    {:ok, _} = Registry.start_link(keys: :unique, name: Registry.ViaTest)\n    name = {:via, Registry, {Registry.ViaTest, \"agent\", :hello}}\n    {:ok, agent_pid} = Agent.start_link(fn -> 0 end, name: name)\n    Registry.lookup(Registry.ViaTest, \"agent\")\n    #=> [{agent_pid, :hello}]\n\nTo this point, we have been starting `Registry` using `start_link/1`.\nTypically the registry is started as part of a supervision tree though:\n\n    {Registry, keys: :unique, name: Registry.ViaTest}\n\nOnly registries with unique keys can be used in `:via`. If the name is\nalready taken, the case-specific `start_link` function (`Agent.start_link/2`\nin the example above) will return `{:error, {:already_started, current_pid}}`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Registry"}
{"completion":"Using as a dispatcher\n\n`Registry` has a dispatch mechanism that allows developers to implement custom\ndispatch logic triggered from the caller. For example, let's say we have a\nduplicate registry started as so:\n\n    {:ok, _} = Registry.start_link(keys: :duplicate, name: Registry.DispatcherTest)\n\nBy calling `register/3`, different processes can register under a given key\nand associate any value under that key. In this case, let's register the\ncurrent process under the key `\"hello\"` and attach the `{IO, :inspect}` tuple\nto it:\n\n    {:ok, _} = Registry.register(Registry.DispatcherTest, \"hello\", {IO, :inspect})\n\nNow, an entity interested in dispatching events for a given key may call\n`dispatch/3` passing in the key and a callback. This callback will be invoked\nwith a list of all the values registered under the requested key, alongside\nthe PID of the process that registered each value, in the form of `{pid,\nvalue}` tuples. In our example, `value` will be the `{module, function}` tuple\nin the code above:\n\n    Registry.dispatch(Registry.DispatcherTest, \"hello\", fn entries ->\n      for {pid, {module, function}} <- entries, do: apply(module, function, [pid])\n    end)\n    # Prints #PID<...> where the PID is for the process that called register/3 above\n    #=> :ok\n\nDispatching happens in the process that calls `dispatch/3` either serially or\nconcurrently in case of multiple partitions (via spawned tasks). The\nregistered processes are not involved in dispatching unless involving them is\ndone explicitly (for example, by sending them a message in the callback).\n\nFurthermore, if there is a failure when dispatching, due to a bad\nregistration, dispatching will always fail and the registered process will not\nbe notified. Therefore let's make sure we at least wrap and report those\nerrors:\n\n    require Logger\n\n    Registry.dispatch(Registry.DispatcherTest, \"hello\", fn entries ->\n      for {pid, {module, function}} <- entries do\n        try do\n          apply(module, function, [pid])\n        catch\n          kind, reason ->\n            formatted = Exception.format(kind, reason, __STACKTRACE__)\n            Logger.error(\"Registry.dispatch/3 failed with #{formatted}\")\n        end\n      end\n    end)\n    # Prints #PID<...>\n    #=> :ok\n\nYou could also replace the whole `apply` system by explicitly sending\nmessages. That's the example we will see next.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Registry"}
{"completion":"Using as a PubSub\n\nRegistries can also be used to implement a local, non-distributed, scalable\nPubSub by relying on the `dispatch/3` function, similarly to the previous\nsection: in this case, however, we will send messages to each associated\nprocess, instead of invoking a given module-function.\n\nIn this example, we will also set the number of partitions to the number of\nschedulers online, which will make the registry more performant on highly\nconcurrent environments:\n\n    {:ok, _} =\n      Registry.start_link(\n        keys: :duplicate,\n        name: Registry.PubSubTest,\n        partitions: System.schedulers_online()\n      )\n\n    {:ok, _} = Registry.register(Registry.PubSubTest, \"hello\", [])\n\n    Registry.dispatch(Registry.PubSubTest, \"hello\", fn entries ->\n      for {pid, _} <- entries, do: send(pid, {:broadcast, \"world\"})\n    end)\n    #=> :ok\n\nThe example above broadcasted the message `{:broadcast, \"world\"}` to all\nprocesses registered under the \"topic\" (or \"key\" as we called it until now)\n`\"hello\"`.\n\nThe third argument given to `register/3` is a value associated to the\ncurrent process. While in the previous section we used it when dispatching,\nin this particular example we are not interested in it, so we have set it\nto an empty list. You could store a more meaningful value if necessary.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Registry"}
{"completion":"Registrations\n\nLooking up, dispatching and registering are efficient and immediate at\nthe cost of delayed unsubscription. For example, if a process crashes,\nits keys are automatically removed from the registry but the change may\nnot propagate immediately. This means certain operations may return processes\nthat are already dead. When such may happen, it will be explicitly stated\nin the function documentation.\n\nHowever, keep in mind those cases are typically not an issue. After all, a\nprocess referenced by a PID may crash at any time, including between getting\nthe value from the registry and sending it a message. Many parts of the standard\nlibrary are designed to cope with that, such as `Process.monitor/1` which will\ndeliver the `:DOWN` message immediately if the monitored process is already dead\nand `send/2` which acts as a no-op for dead processes.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Registry"}
{"completion":"ETS\n\nNote that the registry uses one ETS table plus two ETS tables per partition.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Registry"}
{"completion":"Generic API for sets.\n\nThis module is deprecated, use the `MapSet` module instead.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Set"}
{"completion":"Chunks the `enum` by buffering elements for which `fun` returns the same value.\n\nElements are only emitted when `fun` returns a new value or the `enum` finishes.\n\n## Examples\n\n    iex> stream = Stream.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) == 1))\n    iex> Enum.to_list(stream)\n    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]","prompt":"Can you write a docstring for the following Elixir function? chunk_by(enum, fun)"}
{"completion":"Shortcut to `chunk_every(enum, count, count)`.","prompt":"Can you write a docstring for the following Elixir function? chunk_every(enum, count)"}
{"completion":"Streams the enumerable in chunks, containing `count` elements each,\nwhere each new chunk starts `step` elements into the enumerable.\n\n`step` is optional and, if not passed, defaults to `count`, i.e.\nchunks do not overlap.\n\nIf the last chunk does not have `count` elements to fill the chunk,\nelements are taken from `leftover` to fill in the chunk. If `leftover`\ndoes not have enough elements to fill the chunk, then a partial chunk\nis returned with less than `count` elements.\n\nIf `:discard` is given in `leftover`, the last chunk is discarded\nunless it has exactly `count` elements.\n\n## Examples\n\n    iex> Stream.chunk_every([1, 2, 3, 4, 5, 6], 2) |> Enum.to_list()\n    [[1, 2], [3, 4], [5, 6]]\n\n    iex> Stream.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, :discard) |> Enum.to_list()\n    [[1, 2, 3], [3, 4, 5]]\n\n    iex> Stream.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, [7]) |> Enum.to_list()\n    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n\n    iex> Stream.chunk_every([1, 2, 3, 4, 5, 6], 3, 3, []) |> Enum.to_list()\n    [[1, 2, 3], [4, 5, 6]]\n\n    iex> Stream.chunk_every([1, 2, 3, 4], 3, 3, Stream.cycle([0])) |> Enum.to_list()\n    [[1, 2, 3], [4, 0, 0]]","prompt":"Can you write a docstring for the following Elixir function? chunk_every(enum, count, step, leftover \\\\ [])"}
{"completion":"Chunks the `enum` with fine grained control when every chunk is emitted.\n\n`chunk_fun` receives the current element and the accumulator and\nmust return `{:cont, element, acc}` to emit the given chunk and\ncontinue with accumulator or `{:cont, acc}` to not emit any chunk\nand continue with the return accumulator.\n\n`after_fun` is invoked when iteration is done and must also return\n`{:cont, element, acc}` or `{:cont, acc}`.\n\n## Examples\n\n    iex> chunk_fun = fn element, acc ->\n    ...>   if rem(element, 2) == 0 do\n    ...>     {:cont, Enum.reverse([element | acc]), []}\n    ...>   else\n    ...>     {:cont, [element | acc]}\n    ...>   end\n    ...> end\n    iex> after_fun = fn\n    ...>   [] -> {:cont, []}\n    ...>   acc -> {:cont, Enum.reverse(acc), []}\n    ...> end\n    iex> stream = Stream.chunk_while(1..10, [], chunk_fun, after_fun)\n    iex> Enum.to_list(stream)\n    [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]","prompt":"Can you write a docstring for the following Elixir function? chunk_while(enum, acc, chunk_fun, after_fun)"}
{"completion":"Creates a stream that enumerates each enumerable in an enumerable.\n\n## Examples\n\n    iex> stream = Stream.concat([1..3, 4..6, 7..9])\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]","prompt":"Can you write a docstring for the following Elixir function? concat(enumerables)"}
{"completion":"Creates a stream that enumerates the first argument, followed by the second.\n\n## Examples\n\n    iex> stream = Stream.concat(1..3, 4..6)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5, 6]\n\n    iex> stream1 = Stream.cycle([1, 2, 3])\n    iex> stream2 = Stream.cycle([4, 5, 6])\n    iex> stream = Stream.concat(stream1, stream2)\n    iex> Enum.take(stream, 6)\n    [1, 2, 3, 1, 2, 3]","prompt":"Can you write a docstring for the following Elixir function? concat(first, second)"}
{"completion":"Creates a stream that cycles through the given enumerable,\ninfinitely.\n\n## Examples\n\n    iex> stream = Stream.cycle([1, 2, 3])\n    iex> Enum.take(stream, 5)\n    [1, 2, 3, 1, 2]","prompt":"Can you write a docstring for the following Elixir function? cycle(enumerable)"}
{"completion":"Creates a stream that only emits elements if they are different from the last emitted element.\n\nThis function only ever needs to store the last emitted element.\n\nElements are compared using `===/2`.\n\n## Examples\n\n    iex> Stream.dedup([1, 2, 3, 3, 2, 1]) |> Enum.to_list()\n    [1, 2, 3, 2, 1]","prompt":"Can you write a docstring for the following Elixir function? dedup(enum)"}
{"completion":"Creates a stream that only emits elements if the result of calling `fun` on the element is\ndifferent from the (stored) result of calling `fun` on the last emitted element.\n\n## Examples\n\n    iex> Stream.dedup_by([{1, :x}, {2, :y}, {2, :z}, {1, :x}], fn {x, _} -> x end) |> Enum.to_list()\n    [{1, :x}, {2, :y}, {1, :x}]","prompt":"Can you write a docstring for the following Elixir function? dedup_by(enum, fun)"}
{"completion":"Lazily drops the next `n` elements from the enumerable.\n\nIf a negative `n` is given, it will drop the last `n` elements from\nthe collection. Note that the mechanism by which this is implemented\nwill delay the emission of any element until `n` additional elements have\nbeen emitted by the enum.\n\n## Examples\n\n    iex> stream = Stream.drop(1..10, 5)\n    iex> Enum.to_list(stream)\n    [6, 7, 8, 9, 10]\n\n    iex> stream = Stream.drop(1..10, -5)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]","prompt":"Can you write a docstring for the following Elixir function? drop(enum, n)"}
{"completion":"Creates a stream that drops every `nth` element from the enumerable.\n\nThe first element is always dropped, unless `nth` is 0.\n\n`nth` must be a non-negative integer.\n\n## Examples\n\n    iex> stream = Stream.drop_every(1..10, 2)\n    iex> Enum.to_list(stream)\n    [2, 4, 6, 8, 10]\n\n    iex> stream = Stream.drop_every(1..1000, 1)\n    iex> Enum.to_list(stream)\n    []\n\n    iex> stream = Stream.drop_every([1, 2, 3, 4, 5], 0)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]","prompt":"Can you write a docstring for the following Elixir function? drop_every(enum, nth)"}
{"completion":"Lazily drops elements of the enumerable while the given\nfunction returns a truthy value.\n\n## Examples\n\n    iex> stream = Stream.drop_while(1..10, &(&1 <= 5))\n    iex> Enum.to_list(stream)\n    [6, 7, 8, 9, 10]","prompt":"Can you write a docstring for the following Elixir function? drop_while(enum, fun)"}
{"completion":"Duplicates the given element `n` times in a stream.\n\n`n` is an integer greater than or equal to `0`.\n\nIf `n` is `0`, an empty stream is returned.\n\n## Examples\n\n    iex> stream = Stream.duplicate(\"hello\", 0)\n    iex> Enum.to_list(stream)\n    []\n\n    iex> stream = Stream.duplicate(\"hi\", 1)\n    iex> Enum.to_list(stream)\n    [\"hi\"]\n\n    iex> stream = Stream.duplicate(\"bye\", 2)\n    iex> Enum.to_list(stream)\n    [\"bye\", \"bye\"]\n\n    iex> stream = Stream.duplicate([1, 2], 3)\n    iex> Enum.to_list(stream)\n    [[1, 2], [1, 2], [1, 2]]","prompt":"Can you write a docstring for the following Elixir function? duplicate(value, n)"}
{"completion":"Executes the given function for each element.\n\nThe values in the stream do not change, therefore this\nfunction is useful for adding side effects (like printing)\nto a stream. See `map/2` if producing a different stream\nis desired.\n\n## Examples\n\n    iex> stream = Stream.each([1, 2, 3], fn x -> send(self(), x) end)\n    iex> Enum.to_list(stream)\n    iex> receive do: (x when is_integer(x) -> x)\n    1\n    iex> receive do: (x when is_integer(x) -> x)\n    2\n    iex> receive do: (x when is_integer(x) -> x)\n    3","prompt":"Can you write a docstring for the following Elixir function? each(enum, fun)"}
{"completion":"Creates a stream that filters elements according to\nthe given function on enumeration.\n\n## Examples\n\n    iex> stream = Stream.filter([1, 2, 3], fn x -> rem(x, 2) == 0 end)\n    iex> Enum.to_list(stream)\n    [2]","prompt":"Can you write a docstring for the following Elixir function? filter(enum, fun)"}
{"completion":"Maps the given `fun` over `enumerable` and flattens the result.\n\nThis function returns a new stream built by appending the result of invoking `fun`\non each element of `enumerable` together.\n\n## Examples\n\n    iex> stream = Stream.flat_map([1, 2, 3], fn x -> [x, x * 2] end)\n    iex> Enum.to_list(stream)\n    [1, 2, 2, 4, 3, 6]\n\n    iex> stream = Stream.flat_map([1, 2, 3], fn x -> [[x]] end)\n    iex> Enum.to_list(stream)\n    [[1], [2], [3]]","prompt":"Can you write a docstring for the following Elixir function? flat_map(enum, mapper)"}
{"completion":"Lazily intersperses `intersperse_element` between each element of the enumeration.\n\n## Examples\n\n    iex> Stream.intersperse([1, 2, 3], 0) |> Enum.to_list()\n    [1, 0, 2, 0, 3]\n\n    iex> Stream.intersperse([1], 0) |> Enum.to_list()\n    [1]\n\n    iex> Stream.intersperse([], 0) |> Enum.to_list()\n    []","prompt":"Can you write a docstring for the following Elixir function? intersperse(enumerable, intersperse_element)"}
{"completion":"Creates a stream that emits a value after the given period `n`\nin milliseconds.\n\nThe values emitted are an increasing counter starting at `0`.\nThis operation will block the caller by the given interval\nevery time a new element is streamed.\n\nDo not use this function to generate a sequence of numbers.\nIf blocking the caller process is not necessary, use\n`Stream.iterate(0, & &1 + 1)` instead.\n\n## Examples\n\n    iex> Stream.interval(10) |> Enum.take(10)\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]","prompt":"Can you write a docstring for the following Elixir function? interval(n)"}
{"completion":"Injects the stream values into the given collectable as a side-effect.\n\nThis function is often used with `run/1` since any evaluation\nis delayed until the stream is executed. See `run/1` for an example.","prompt":"Can you write a docstring for the following Elixir function? into(enum, collectable, transform \\\\ fn x -> x end)"}
{"completion":"Emits a sequence of values, starting with `start_value`. Successive\nvalues are generated by calling `next_fun` on the previous value.\n\n## Examples\n\n    iex> Stream.iterate(0, &(&1 + 1)) |> Enum.take(5)\n    [0, 1, 2, 3, 4]","prompt":"Can you write a docstring for the following Elixir function? iterate(start_value, next_fun)"}
{"completion":"Creates a stream that will apply the given function on\nenumeration.\n\n## Examples\n\n    iex> stream = Stream.map([1, 2, 3], fn x -> x * 2 end)\n    iex> Enum.to_list(stream)\n    [2, 4, 6]","prompt":"Can you write a docstring for the following Elixir function? map(enum, fun)"}
{"completion":"Creates a stream that will apply the given function on\nevery `nth` element from the enumerable.\n\nThe first element is always passed to the given function.\n\n`nth` must be a non-negative integer.\n\n## Examples\n\n    iex> stream = Stream.map_every(1..10, 2, fn x -> x * 2 end)\n    iex> Enum.to_list(stream)\n    [2, 2, 6, 4, 10, 6, 14, 8, 18, 10]\n\n    iex> stream = Stream.map_every([1, 2, 3, 4, 5], 1, fn x -> x * 2 end)\n    iex> Enum.to_list(stream)\n    [2, 4, 6, 8, 10]\n\n    iex> stream = Stream.map_every(1..5, 0, fn x -> x * 2 end)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]","prompt":"Can you write a docstring for the following Elixir function? map_every(enum, nth, fun)"}
{"completion":"Creates a stream that will reject elements according to\nthe given function on enumeration.\n\n## Examples\n\n    iex> stream = Stream.reject([1, 2, 3], fn x -> rem(x, 2) == 0 end)\n    iex> Enum.to_list(stream)\n    [1, 3]","prompt":"Can you write a docstring for the following Elixir function? reject(enum, fun)"}
{"completion":"Returns a stream generated by calling `generator_fun` repeatedly.\n\n## Examples\n\n    # Although not necessary, let's seed the random algorithm\n    iex> :rand.seed(:exsss, {1, 2, 3})\n    iex> Stream.repeatedly(&:rand.uniform/0) |> Enum.take(3)\n    [0.5455598952593053, 0.6039309974353404, 0.6684893034823949]","prompt":"Can you write a docstring for the following Elixir function? repeatedly(generator_fun)"}
{"completion":"Emits a sequence of values for the given resource.\n\nSimilar to `transform/3` but the initial accumulated value is\ncomputed lazily via `start_fun` and executes an `after_fun` at\nthe end of enumeration (both in cases of success and failure).\n\nSuccessive values are generated by calling `next_fun` with the\nprevious accumulator (the initial value being the result returned\nby `start_fun`) and it must return a tuple containing a list\nof elements to be emitted and the next accumulator. The enumeration\nfinishes if it returns `{:halt, acc}`.\n\nAs the name says, this function is useful to stream values from\nresources.\n\n## Examples\n\n    Stream.resource(\n      fn -> File.open!(\"sample\") end,\n      fn file ->\n        case IO.read(file, :line) do\n          data when is_binary(data) -> {[data], file}\n          _ -> {:halt, file}\n        end\n      end,\n      fn file -> File.close(file) end\n    )\n\n    iex> Stream.resource(\n    ...>  fn ->\n    ...>    {:ok, pid} = StringIO.open(\"string\")\n    ...>    pid\n    ...>  end,\n    ...>  fn pid ->\n    ...>    case IO.getn(pid, \"\", 1) do\n    ...>      :eof -> {:halt, pid}\n    ...>      char -> {[char], pid}\n    ...>    end\n    ...>  end,\n    ...>  fn pid -> StringIO.close(pid) end\n    ...> ) |> Enum.to_list()\n    [\"s\", \"t\", \"r\", \"i\", \"n\", \"g\"]","prompt":"Can you write a docstring for the following Elixir function? resource(start_fun, next_fun, after_fun)"}
{"completion":"Runs the given stream.\n\nThis is useful when a stream needs to be run, for side effects,\nand there is no interest in its return result.\n\n## Examples\n\nOpen up a file, replace all `#` by `%` and stream to another file\nwithout loading the whole file in memory:\n\n    File.stream!(\"/path/to/file\")\n    |> Stream.map(&String.replace(&1, \"#\", \"%\"))\n    |> Stream.into(File.stream!(\"/path/to/other/file\"))\n    |> Stream.run()\n\nNo computation will be done until we call one of the `Enum` functions\nor `run/1`.","prompt":"Can you write a docstring for the following Elixir function? run(stream)"}
{"completion":"Creates a stream that applies the given function to each\nelement, emits the result and uses the same result as the accumulator\nfor the next computation. Uses the first element in the enumerable\nas the starting value.\n\n## Examples\n\n    iex> stream = Stream.scan(1..5, &(&1 + &2))\n    iex> Enum.to_list(stream)\n    [1, 3, 6, 10, 15]","prompt":"Can you write a docstring for the following Elixir function? scan(enum, fun)"}
{"completion":"Creates a stream that applies the given function to each\nelement, emits the result and uses the same result as the accumulator\nfor the next computation. Uses the given `acc` as the starting value.\n\n## Examples\n\n    iex> stream = Stream.scan(1..5, 0, &(&1 + &2))\n    iex> Enum.to_list(stream)\n    [1, 3, 6, 10, 15]","prompt":"Can you write a docstring for the following Elixir function? scan(enum, acc, fun)"}
{"completion":"Lazily takes the next `count` elements from the enumerable and stops\nenumeration.\n\nIf a negative `count` is given, the last `count` values will be taken.\nFor such, the collection is fully enumerated keeping up to `2 * count`\nelements in memory. Once the end of the collection is reached,\nthe last `count` elements will be executed. Therefore, using\na negative `count` on an infinite collection will never return.\n\n## Examples\n\n    iex> stream = Stream.take(1..100, 5)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]\n\n    iex> stream = Stream.take(1..100, -5)\n    iex> Enum.to_list(stream)\n    [96, 97, 98, 99, 100]\n\n    iex> stream = Stream.cycle([1, 2, 3]) |> Stream.take(5)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 1, 2]","prompt":"Can you write a docstring for the following Elixir function? take(enum, count)"}
{"completion":"Creates a stream that takes every `nth` element from the enumerable.\n\nThe first element is always included, unless `nth` is 0.\n\n`nth` must be a non-negative integer.\n\n## Examples\n\n    iex> stream = Stream.take_every(1..10, 2)\n    iex> Enum.to_list(stream)\n    [1, 3, 5, 7, 9]\n\n    iex> stream = Stream.take_every([1, 2, 3, 4, 5], 1)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]\n\n    iex> stream = Stream.take_every(1..1000, 0)\n    iex> Enum.to_list(stream)\n    []","prompt":"Can you write a docstring for the following Elixir function? take_every(enum, nth)"}
{"completion":"Lazily takes elements of the enumerable while the given\nfunction returns a truthy value.\n\n## Examples\n\n    iex> stream = Stream.take_while(1..100, &(&1 <= 5))\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]","prompt":"Can you write a docstring for the following Elixir function? take_while(enum, fun)"}
{"completion":"Creates a stream that emits a single value after `n` milliseconds.\n\nThe value emitted is `0`. This operation will block the caller by\nthe given time until the element is streamed.\n\n## Examples\n\n    iex> Stream.timer(10) |> Enum.to_list()\n    [0]","prompt":"Can you write a docstring for the following Elixir function? timer(n)"}
{"completion":"Transforms an existing stream.\n\nIt expects an accumulator and a function that receives two arguments,\nthe stream element and the updated accumulator. It must return a tuple,\nwhere the first element is a new stream (often a list) or the atom `:halt`,\nand the second element is the accumulator to be used by the next element.\n\nNote: this function is equivalent to `Enum.flat_map_reduce/3`, except this\nfunction does not return the accumulator once the stream is processed.\n\n## Examples\n\n`Stream.transform/3` is useful as it can be used as the basis to implement\nmany of the functions defined in this module. For example, we can implement\n`Stream.take(enum, n)` as follows:\n\n    iex> enum = 1001..9999\n    iex> n = 3\n    iex> stream = Stream.transform(enum, 0, fn i, acc ->\n    ...>   if acc < n, do: {[i], acc + 1}, else: {:halt, acc}\n    ...> end)\n    iex> Enum.to_list(stream)\n    [1001, 1002, 1003]\n\n`Stream.transform/5` further generalizes this function to allow wrapping\naround resources.","prompt":"Can you write a docstring for the following Elixir function? transform(enum, acc, reducer)"}
{"completion":"Similar to `Stream.transform/5`, except `last_fun` is not supplied.\n\nThis function can be seen as a combination of `Stream.resource/3` with\n`Stream.transform/3`.","prompt":"Can you write a docstring for the following Elixir function? transform(enum, start_fun, reducer, after_fun)"}
{"completion":"Transforms an existing stream with function-based start, last, and after\ncallbacks.\n\nOnce transformation starts, `start_fun` is invoked to compute the initial\naccumulator. Then, for each element in the enumerable, the `reducer` function\nis invoked with the element and the accumulator, returning new elements and a\nnew accumulator, as in `transform/3`.\n\nOnce the collection is done, `last_fun` is invoked with the accumulator to\nemit any remaining items. Then `after_fun` is invoked, to close any resource,\nbut not emitting any new items. `last_fun` is only invoked if the given\nenumerable terminates successfully (either because it is done or it halted\nitself). `after_fun` is always invoked, therefore `after_fun` must be the\none used for closing resources.","prompt":"Can you write a docstring for the following Elixir function? transform(enum, start_fun, reducer, last_fun, after_fun)"}
{"completion":"Emits a sequence of values for the given accumulator.\n\nSuccessive values are generated by calling `next_fun` with the previous\naccumulator and it must return a tuple with the current value and next\naccumulator. The enumeration finishes if it returns `nil`.\n\n## Examples\n\n    iex> Stream.unfold(5, fn\n    ...>   0 -> nil\n    ...>   n -> {n, n - 1}\n    ...> end) |> Enum.to_list()\n    [5, 4, 3, 2, 1]","prompt":"Can you write a docstring for the following Elixir function? unfold(next_acc, next_fun)"}
{"completion":"Creates a stream that only emits elements if they are unique.\n\nKeep in mind that, in order to know if an element is unique\nor not, this function needs to store all unique values emitted\nby the stream. Therefore, if the stream is infinite, the number\nof elements stored will grow infinitely, never being garbage-collected.\n\n## Examples\n\n    iex> Stream.uniq([1, 2, 3, 3, 2, 1]) |> Enum.to_list()\n    [1, 2, 3]","prompt":"Can you write a docstring for the following Elixir function? uniq(enum)"}
{"completion":"Creates a stream that only emits elements if they are unique, by removing the\nelements for which function `fun` returned duplicate elements.\n\nThe function `fun` maps every element to a term which is used to\ndetermine if two elements are duplicates.\n\nKeep in mind that, in order to know if an element is unique\nor not, this function needs to store all unique values emitted\nby the stream. Therefore, if the stream is infinite, the number\nof elements stored will grow infinitely, never being garbage-collected.\n\n## Example\n\n    iex> Stream.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end) |> Enum.to_list()\n    [{1, :x}, {2, :y}]\n\n    iex> Stream.uniq_by([a: {:tea, 2}, b: {:tea, 2}, c: {:coffee, 1}], fn {_, y} -> y end) |> Enum.to_list()\n    [a: {:tea, 2}, c: {:coffee, 1}]","prompt":"Can you write a docstring for the following Elixir function? uniq_by(enum, fun)"}
{"completion":"Creates a stream where each element in the enumerable will\nbe wrapped in a tuple alongside its index.\n\nIf an `offset` is given, we will index from the given offset instead of from zero.\n\n## Examples\n\n    iex> stream = Stream.with_index([1, 2, 3])\n    iex> Enum.to_list(stream)\n    [{1, 0}, {2, 1}, {3, 2}]\n\n    iex> stream = Stream.with_index([1, 2, 3], 3)\n    iex> Enum.to_list(stream)\n    [{1, 3}, {2, 4}, {3, 5}]","prompt":"Can you write a docstring for the following Elixir function? with_index(enum, offset \\\\ 0)"}
{"completion":"Zips corresponding elements from a finite collection of enumerables\ninto one stream of tuples.\n\nThe zipping finishes as soon as any enumerable in the given collection completes.\n\n## Examples\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> cycle = Stream.cycle([\"foo\", \"bar\", \"baz\"])\n    iex> Stream.zip([concat, [:a, :b, :c], cycle]) |> Enum.to_list()\n    [{1, :a, \"foo\"}, {2, :b, \"bar\"}, {3, :c, \"baz\"}]","prompt":"Can you write a docstring for the following Elixir function? zip(enumerables)"}
{"completion":"Zips two enumerables together, lazily.\n\nThe zipping finishes as soon as either enumerable completes.\n\n## Examples\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> cycle = Stream.cycle([:a, :b, :c])\n    iex> Stream.zip(concat, cycle) |> Enum.to_list()\n    [{1, :a}, {2, :b}, {3, :c}, {4, :a}, {5, :b}, {6, :c}]","prompt":"Can you write a docstring for the following Elixir function? zip(enumerable1, enumerable2)"}
{"completion":"Lazily zips corresponding elements from a finite collection of enumerables into a new\nenumerable, transforming them with the `zip_fun` function as it goes.\n\nThe first element from each of the enums in `enumerables` will be put into a list which is then passed to\nthe one-arity `zip_fun` function. Then, the second elements from each of the enums are put into a list and passed to\n`zip_fun`, and so on until any one of the enums in `enumerables` completes.\n\nReturns a new enumerable with the results of calling `zip_fun`.\n\n## Examples\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> Stream.zip_with([concat, concat], fn [a, b] -> a + b end) |> Enum.to_list()\n    [2, 4, 6, 8, 10, 12]\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> Stream.zip_with([concat, concat, 1..3], fn [a, b, c] -> a + b + c end) |> Enum.to_list()\n    [3, 6, 9]","prompt":"Can you write a docstring for the following Elixir function? zip_with(enumerables, zip_fun)"}
{"completion":"Lazily zips corresponding elements from two enumerables into a new one, transforming them with\nthe `zip_fun` function as it goes.\n\nThe `zip_fun` will be called with the first element from `enumerable1` and the first\nelement from `enumerable2`, then with the second element from each, and so on until\neither one of the enumerables completes.\n\n## Examples\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> Stream.zip_with(concat, concat, fn a, b -> a + b end) |> Enum.to_list()\n    [2, 4, 6, 8, 10, 12]","prompt":"Can you write a docstring for the following Elixir function? zip_with(enumerable1, enumerable2, zip_fun)"}
{"completion":"Functions for creating and composing streams.\n\nStreams are composable, lazy enumerables (for an introduction on\nenumerables, see the `Enum` module). Any enumerable that generates\nelements one by one during enumeration is called a stream. For example,\nElixir's `Range` is a stream:\n\n    iex> range = 1..5\n    1..5\n    iex> Enum.map(range, &(&1 * 2))\n    [2, 4, 6, 8, 10]\n\nIn the example above, as we mapped over the range, the elements being\nenumerated were created one by one, during enumeration. The `Stream`\nmodule allows us to map the range, without triggering its enumeration:\n\n    iex> range = 1..3\n    iex> stream = Stream.map(range, &(&1 * 2))\n    iex> Enum.map(stream, &(&1 + 1))\n    [3, 5, 7]\n\nNote that we started with a range and then we created a stream that is\nmeant to multiply each element in the range by 2. At this point, no\ncomputation was done. Only when `Enum.map/2` is called we actually\nenumerate over each element in the range, multiplying it by 2 and adding 1.\nWe say the functions in `Stream` are *lazy* and the functions in `Enum`\nare *eager*.\n\nDue to their laziness, streams are useful when working with large\n(or even infinite) collections. When chaining many operations with `Enum`,\nintermediate lists are created, while `Stream` creates a recipe of\ncomputations that are executed at a later moment. Let's see another\nexample:\n\n    1..3\n    |> Enum.map(&IO.inspect(&1))\n    |> Enum.map(&(&1 * 2))\n    |> Enum.map(&IO.inspect(&1))\n    1\n    2\n    3\n    2\n    4\n    6\n    #=> [2, 4, 6]\n\nNote that we first printed each element in the list, then multiplied each\nelement by 2 and finally printed each new value. In this example, the list\nwas enumerated three times. Let's see an example with streams:\n\n    stream = 1..3\n    |> Stream.map(&IO.inspect(&1))\n    |> Stream.map(&(&1 * 2))\n    |> Stream.map(&IO.inspect(&1))\n    Enum.to_list(stream)\n    1\n    2\n    2\n    4\n    3\n    6\n    #=> [2, 4, 6]\n\nAlthough the end result is the same, the order in which the elements were\nprinted changed! With streams, we print the first element and then print\nits double. In this example, the list was enumerated just once!\n\nThat's what we meant when we said earlier that streams are composable,\nlazy enumerables. Note that we could call `Stream.map/2` multiple times,\neffectively composing the streams and keeping them lazy. The computations\nare only performed when you call a function from the `Enum` module.\n\nLike with `Enum`, the functions in this module work in linear time. This\nmeans that, the time it takes to perform an operation grows at the same\nrate as the length of the list. This is expected on operations such as\n`Stream.map/2`. After all, if we want to traverse every element on a\nstream, the longer the stream, the more elements we need to traverse,\nand the longer it will take.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Stream"}
{"completion":"Creating Streams\n\nThere are many functions in Elixir's standard library that return\nstreams, some examples are:\n\n  * `IO.stream/2`         - streams input lines, one by one\n  * `URI.query_decoder/1` - decodes a query string, pair by pair\n\nThis module also provides many convenience functions for creating streams,\nlike `Stream.cycle/1`, `Stream.unfold/2`, `Stream.resource/3` and more.\n\nNote the functions in this module are guaranteed to return enumerables.\nSince enumerables can have different shapes (structs, anonymous functions,\nand so on), the functions in this module may return any of those shapes\nand this may change at any time. For example, a function that today\nreturns an anonymous function may return a struct in future releases.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Stream"}
{"completion":"Converts `term` to a string.","prompt":"Can you write a docstring for the following Elixir function? to_string(term)"}
{"completion":"The `String.Chars` protocol is responsible for\nconverting a structure to a binary (only if applicable).\n\nThe only function required to be implemented is\n`to_string/1`, which does the conversion.\n\nThe `to_string/1` function automatically imported\nby `Kernel` invokes this protocol. String\ninterpolation also invokes `to_string/1` in its\narguments. For example, `\"foo#{bar}\"` is the same\nas `\"foo\" <> to_string(bar)`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.String.Chars"}
{"completion":"Returns the grapheme at the `position` of the given UTF-8 `string`.\nIf `position` is greater than `string` length, then it returns `nil`.\n\n## Examples\n\n    iex> String.at(\"elixir\", 0)\n    \"e\"\n\n    iex> String.at(\"elixir\", 1)\n    \"l\"\n\n    iex> String.at(\"elixir\", 10)\n    nil\n\n    iex> String.at(\"elixir\", -1)\n    \"r\"\n\n    iex> String.at(\"elixir\", -10)\n    nil","prompt":"Can you write a docstring for the following Elixir function? at(string, position)"}
{"completion":"Computes the bag distance between two strings.\n\nReturns a float value between 0 and 1 representing the bag\ndistance between `string1` and `string2`.\n\nThe bag distance is meant to be an efficient approximation\nof the distance between two strings to quickly rule out strings\nthat are largely different.\n\nThe algorithm is outlined in the \"String Matching with Metric\nTrees Using an Approximate Distance\" paper by Ilaria Bartolini,\nPaolo Ciaccia, and Marco Patella.\n\n## Examples\n\n    iex> String.bag_distance(\"abc\", \"\")\n    0.0\n    iex> String.bag_distance(\"abcd\", \"a\")\n    0.25\n    iex> String.bag_distance(\"abcd\", \"ab\")\n    0.5\n    iex> String.bag_distance(\"abcd\", \"abc\")\n    0.75\n    iex> String.bag_distance(\"abcd\", \"abcd\")\n    1.0","prompt":"Can you write a docstring for the following Elixir function? bag_distance(string1, string2)"}
{"completion":"Converts the first character in the given string to\nuppercase and the remainder to lowercase according to `mode`.\n\n`mode` may be `:default`, `:ascii`, `:greek` or `:turkic`. The `:default` mode considers\nall non-conditional transformations outlined in the Unicode standard. `:ascii`\ncapitalizes only the letters A to Z. `:greek` includes the context sensitive\nmappings found in Greek. `:turkic` properly handles the letter i with the dotless variant.\n\n## Examples\n\n    iex> String.capitalize(\"abcd\")\n    \"Abcd\"\n\n    iex> String.capitalize(\"n\")\n    \"Fin\"\n\n    iex> String.capitalize(\"ol\")\n    \"Ol\"","prompt":"Can you write a docstring for the following Elixir function? capitalize(string, mode \\\\ :default)"}
{"completion":"Splits the string into chunks of characters that share a common trait.\n\nThe trait can be one of two options:\n\n  * `:valid` - the string is split into chunks of valid and invalid\n    character sequences\n\n  * `:printable` - the string is split into chunks of printable and\n    non-printable character sequences\n\nReturns a list of binaries each of which contains only one kind of\ncharacters.\n\nIf the given string is empty, an empty list is returned.\n\n## Examples\n\n    iex> String.chunk(<<?a, ?b, ?c, 0>>, :valid)\n    [\"abc\\0\"]\n\n    iex> String.chunk(<<?a, ?b, ?c, 0, 0xFFFF::utf16>>, :valid)\n    [\"abc\\0\", <<0xFFFF::utf16>>]\n\n    iex> String.chunk(<<?a, ?b, ?c, 0, 0x0FFFF::utf8>>, :printable)\n    [\"abc\", <<0, 0x0FFFF::utf8>>]","prompt":"Can you write a docstring for the following Elixir function? chunk(string, trait)"}
{"completion":"Returns a list of code points encoded as strings.\n\nTo retrieve code points in their natural integer\nrepresentation, see `to_charlist/1`. For details about\ncode points and graphemes, see the `String` module\ndocumentation.\n\n## Examples\n\n    iex> String.codepoints(\"ol\")\n    [\"o\", \"l\", \"\"]\n\n    iex> String.codepoints(\" \")\n    [\"\", \"\", \"\", \"\", \"\", \"\", \" \", \"\", \"\", \"\", \"\", \"\"]\n\n    iex> String.codepoints(\"\")\n    [\"\", \"\", \"\"]\n\n    iex> String.codepoints(\"\\u00e9\")\n    [\"\"]\n\n    iex> String.codepoints(\"\\u0065\\u0301\")\n    [\"e\", \"\"]","prompt":"Can you write a docstring for the following Elixir function? codepoints(string)"}
{"completion":"Searches if `string` contains any of the given `contents`.\n\n`contents` can be either a string, a list of strings,\nor a compiled pattern. If `contents` is a list, this\nfunction will search if any of the strings in `contents`\nare part of `string`.\n\n> Note: if you want to check if `string` is listed in `contents`,\n> where `contents` is a list, use `Enum.member?(contents, string)`\n> instead.\n\n## Examples\n\n    iex> String.contains?(\"elixir of life\", \"of\")\n    true\n    iex> String.contains?(\"elixir of life\", [\"life\", \"death\"])\n    true\n    iex> String.contains?(\"elixir of life\", [\"death\", \"mercury\"])\n    false\n\nThe argument can also be a compiled pattern:\n\n    iex> pattern = :binary.compile_pattern([\"life\", \"death\"])\n    iex> String.contains?(\"elixir of life\", pattern)\n    true\n\nAn empty string will always match:\n\n    iex> String.contains?(\"elixir of life\", \"\")\n    true\n    iex> String.contains?(\"elixir of life\", [\"\", \"other\"])\n    true\n\nAn empty list will never match:\n\n    iex> String.contains?(\"elixir of life\", [])\n    false\n\n    iex> String.contains?(\"\", [])\n    false\n\nBe aware that this function can match within or across grapheme boundaries.\nFor example, take the grapheme \"\" which is made of the characters\n\"e\" and the acute accent. The following returns `true`:\n\n    iex> String.contains?(String.normalize(\"\", :nfd), \"e\")\n    true\n\nHowever, if \"\" is represented by the single character \"e with acute\"\naccent, then it will return `false`:\n\n    iex> String.contains?(String.normalize(\"\", :nfc), \"e\")\n    false","prompt":"Can you write a docstring for the following Elixir function? contains?(string, contents)"}
{"completion":"Converts all characters in the given string to lowercase according to `mode`.\n\n`mode` may be `:default`, `:ascii`, `:greek` or `:turkic`. The `:default` mode considers\nall non-conditional transformations outlined in the Unicode standard. `:ascii`\nlowercases only the letters A to Z. `:greek` includes the context sensitive\nmappings found in Greek. `:turkic` properly handles the letter i with the dotless variant.\n\n## Examples\n\n    iex> String.downcase(\"ABCD\")\n    \"abcd\"\n\n    iex> String.downcase(\"AB 123 XPTO\")\n    \"ab 123 xpto\"\n\n    iex> String.downcase(\"OL\")\n    \"ol\"\n\nThe `:ascii` mode ignores Unicode characters and provides a more\nperformant implementation when you know the string contains only\nASCII characters:\n\n    iex> String.downcase(\"OL\", :ascii)\n    \"ol\"\n\nThe `:greek` mode properly handles the context sensitive sigma in Greek:\n\n    iex> String.downcase(\"\")\n    \"\"\n\n    iex> String.downcase(\"\", :greek)\n    \"\"\n\nAnd `:turkic` properly handles the letter i with the dotless variant:\n\n    iex> String.downcase(\"I\")\n    \"ii\"\n\n    iex> String.downcase(\"I\", :turkic)\n    \"i\"","prompt":"Can you write a docstring for the following Elixir function? downcase(string, mode \\\\ :default)"}
{"completion":"Returns a string `subject` repeated `n` times.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.duplicate(\"abc\", 0)\n    \"\"\n\n    iex> String.duplicate(\"abc\", 1)\n    \"abc\"\n\n    iex> String.duplicate(\"abc\", 2)\n    \"abcabc\"","prompt":"Can you write a docstring for the following Elixir function? duplicate(subject, n)"}
{"completion":"Returns `true` if `string` ends with any of the suffixes given.\n\n`suffixes` can be either a single suffix or a list of suffixes.\n\n## Examples\n\n    iex> String.ends_with?(\"language\", \"age\")\n    true\n    iex> String.ends_with?(\"language\", [\"youth\", \"age\"])\n    true\n    iex> String.ends_with?(\"language\", [\"youth\", \"elixir\"])\n    false\n\nAn empty suffix will always match:\n\n    iex> String.ends_with?(\"language\", \"\")\n    true\n    iex> String.ends_with?(\"language\", [\"\", \"other\"])\n    true","prompt":"Can you write a docstring for the following Elixir function? ends_with?(string, suffix)"}
{"completion":"Returns `true` if `string1` is canonically equivalent to `string2`.\n\nIt performs Normalization Form Canonical Decomposition (NFD) on the\nstrings before comparing them. This function is equivalent to:\n\n    String.normalize(string1, :nfd) == String.normalize(string2, :nfd)\n\nIf you plan to compare multiple strings, multiple times in a row, you\nmay normalize them upfront and compare them directly to avoid multiple\nnormalization passes.\n\n## Examples\n\n    iex> String.equivalent?(\"abc\", \"abc\")\n    true\n\n    iex> String.equivalent?(\"man\\u0303ana\", \"maana\")\n    true\n\n    iex> String.equivalent?(\"abc\", \"ABC\")\n    false\n\n    iex> String.equivalent?(\"n\", \"n\")\n    false","prompt":"Can you write a docstring for the following Elixir function? equivalent?(string1, string2)"}
{"completion":"Returns the first grapheme from a UTF-8 string,\n`nil` if the string is empty.\n\n## Examples\n\n    iex> String.first(\"elixir\")\n    \"e\"\n\n    iex> String.first(\"\")\n    \"\"\n\n    iex> String.first(\"\")\n    nil","prompt":"Can you write a docstring for the following Elixir function? first(string)"}
{"completion":"Returns Unicode graphemes in the string as per Extended Grapheme\nCluster algorithm.\n\nThe algorithm is outlined in the [Unicode Standard Annex #29,\nUnicode Text Segmentation](https://www.unicode.org/reports/tr29/).\n\nFor details about code points and graphemes, see the `String` module documentation.\n\n## Examples\n\n    iex> String.graphemes(\"ave\")\n    [\"\", \"a\", \"\", \"v\", \"e\"]\n\n    iex> String.graphemes(\"\\u00e9\")\n    [\"\"]\n\n    iex> String.graphemes(\"\\u0065\\u0301\")\n    [\"e\"]","prompt":"Can you write a docstring for the following Elixir function? graphemes(string)"}
{"completion":"Computes the Jaro distance (similarity) between two strings.\n\nReturns a float value between `0.0` (equates to no similarity) and `1.0`\n(is an exact match) representing [Jaro](https://en.wikipedia.org/wiki/Jaro-Winkler_distance)\ndistance between `string1` and `string2`.\n\nThe Jaro distance metric is designed and best suited for short\nstrings such as person names. Elixir itself uses this function\nto provide the \"did you mean?\" functionality. For instance, when you\nare calling a function in a module and you have a typo in the\nfunction name, we attempt to suggest the most similar function\nname available, if any, based on the `jaro_distance/2` score.\n\n## Examples\n\n    iex> String.jaro_distance(\"Dwayne\", \"Duane\")\n    0.8222222222222223\n    iex> String.jaro_distance(\"even\", \"odd\")\n    0.0\n    iex> String.jaro_distance(\"same\", \"same\")\n    1.0","prompt":"Can you write a docstring for the following Elixir function? jaro_distance(string1, string2)"}
{"completion":"Returns the last grapheme from a UTF-8 string,\n`nil` if the string is empty.\n\nIt traverses the whole string to find its last grapheme.\n\n## Examples\n\n    iex> String.last(\"\")\n    nil\n\n    iex> String.last(\"elixir\")\n    \"r\"\n\n    iex> String.last(\"\")\n    \"\"","prompt":"Can you write a docstring for the following Elixir function? last(string)"}
{"completion":"Returns the number of Unicode graphemes in a UTF-8 string.\n\n## Examples\n\n    iex> String.length(\"elixir\")\n    6\n\n    iex> String.length(\"\")\n    5","prompt":"Can you write a docstring for the following Elixir function? length(string)"}
{"completion":"Checks if `string` matches the given regular expression.\n\n## Examples\n\n    iex> String.match?(\"foo\", ~r/foo/)\n    true\n\n    iex> String.match?(\"bar\", ~r/foo/)\n    false\n\nElixir also provides text-based match operator `=~/2` and function `Regex.match?/2` as\nalternatives to test strings against regular expressions.","prompt":"Can you write a docstring for the following Elixir function? match?(string, regex)"}
{"completion":"Returns a keyword list that represents an edit script.\n\nCheck `List.myers_difference/2` for more information.\n\n## Examples\n\n    iex> string1 = \"fox hops over the dog\"\n    iex> string2 = \"fox jumps over the lazy cat\"\n    iex> String.myers_difference(string1, string2)\n    [eq: \"fox \", del: \"ho\", ins: \"jum\", eq: \"ps over the \", del: \"dog\", ins: \"lazy cat\"]","prompt":"Can you write a docstring for the following Elixir function? myers_difference(string1, string2)"}
{"completion":"Returns the next code point in a string.\n\nThe result is a tuple with the code point and the\nremainder of the string or `nil` in case\nthe string reached its end.\n\nAs with other functions in the `String` module, `next_codepoint/1`\nworks with binaries that are invalid UTF-8. If the string starts\nwith a sequence of bytes that is not valid in UTF-8 encoding, the\nfirst element of the returned tuple is a binary with the first byte.\n\n## Examples\n\n    iex> String.next_codepoint(\"ol\")\n    {\"o\", \"l\"}\n\n    iex> invalid = \"\\x80\\x80OK\" # first two bytes are invalid in UTF-8\n    iex> {_, rest} = String.next_codepoint(invalid)\n    {<<128>>, <<128, 79, 75>>}\n    iex> String.next_codepoint(rest)\n    {<<128>>, \"OK\"}\n\n## Comparison with binary pattern matching\n\nBinary pattern matching provides a similar way to decompose\na string:\n\n    iex> <<codepoint::utf8, rest::binary>> = \"Elixir\"\n    \"Elixir\"\n    iex> codepoint\n    69\n    iex> rest\n    \"lixir\"\n\nthough not entirely equivalent because `codepoint` comes as\nan integer, and the pattern won't match invalid UTF-8.\n\nBinary pattern matching, however, is simpler and more efficient,\nso pick the option that better suits your use case.","prompt":"Can you write a docstring for the following Elixir function? next_codepoint(arg)"}
{"completion":"Returns the next grapheme in a string.\n\nThe result is a tuple with the grapheme and the\nremainder of the string or `nil` in case\nthe String reached its end.\n\n## Examples\n\n    iex> String.next_grapheme(\"ol\")\n    {\"o\", \"l\"}\n\n    iex> String.next_grapheme(\"\")\n    nil","prompt":"Can you write a docstring for the following Elixir function? next_grapheme(string)"}
{"completion":"Converts all characters in `string` to Unicode normalization\nform identified by `form`.\n\nInvalid Unicode codepoints are skipped and the remaining of\nthe string is converted. If you want the algorithm to stop\nand return on invalid codepoint, use `:unicode.characters_to_nfd_binary/1`,\n`:unicode.characters_to_nfc_binary/1`, `:unicode.characters_to_nfkd_binary/1`,\nand `:unicode.characters_to_nfkc_binary/1` instead.\n\nNormalization forms `:nfkc` and `:nfkd` should not be blindly applied\nto arbitrary text. Because they erase many formatting distinctions,\nthey will prevent round-trip conversion to and from many legacy\ncharacter sets.\n\n## Forms\n\nThe supported forms are:\n\n  * `:nfd` - Normalization Form Canonical Decomposition.\n    Characters are decomposed by canonical equivalence, and\n    multiple combining characters are arranged in a specific\n    order.\n\n  * `:nfc` - Normalization Form Canonical Composition.\n    Characters are decomposed and then recomposed by canonical equivalence.\n\n  * `:nfkd` - Normalization Form Compatibility Decomposition.\n    Characters are decomposed by compatibility equivalence, and\n    multiple combining characters are arranged in a specific\n    order.\n\n  * `:nfkc` - Normalization Form Compatibility Composition.\n    Characters are decomposed and then recomposed by compatibility equivalence.\n\n## Examples\n\n    iex> String.normalize(\"ys\", :nfd)\n    \"yes\"\n\n    iex> String.normalize(\"lena\", :nfc)\n    \"lea\"\n\n    iex> String.normalize(\"\", :nfkd)\n    \"fi\"\n\n    iex> String.normalize(\"fi\", :nfkc)\n    \"fi\"","prompt":"Can you write a docstring for the following Elixir function? normalize(string, form)"}
{"completion":"Returns a new string padded with a leading filler\nwhich is made of elements from the `padding`.\n\nPassing a list of strings as `padding` will take one element of the list\nfor every missing entry. If the list is shorter than the number of inserts,\nthe filling will start again from the beginning of the list.\nPassing a string `padding` is equivalent to passing the list of graphemes in it.\nIf no `padding` is given, it defaults to whitespace.\n\nWhen `count` is less than or equal to the length of `string`,\ngiven `string` is returned.\n\nRaises `ArgumentError` if the given `padding` contains a non-string element.\n\n## Examples\n\n    iex> String.pad_leading(\"abc\", 5)\n    \"  abc\"\n\n    iex> String.pad_leading(\"abc\", 4, \"12\")\n    \"1abc\"\n\n    iex> String.pad_leading(\"abc\", 6, \"12\")\n    \"121abc\"\n\n    iex> String.pad_leading(\"abc\", 5, [\"1\", \"23\"])\n    \"123abc\"","prompt":"Can you write a docstring for the following Elixir function? pad_leading(string, count, padding \\\\ [\" \"])"}
{"completion":"Returns a new string padded with a trailing filler\nwhich is made of elements from the `padding`.\n\nPassing a list of strings as `padding` will take one element of the list\nfor every missing entry. If the list is shorter than the number of inserts,\nthe filling will start again from the beginning of the list.\nPassing a string `padding` is equivalent to passing the list of graphemes in it.\nIf no `padding` is given, it defaults to whitespace.\n\nWhen `count` is less than or equal to the length of `string`,\ngiven `string` is returned.\n\nRaises `ArgumentError` if the given `padding` contains a non-string element.\n\n## Examples\n\n    iex> String.pad_trailing(\"abc\", 5)\n    \"abc  \"\n\n    iex> String.pad_trailing(\"abc\", 4, \"12\")\n    \"abc1\"\n\n    iex> String.pad_trailing(\"abc\", 6, \"12\")\n    \"abc121\"\n\n    iex> String.pad_trailing(\"abc\", 5, [\"1\", \"23\"])\n    \"abc123\"","prompt":"Can you write a docstring for the following Elixir function? pad_trailing(string, count, padding \\\\ [\" \"])"}
{"completion":"Checks if a string contains only printable characters up to `character_limit`.\n\nTakes an optional `character_limit` as a second argument. If `character_limit` is `0`, this\nfunction will return `true`.\n\n## Examples\n\n    iex> String.printable?(\"abc\")\n    true\n\n    iex> String.printable?(\"abc\" <> <<0>>)\n    false\n\n    iex> String.printable?(\"abc\" <> <<0>>, 2)\n    true\n\n    iex> String.printable?(\"abc\" <> <<0>>, 0)\n    true","prompt":"Can you write a docstring for the following Elixir function? printable?(string, character_limit \\\\ :infinity)"}
{"completion":"Returns a new string created by replacing occurrences of `pattern` in\n`subject` with `replacement`.\n\nThe `subject` is always a string.\n\nThe `pattern` may be a string, a list of strings, a regular expression, or a\ncompiled pattern.\n\nThe `replacement` may be a string or a function that receives the matched\npattern and must return the replacement as a string or iodata.\n\nBy default it replaces all occurrences but this behaviour can be controlled\nthrough the `:global` option; see the \"Options\" section below.\n\n## Options\n\n  * `:global` - (boolean) if `true`, all occurrences of `pattern` are replaced\n    with `replacement`, otherwise only the first occurrence is\n    replaced. Defaults to `true`\n\n## Examples\n\n    iex> String.replace(\"a,b,c\", \",\", \"-\")\n    \"a-b-c\"\n\n    iex> String.replace(\"a,b,c\", \",\", \"-\", global: false)\n    \"a-b,c\"\n\nThe pattern may also be a list of strings and the replacement may also\nbe a function that receives the matches:\n\n    iex> String.replace(\"a,b,c\", [\"a\", \"c\"], fn <<char>> -> <<char + 1>> end)\n    \"b,b,d\"\n\nWhen the pattern is a regular expression, one can give `\\N` or\n`\\g{N}` in the `replacement` string to access a specific capture in the\nregular expression:\n\n    iex> String.replace(\"a,b,c\", ~r/,(.)/, \",\\\\1\\\\g{1}\")\n    \"a,bb,cc\"\n\nNote that we had to escape the backslash escape character (i.e., we used `\\\\N`\ninstead of just `\\N` to escape the backslash; same thing for `\\\\g{N}`). By\ngiving `\\0`, one can inject the whole match in the replacement string.\n\nA compiled pattern can also be given:\n\n    iex> pattern = :binary.compile_pattern(\",\")\n    iex> String.replace(\"a,b,c\", pattern, \"[]\")\n    \"a[]b[]c\"\n\nWhen an empty string is provided as a `pattern`, the function will treat it as\nan implicit empty string between each grapheme and the string will be\ninterspersed. If an empty string is provided as `replacement` the `subject`\nwill be returned:\n\n    iex> String.replace(\"ELIXIR\", \"\", \".\")\n    \".E.L.I.X.I.R.\"\n\n    iex> String.replace(\"ELIXIR\", \"\", \"\")\n    \"ELIXIR\"\n\nBe aware that this function can replace within or across grapheme boundaries.\nFor example, take the grapheme \"\" which is made of the characters\n\"e\" and the acute accent. The following will replace only the letter \"e\",\nmoving the accent to the letter \"o\":\n\n    iex> String.replace(String.normalize(\"\", :nfd), \"e\", \"o\")\n    \"o\"\n\nHowever, if \"\" is represented by the single character \"e with acute\"\naccent, then it won't be replaced at all:\n\n    iex> String.replace(String.normalize(\"\", :nfc), \"e\", \"o\")\n    \"\"","prompt":"Can you write a docstring for the following Elixir function? replace(subject, pattern, replacement, options \\\\ [])"}
{"completion":"Replaces all leading occurrences of `match` by `replacement` of `match` in `string`.\n\nReturns the string untouched if there are no occurrences.\n\nIf `match` is `\"\"`, this function raises an `ArgumentError` exception: this\nhappens because this function replaces **all** the occurrences of `match` at\nthe beginning of `string`, and it's impossible to replace \"multiple\"\noccurrences of `\"\"`.\n\n## Examples\n\n    iex> String.replace_leading(\"hello world\", \"hello \", \"\")\n    \"world\"\n    iex> String.replace_leading(\"hello hello world\", \"hello \", \"\")\n    \"world\"\n\n    iex> String.replace_leading(\"hello world\", \"hello \", \"ola \")\n    \"ola world\"\n    iex> String.replace_leading(\"hello hello world\", \"hello \", \"ola \")\n    \"ola ola world\"\n\nThis function can replace across grapheme boundaries. See `replace/3`\nfor more information and examples.","prompt":"Can you write a docstring for the following Elixir function? replace_leading(string, match, replacement)"}
{"completion":"Replaces prefix in `string` by `replacement` if it matches `match`.\n\nReturns the string untouched if there is no match. If `match` is an empty\nstring (`\"\"`), `replacement` is just prepended to `string`.\n\n## Examples\n\n    iex> String.replace_prefix(\"world\", \"hello \", \"\")\n    \"world\"\n    iex> String.replace_prefix(\"hello world\", \"hello \", \"\")\n    \"world\"\n    iex> String.replace_prefix(\"hello hello world\", \"hello \", \"\")\n    \"hello world\"\n\n    iex> String.replace_prefix(\"world\", \"hello \", \"ola \")\n    \"world\"\n    iex> String.replace_prefix(\"hello world\", \"hello \", \"ola \")\n    \"ola world\"\n    iex> String.replace_prefix(\"hello hello world\", \"hello \", \"ola \")\n    \"ola hello world\"\n\n    iex> String.replace_prefix(\"world\", \"\", \"hello \")\n    \"hello world\"\n\nThis function can replace across grapheme boundaries. See `replace/3`\nfor more information and examples.","prompt":"Can you write a docstring for the following Elixir function? replace_prefix(string, match, replacement)"}
{"completion":"Replaces suffix in `string` by `replacement` if it matches `match`.\n\nReturns the string untouched if there is no match. If `match` is an empty\nstring (`\"\"`), `replacement` is just appended to `string`.\n\n## Examples\n\n    iex> String.replace_suffix(\"hello\", \" world\", \"\")\n    \"hello\"\n    iex> String.replace_suffix(\"hello world\", \" world\", \"\")\n    \"hello\"\n    iex> String.replace_suffix(\"hello world world\", \" world\", \"\")\n    \"hello world\"\n\n    iex> String.replace_suffix(\"hello\", \" world\", \" mundo\")\n    \"hello\"\n    iex> String.replace_suffix(\"hello world\", \" world\", \" mundo\")\n    \"hello mundo\"\n    iex> String.replace_suffix(\"hello world world\", \" world\", \" mundo\")\n    \"hello world mundo\"\n\n    iex> String.replace_suffix(\"hello\", \"\", \" world\")\n    \"hello world\"\n\nThis function can replace across grapheme boundaries. See `replace/3`\nfor more information and examples.","prompt":"Can you write a docstring for the following Elixir function? replace_suffix(string, match, replacement)"}
{"completion":"Replaces all trailing occurrences of `match` by `replacement` in `string`.\n\nReturns the string untouched if there are no occurrences.\n\nIf `match` is `\"\"`, this function raises an `ArgumentError` exception: this\nhappens because this function replaces **all** the occurrences of `match` at\nthe end of `string`, and it's impossible to replace \"multiple\" occurrences of\n`\"\"`.\n\n## Examples\n\n    iex> String.replace_trailing(\"hello world\", \" world\", \"\")\n    \"hello\"\n    iex> String.replace_trailing(\"hello world world\", \" world\", \"\")\n    \"hello\"\n\n    iex> String.replace_trailing(\"hello world\", \" world\", \" mundo\")\n    \"hello mundo\"\n    iex> String.replace_trailing(\"hello world world\", \" world\", \" mundo\")\n    \"hello mundo mundo\"\n\nThis function can replace across grapheme boundaries. See `replace/3`\nfor more information and examples.","prompt":"Can you write a docstring for the following Elixir function? replace_trailing(string, match, replacement)"}
{"completion":"Reverses the graphemes in given string.\n\n## Examples\n\n    iex> String.reverse(\"abcd\")\n    \"dcba\"\n\n    iex> String.reverse(\"hello world\")\n    \"dlrow olleh\"\n\n    iex> String.reverse(\"hello og\")\n    \"go olleh\"\n\nKeep in mind reversing the same string twice does\nnot necessarily yield the original string:\n\n    iex> \"e\"\n    \"e\"\n    iex> String.reverse(\"e\")\n    \"e\"\n    iex> String.reverse(String.reverse(\"e\"))\n    \"e\"\n\nIn the first example the accent is before the vowel, so\nit is considered two graphemes. However, when you reverse\nit once, you have the vowel followed by the accent, which\nbecomes one grapheme. Reversing it again will keep it as\none single grapheme.","prompt":"Can you write a docstring for the following Elixir function? reverse(string)"}
{"completion":"Returns a substring from the offset given by the start of the\nrange to the offset given by the end of the range.\n\nIf the start of the range is not a valid offset for the given\nstring or if the range is in reverse order, returns `\"\"`.\n\nIf the start or end of the range is negative, the whole string\nis traversed first in order to convert the negative indices into\npositive ones.\n\nRemember this function works with Unicode graphemes and considers\nthe slices to represent grapheme offsets. If you want to split\non raw bytes, check `Kernel.binary_part/3` or\n`Kernel.binary_slice/2` instead\n\n## Examples\n\n    iex> String.slice(\"elixir\", 1..3)\n    \"lix\"\n    iex> String.slice(\"elixir\", 1..10)\n    \"lixir\"\n\n    iex> String.slice(\"elixir\", -4..-1)\n    \"ixir\"\n    iex> String.slice(\"elixir\", -4..6)\n    \"ixir\"\n    iex> String.slice(\"elixir\", -100..100)\n    \"elixir\"\n\nFor ranges where `start > stop`, you need to explicitly\nmark them as increasing:\n\n    iex> String.slice(\"elixir\", 2..-1//1)\n    \"ixir\"\n    iex> String.slice(\"elixir\", 1..-2//1)\n    \"lixi\"\n\nYou can use `../0` as a shortcut for `0..-1//1`, which returns\nthe whole string as is:\n\n    iex> String.slice(\"elixir\", ..)\n    \"elixir\"\n\nThe step can be any positive number. For example, to\nget every 2 characters of the string:\n\n    iex> String.slice(\"elixir\", 0..-1//2)\n    \"eii\"\n\nIf the first position is after the string ends or after\nthe last position of the range, it returns an empty string:\n\n    iex> String.slice(\"elixir\", 10..3)\n    \"\"\n    iex> String.slice(\"a\", 1..1500)\n    \"\"","prompt":"Can you write a docstring for the following Elixir function? slice(string, range)"}
{"completion":"Returns a substring starting at the offset `start`, and of the given `length`.\n\nIf the offset is greater than string length, then it returns `\"\"`.\n\nRemember this function works with Unicode graphemes and considers\nthe slices to represent grapheme offsets. If you want to split\non raw bytes, check `Kernel.binary_part/3` or `Kernel.binary_slice/3`\ninstead.\n\n## Examples\n\n    iex> String.slice(\"elixir\", 1, 3)\n    \"lix\"\n\n    iex> String.slice(\"elixir\", 1, 10)\n    \"lixir\"\n\n    iex> String.slice(\"elixir\", 10, 3)\n    \"\"\n\nIf the start position is negative, it is normalized\nagainst the string length and clamped to 0:\n\n    iex> String.slice(\"elixir\", -4, 4)\n    \"ixir\"\n\n    iex> String.slice(\"elixir\", -10, 3)\n    \"eli\"\n\nIf start is more than the string length, an empty\nstring is returned:\n\n    iex> String.slice(\"elixir\", 10, 1500)\n    \"\"","prompt":"Can you write a docstring for the following Elixir function? slice(string, start, length)"}
{"completion":"Divides a string into substrings at each Unicode whitespace\noccurrence with leading and trailing whitespace ignored. Groups\nof whitespace are treated as a single occurrence. Divisions do\nnot occur on non-breaking whitespace.\n\n## Examples\n\n    iex> String.split(\"foo bar\")\n    [\"foo\", \"bar\"]\n\n    iex> String.split(\"foo\" <> <<194, 133>> <> \"bar\")\n    [\"foo\", \"bar\"]\n\n    iex> String.split(\" foo   bar \")\n    [\"foo\", \"bar\"]\n\n    iex> String.split(\"no\\u00a0break\")\n    [\"no\\u00a0break\"]","prompt":"Can you write a docstring for the following Elixir function? split(binary)"}
{"completion":"Divides a string into parts based on a pattern.\n\nReturns a list of these parts.\n\nThe `pattern` may be a string, a list of strings, a regular expression, or a\ncompiled pattern.\n\nThe string is split into as many parts as possible by\ndefault, but can be controlled via the `:parts` option.\n\nEmpty strings are only removed from the result if the\n`:trim` option is set to `true`.\n\nWhen the pattern used is a regular expression, the string is\nsplit using `Regex.split/3`.\n\n## Options\n\n  * `:parts` (positive integer or `:infinity`) - the string\n    is split into at most as many parts as this option specifies.\n    If `:infinity`, the string will be split into all possible\n    parts. Defaults to `:infinity`.\n\n  * `:trim` (boolean) - if `true`, empty strings are removed from\n    the resulting list.\n\nThis function also accepts all options accepted by `Regex.split/3`\nif `pattern` is a regular expression.\n\n## Examples\n\nSplitting with a string pattern:\n\n    iex> String.split(\"a,b,c\", \",\")\n    [\"a\", \"b\", \"c\"]\n\n    iex> String.split(\"a,b,c\", \",\", parts: 2)\n    [\"a\", \"b,c\"]\n\n    iex> String.split(\" a b c \", \" \", trim: true)\n    [\"a\", \"b\", \"c\"]\n\nA list of patterns:\n\n    iex> String.split(\"1,2 3,4\", [\" \", \",\"])\n    [\"1\", \"2\", \"3\", \"4\"]\n\nA regular expression:\n\n    iex> String.split(\"a,b,c\", ~r{,})\n    [\"a\", \"b\", \"c\"]\n\n    iex> String.split(\"a,b,c\", ~r{,}, parts: 2)\n    [\"a\", \"b,c\"]\n\n    iex> String.split(\" a b c \", ~r{\\s}, trim: true)\n    [\"a\", \"b\", \"c\"]\n\n    iex> String.split(\"abc\", ~r{b}, include_captures: true)\n    [\"a\", \"b\", \"c\"]\n\nA compiled pattern:\n\n    iex> pattern = :binary.compile_pattern([\" \", \",\"])\n    iex> String.split(\"1,2 3,4\", pattern)\n    [\"1\", \"2\", \"3\", \"4\"]\n\nSplitting on empty string returns graphemes:\n\n    iex> String.split(\"abc\", \"\")\n    [\"\", \"a\", \"b\", \"c\", \"\"]\n\n    iex> String.split(\"abc\", \"\", trim: true)\n    [\"a\", \"b\", \"c\"]\n\n    iex> String.split(\"abc\", \"\", parts: 1)\n    [\"abc\"]\n\n    iex> String.split(\"abc\", \"\", parts: 3)\n    [\"\", \"a\", \"bc\"]\n\nBe aware that this function can split within or across grapheme boundaries.\nFor example, take the grapheme \"\" which is made of the characters\n\"e\" and the acute accent. The following will split the string into two parts:\n\n    iex> String.split(String.normalize(\"\", :nfd), \"e\")\n    [\"\", \"\"]\n\nHowever, if \"\" is represented by the single character \"e with acute\"\naccent, then it will split the string into just one part:\n\n    iex> String.split(String.normalize(\"\", :nfc), \"e\")\n    [\"\"]","prompt":"Can you write a docstring for the following Elixir function? split(string, pattern, options \\\\ [])"}
{"completion":"Splits a string into two at the specified offset. When the offset given is\nnegative, location is counted from the end of the string.\n\nThe offset is capped to the length of the string. Returns a tuple with\ntwo elements.\n\nNote: keep in mind this function splits on graphemes and for such it\nhas to linearly traverse the string. If you want to split a string or\na binary based on the number of bytes, use `Kernel.binary_part/3`\ninstead.\n\n## Examples\n\n    iex> String.split_at(\"sweetelixir\", 5)\n    {\"sweet\", \"elixir\"}\n\n    iex> String.split_at(\"sweetelixir\", -6)\n    {\"sweet\", \"elixir\"}\n\n    iex> String.split_at(\"abc\", 0)\n    {\"\", \"abc\"}\n\n    iex> String.split_at(\"abc\", 1000)\n    {\"abc\", \"\"}\n\n    iex> String.split_at(\"abc\", -1000)\n    {\"\", \"abc\"}","prompt":"Can you write a docstring for the following Elixir function? split_at(string, position)"}
{"completion":"Returns an enumerable that splits a string on demand.\n\nThis is in contrast to `split/3` which splits the\nentire string upfront.\n\nThis function does not support regular expressions\nby design. When using regular expressions, it is often\nmore efficient to have the regular expressions traverse\nthe string at once than in parts, like this function does.\n\n## Options\n\n  * :trim - when `true`, does not emit empty patterns\n\n## Examples\n\n    iex> String.splitter(\"1,2 3,4 5,6 7,8,...,99999\", [\" \", \",\"]) |> Enum.take(4)\n    [\"1\", \"2\", \"3\", \"4\"]\n\n    iex> String.splitter(\"abcd\", \"\") |> Enum.take(10)\n    [\"\", \"a\", \"b\", \"c\", \"d\", \"\"]\n\n    iex> String.splitter(\"abcd\", \"\", trim: true) |> Enum.take(10)\n    [\"a\", \"b\", \"c\", \"d\"]\n\nA compiled pattern can also be given:\n\n    iex> pattern = :binary.compile_pattern([\" \", \",\"])\n    iex> String.splitter(\"1,2 3,4 5,6 7,8,...,99999\", pattern) |> Enum.take(4)\n    [\"1\", \"2\", \"3\", \"4\"]","prompt":"Can you write a docstring for the following Elixir function? splitter(string, pattern, options \\\\ [])"}
{"completion":"Returns `true` if `string` starts with any of the prefixes given.\n\n`prefix` can be either a string, a list of strings, or a compiled\npattern.\n\n## Examples\n\n    iex> String.starts_with?(\"elixir\", \"eli\")\n    true\n    iex> String.starts_with?(\"elixir\", [\"erlang\", \"elixir\"])\n    true\n    iex> String.starts_with?(\"elixir\", [\"erlang\", \"ruby\"])\n    false\n\nAn empty string will always match:\n\n    iex> String.starts_with?(\"elixir\", \"\")\n    true\n    iex> String.starts_with?(\"elixir\", [\"\", \"other\"])\n    true\n\nAn empty list will never match:\n\n    iex> String.starts_with?(\"elixir\", [])\n    false\n\n    iex> String.starts_with?(\"\", [])\n    false","prompt":"Can you write a docstring for the following Elixir function? starts_with?(string, prefix)"}
{"completion":"Converts a string to an atom.\n\nWarning: this function creates atoms dynamically and atoms are\nnot garbage-collected. Therefore, `string` should not be an\nuntrusted value, such as input received from a socket or during\na web request. Consider using `to_existing_atom/1` instead.\n\nBy default, the maximum number of atoms is `1_048_576`. This limit\ncan be raised or lowered using the VM option `+t`.\n\nThe maximum atom size is of 255 Unicode code points.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.to_atom(\"my_atom\")\n    :my_atom","prompt":"Can you write a docstring for the following Elixir function? to_atom(string)"}
{"completion":"Converts a string into a charlist.\n\nSpecifically, this function takes a UTF-8 encoded binary and returns a list of its integer\ncode points. It is similar to `codepoints/1` except that the latter returns a list of code points as\nstrings.\n\nIn case you need to work with bytes, take a look at the\n[`:binary` module](`:binary`).\n\n## Examples\n\n    iex> String.to_charlist(\"\")\n    ''","prompt":"Can you write a docstring for the following Elixir function? to_charlist(string)"}
{"completion":"Converts a string to an existing atom.\n\nThe maximum atom size is of 255 Unicode code points.\nRaises an `ArgumentError` if the atom does not exist.\n\nInlined by the compiler.\n\n> #### Atoms and modules {: .info}\n>\n> Since Elixir is a compiled language, the atoms defined in a module\n> will only exist after said module is loaded, which typically happens\n> whenever a function in the module is executed. Therefore, it is\n> generally recommended to call `String.to_existing_atom/1` only to\n> convert atoms defined within the module making the function call\n> to `to_existing_atom/1`.\n\n## Examples\n\n    iex> _ = :my_atom\n    iex> String.to_existing_atom(\"my_atom\")\n    :my_atom","prompt":"Can you write a docstring for the following Elixir function? to_existing_atom(string)"}
{"completion":"Returns a float whose text representation is `string`.\n\n`string` must be the string representation of a float including a decimal point.\nIn order to parse a string without decimal point as a float then `Float.parse/1`\nshould be used. Otherwise, an `ArgumentError` will be raised.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.to_float(\"2.2017764e+0\")\n    2.2017764\n\n    iex> String.to_float(\"3.0\")\n    3.0\n\n    String.to_float(\"3\")\n    ** (ArgumentError) argument error","prompt":"Can you write a docstring for the following Elixir function? to_float(string)"}
{"completion":"Returns an integer whose text representation is `string`.\n\n`string` must be the string representation of an integer.\nOtherwise, an `ArgumentError` will be raised. If you want\nto parse a string that may contain an ill-formatted integer,\nuse `Integer.parse/1`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.to_integer(\"123\")\n    123\n\nPassing a string that does not represent an integer leads to an error:\n\n    String.to_integer(\"invalid data\")\n    ** (ArgumentError) argument error","prompt":"Can you write a docstring for the following Elixir function? to_integer(string)"}
{"completion":"Returns an integer whose text representation is `string` in base `base`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.to_integer(\"3FF\", 16)\n    1023","prompt":"Can you write a docstring for the following Elixir function? to_integer(string, base)"}
{"completion":"Returns a string where all leading and trailing Unicode whitespaces\nhave been removed.\n\n## Examples\n\n    iex> String.trim(\"\\n  abc\\n  \")\n    \"abc\"","prompt":"Can you write a docstring for the following Elixir function? trim(string)"}
{"completion":"Returns a string where all leading and trailing `to_trim` characters have been\nremoved.\n\n## Examples\n\n    iex> String.trim(\"a  abc  a\", \"a\")\n    \"  abc  \"","prompt":"Can you write a docstring for the following Elixir function? trim(string, to_trim)"}
{"completion":"Returns a string where all leading Unicode whitespaces\nhave been removed.\n\n## Examples\n\n    iex> String.trim_leading(\"\\n  abc   \")\n    \"abc   \"","prompt":"Can you write a docstring for the following Elixir function? trim_leading(string)"}
{"completion":"Returns a string where all leading `to_trim` characters have been removed.\n\n## Examples\n\n    iex> String.trim_leading(\"__ abc _\", \"_\")\n    \" abc _\"\n\n    iex> String.trim_leading(\"1 abc\", \"11\")\n    \"1 abc\"","prompt":"Can you write a docstring for the following Elixir function? trim_leading(string, to_trim)"}
{"completion":"Returns a string where all trailing Unicode whitespaces\nhas been removed.\n\n## Examples\n\n    iex> String.trim_trailing(\"   abc\\n  \")\n    \"   abc\"","prompt":"Can you write a docstring for the following Elixir function? trim_trailing(string)"}
{"completion":"Returns a string where all trailing `to_trim` characters have been removed.\n\n## Examples\n\n    iex> String.trim_trailing(\"_ abc __\", \"_\")\n    \"_ abc \"\n\n    iex> String.trim_trailing(\"abc 1\", \"11\")\n    \"abc 1\"","prompt":"Can you write a docstring for the following Elixir function? trim_trailing(string, to_trim)"}
{"completion":"Converts all characters in the given string to uppercase according to `mode`.\n\n`mode` may be `:default`, `:ascii`, `:greek` or `:turkic`. The `:default` mode considers\nall non-conditional transformations outlined in the Unicode standard. `:ascii`\nuppercases only the letters a to z. `:greek` includes the context sensitive\nmappings found in Greek. `:turkic` properly handles the letter i with the dotless variant.\n\n## Examples\n\n    iex> String.upcase(\"abcd\")\n    \"ABCD\"\n\n    iex> String.upcase(\"ab 123 xpto\")\n    \"AB 123 XPTO\"\n\n    iex> String.upcase(\"ol\")\n    \"OL\"\n\nThe `:ascii` mode ignores Unicode characters and provides a more\nperformant implementation when you know the string contains only\nASCII characters:\n\n    iex> String.upcase(\"ol\", :ascii)\n    \"OL\"\n\nAnd `:turkic` properly handles the letter i with the dotless variant:\n\n    iex> String.upcase(\"i\")\n    \"II\"\n\n    iex> String.upcase(\"i\", :turkic)\n    \"I\"","prompt":"Can you write a docstring for the following Elixir function? upcase(string, mode \\\\ :default)"}
{"completion":"Checks whether `string` contains only valid characters.\n\n## Examples\n\n    iex> String.valid?(\"a\")\n    true\n\n    iex> String.valid?(\"\")\n    true\n\n    iex> String.valid?(<<0xFFFF::16>>)\n    false\n\n    iex> String.valid?(<<0xEF, 0xB7, 0x90>>)\n    true\n\n    iex> String.valid?(\"asd\" <> <<0xFFFF::16>>)\n    false","prompt":"Can you write a docstring for the following Elixir function? valid?(string)"}
{"completion":"Strings in Elixir are UTF-8 encoded binaries.\n\nStrings in Elixir are a sequence of Unicode characters,\ntypically written between double quoted strings, such\nas `\"hello\"` and `\"hll\"`.\n\nIn case a string must have a double-quote in itself,\nthe double quotes must be escaped with a backslash,\nfor example: `\"this is a string with \\\"double quotes\\\"\"`.\n\nYou can concatenate two strings with the `<>/2` operator:\n\n    iex> \"hello\" <> \" \" <> \"world\"\n    \"hello world\"\n\nThe functions in this module act according to\n[The Unicode Standard, Version 14.0.0](http://www.unicode.org/versions/Unicode14.0.0/).","prompt":"Can you write a docstring for the following Elixir function? Elixir.String"}
{"completion":"Interpolation\n\nStrings in Elixir also support interpolation. This allows\nyou to place some value in the middle of a string by using\nthe `#{}` syntax:\n\n    iex> name = \"joe\"\n    iex> \"hello #{name}\"\n    \"hello joe\"\n\nAny Elixir expression is valid inside the interpolation.\nIf a string is given, the string is interpolated as is.\nIf any other value is given, Elixir will attempt to convert\nit to a string using the `String.Chars` protocol. This\nallows, for example, to output an integer from the interpolation:\n\n    iex> \"2 + 2 = #{2 + 2}\"\n    \"2 + 2 = 4\"\n\nIn case the value you want to interpolate cannot be\nconverted to a string, because it doesn't have a human\ntextual representation, a protocol error will be raised.","prompt":"Can you write a docstring for the following Elixir function? Elixir.String"}
{"completion":"Escape characters\n\nBesides allowing double-quotes to be escaped with a backslash,\nstrings also support the following escape characters:\n\n  * `\\0` - Null byte\n  * `\\a` - Bell\n  * `\\b` - Backspace\n  * `\\t` - Horizontal tab\n  * `\\n` - Line feed (New lines)\n  * `\\v` - Vertical tab\n  * `\\f` - Form feed\n  * `\\r` - Carriage return\n  * `\\e` - Command Escape\n  * `\\s` - Space\n  * `\\#` - Returns the `#` character itself, skipping interpolation\n  * `\\\\` - Single backslash\n  * `\\xNN` - A byte represented by the hexadecimal `NN`\n  * `\\uNNNN` - A Unicode code point represented by `NNNN`\n\nNote it is generally not advised to use `\\xNN` in Elixir\nstrings, as introducing an invalid byte sequence would\nmake the string invalid. If you have to introduce a\ncharacter by its hexadecimal representation, it is best\nto work with Unicode code points, such as `\\uNNNN`. In fact,\nunderstanding Unicode code points can be essential when doing\nlow-level manipulations of string, so let's explore them in\ndetail next.","prompt":"Can you write a docstring for the following Elixir function? Elixir.String"}
{"completion":"Unicode and code points\n\nIn order to facilitate meaningful communication between computers\nacross multiple languages, a standard is required so that the ones\nand zeros on one machine mean the same thing when they are transmitted\nto another. The Unicode Standard acts as an official registry of\nvirtually all the characters we know: this includes characters from\nclassical and historical texts, emoji, and formatting and control\ncharacters as well.\n\nUnicode organizes all of the characters in its repertoire into code\ncharts, and each character is given a unique numerical index. This\nnumerical index is known as a Code Point.\n\nIn Elixir you can use a `?` in front of a character literal to reveal\nits code point:\n\n    iex> ?a\n    97\n    iex> ?\n    322\n\nNote that most Unicode code charts will refer to a code point by its\nhexadecimal (hex) representation, e.g. `97` translates to `0061` in hex,\nand we can represent any Unicode character in an Elixir string by\nusing the `\\u` escape character followed by its code point number:\n\n    iex> \"\\u0061\" === \"a\"\n    true\n    iex> 0x0061 = 97 = ?a\n    97\n\nThe hex representation will also help you look up information about a\ncode point, e.g. [https://codepoints.net/U+0061](https://codepoints.net/U+0061)\nhas a data sheet all about the lower case `a`, a.k.a. code point 97.\nRemember you can get the hex presentation of a number by calling\n`Integer.to_string/2`:\n\n    iex> Integer.to_string(?a, 16)\n    \"61\"","prompt":"Can you write a docstring for the following Elixir function? Elixir.String"}
{"completion":"UTF-8 encoded and encodings\n\nNow that we understand what the Unicode standard is and what code points\nare, we can finally talk about encodings. Whereas the code point is **what**\nwe store, an encoding deals with **how** we store it: encoding is an\nimplementation. In other words, we need a mechanism to convert the code\npoint numbers into bytes so they can be stored in memory, written to disk, and such.\n\nElixir uses UTF-8 to encode its strings, which means that code points are\nencoded as a series of 8-bit bytes. UTF-8 is a **variable width** character\nencoding that uses one to four bytes to store each code point. It is capable\nof encoding all valid Unicode code points. Let's see an example:\n\n    iex> string = \"hllo\"\n    \"hllo\"\n    iex> String.length(string)\n    5\n    iex> byte_size(string)\n    6\n\nAlthough the string above has 5 characters, it uses 6 bytes, as two bytes\nare used to represent the character ``.","prompt":"Can you write a docstring for the following Elixir function? Elixir.String"}
{"completion":"Grapheme clusters\n\nThis module also works with the concept of grapheme cluster\n(from now on referenced as graphemes). Graphemes can consist\nof multiple code points that may be perceived as a single character\nby readers. For example, \"\" can be represented either as a single\n\"e with acute\" code point, as seen above in the string `\"hllo\"`,\nor as the letter \"e\" followed by a \"combining acute accent\"\n(two code points):\n\n    iex> string = \"\\u0065\\u0301\"\n    \"e\"\n    iex> byte_size(string)\n    3\n    iex> String.length(string)\n    1\n    iex> String.codepoints(string)\n    [\"e\", \"\"]\n    iex> String.graphemes(string)\n    [\"e\"]\n\nAlthough it looks visually the same as before, the example above\nis made of two characters, it is perceived by users as one.\n\nGraphemes can also be two characters that are interpreted as one\nby some languages. For example, some languages may consider \"ch\"\nas a single character. However, since this information depends on\nthe locale, it is not taken into account by this module.\n\nIn general, the functions in this module rely on the Unicode\nStandard, but do not contain any of the locale specific behaviour.\nMore information about graphemes can be found in the [Unicode\nStandard Annex #29](https://www.unicode.org/reports/tr29/).\n\nFor converting a binary to a different encoding and for Unicode\nnormalization mechanisms, see Erlang's `:unicode` module.","prompt":"Can you write a docstring for the following Elixir function? Elixir.String"}
{"completion":"String and binary operations\n\nTo act according to the Unicode Standard, many functions\nin this module run in linear time, as they need to traverse\nthe whole string considering the proper Unicode code points.\n\nFor example, `String.length/1` will take longer as\nthe input grows. On the other hand, `Kernel.byte_size/1` always runs\nin constant time (i.e. regardless of the input size).\n\nThis means often there are performance costs in using the\nfunctions in this module, compared to the more low-level\noperations that work directly with binaries:\n\n  * `Kernel.binary_part/3` - retrieves part of the binary\n  * `Kernel.bit_size/1` and `Kernel.byte_size/1` - size related functions\n  * `Kernel.is_bitstring/1` and `Kernel.is_binary/1` - type-check function\n  * Plus a number of functions for working with binaries (bytes)\n    in the [`:binary` module](`:binary`)\n\nA `utf8` modifier is also available inside the binary syntax `<<>>`.\nIt can be used to match code points out of a binary/string:\n\n    iex> <<eacute::utf8>> = \"\"\n    iex> eacute\n    233\n\nYou can also fully convert a string into a list of integer code points,\nknown as \"charlists\" in Elixir, by calling `String.to_charlist/1`:\n\n    iex> String.to_charlist(\"hllo\")\n    [104, 233, 108, 108, 111]\n\nIf you would rather see the underlying bytes of a string, instead of\nits codepoints, a common trick is to concatenate the null byte `<<0>>`\nto it:\n\n    iex> \"hllo\" <> <<0>>\n    <<104, 195, 169, 108, 108, 111, 0>>\n\nAlternatively, you can view a string's binary representation by\npassing an option to `IO.inspect/2`:\n\n    IO.inspect(\"hllo\", binaries: :as_binaries)\n    #=> <<104, 195, 169, 108, 108, 111>>","prompt":"Can you write a docstring for the following Elixir function? Elixir.String"}
{"completion":"Self-synchronization\n\nThe UTF-8 encoding is self-synchronizing. This means that\nif malformed data (i.e., data that is not possible according\nto the definition of the encoding) is encountered, only one\ncode point needs to be rejected.\n\nThis module relies on this behaviour to ignore such invalid\ncharacters. For example, `length/1` will return\na correct result even if an invalid code point is fed into it.\n\nIn other words, this module expects invalid data to be detected\nelsewhere, usually when retrieving data from the external source.\nFor example, a driver that reads strings from a database will be\nresponsible to check the validity of the encoding. `String.chunk/2`\ncan be used for breaking a string into valid and invalid parts.","prompt":"Can you write a docstring for the following Elixir function? Elixir.String"}
{"completion":"Compile binary patterns\n\nMany functions in this module work with patterns. For example,\n`String.split/3` can split a string into multiple strings given\na pattern. This pattern can be a string, a list of strings or\na compiled pattern:\n\n    iex> String.split(\"foo bar\", \" \")\n    [\"foo\", \"bar\"]\n\n    iex> String.split(\"foo bar!\", [\" \", \"!\"])\n    [\"foo\", \"bar\", \"\"]\n\n    iex> pattern = :binary.compile_pattern([\" \", \"!\"])\n    iex> String.split(\"foo bar!\", pattern)\n    [\"foo\", \"bar\", \"\"]\n\nThe compiled pattern is useful when the same match will\nbe done over and over again. Note though that the compiled\npattern cannot be stored in a module attribute as the pattern\nis generated at runtime and does not survive compile time.","prompt":"Can you write a docstring for the following Elixir function? Elixir.String"}
{"completion":"Stops the IO device and returns the remaining input/output\nbuffers.\n\n## Examples\n\n    iex> {:ok, pid} = StringIO.open(\"in\")\n    iex> IO.write(pid, \"out\")\n    iex> StringIO.close(pid)\n    {:ok, {\"in\", \"out\"}}","prompt":"Can you write a docstring for the following Elixir function? close(pid)"}
{"completion":"Returns the current input/output buffers for the given IO\ndevice.\n\n## Examples\n\n    iex> {:ok, pid} = StringIO.open(\"in\")\n    iex> IO.write(pid, \"out\")\n    iex> StringIO.contents(pid)\n    {\"in\", \"out\"}","prompt":"Can you write a docstring for the following Elixir function? contents(pid)"}
{"completion":"Flushes the output buffer and returns its current contents.\n\n## Examples\n\n    iex> {:ok, pid} = StringIO.open(\"in\")\n    iex> IO.write(pid, \"out\")\n    iex> StringIO.flush(pid)\n    \"out\"\n    iex> StringIO.contents(pid)\n    {\"in\", \"\"}","prompt":"Can you write a docstring for the following Elixir function? flush(pid)"}
{"completion":"Creates an IO device.\n\n`string` will be the initial input of the newly created\ndevice.\n\n`options_or_function` can be a keyword list of options or\na function.\n\nIf options are provided, the result will be `{:ok, pid}`, returning the\nIO device created. The option `:capture_prompt`, when set to `true`, causes\nprompts (which are specified as arguments to `IO.get*` functions) to be\nincluded in the device's output.\n\nIf a function is provided, the device will be created and sent to the\nfunction. When the function returns, the device will be closed. The final\nresult will be a tuple with `:ok` and the result of the function.\n\n## Examples\n\n    iex> {:ok, pid} = StringIO.open(\"foo\")\n    iex> IO.gets(pid, \">\")\n    \"foo\"\n    iex> StringIO.contents(pid)\n    {\"\", \"\"}\n\n    iex> {:ok, pid} = StringIO.open(\"foo\", capture_prompt: true)\n    iex> IO.gets(pid, \">\")\n    \"foo\"\n    iex> StringIO.contents(pid)\n    {\"\", \">\"}\n\n    iex> StringIO.open(\"foo\", fn pid ->\n    ...>   input = IO.gets(pid, \">\")\n    ...>   IO.write(pid, \"The input was #{input}\")\n    ...>   StringIO.contents(pid)\n    ...> end)\n    {:ok, {\"\", \"The input was foo\"}}","prompt":"Can you write a docstring for the following Elixir function? open(string, options_or_function \\\\ [])"}
{"completion":"Creates an IO device.\n\n`string` will be the initial input of the newly created\ndevice.\n\nThe device will be created and sent to the function given.\nWhen the function returns, the device will be closed. The final\nresult will be a tuple with `:ok` and the result of the function.\n\n## Options\n\n  * `:capture_prompt` - if set to `true`, prompts (specified as\n    arguments to `IO.get*` functions) are captured in the output.\n    Defaults to `false`.\n\n  * `:encoding` (since v1.10.0) - encoding of the IO device. Allowed\n    values are `:unicode` (default) and `:latin1`.\n\n## Examples\n\n    iex> StringIO.open(\"foo\", [], fn pid ->\n    ...>   input = IO.gets(pid, \">\")\n    ...>   IO.write(pid, \"The input was #{input}\")\n    ...>   StringIO.contents(pid)\n    ...> end)\n    {:ok, {\"\", \"The input was foo\"}}\n\n    iex> StringIO.open(\"foo\", [capture_prompt: true], fn pid ->\n    ...>   input = IO.gets(pid, \">\")\n    ...>   IO.write(pid, \"The input was #{input}\")\n    ...>   StringIO.contents(pid)\n    ...> end)\n    {:ok, {\"\", \">The input was foo\"}}","prompt":"Can you write a docstring for the following Elixir function? open(string, options, function)"}
{"completion":"Controls an IO device process that wraps a string.\n\nA `StringIO` IO device can be passed as a \"device\" to\nmost of the functions in the `IO` module.","prompt":"Can you write a docstring for the following Elixir function? Elixir.StringIO"}
{"completion":"Examples\n\n    iex> {:ok, pid} = StringIO.open(\"foo\")\n    iex> IO.read(pid, 2)\n    \"fo\"","prompt":"Can you write a docstring for the following Elixir function? Elixir.StringIO"}
{"completion":"Receives a list of `children` (workers or supervisors) to\nsupervise and a set of `options`.\n\nReturns a tuple containing the supervisor specification. This tuple can be\nused as the return value of the `c:Supervisor.init/1` callback when implementing a\nmodule-based supervisor.\n\n## Examples\n\n    supervise(children, strategy: :one_for_one)\n\n## Options\n\n  * `:strategy` - the restart strategy option. It can be either\n    `:one_for_one`, `:rest_for_one`, `:one_for_all`, or\n    `:simple_one_for_one`. You can learn more about strategies\n    in the `Supervisor` module docs.\n\n  * `:max_restarts` - the maximum number of restarts allowed in\n    a time frame. Defaults to `3`.\n\n  * `:max_seconds` - the time frame in which `:max_restarts` applies.\n    Defaults to `5`.\n\nThe `:strategy` option is required and by default a maximum of 3 restarts is\nallowed within 5 seconds. Check the `Supervisor` module for a detailed\ndescription of the available strategies.","prompt":"Can you write a docstring for the following Elixir function? supervise(children, options)"}
{"completion":"Defines the given `module` as a supervisor which will be started\nwith the given arguments.\n\n    supervisor(module, [], restart: :permanent)\n\nBy default, the function `start_link` is invoked on the given\nmodule. Overall, the default values for the options are:\n\n    [\n      id: module,\n      function: :start_link,\n      restart: :permanent,\n      shutdown: :infinity,\n      modules: [module]\n    ]\n\nSee the \"Supervisor and worker options\" section in the `Supervisor.Spec` module for more\ninformation on the available options.","prompt":"Can you write a docstring for the following Elixir function? supervisor(module, args, options \\\\ [])"}
{"completion":"Defines the given `module` as a worker which will be started\nwith the given arguments.\n\n    worker(ExUnit.Runner, [], restart: :permanent)\n\nBy default, the function `start_link` is invoked on the given\nmodule. Overall, the default values for the options are:\n\n    [\n      id: module,\n      function: :start_link,\n      restart: :permanent,\n      shutdown: 5000,\n      modules: [module]\n    ]\n\nSee the \"Supervisor and worker options\" section in the `Supervisor.Spec` module for more\ninformation on the available options.","prompt":"Can you write a docstring for the following Elixir function? worker(module, args, options \\\\ [])"}
{"completion":"Outdated functions for building child specifications.\n\nThe functions in this module are deprecated and they do not work\nwith the module-based child specs introduced in Elixir v1.5.\nPlease see the `Supervisor` documentation instead.\n\nConvenience functions for defining supervisor specifications.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Supervisor.Spec"}
{"completion":"Example\n\nBy using the functions in this module one can specify the children\nto be used under a supervisor, started with `Supervisor.start_link/2`:\n\n    import Supervisor.Spec\n\n    children = [\n      worker(MyWorker, [arg1, arg2, arg3]),\n      supervisor(MySupervisor, [arg1])\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nSometimes, it may be handy to define supervisors backed\nby a module:\n\n    defmodule MySupervisor do\n      use Supervisor\n\n      def start_link(arg) do\n        Supervisor.start_link(__MODULE__, arg)\n      end\n\n      def init(arg) do\n        children = [\n          worker(MyWorker, [arg], restart: :temporary)\n        ]\n\n        supervise(children, strategy: :simple_one_for_one)\n      end\n    end\n\nNote that in this case we don't have to explicitly import\n`Supervisor.Spec` since `use Supervisor` automatically does so.\nDefining a module-based supervisor can be useful, for example,\nto perform initialization tasks in the `c:Supervisor.init/1` callback.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Supervisor.Spec"}
{"completion":"Supervisor and worker options\n\nIn the example above, we defined specs for workers and supervisors.\nThese specs (both for workers as well as supervisors) accept the\nfollowing options:\n\n  * `:id` - a name used to identify the child specification\n    internally by the supervisor; defaults to the given module\n    name for the child worker/supervisor\n\n  * `:function` - the function to invoke on the child to start it\n\n  * `:restart` - an atom that defines when a terminated child process should\n    be restarted (see the \"Restart values\" section below)\n\n  * `:shutdown` - an atom that defines how a child process should be\n    terminated (see the \"Shutdown values\" section below)\n\n  * `:modules` - it should be a list with one element `[module]`,\n    where module is the name of the callback module only if the\n    child process is a `Supervisor` or `GenServer`; if the child\n    process is a `GenEvent`, `:modules` should be `:dynamic`","prompt":"Can you write a docstring for the following Elixir function? Elixir.Supervisor.Spec"}
{"completion":"# Restart values (:restart)\n\nThe following restart values are supported in the `:restart` option:\n\n  * `:permanent` - the child process is always restarted\n\n  * `:temporary` - the child process is never restarted (not even\n    when the supervisor's strategy is `:rest_for_one` or `:one_for_all`)\n\n  * `:transient` - the child process is restarted only if it\n    terminates abnormally, i.e., with an exit reason other than\n    `:normal`, `:shutdown` or `{:shutdown, term}`\n\nNote that supervisor that reached maximum restart intensity will exit with `:shutdown` reason.\nIn this case the supervisor will only restart if its child specification was defined with\nthe `:restart` option set to `:permanent` (the default).","prompt":"Can you write a docstring for the following Elixir function? Elixir.Supervisor.Spec"}
{"completion":"# Shutdown values (`:shutdown`)\n\nThe following shutdown values are supported in the `:shutdown` option:\n\n  * `:brutal_kill` - the child process is unconditionally terminated\n    using `Process.exit(child, :kill)`\n\n  * `:infinity` - if the child process is a supervisor, this is a mechanism\n    to give the subtree enough time to shut down; it can also be used with\n    workers with care\n\n  * a non-negative integer - the amount of time in milliseconds\n    that the supervisor tells the child process to terminate by calling\n    `Process.exit(child, :shutdown)` and then waits for an exit signal back.\n    If no exit signal is received within the specified time,\n    the child process is unconditionally terminated\n    using `Process.exit(child, :kill)`","prompt":"Can you write a docstring for the following Elixir function? Elixir.Supervisor.Spec"}
{"completion":"Builds and overrides a child specification.\n\nSimilar to `start_link/2` and `init/2`, it expects a module, `{module, arg}`,\nor a [child specification](`t:child_spec/0`).\n\nIf a two-element tuple in the shape of `{module, arg}` is given,\nthe child specification is retrieved by calling `module.child_spec(arg)`.\n\nIf a module is given, the child specification is retrieved by calling\n`module.child_spec([])`.\n\nAfter the child specification is retrieved, the fields on `overrides`\nare directly applied on the child spec. If `overrides` has keys that\ndo not map to any child specification field, an error is raised.\n\nSee the \"Child specification\" section in the module documentation\nfor all of the available keys for overriding.\n\n## Examples\n\nThis function is often used to set an `:id` option when\nthe same module needs to be started multiple times in the\nsupervision tree:\n\n    Supervisor.child_spec({Agent, fn -> :ok end}, id: {Agent, 1})\n    #=> %{id: {Agent, 1},\n    #=>   start: {Agent, :start_link, [fn -> :ok end]}}","prompt":"Can you write a docstring for the following Elixir function? child_spec(module_or_map, overrides)"}
{"completion":"Returns a map containing count values for the given supervisor.\n\nThe map contains the following keys:\n\n  * `:specs` - the total count of children, dead or alive\n\n  * `:active` - the count of all actively running child processes managed by\n    this supervisor\n\n  * `:supervisors` - the count of all supervisors whether or not these\n    child supervisors are still alive\n\n  * `:workers` - the count of all workers, whether or not these child workers\n    are still alive","prompt":"Can you write a docstring for the following Elixir function? count_children(supervisor)"}
{"completion":"Deletes the child specification identified by `child_id`.\n\nThe corresponding child process must not be running; use `terminate_child/2`\nto terminate it if it's running.\n\nIf successful, this function returns `:ok`. This function may return an error\nwith an appropriate error tuple if the `child_id` is not found, or if the\ncurrent process is running or being restarted.","prompt":"Can you write a docstring for the following Elixir function? delete_child(supervisor, child_id)"}
{"completion":"Receives a list of child specifications to initialize and a set of `options`.\n\nThis is typically invoked at the end of the `c:init/1` callback of\nmodule-based supervisors. See the sections \"Supervisor strategies and options\" and\n\"Module-based supervisors\" in the module documentation for more information.\n\nThis function returns a tuple containing the supervisor\nflags and child specifications.\n\n## Examples\n\n    def init(_init_arg) do\n      children = [\n        {Counter, 0}\n      ]\n\n      Supervisor.init(children, strategy: :one_for_one)\n    end\n\n## Options\n\n  * `:strategy` - the supervision strategy option. It can be either\n    `:one_for_one`, `:rest_for_one`, or `:one_for_all`\n\n  * `:max_restarts` - the maximum number of restarts allowed in\n    a time frame. Defaults to `3`.\n\n  * `:max_seconds` - the time frame in seconds in which `:max_restarts`\n    applies. Defaults to `5`.\n\nThe `:strategy` option is required and by default a maximum of 3 restarts\nis allowed within 5 seconds. Check the `Supervisor` module for a detailed\ndescription of the available strategies.","prompt":"Can you write a docstring for the following Elixir function? init(children, options)"}
{"completion":"Restarts a child process identified by `child_id`.\n\nThe child specification must exist and the corresponding child process must not\nbe running.\n\nNote that for temporary children, the child specification is automatically deleted\nwhen the child terminates, and thus it is not possible to restart such children.\n\nIf the child process start function returns `{:ok, child}` or `{:ok, child, info}`,\nthe PID is added to the supervisor and this function returns the same value.\n\nIf the child process start function returns `:ignore`, the PID remains set to\n`:undefined` and this function returns `{:ok, :undefined}`.\n\nThis function may return an error with an appropriate error tuple if the\n`child_id` is not found, or if the current process is running or being\nrestarted.\n\nIf the child process start function returns an error tuple or an erroneous value,\nor if it fails, this function returns `{:error, error}`.","prompt":"Can you write a docstring for the following Elixir function? restart_child(supervisor, child_id)"}
{"completion":"Adds a child specification to `supervisor` and starts that child.\n\n`child_spec` should be a valid child specification. The child process will\nbe started as defined in the child specification.\n\nIf a child specification with the specified ID already exists, `child_spec` is\ndiscarded and this function returns an error with `:already_started` or\n`:already_present` if the corresponding child process is running or not,\nrespectively.\n\nIf the child process start function returns `{:ok, child}` or `{:ok, child,\ninfo}`, then child specification and PID are added to the supervisor and\nthis function returns the same value.\n\nIf the child process start function returns `:ignore`, the child specification\nis added to the supervisor, the PID is set to `:undefined` and this function\nreturns `{:ok, :undefined}`.\n\nIf the child process start function returns an error tuple or an erroneous\nvalue, or if it fails, the child specification is discarded and this function\nreturns `{:error, error}` where `error` is a term containing information about\nthe error and child specification.","prompt":"Can you write a docstring for the following Elixir function? start_child(supervisor, child_spec)"}
{"completion":"Starts a supervisor with the given children.\n\n`children` is a list of the following forms:\n\n  * a [child specification](`t:child_spec/0`)\n\n  * a module, where `module.child_spec([])` will be invoked to retrieve\n    its child specification\n\n  * a two-element tuple in the shape of `{module, arg}`, where `module.child_spec(arg)`\n    will be invoked to retrieve its child specification\n\nA strategy is required to be provided through the `:strategy` option. See\n\"Supervisor strategies and options\" for examples and other options.\n\nThe options can also be used to register a supervisor name.\nThe supported values are described under the \"Name registration\"\nsection in the `GenServer` module docs.\n\nIf the supervisor and all child processes are successfully spawned\n(if the start function of each child process returns `{:ok, child}`,\n`{:ok, child, info}`, or `:ignore`), this function returns\n`{:ok, pid}`, where `pid` is the PID of the supervisor. If the supervisor\nis given a name and a process with the specified name already exists,\nthe function returns `{:error, {:already_started, pid}}`, where `pid`\nis the PID of that process.\n\nIf the start function of any of the child processes fails or returns an error\ntuple or an erroneous value, the supervisor first terminates with reason\n`:shutdown` all the child processes that have already been started, and then\nterminates itself and returns `{:error, {:shutdown, reason}}`.\n\nNote that a supervisor started with this function is linked to the parent\nprocess and exits not only on crashes but also if the parent process exits\nwith `:normal` reason.","prompt":"Can you write a docstring for the following Elixir function? start_link(children, options)"}
{"completion":"Starts a module-based supervisor process with the given `module` and `init_arg`.\n\nTo start the supervisor, the `c:init/1` callback will be invoked in the given\n`module`, with `init_arg` as its argument. The `c:init/1` callback must return a\nsupervisor specification which can be created with the help of the `init/2`\nfunction.\n\nIf the `c:init/1` callback returns `:ignore`, this function returns\n`:ignore` as well and the supervisor terminates with reason `:normal`.\nIf it fails or returns an incorrect value, this function returns\n`{:error, term}` where `term` is a term with information about the\nerror, and the supervisor terminates with reason `term`.\n\nThe `:name` option can also be given in order to register a supervisor\nname, the supported values are described in the \"Name registration\"\nsection in the `GenServer` module docs.","prompt":"Can you write a docstring for the following Elixir function? start_link(module, init_arg, options \\\\ [])"}
{"completion":"Synchronously stops the given supervisor with the given `reason`.\n\nIt returns `:ok` if the supervisor terminates with the given\nreason. If it terminates with another reason, the call exits.\n\nThis function keeps OTP semantics regarding error reporting.\nIf the reason is any other than `:normal`, `:shutdown` or\n`{:shutdown, _}`, an error report is logged.","prompt":"Can you write a docstring for the following Elixir function? stop(supervisor, reason \\\\ :normal, timeout \\\\ :infinity)"}
{"completion":"Terminates the given child identified by `child_id`.\n\nThe process is terminated, if there's one. The child specification is\nkept unless the child is temporary.\n\nA non-temporary child process may later be restarted by the supervisor.\nThe child process can also be restarted explicitly by calling `restart_child/2`.\nUse `delete_child/2` to remove the child specification.\n\nIf successful, this function returns `:ok`. If there is no child\nspecification for the given child ID, this function returns\n`{:error, :not_found}`.","prompt":"Can you write a docstring for the following Elixir function? terminate_child(supervisor, child_id)"}
{"completion":"Returns a list with information about all children of the given supervisor.\n\nNote that calling this function when supervising a large number of children\nunder low memory conditions can cause an out of memory exception.\n\nThis function returns a list of `{id, child, type, modules}` tuples, where:\n\n  * `id` - as defined in the child specification\n\n  * `child` - the PID of the corresponding child process, `:restarting` if the\n    process is about to be restarted, or `:undefined` if there is no such\n    process\n\n  * `type` - `:worker` or `:supervisor`, as specified by the child specification\n\n  * `modules` - as specified by the child specification","prompt":"Can you write a docstring for the following Elixir function? which_children(supervisor)"}
{"completion":"A behaviour module for implementing supervisors.\n\nA supervisor is a process which supervises other processes, which we\nrefer to as *child processes*. Supervisors are used to build a hierarchical\nprocess structure called a *supervision tree*. Supervision trees provide\nfault-tolerance and encapsulate how our applications start and shutdown.\n\nA supervisor may be started directly with a list of child specifications via\n`start_link/2` or you may define a module-based supervisor that implements\nthe required callbacks. The sections below use `start_link/2` to start\nsupervisors in most examples, but it also includes a specific section\non module-based ones.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Supervisor"}
{"completion":"Examples\n\nIn order to start a supervisor, we need to first define a child process\nthat will be supervised. As an example, we will define a `GenServer`,\na generic server, that keeps a counter. Other processes can then send\nmessages to this process to read the counter and bump its value.\n\n> Note: in practice you would not define a counter as a GenServer. Instead,\n> if you need a counter, you would pass it around as inputs and outputs to\n> the functions that need it. The reason we picked a counter in this example\n> is due to its simplicity, as it allows us to focus on how supervisors work.\n\n    defmodule Counter do\n      use GenServer\n\n      def start_link(arg) when is_integer(arg) do\n        GenServer.start_link(__MODULE__, arg, name: __MODULE__)\n      end\n\n      ## Callbacks\n\n      @impl true\n      def init(counter) do\n        {:ok, counter}\n      end\n\n      @impl true\n      def handle_call(:get, _from, counter) do\n        {:reply, counter, counter}\n      end\n\n      def handle_call({:bump, value}, _from, counter) do\n        {:reply, counter, counter + value}\n      end\n    end\n\nThe `Counter` receives an argument on `start_link`. This argument\nis passed to the `init/1` callback which becomes the initial value\nof the counter. Our counter handles two operations (known as calls):\n`:get`, to get the current counter value, and `:bump`, that bumps\nthe counter by the given `value` and returns the old counter.\n\nWe can now start a supervisor that will start and supervise our\ncounter process. The first step is to define a list of **child\nspecifications** that control how each child behaves. Each child\nspecification is a map, as shown below:\n\n    children = [\n      # The Counter is a child started via Counter.start_link(0)\n      %{\n        id: Counter,\n        start: {Counter, :start_link, [0]}\n      }\n    ]\n\n    # Now we start the supervisor with the children and a strategy\n    {:ok, pid} = Supervisor.start_link(children, strategy: :one_for_one)\n\n    # After started, we can query the supervisor for information\n    Supervisor.count_children(pid)\n    #=> %{active: 1, specs: 1, supervisors: 0, workers: 1}\n\nNote that when starting the GenServer, we are registering it\nwith name `Counter` via the `name: __MODULE__` option. This allows\nus to call it directly and get its value:\n\n    GenServer.call(Counter, :get)\n    #=> 0\n\n    GenServer.cast(Counter, {:bump, 3})\n    #=> 0\n\n    GenServer.call(Counter, :get)\n    #=> 3\n\nHowever, there is a bug in our counter server. If we call `:bump` with\na non-numeric value, it is going to crash:\n\n    GenServer.call(Counter, {:bump, \"oops\"})\n    ** (exit) exited in: GenServer.call(Counter, {:bump, \"oops\"}, 5000)\n\nLuckily, since the server is being supervised by a supervisor, the\nsupervisor will automatically start a new one, reset back to its initial\nvalue of `0`:\n\n    GenServer.call(Counter, :get)\n    #=> 0\n\nSupervisors support different strategies; in the example above, we\nhave chosen `:one_for_one`. Furthermore, each supervisor can have many\nworkers and/or supervisors as children, with each one having its own\nconfiguration (as outlined in the \"Child specification\" section).\n\nThe rest of this document will cover how child processes are specified,\nhow they can be started and stopped, different supervision strategies\nand more.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Supervisor"}
{"completion":"Child specification\n\nThe child specification describes how the supervisor starts, shuts down,\nand restarts child processes.\n\nThe child specification is a map containing up to 6 elements. The first two keys\nin the following list are required, and the remaining ones are optional:\n\n  * `:id` - any term used to identify the child specification internally by\n    the supervisor; defaults to the given module. This key is required.\n    For supervisors, in the case of conflicting `:id` values, the supervisor\n    will refuse to initialize and require explicit IDs. This is not the case\n    for [dynamic supervisors](`DynamicSupervisor`) though.\n\n  * `:start` - a tuple with the module-function-args to be invoked\n    to start the child process. This key is required.\n\n  * `:restart` - an atom that defines when a terminated child process\n     should be restarted (see the \"Restart values\" section below).\n     This key is optional and defaults to `:permanent`.\n\n  * `:shutdown` - an integer or atom that defines how a child process should\n    be terminated (see the \"Shutdown values\" section below). This key\n    is optional and defaults to `5_000` if the type is `:worker` or\n    `:infinity` if the type is `:supervisor`.\n\n  * `:type` - specifies that the child process is a `:worker` or a\n    `:supervisor`. This key is optional and defaults to `:worker`.\n\n  * `:modules` - a list of modules used by hot code upgrade mechanisms\n    to determine which processes are using certain modules. It is typically\n    set to the callback module of behaviours like `GenServer`, `Supervisor`,\n    and such. It is set automatically based on the `:start` value and it is rarely\n    changed in practice.\n\nLet's understand what the `:shutdown` and `:restart` options control.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Supervisor"}
{"completion":"# Shutdown values (:shutdown)\n\nThe following shutdown values are supported in the `:shutdown` option:\n\n  * `:brutal_kill` - the child process is unconditionally and immediately\n    terminated using `Process.exit(child, :kill)`.\n\n  * any integer >= 0 - the amount of time in milliseconds that the\n    supervisor will wait for its children to terminate after emitting a\n    `Process.exit(child, :shutdown)` signal. If the child process is\n    not trapping exits, the initial `:shutdown` signal will terminate\n    the child process immediately. If the child process is trapping\n    exits, it has the given amount of time to terminate.\n    If it doesn't terminate within the specified time, the child process\n    is unconditionally terminated by the supervisor via\n    `Process.exit(child, :kill)`.\n\n  * `:infinity` - works as an integer except the supervisor will wait\n    indefinitely for the child to terminate. If the child process is a\n    supervisor, the recommended value is `:infinity` to give the supervisor\n    and its children enough time to shut down. This option can be used with\n    regular workers but doing so is discouraged and requires extreme care.\n    If not used carefully, the child process will never terminate,\n    preventing your application from terminating as well.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Supervisor"}
{"completion":"# Restart values (:restart)\n\nThe `:restart` option controls what the supervisor should consider to\nbe a successful termination or not. If the termination is successful,\nthe supervisor won't restart the child. If the child process crashed,\nthe supervisor will start a new one.\n\nThe following restart values are supported in the `:restart` option:\n\n  * `:permanent` - the child process is always restarted.\n\n  * `:temporary` - the child process is never restarted, regardless\n    of the supervision strategy: any termination (even abnormal) is\n    considered successful.\n\n  * `:transient` - the child process is restarted only if it\n    terminates abnormally, i.e., with an exit reason other than\n    `:normal`, `:shutdown`, or `{:shutdown, term}`.\n\nFor a more complete understanding of the exit reasons and their\nimpact, see the \"Exit reasons and restarts\" section.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Supervisor"}
{"completion":"`child_spec/1` function\n\nWhen starting a supervisor, we may pass a list of child specifications. Those\nspecifications are maps that tell how the supervisor should start, stop and\nrestart each of its children:\n\n    %{\n      id: Counter,\n      start: {Counter, :start_link, [0]}\n    }\n\nThe map above defines a child with `:id` of `Counter` that is started\nby calling `Counter.start_link(0)`.\n\nHowever, defining the child specification for each child as a map can be\nquite error prone, as we may change the `Counter` implementation and forget\nto update its specification. That's why Elixir allows you to pass a tuple with\nthe module name and the `start_link` argument instead of the specification:\n\n    children = [\n      {Counter, 0}\n    ]\n\nThe supervisor will then invoke `Counter.child_spec(0)` to retrieve a child\nspecification. Now the `Counter` module is responsible for building its own\nspecification, for example, we could write:\n\n    def child_spec(arg) do\n      %{\n        id: Counter,\n        start: {Counter, :start_link, [arg]}\n      }\n    end\n\nLuckily for us, `use GenServer` already defines a `Counter.child_spec/1`\nexactly like above, so you don't need to write the definition above yourself.\nIf you want to customize the automatically generated `child_spec/1` function,\nyou can pass the options directly to `use GenServer`:\n\n    use GenServer, restart: :transient\n\nFinally, note it is also possible to simply pass the `Counter` module as\na child:\n\n    children = [\n      Counter\n    ]\n\nWhen only the module name is given, it is equivalent to `{Counter, []}`,\nwhich in our case would be invalid, which is why we always pass the initial\ncounter explicitly.\n\nBy replacing the child specification with `{Counter, 0}`, we keep it\nencapsulated in the `Counter` module. We could now share our\n`Counter` implementation with other developers and they can add it directly\nto their supervision tree without worrying about the low-level details of\nthe counter.\n\nOverall, a child specification can be one of the following:\n\n  * a map representing the child specification itself - as outlined in the\n    \"Child specification\" section\n\n  * a tuple with a module as first element and the start argument as second -\n    such as `{Counter, 0}`. In this case, `Counter.child_spec(0)` is called\n    to retrieve the child specification\n\n  * a module - such as `Counter`. In this case, `Counter.child_spec([])`\n    would be called, which is invalid for the counter, but it is useful in\n    many other cases, especially when you want to pass a list of options\n    to the child process\n\nIf you need to convert a `{module, arg}` tuple or a module child specification to a\n[child specification](`t:child_spec/0`) or modify a child specification itself,\nyou can use the `Supervisor.child_spec/2` function.\nFor example, to run the counter with a different `:id` and a `:shutdown` value of\n10 seconds (10_000 milliseconds):\n\n    children = [\n      Supervisor.child_spec({Counter, 0}, id: MyCounter, shutdown: 10_000)\n    ]","prompt":"Can you write a docstring for the following Elixir function? Elixir.Supervisor"}
{"completion":"Supervisor strategies and options\n\nSo far we have started the supervisor passing a single child as a tuple\nas well as a strategy called `:one_for_one`:\n\n    children = [\n      {Counter, 0}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nThe first argument given to `start_link/2` is a list of child\nspecifications as defined in the \"child_spec/1\" section above.\n\nThe second argument is a keyword list of options:\n\n  * `:strategy` - the supervision strategy option. It can be either\n    `:one_for_one`, `:rest_for_one` or `:one_for_all`. Required.\n    See the \"Strategies\" section.\n\n  * `:max_restarts` - the maximum number of restarts allowed in\n    a time frame. Defaults to `3`.\n\n  * `:max_seconds` - the time frame in which `:max_restarts` applies.\n    Defaults to `5`.\n\n  * `:name` - a name to register the supervisor process. Supported values are\n    explained in the \"Name registration\" section in the documentation for\n    `GenServer`. Optional.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Supervisor"}
{"completion":"# Strategies\n\nSupervisors support different supervision strategies (through the\n`:strategy` option, as seen above):\n\n  * `:one_for_one` - if a child process terminates, only that\n    process is restarted.\n\n  * `:one_for_all` - if a child process terminates, all other child\n    processes are terminated and then all child processes (including\n    the terminated one) are restarted.\n\n  * `:rest_for_one` - if a child process terminates, the terminated child\n    process and the rest of the children started after it, are terminated and\n    restarted.\n\nIn the above, process termination refers to unsuccessful termination, which\nis determined by the `:restart` option.\n\nTo efficiently supervise children started dynamically, see `DynamicSupervisor`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Supervisor"}
{"completion":"# Name registration\n\nA supervisor is bound to the same name registration rules as a `GenServer`.\nRead more about these rules in the documentation for `GenServer`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Supervisor"}
{"completion":"Module-based supervisors\n\nIn the example so far, the supervisor was started by passing the supervision\nstructure to `start_link/2`. However, supervisors can also be created by\nexplicitly defining a supervision module:\n\n    defmodule MyApp.Supervisor do\n      # Automatically defines child_spec/1\n      use Supervisor\n\n      def start_link(init_arg) do\n        Supervisor.start_link(__MODULE__, init_arg, name: __MODULE__)\n      end\n\n      @impl true\n      def init(_init_arg) do\n        children = [\n          {Counter, 0}\n        ]\n\n        Supervisor.init(children, strategy: :one_for_one)\n      end\n    end\n\nThe difference between the two approaches is that a module-based\nsupervisor gives you more direct control over how the supervisor\nis initialized. Instead of calling `Supervisor.start_link/2` with\na list of child specifications that are automatically initialized, we manually\ninitialize the children by calling `Supervisor.init/2` inside its\n`c:init/1` callback. `Supervisor.init/2` accepts the same `:strategy`,\n`:max_restarts`, and `:max_seconds` options as `start_link/2`.\n\n`use Supervisor` also defines a `child_spec/1` function which allows\nus to run `MyApp.Supervisor` as a child of another supervisor or\nat the top of your supervision tree as:\n\n    children = [\n      MyApp.Supervisor\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nA general guideline is to use the supervisor without a callback\nmodule only at the top of your supervision tree, generally in the\n`c:Application.start/2` callback. We recommend using module-based\nsupervisors for any other supervisor in your application, so they\ncan run as a child of another supervisor in the tree. The `child_spec/1`\ngenerated automatically by `Supervisor` can be customized with the\nfollowing options:\n\n  * `:id` - the child specification identifier, defaults to the current module\n  * `:restart` - when the supervisor should be restarted, defaults to `:permanent`\n\nThe `@doc` annotation immediately preceding `use Supervisor` will be\nattached to the generated `child_spec/1` function.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Supervisor"}
{"completion":"Start and shutdown\n\nWhen the supervisor starts, it traverses all child specifications and\nthen starts each child in the order they are defined. This is done by\ncalling the function defined under the `:start` key in the child\nspecification and typically defaults to `start_link/1`.\n\nThe `start_link/1` (or a custom) is then called for each child process.\nThe `start_link/1` function must return `{:ok, pid}` where `pid` is the\nprocess identifier of a new process that is linked to the supervisor.\nThe child process usually starts its work by executing the `c:init/1`\ncallback. Generally speaking, the `init` callback is where we initialize\nand configure the child process.\n\nThe shutdown process happens in reverse order.\n\nWhen a supervisor shuts down, it terminates all children in the opposite\norder they are listed. The termination happens by sending a shutdown exit\nsignal, via `Process.exit(child_pid, :shutdown)`, to the child process and\nthen awaiting for a time interval for the child process to terminate. This\ninterval defaults to 5000 milliseconds. If the child process does not\nterminate in this interval, the supervisor abruptly terminates the child\nwith reason `:kill`. The shutdown time can be configured in the child\nspecification which is fully detailed in the next section.\n\nIf the child process is not trapping exits, it will shutdown immediately\nwhen it receives the first exit signal. If the child process is trapping\nexits, then the `terminate` callback is invoked, and the child process\nmust terminate in a reasonable time interval before being abruptly\nterminated by the supervisor.\n\nIn other words, if it is important that a process cleans after itself\nwhen your application or the supervision tree is shutting down, then\nthis process must trap exits and its child specification should specify\nthe proper `:shutdown` value, ensuring it terminates within a reasonable\ninterval.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Supervisor"}
{"completion":"Exit reasons and restarts\n\nA supervisor restarts a child process depending on its `:restart` configuration.\nFor example, when `:restart` is set to `:transient`, the supervisor does not\nrestart the child in case it exits with reason `:normal`, `:shutdown` or\n`{:shutdown, term}`.\n\nSo one may ask: which exit reason should I choose when exiting? There are\nthree options:\n\n  * `:normal` - in such cases, the exit won't be logged, there is no restart\n    in transient mode, and linked processes do not exit\n\n  * `:shutdown` or `{:shutdown, term}` - in such cases, the exit won't be\n    logged, there is no restart in transient mode, and linked processes exit\n    with the same reason unless they're trapping exits\n\n  * any other term - in such cases, the exit will be logged, there are\n    restarts in transient mode, and linked processes exit with the same\n    reason unless they're trapping exits\n\nNote that the supervisor that reaches maximum restart intensity will exit with\n`:shutdown` reason. In this case the supervisor will only be restarted if its\nchild specification was defined with the `:restart` option set to `:permanent`\n(the default).","prompt":"Can you write a docstring for the following Elixir function? Elixir.Supervisor"}
{"completion":"Lists command line arguments.\n\nReturns the list of command line arguments passed to the program.","prompt":"Can you write a docstring for the following Elixir function? argv()"}
{"completion":"Modifies command line arguments.\n\nChanges the list of command line arguments. Use it with caution,\nas it destroys any previous argv information.","prompt":"Can you write a docstring for the following Elixir function? argv(args)"}
{"completion":"Registers a program exit handler function.\n\nRegisters a function that will be invoked at the end of an Elixir script.\nA script is typically started via the command line via the `elixir` and\n`mix` executables.\n\nThe handler always executes in a different process from the one it was\nregistered in. As a consequence, any resources managed by the calling process\n(ETS tables, open files, and others) won't be available by the time the handler\nfunction is invoked.\n\nThe function must receive the exit status code as an argument.\n\nIf the VM terminates programmatically, via `System.stop/1`, `System.halt/1`,\nor exit signals, the `at_exit/1` callbacks are not executed.","prompt":"Can you write a docstring for the following Elixir function? at_exit(fun)"}
{"completion":"Elixir build information.\n\nReturns a map with the Elixir version, the Erlang/OTP release it was compiled\nwith, a short Git revision hash and the date and time it was built.\n\nEvery value in the map is a string, and these are:\n\n  * `:build` - the Elixir version, short Git revision hash and\n    Erlang/OTP release it was compiled with\n  * `:date` - a string representation of the ISO8601 date and time it was built\n  * `:otp_release` - OTP release it was compiled with\n  * `:revision` - short Git revision hash. If Git was not available at building\n    time, it is set to `\"\"`\n  * `:version` - the Elixir version\n\nOne should not rely on the specific formats returned by each of those fields.\nInstead one should use specialized functions, such as `version/0` to retrieve\nthe Elixir version and `otp_release/0` to retrieve the Erlang/OTP release.\n\n## Examples\n\n    iex> System.build_info()\n    %{\n      build: \"1.9.0-dev (772a00a0c) (compiled with Erlang/OTP 21)\",\n      date: \"2018-12-24T01:09:21Z\",\n      otp_release: \"21\",\n      revision: \"772a00a0c\",\n      version: \"1.9.0-dev\"\n    }","prompt":"Can you write a docstring for the following Elixir function? build_info()"}
{"completion":"Executes the given `command` with `args`.\n\n`command` is expected to be an executable available in PATH\nunless an absolute path is given.\n\n`args` must be a list of binaries which the executable will receive\nas its arguments as is. This means that:\n\n  * environment variables will not be interpolated\n  * wildcard expansion will not happen (unless `Path.wildcard/2` is used\n    explicitly)\n  * arguments do not need to be escaped or quoted for shell safety\n\nThis function returns a tuple containing the collected result\nand the command exit status.\n\nInternally, this function uses a `Port` for interacting with the\noutside world. However, if you plan to run a long-running program,\nports guarantee stdin/stdout devices will be closed but it does not\nautomatically terminate the program. The documentation for the\n`Port` module describes this problem and possible solutions under\nthe \"Zombie processes\" section.\n\n## Examples\n\n    iex> System.cmd(\"echo\", [\"hello\"])\n    {\"hello\\n\", 0}\n\n    iex> System.cmd(\"echo\", [\"hello\"], env: [{\"MIX_ENV\", \"test\"}])\n    {\"hello\\n\", 0}\n\nIf you want to stream the output to Standard IO as it arrives:\n\n    iex> System.cmd(\"echo\", [\"hello\"], into: IO.stream())\n    hello\n    {%IO.Stream{}, 0}\n\n## Options\n\n  * `:into` - injects the result into the given collectable, defaults to `\"\"`\n  * `:cd` - the directory to run the command in\n  * `:env` - an enumerable of tuples containing environment key-value as\n    binary. The child process inherits all environment variables from its\n    parent process, the Elixir application, except those overwritten or\n    cleared using this option. Specify a value of `nil` to clear (unset) an\n    environment variable, which is useful for preventing credentials passed\n    to the application from leaking into child processes.\n  * `:arg0` - sets the command arg0\n  * `:stderr_to_stdout` - redirects stderr to stdout when `true`\n  * `:parallelism` - when `true`, the VM will schedule port tasks to improve\n    parallelism in the system. If set to `false`, the VM will try to perform\n    commands immediately, improving latency at the expense of parallelism.\n    The default can be set on system startup by passing the \"+spp\" argument\n    to `--erl`.\n\n## Error reasons\n\nIf invalid arguments are given, `ArgumentError` is raised by\n`System.cmd/3`. `System.cmd/3` also expects a strict set of\noptions and will raise if unknown or invalid options are given.\n\nFurthermore, `System.cmd/3` may fail with one of the POSIX reasons\ndetailed below:\n\n  * `:system_limit` - all available ports in the Erlang emulator are in use\n\n  * `:enomem` - there was not enough memory to create the port\n\n  * `:eagain` - there are no more available operating system processes\n\n  * `:enametoolong` - the external command given was too long\n\n  * `:emfile` - there are no more available file descriptors\n    (for the operating system process that the Erlang emulator runs in)\n\n  * `:enfile` - the file table is full (for the entire operating system)\n\n  * `:eacces` - the command does not point to an executable file\n\n  * `:enoent` - the command does not point to an existing file\n\n## Shell commands\n\nIf you desire to execute a trusted command inside a shell, with pipes,\nredirecting and so on, please check `shell/2`.","prompt":"Can you write a docstring for the following Elixir function? cmd(command, args, opts \\\\ [])"}
{"completion":"Returns the endianness the system was compiled with.","prompt":"Can you write a docstring for the following Elixir function? compiled_endianness()"}
{"completion":"Converts `time` from time unit `from_unit` to time unit `to_unit`.\n\nThe result is rounded via the floor function.\n\n`convert_time_unit/3` accepts an additional time unit (other than the\nones in the `t:time_unit/0` type) called `:native`. `:native` is the time\nunit used by the Erlang runtime system. It's determined when the runtime\nstarts and stays the same until the runtime is stopped, but could differ\nthe next time the runtime is started on the same machine. For this reason,\nyou should use this function to convert `:native` time units to a predictable\nunit before you display them to humans.\n\nTo determine how many seconds the `:native` unit represents in your current\nruntime, you can call this function to convert 1 second to the `:native`\ntime unit: `System.convert_time_unit(1, :second, :native)`.","prompt":"Can you write a docstring for the following Elixir function? convert_time_unit(time, from_unit, to_unit)"}
{"completion":"Current working directory.\n\nReturns the current working directory or `nil` if one\nis not available.","prompt":"Can you write a docstring for the following Elixir function? cwd()"}
{"completion":"Current working directory, exception on error.\n\nReturns the current working directory or raises `RuntimeError`.","prompt":"Can you write a docstring for the following Elixir function? cwd!()"}
{"completion":"Deletes an environment variable.\n\nRemoves the variable `varname` from the environment.","prompt":"Can you write a docstring for the following Elixir function? delete_env(varname)"}
{"completion":"Returns the endianness.","prompt":"Can you write a docstring for the following Elixir function? endianness()"}
{"completion":"Returns the value of the given environment variable or `:error` if not found.\n\nIf the environment variable `varname` is set, then `{:ok, value}` is returned\nwhere `value` is a string. If `varname` is not set, `:error` is returned.\n\n## Examples\n\n    iex> System.fetch_env(\"PORT\")\n    {:ok, \"4000\"}\n\n    iex> System.fetch_env(\"NOT_SET\")\n    :error","prompt":"Can you write a docstring for the following Elixir function? fetch_env(varname)"}
{"completion":"Returns the value of the given environment variable or raises if not found.\n\nSame as `get_env/1` but raises instead of returning `nil` when the variable is\nnot set.\n\n## Examples\n\n    iex> System.fetch_env!(\"PORT\")\n    \"4000\"\n\n    iex> System.fetch_env!(\"NOT_SET\")\n    ** (ArgumentError) could not fetch environment variable \"NOT_SET\" because it is not set","prompt":"Can you write a docstring for the following Elixir function? fetch_env!(varname)"}
{"completion":"Locates an executable on the system.\n\nThis function looks up an executable program given\nits name using the environment variable PATH on Windows and Unix-like\noperating systems. It also considers the proper executable\nextension for each operating system, so for Windows it will try to\nlookup files with `.com`, `.cmd` or similar extensions.","prompt":"Can you write a docstring for the following Elixir function? find_executable(program)"}
{"completion":"Returns all system environment variables.\n\nThe returned value is a map containing name-value pairs.\nVariable names and their values are strings.","prompt":"Can you write a docstring for the following Elixir function? get_env()"}
{"completion":"Returns the value of the given environment variable.\n\nThe returned value of the environment variable\n`varname` is a string. If the environment variable\nis not set, returns the string specified in `default` or\n`nil` if none is specified.\n\n## Examples\n\n    iex> System.get_env(\"PORT\")\n    \"4000\"\n\n    iex> System.get_env(\"NOT_SET\")\n    nil\n\n    iex> System.get_env(\"NOT_SET\", \"4001\")\n    \"4001\"","prompt":"Can you write a docstring for the following Elixir function? get_env(varname, default \\\\ nil)"}
{"completion":"Erlang VM process identifier.\n\nReturns the process identifier of the current Erlang emulator\nin the format most commonly used by the operating system environment.\n\nFor more information, see `:os.getpid/0`.","prompt":"Can you write a docstring for the following Elixir function? get_pid()"}
{"completion":"Immediately halts the Erlang runtime system.\n\nTerminates the Erlang runtime system without properly shutting down\napplications and ports. Please see `stop/1` for a careful shutdown of the\nsystem.\n\n`status` must be a non-negative integer, the atom `:abort` or a binary.\n\n  * If an integer, the runtime system exits with the integer value which\n    is returned to the operating system.\n\n  * If `:abort`, the runtime system aborts producing a core dump, if that is\n    enabled in the operating system.\n\n  * If a string, an Erlang crash dump is produced with status as slogan,\n    and then the runtime system exits with status code 1.\n\nNote that on many platforms, only the status codes 0-255 are supported\nby the operating system.\n\nFor more information, see `:erlang.halt/1`.\n\n## Examples\n\n    System.halt(0)\n    System.halt(1)\n    System.halt(:abort)","prompt":"Can you write a docstring for the following Elixir function? halt(status \\\\ 0)"}
{"completion":"Returns the current monotonic time in the `:native` time unit.\n\nThis time is monotonically increasing and starts in an unspecified\npoint in time.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? monotonic_time()"}
{"completion":"Returns the current monotonic time in the given time unit.\n\nThis time is monotonically increasing and starts in an unspecified\npoint in time.","prompt":"Can you write a docstring for the following Elixir function? monotonic_time(unit)"}
{"completion":"Checks if the system will halt or not at the end of ARGV processing.","prompt":"Can you write a docstring for the following Elixir function? no_halt()"}
{"completion":"Marks if the system should halt or not at the end of ARGV processing.","prompt":"Can you write a docstring for the following Elixir function? no_halt(boolean)"}
{"completion":"Returns the current operating system (OS) time.\n\nThe result is returned in the `:native` time unit.\n\nThis time may be adjusted forwards or backwards in time\nwith no limitation and is not monotonic.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? os_time()"}
{"completion":"Returns the current operating system (OS) time in the given time `unit`.\n\nThis time may be adjusted forwards or backwards in time\nwith no limitation and is not monotonic.","prompt":"Can you write a docstring for the following Elixir function? os_time(unit)"}
{"completion":"Returns the Erlang/OTP release number.","prompt":"Can you write a docstring for the following Elixir function? otp_release()"}
{"completion":"Returns the operating system PID for the current Erlang runtime system instance.\n\nReturns a string containing the (usually) numerical identifier for a process.\nOn Unix-like operating systems, this is typically the return value of the `getpid()` system call.\nOn Windows, the process ID as returned by the `GetCurrentProcessId()` system\ncall is used.\n\n## Examples\n\n    System.pid()","prompt":"Can you write a docstring for the following Elixir function? pid()"}
{"completion":"Sets multiple environment variables.\n\nSets a new value for each environment variable corresponding\nto each `{key, value}` pair in `enum`. Keys are automatically\nconverted to strings, values are sent as is. `nil` values erase\nthe given keys.","prompt":"Can you write a docstring for the following Elixir function? put_env(enum)"}
{"completion":"Sets an environment variable value.\n\nSets a new `value` for the environment variable `varname`.","prompt":"Can you write a docstring for the following Elixir function? put_env(varname, value)"}
{"completion":"Restarts all applications in the Erlang runtime system.\n\nAll applications are taken down smoothly, all code is unloaded, and all ports\nare closed before the system starts all applications once again.\n\n## Examples\n\n    System.restart()","prompt":"Can you write a docstring for the following Elixir function? restart()"}
{"completion":"Returns the number of schedulers in the VM.","prompt":"Can you write a docstring for the following Elixir function? schedulers()"}
{"completion":"Returns the number of schedulers online in the VM.","prompt":"Can you write a docstring for the following Elixir function? schedulers_online()"}
{"completion":"Executes the given `command` in the OS shell.\n\nIt uses `sh` for Unix-like systems and `cmd` for Windows.\n\n> **Important:**: Use this function with care. In particular, **never\n> pass untrusted user input to this function**, as the user would be\n> able to perform \"command injection attacks\" by executing any code\n> directly on the machine. Generally speaking, prefer to use `cmd/3`\n> over this function.\n\n## Examples\n\n    iex> System.shell(\"echo hello\")\n    {\"hello\\n\", 0}\n\nIf you want to stream the output to Standard IO as it arrives:\n\n    iex> System.shell(\"echo hello\", into: IO.stream())\n    hello\n    {%IO.Stream{}, 0}\n\n## Options\n\nIt accepts the same options as `cmd/3` (except for `arg0`).\nIt also accepts the following exclusive options:\n\n  * `:close_stdin` (since v1.14.1) - if the stdin should be closed\n    on Unix systems, forcing any command that waits on stdin to\n    immediately terminate. Defaults to false.","prompt":"Can you write a docstring for the following Elixir function? shell(command, opts \\\\ [])"}
{"completion":"Deprecated mechanism to retrieve the last exception stacktrace.\n\nIt always return an empty list.","prompt":"Can you write a docstring for the following Elixir function? stacktrace()"}
{"completion":"Carefully stops the Erlang runtime system.\n\nAll applications are taken down smoothly, all code is unloaded, and all ports\nare closed before the system terminates by calling `halt/1`.\n\n`status` must be a non-negative integer or a binary.\n\n  * If an integer, the runtime system exits with the integer value which is\n    returned to the operating system.\n\n  * If a binary, an Erlang crash dump is produced with status as slogan, and\n    then the runtime system exits with status code 1.\n\nNote that on many platforms, only the status codes 0-255 are supported\nby the operating system.\n\n## Examples\n\n    System.stop(0)\n    System.stop(1)","prompt":"Can you write a docstring for the following Elixir function? stop(status \\\\ 0)"}
{"completion":"Returns the current system time in the `:native` time unit.\n\nIt is the VM view of the `os_time/0`. They may not match in\ncase of time warps although the VM works towards aligning\nthem. This time is not monotonic.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? system_time()"}
{"completion":"Returns the current system time in the given time unit.\n\nIt is the VM view of the `os_time/0`. They may not match in\ncase of time warps although the VM works towards aligning\nthem. This time is not monotonic.","prompt":"Can you write a docstring for the following Elixir function? system_time(unit)"}
{"completion":"Returns the current time offset between the Erlang VM monotonic\ntime and the Erlang VM system time.\n\nThe result is returned in the `:native` time unit.\n\nSee `time_offset/1` for more information.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? time_offset()"}
{"completion":"Returns the current time offset between the Erlang VM monotonic\ntime and the Erlang VM system time.\n\nThe result is returned in the given time unit `unit`. The returned\noffset, added to an Erlang monotonic time (for instance, one obtained with\n`monotonic_time/1`), gives the Erlang system time that corresponds\nto that monotonic time.","prompt":"Can you write a docstring for the following Elixir function? time_offset(unit)"}
{"completion":"Writable temporary directory.\n\nReturns a writable temporary directory.\nSearches for directories in the following order:\n\n  1. the directory named by the TMPDIR environment variable\n  2. the directory named by the TEMP environment variable\n  3. the directory named by the TMP environment variable\n  4. `C:\\TMP` on Windows or `/tmp` on Unix-like operating systems\n  5. as a last resort, the current working directory\n\nReturns `nil` if none of the above are writable.","prompt":"Can you write a docstring for the following Elixir function? tmp_dir()"}
{"completion":"Writable temporary directory, exception on error.\n\nSame as `tmp_dir/0` but raises `RuntimeError`\ninstead of returning `nil` if no temp dir is set.","prompt":"Can you write a docstring for the following Elixir function? tmp_dir!()"}
{"completion":"Traps the given `signal` to execute the `fun`.\n\n> **Important**: Trapping signals may have strong implications\n> on how a system shuts down and behave in production and\n> therefore it is extremely discouraged for libraries to\n> set their own traps. Instead, they should redirect users\n> to configure them themselves. The only cases where it is\n> acceptable for libraries to set their own traps is when\n> using Elixir in script mode, such as in `.exs` files and\n> via Mix tasks.\n\nAn optional `id` that uniquely identifies the function\ncan be given, otherwise a unique one is automatically\ngenerated. If a previously registered `id` is given,\nthis function returns an error tuple. The `id` can be\nused to remove a registered signal by calling\n`untrap_signal/2`.\n\nThe given `fun` receives no arguments and it must return\n`:ok`.\n\nIt returns `{:ok, id}` in case of success,\n`{:error, :already_registered}` in case the id has already\nbeen registered for the given signal, or `{:error, :not_sup}`\nin case trapping exists is not supported by the current OS.\n\nThe first time a signal is trapped, it will override the\ndefault behaviour from the operating system. If the same\nsignal is trapped multiple times, subsequent functions\ngiven to `trap_signal` will execute *first*. In other\nwords, you can consider each function is prepended to\nthe signal handler.\n\nBy default, the Erlang VM register traps to the three\nsignals:\n\n  * `:sigstop` - gracefully shuts down the VM with `stop/0`\n  * `:sigquit` - halts the VM via `halt/0`\n  * `:sigusr1` - halts the VM via status code of 1\n\nTherefore, if you add traps to the signals above, the\ndefault behaviour above will be executed after all user\nsignals.\n\n## Implementation notes\n\nAll signals run from a single process. Therefore, blocking the\n`fun` will block subsequent traps. It is also not possible to add\nor remove traps from within a trap itself.\n\nInternally, this functionality is built on top of `:os.set_signal/2`.\nWhen you register a trap, Elixir automatically sets it to `:handle`\nand it reverts it back to `:default` once all traps are removed\n(except for `:sigquit`, `:sigterm`, and `:sigusr1` which are always\nhandled). If you or a library call `:os.set_signal/2` directly,\nit may disable Elixir traps (or Elixir may override your configuration).","prompt":"Can you write a docstring for the following Elixir function? trap_signal(signal, id \\\\ make_ref(), fun)"}
{"completion":"Generates and returns an integer that is unique in the current runtime\ninstance.\n\n\"Unique\" means that this function, called with the same list of `modifiers`,\nwill never return the same integer more than once on the current runtime\ninstance.\n\nIf `modifiers` is `[]`, then a unique integer (that can be positive or negative) is returned.\nOther modifiers can be passed to change the properties of the returned integer:\n\n  * `:positive` - the returned integer is guaranteed to be positive.\n  * `:monotonic` - the returned integer is monotonically increasing. This\n    means that, on the same runtime instance (but even on different\n    processes), integers returned using the `:monotonic` modifier will always\n    be strictly less than integers returned by successive calls with the\n    `:monotonic` modifier.\n\nAll modifiers listed above can be combined; repeated modifiers in `modifiers`\nwill be ignored.\n\nInlined by the compiler.","prompt":"Can you write a docstring for the following Elixir function? unique_integer(modifiers \\\\ [])"}
{"completion":"Removes a previously registered `signal` with `id`.","prompt":"Can you write a docstring for the following Elixir function? untrap_signal(signal, id)"}
{"completion":"User home directory.\n\nReturns the user home directory (platform independent).","prompt":"Can you write a docstring for the following Elixir function? user_home()"}
{"completion":"User home directory, exception on error.\n\nSame as `user_home/0` but raises `RuntimeError`\ninstead of returning `nil` if no user home is set.","prompt":"Can you write a docstring for the following Elixir function? user_home!()"}
{"completion":"Elixir version information.\n\nReturns Elixir's version as binary.","prompt":"Can you write a docstring for the following Elixir function? version()"}
{"completion":"The `System` module provides functions that interact directly\nwith the VM or the host system.","prompt":"Can you write a docstring for the following Elixir function? Elixir.System"}
{"completion":"Time\n\nThe `System` module also provides functions that work with time,\nreturning different times kept by the system with support for\ndifferent time units.\n\nOne of the complexities in relying on system times is that they\nmay be adjusted. For example, when you enter and leave daylight\nsaving time, the system clock will be adjusted, often adding\nor removing one hour. We call such changes \"time warps\". In\norder to understand how such changes may be harmful, imagine\nthe following code:\n\n    ## DO NOT DO THIS\n    prev = System.os_time()\n    # ... execute some code ...\n    next = System.os_time()\n    diff = next - prev\n\nIf, while the code is executing, the system clock changes,\nsome code that executed in 1 second may be reported as taking\nover 1 hour! To address such concerns, the VM provides a\nmonotonic time via `System.monotonic_time/0` which never\ndecreases and does not leap:\n\n    ## DO THIS\n    prev = System.monotonic_time()\n    # ... execute some code ...\n    next = System.monotonic_time()\n    diff = next - prev\n\nGenerally speaking, the VM provides three time measurements:\n\n  * `os_time/0` - the time reported by the operating system (OS). This time may be\n    adjusted forwards or backwards in time with no limitation;\n\n  * `system_time/0` - the VM view of the `os_time/0`. The system time and operating\n    system time may not match in case of time warps although the VM works towards\n    aligning them. This time is not monotonic (i.e., it may decrease)\n    as its behaviour is configured [by the VM time warp\n    mode](https://www.erlang.org/doc/apps/erts/time_correction.html#Time_Warp_Modes);\n\n  * `monotonic_time/0` - a monotonically increasing time provided\n    by the Erlang VM.\n\nThe time functions in this module work in the `:native` unit\n(unless specified otherwise), which is operating system dependent. Most of\nthe time, all calculations are done in the `:native` unit, to\navoid loss of precision, with `convert_time_unit/3` being\ninvoked at the end to convert to a specific time unit like\n`:millisecond` or `:microsecond`. See the `t:time_unit/0` type for\nmore information.\n\nFor a more complete rundown on the VM support for different\ntimes, see the [chapter on time and time\ncorrection](https://www.erlang.org/doc/apps/erts/time_correction.html)\nin the Erlang docs.","prompt":"Can you write a docstring for the following Elixir function? Elixir.System"}
{"completion":"Starts a task that can be awaited on.\n\nThe `supervisor` must be a reference as defined in `Supervisor`.\nThe task will still be linked to the caller, see `Task.async/3` for\nmore information and `async_nolink/3` for a non-linked variant.\n\nRaises an error if `supervisor` has reached the maximum number of\nchildren.\n\n## Options\n\n  * `:shutdown` - `:brutal_kill` if the tasks must be killed directly on shutdown\n    or an integer indicating the timeout value, defaults to 5000 milliseconds.","prompt":"Can you write a docstring for the following Elixir function? async(supervisor, fun, options \\\\ [])"}
{"completion":"Starts a task that can be awaited on.\n\nThe `supervisor` must be a reference as defined in `Supervisor`.\nThe task will still be linked to the caller, see `Task.async/3` for\nmore information and `async_nolink/3` for a non-linked variant.\n\nRaises an error if `supervisor` has reached the maximum number of\nchildren.\n\n## Options\n\n  * `:shutdown` - `:brutal_kill` if the tasks must be killed directly on shutdown\n    or an integer indicating the timeout value, defaults to 5000 milliseconds.","prompt":"Can you write a docstring for the following Elixir function? async(supervisor, module, fun, args, options \\\\ [])"}
{"completion":"Starts a task that can be awaited on.\n\nThe `supervisor` must be a reference as defined in `Supervisor`.\nThe task won't be linked to the caller, see `Task.async/3` for\nmore information.\n\nRaises an error if `supervisor` has reached the maximum number of\nchildren.\n\n## Options\n\n  * `:shutdown` - `:brutal_kill` if the tasks must be killed directly on shutdown\n    or an integer indicating the timeout value, defaults to 5000 milliseconds.\n\n## Compatibility with OTP behaviours\n\nIf you create a task using `async_nolink` inside an OTP behaviour\nlike `GenServer`, you should match on the message coming from the\ntask inside your `c:GenServer.handle_info/2` callback.\n\nThe reply sent by the task will be in the format `{ref, result}`,\nwhere `ref` is the monitor reference held by the task struct\nand `result` is the return value of the task function.\n\nKeep in mind that, regardless of how the task created with `async_nolink`\nterminates, the caller's process will always receive a `:DOWN` message\nwith the same `ref` value that is held by the task struct. If the task\nterminates normally, the reason in the `:DOWN` message will be `:normal`.\n\n## Examples\n\nTypically, you use `async_nolink/3` when there is a reasonable expectation that\nthe task may fail, and you don't want it to take down the caller. Let's see an\nexample where a `GenServer` is meant to run a single task and track its status:\n\n    defmodule MyApp.Server do\n      use GenServer\n\n      # ...\n\n      def start_task do\n        GenServer.call(__MODULE__, :start_task)\n      end\n\n      # In this case the task is already running, so we just return :ok.\n      def handle_call(:start_task, _from, %{ref: ref} = state) when is_reference(ref) do\n        {:reply, :ok, state}\n      end\n\n      # The task is not running yet, so let's start it.\n      def handle_call(:start_task, _from, %{ref: nil} = state) do\n        task =\n          Task.Supervisor.async_nolink(MyApp.TaskSupervisor, fn ->\n            ...\n          end)\n\n        # We return :ok and the server will continue running\n        {:reply, :ok, %{state | ref: task.ref}}\n      end\n\n      # The task completed successfully\n      def handle_info({ref, answer}, %{ref: ref} = state) do\n        # We don't care about the DOWN message now, so let's demonitor and flush it\n        Process.demonitor(ref, [:flush])\n        # Do something with the result and then return\n        {:noreply, %{state | ref: nil}}\n      end\n\n      # The task failed\n      def handle_info({:DOWN, ref, :process, _pid, _reason}, %{ref: ref} = state) do\n        # Log and possibly restart the task...\n        {:noreply, %{state | ref: nil}}\n      end\n    end","prompt":"Can you write a docstring for the following Elixir function? async_nolink(supervisor, fun, options \\\\ [])"}
{"completion":"Starts a task that can be awaited on.\n\nThe `supervisor` must be a reference as defined in `Supervisor`.\nThe task won't be linked to the caller, see `Task.async/3` for\nmore information.\n\nRaises an error if `supervisor` has reached the maximum number of\nchildren.\n\nNote this function requires the task supervisor to have `:temporary`\nas the `:restart` option (the default), as `async_nolink/5` keeps a\ndirect reference to the task which is lost if the task is restarted.","prompt":"Can you write a docstring for the following Elixir function? async_nolink(supervisor, module, fun, args, options \\\\ [])"}
{"completion":"Returns a stream that runs the given function `fun` concurrently\non each element in `enumerable`.\n\nEach element in `enumerable` is passed as argument to the given function `fun`\nand processed by its own task. The tasks will be spawned under the given\n`supervisor` and linked to the caller process, similarly to `async/3`.\n\nSee `async_stream/6` for discussion, options, and examples.","prompt":"Can you write a docstring for the following Elixir function? async_stream(supervisor, enumerable, fun, options \\\\ [])"}
{"completion":"Returns a stream where the given function (`module` and `function`)\nis mapped concurrently on each element in `enumerable`.\n\nEach element will be prepended to the given `args` and processed by its\nown task. The tasks will be spawned under the given `supervisor` and\nlinked to the caller process, similarly to `async/5`.\n\nWhen streamed, each task will emit `{:ok, value}` upon successful\ncompletion or `{:exit, reason}` if the caller is trapping exits.\nThe order of results depends on the value of the `:ordered` option.\n\nThe level of concurrency and the time tasks are allowed to run can\nbe controlled via options (see the \"Options\" section below).\n\nIf you find yourself trapping exits to handle exits inside\nthe async stream, consider using `async_stream_nolink/6` to start tasks\nthat are not linked to the calling process.\n\n## Options\n\n  * `:max_concurrency` - sets the maximum number of tasks to run\n    at the same time. Defaults to `System.schedulers_online/0`.\n\n  * `:ordered` - whether the results should be returned in the same order\n    as the input stream. This option is useful when you have large\n    streams and don't want to buffer results before they are delivered.\n    This is also useful when you're using the tasks for side effects.\n    Defaults to `true`.\n\n  * `:timeout` - the maximum amount of time to wait (in milliseconds)\n    without receiving a task reply (across all running tasks).\n    Defaults to `5000`.\n\n  * `:on_timeout` - what do to when a task times out. The possible\n    values are:\n    * `:exit` (default) - the process that spawned the tasks exits.\n    * `:kill_task` - the task that timed out is killed. The value\n      emitted for that task is `{:exit, :timeout}`.\n\n  * `:shutdown` - `:brutal_kill` if the tasks must be killed directly on shutdown\n    or an integer indicating the timeout value. Defaults to `5000` milliseconds.\n\n## Examples\n\nLet's build a stream and then enumerate it:\n\n    stream = Task.Supervisor.async_stream(MySupervisor, collection, Mod, :expensive_fun, [])\n    Enum.to_list(stream)","prompt":"Can you write a docstring for the following Elixir function? async_stream(supervisor, enumerable, module, function, args, options \\\\ [])"}
{"completion":"Returns a stream that runs the given `function` concurrently on each\nelement in `enumerable`.\n\nEach element in `enumerable` is passed as argument to the given function `fun`\nand processed by its own task. The tasks will be spawned under the given\n`supervisor` and will not be linked to the caller process, similarly\nto `async_nolink/3`.\n\nSee `async_stream/6` for discussion and examples.","prompt":"Can you write a docstring for the following Elixir function? async_stream_nolink(supervisor, enumerable, fun, options \\\\ [])"}
{"completion":"Returns a stream where the given function (`module` and `function`)\nis mapped concurrently on each element in `enumerable`.\n\nEach element in `enumerable` will be prepended to the given `args` and processed\nby its own task. The tasks will be spawned under the given `supervisor` and\nwill not be linked to the caller process, similarly to `async_nolink/5`.\n\nSee `async_stream/6` for discussion, options, and examples.","prompt":"Can you write a docstring for the following Elixir function? async_stream_nolink(supervisor, enumerable, module, function, args, options \\\\ [])"}
{"completion":"Returns all children PIDs except those that are restarting.\n\nNote that calling this function when supervising a large number\nof children under low memory conditions can cause an out of memory\nexception.","prompt":"Can you write a docstring for the following Elixir function? children(supervisor)"}
{"completion":"Starts a task as a child of the given `supervisor`.\n\n    Task.Supervisor.start_child(MyTaskSupervisor, fn ->\n      IO.puts \"I am running in a task\"\n    end)\n\nNote that the spawned process is not linked to the caller, but\nonly to the supervisor. This command is useful in case the\ntask needs to perform side-effects (like I/O) and you have no\ninterest in its results nor if it completes successfully.\n\n## Options\n\n  * `:restart` - the restart strategy, may be `:temporary` (the default),\n    `:transient` or `:permanent`. `:temporary` means the task is never\n    restarted, `:transient` means it is restarted if the exit is not\n    `:normal`, `:shutdown` or `{:shutdown, reason}`. A `:permanent` restart\n    strategy means it is always restarted.\n\n  * `:shutdown` - `:brutal_kill` if the task must be killed directly on shutdown\n    or an integer indicating the timeout value, defaults to 5000 milliseconds.","prompt":"Can you write a docstring for the following Elixir function? start_child(supervisor, fun, options \\\\ [])"}
{"completion":"Starts a task as a child of the given `supervisor`.\n\nSimilar to `start_child/3` except the task is specified\nby the given `module`, `fun` and `args`.","prompt":"Can you write a docstring for the following Elixir function? start_child(supervisor, module, fun, args, options \\\\ [])"}
{"completion":"Starts a new supervisor.\n\n## Examples\n\nA task supervisor is typically started under a supervision tree using\nthe tuple format:\n\n    {Task.Supervisor, name: MyApp.TaskSupervisor}\n\nYou can also start it by calling `start_link/1` directly:\n\n    Task.Supervisor.start_link(name: MyApp.TaskSupervisor)\n\nBut this is recommended only for scripting and should be avoided in\nproduction code. Generally speaking, processes should always be started\ninside supervision trees.\n\n## Options\n\n  * `:name` - used to register a supervisor name, the supported values are\n    described under the `Name Registration` section in the `GenServer` module\n    docs;\n\n  * `:max_restarts`, `:max_seconds`, and `:max_children` - as specified in\n    `DynamicSupervisor`;\n\nThis function could also receive `:restart` and `:shutdown` as options\nbut those two options have been deprecated and it is now preferred to\ngive them directly to `start_child`.","prompt":"Can you write a docstring for the following Elixir function? start_link(options \\\\ [])"}
{"completion":"Terminates the child with the given `pid`.","prompt":"Can you write a docstring for the following Elixir function? terminate_child(supervisor, pid)"}
{"completion":"A task supervisor.\n\nThis module defines a supervisor which can be used to dynamically\nsupervise tasks.\n\nA task supervisor is started with no children, often under a\nsupervisor and a name:\n\n    children = [\n      {Task.Supervisor, name: MyApp.TaskSupervisor}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nThe options given in the child specification are documented in `start_link/1`.\n\nOnce started, you can start tasks directly under the supervisor, for example:\n\n    task = Task.Supervisor.async(MyApp.TaskSupervisor, fn ->\n      :do_some_work\n    end)\n\nSee the `Task` module for more examples.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Task.Supervisor"}
{"completion":"Scalability and partitioning\n\nThe `Task.Supervisor` is a single process responsible for starting\nother processes. In some applications, the `Task.Supervisor` may\nbecome a bottleneck. To address this, you can start multiple instances\nof the `Task.Supervisor` and then pick a random instance to start\nthe task on.\n\nInstead of:\n\n    children = [\n      {Task.Supervisor, name: Task.Supervisor}\n    ]\n\nand:\n\n    Task.Supervisor.async(MyApp.TaskSupervisor, fn -> :do_some_work end)\n\nYou can do this:\n\n    children = [\n      {PartitionSupervisor,\n       child_spec: Task.Supervisor,\n       name: MyApp.TaskSupervisors}\n    ]\n\nand then:\n\n    Task.Supervisor.async(\n      {:via, PartitionSupervisor, {MyApp.TaskSupervisors, self()}},\n      fn -> :do_some_work end\n    )\n\nIn the code above, we start a partition supervisor that will by default\nstart a dynamic supervisor for each core in your machine. Then, instead\nof calling the `Task.Supervisor` by name, you call it through the\npartition supervisor using the `{:via, PartitionSupervisor, {name, key}}`\nformat, where `name` is the name of the partition supervisor and `key`\nis the routing key. We picked `self()` as the routing key, which means\neach process will be assigned one of the existing task supervisors.\nRead the `PartitionSupervisor` docs for more information.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Task.Supervisor"}
{"completion":"Name registration\n\nA `Task.Supervisor` is bound to the same name registration rules as a\n`GenServer`. Read more about them in the `GenServer` docs.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Task.Supervisor"}
{"completion":"The Task struct.\n\nIt contains these fields:\n\n  * `:mfa` - a three-element tuple containing the module, function name,\n    and arity invoked to start the task in `async/1` and `async/3`\n\n  * `:owner` - the PID of the process that started the task\n\n  * `:pid` - the PID of the task process; `nil` if the task does\n    not use a task process\n\n  * `:ref` - the task monitor reference","prompt":"Can you write a docstring for the following Elixir function? %Task{}"}
{"completion":"Starts a task that must be awaited on.\n\n`fun` must be a zero-arity anonymous function. This function\nspawns a process that is linked to and monitored by the caller\nprocess. A `Task` struct is returned containing the relevant\ninformation. Developers must eventually call `Task.await/2` or\n`Task.yield/2` followed by `Task.shutdown/2` on the returned task.\n\nRead the `Task` module documentation for more information about\nthe general usage of async tasks.\n\n## Linking\n\nThis function spawns a process that is linked to and monitored\nby the caller process. The linking part is important because it\naborts the task if the parent process dies. It also guarantees\nthe code before async/await has the same properties after you\nadd the async call. For example, imagine you have this:\n\n    x = heavy_fun()\n    y = some_fun()\n    x + y\n\nNow you want to make the `heavy_fun()` async:\n\n    x = Task.async(&heavy_fun/0)\n    y = some_fun()\n    Task.await(x) + y\n\nAs before, if `heavy_fun/0` fails, the whole computation will\nfail, including the caller process. If you don't want the task\nto fail then you must change the `heavy_fun/0` code in the\nsame way you would achieve it if you didn't have the async call.\nFor example, to either return `{:ok, val} | :error` results or,\nin more extreme cases, by using `try/rescue`. In other words,\nan asynchronous task should be thought of as an extension of the\ncaller process rather than a mechanism to isolate it from all errors.\n\nIf you don't want to link the caller to the task, then you\nmust use a supervised task with `Task.Supervisor` and call\n`Task.Supervisor.async_nolink/2`.\n\nIn any case, avoid any of the following:\n\n  * Setting `:trap_exit` to `true` - trapping exits should be\n    used only in special circumstances as it would make your\n    process immune to not only exits from the task but from\n    any other processes.\n\n    Moreover, even when trapping exits, calling `await` will\n    still exit if the task has terminated without sending its\n    result back.\n\n  * Unlinking the task process started with `async`/`await`.\n    If you unlink the processes and the task does not belong\n    to any supervisor, you may leave dangling tasks in case\n    the caller process dies.\n\n## Metadata\n\nThe task created with this function stores `:erlang.apply/2` in\nits `:mfa` metadata field, which is used internally to apply\nthe anonymous function. Use `async/3` if you want another function\nto be used as metadata.","prompt":"Can you write a docstring for the following Elixir function? async(fun)"}
{"completion":"Starts a task that must be awaited on.\n\nSimilar to `async/1` except the function to be started is\nspecified by the given `module`, `function_name`, and `args`.\nThe `module`, `function_name`, and its arity are stored as\na tuple in the `:mfa` field for reflection purposes.","prompt":"Can you write a docstring for the following Elixir function? async(module, function_name, args)"}
{"completion":"Returns a stream that runs the given function `fun` concurrently\non each element in `enumerable`.\n\nWorks the same as `async_stream/5` but with an anonymous function instead of a\nmodule-function-arguments tuple. `fun` must be a one-arity anonymous function.\n\nEach `enumerable` element is passed as argument to the given function `fun` and\nprocessed by its own task. The tasks will be linked to the caller process, similarly\nto `async/1`.\n\n## Example\n\nCount the code points in each string asynchronously, then add the counts together using reduce.\n\n    iex> strings = [\"long string\", \"longer string\", \"there are many of these\"]\n    iex> stream = Task.async_stream(strings, fn text -> text |> String.codepoints() |> Enum.count() end)\n    iex> Enum.reduce(stream, 0, fn {:ok, num}, acc -> num + acc end)\n    47\n\nSee `async_stream/5` for discussion, options, and more examples.","prompt":"Can you write a docstring for the following Elixir function? async_stream(enumerable, fun, options \\\\ [])"}
{"completion":"Returns a stream where the given function (`module` and `function_name`)\nis mapped concurrently on each element in `enumerable`.\n\nEach element of `enumerable` will be prepended to the given `args` and\nprocessed by its own task. Those tasks will be linked to an intermediate\nprocess that is then linked to the caller process. This means a failure\nin a task terminates the caller process and a failure in the caller\nprocess terminates all tasks.\n\nWhen streamed, each task will emit `{:ok, value}` upon successful\ncompletion or `{:exit, reason}` if the caller is trapping exits.\nIt's possible to have `{:exit, {element, reason}}` for exits\nusing the `:zip_input_on_exit` option. The order of results depends\non the value of the `:ordered` option.\n\nThe level of concurrency and the time tasks are allowed to run can\nbe controlled via options (see the \"Options\" section below).\n\nConsider using `Task.Supervisor.async_stream/6` to start tasks\nunder a supervisor. If you find yourself trapping exits to ensure\nerrors in the tasks do not terminate the caller process, consider\nusing `Task.Supervisor.async_stream_nolink/6` to start tasks that\nare not linked to the caller process.\n\n## Options\n\n  * `:max_concurrency` - sets the maximum number of tasks to run\n    at the same time. Defaults to `System.schedulers_online/0`.\n\n  * `:ordered` - whether the results should be returned in the same order\n    as the input stream. When the output is ordered, Elixir may need to\n    buffer results to emit them in the original order. Setting this option\n    to false disables the need to buffer at the cost of removing ordering.\n    This is also useful when you're using the tasks only for the side effects.\n    Note that regardless of what `:ordered` is set to, the tasks will\n    process asynchronously. If you need to process elements in order,\n    consider using `Enum.map/2` or `Enum.each/2` instead. Defaults to `true`.\n\n  * `:timeout` - the maximum amount of time (in milliseconds or `:infinity`)\n    each task is allowed to execute for. Defaults to `5000`.\n\n  * `:on_timeout` - what to do when a task times out. The possible\n    values are:\n    * `:exit` (default) - the caller (the process that spawned the tasks) exits.\n    * `:kill_task` - the task that timed out is killed. The value\n      emitted for that task is `{:exit, :timeout}`.\n\n  * `:zip_input_on_exit` - (since v1.14.0) adds the original\n    input to `:exit` tuples. The value emitted for that task is\n    `{:exit, {input, reason}}`, where `input` is the collection element\n    that caused an exited during processing. Defaults to `false`.\n\n## Example\n\nLet's build a stream and then enumerate it:\n\n    stream = Task.async_stream(collection, Mod, :expensive_fun, [])\n    Enum.to_list(stream)\n\nThe concurrency can be increased or decreased using the `:max_concurrency`\noption. For example, if the tasks are IO heavy, the value can be increased:\n\n    max_concurrency = System.schedulers_online() * 2\n    stream = Task.async_stream(collection, Mod, :expensive_fun, [], max_concurrency: max_concurrency)\n    Enum.to_list(stream)\n\nIf you do not care about the results of the computation, you can run\nthe stream with `Stream.run/1`. Also set `ordered: false`, as you don't\ncare about the order of the results either:\n\n    stream = Task.async_stream(collection, Mod, :expensive_fun, [], ordered: false)\n    Stream.run(stream)\n\n## First async tasks to complete\n\nYou can also use `async_stream/3` to execute M tasks and find the N tasks\nto complete. For example:\n\n    [\n      &heavy_call_1/0,\n      &heavy_call_2/0,\n      &heavy_call_3/0\n    ]\n    |> Task.async_stream(fn fun -> fun.() end, ordered: false, max_concurrency: 3)\n    |> Stream.filter(&match?({:ok, _}, &1))\n    |> Enum.take(2)\n\nIn the example above, we are executing three tasks and waiting for the\nfirst 2 to complete. We use `Stream.filter/2` to restrict ourselves only\nto successfully completed tasks, and then use `Enum.take/2` to retrieve\nN items. Note it is important to set both `ordered: false` and\n`max_concurrency: M`, where M is the number of tasks, to make sure all\ncalls execute concurrently.\n\n### Attention: unbound async + take\n\nIf you want to potentially process a high number of items and keep only\npart of the results, you may end-up processing more items than desired.\nLet's see an example:\n\n    1..100\n    |> Task.async_stream(fn i ->\n      Process.sleep(100)\n      IO.puts(to_string(i))\n    end)\n    |> Enum.take(10)\n\nRunning the example above in a machine with 8 cores will process 16 items,\neven though you want only 10 elements, since `async_stream/3` process items\nconcurrently. That's because it will process 8 elements at once. Then all 8\nelements complete at roughly the same time, causing 8 elements to be kicked\noff for processing. Out of these extra 8, only 2 will be used, and the rest\nwill be terminated.\n\nDepending on the problem, you can filter or limit the number of elements\nupfront:\n\n    1..100\n    |> Stream.take(10)\n    |> Task.async_stream(fn i ->\n      Process.sleep(100)\n      IO.puts(to_string(i))\n    end)\n    |> Enum.to_list()\n\nIn other cases, you likely want to tweak `:max_concurrency` to limit how\nmany elements may be over processed at the cost of reducing concurrency.\nYou can also set the number of elements to take to be a multiple of\n`:max_concurrency`. For instance, setting `max_concurrency: 5` in the\nexample above.","prompt":"Can you write a docstring for the following Elixir function? async_stream(enumerable, module, function_name, args, options \\\\ [])"}
{"completion":"Awaits a task reply and returns it.\n\nIn case the task process dies, the caller process will exit with the same\nreason as the task.\n\nA timeout, in milliseconds or `:infinity`, can be given with a default value\nof `5000`. If the timeout is exceeded, then the caller process will exit.\nIf the task process is linked to the caller process which is the case when\na task is started with `async`, then the task process will also exit. If the\ntask process is trapping exits or not linked to the caller process, then it\nwill continue to run.\n\nThis function assumes the task's monitor is still active or the monitor's\n`:DOWN` message is in the message queue. If it has been demonitored, or the\nmessage already received, this function will wait for the duration of the\ntimeout awaiting the message.\n\nThis function can only be called once for any given task. If you want\nto be able to check multiple times if a long-running task has finished\nits computation, use `yield/2` instead.\n\n## Examples\n\n    iex> task = Task.async(fn -> 1 + 1 end)\n    iex> Task.await(task)\n    2\n\n## Compatibility with OTP behaviours\n\nIt is not recommended to `await` a long-running task inside an OTP\nbehaviour such as `GenServer`. Instead, you should match on the message\ncoming from a task inside your `c:GenServer.handle_info/2` callback.\n\nA GenServer will receive two messages on `handle_info/2`:\n\n  * `{ref, result}` - the reply message where `ref` is the monitor\n    reference returned by the `task.ref` and `result` is the task\n    result\n\n  * `{:DOWN, ref, :process, pid, reason}` - since all tasks are also\n    monitored, you will also receive the `:DOWN` message delivered by\n    `Process.monitor/1`. If you receive the `:DOWN` message without a\n    a reply, it means the task crashed\n\nAnother consideration to have in mind is that tasks started by `Task.async/1`\nare always linked to their callers and you may not want the GenServer to\ncrash if the task crashes. Therefore, it is preferable to instead use\n`Task.Supervisor.async_nolink/3` inside OTP behaviours. For completeness, here\nis an example of a GenServer that start tasks and handles their results:\n\n    defmodule GenServerTaskExample do\n      use GenServer\n\n      def start_link(opts) do\n        GenServer.start_link(__MODULE__, :ok, opts)\n      end\n\n      def init(_opts) do\n        # We will keep all running tasks in a map\n        {:ok, %{tasks: %{}}}\n      end\n\n      # Imagine we invoke a task from the GenServer to access a URL...\n      def handle_call(:some_message, _from, state) do\n        url = ...\n        task = Task.Supervisor.async_nolink(MyApp.TaskSupervisor, fn -> fetch_url(url) end)\n\n        # After we start the task, we store its reference and the url it is fetching\n        state = put_in(state.tasks[task.ref], url)\n\n        {:reply, :ok, state}\n      end\n\n      # If the task succeeds...\n      def handle_info({ref, result}, state) do\n        # The task succeed so we can cancel the monitoring and discard the DOWN message\n        Process.demonitor(ref, [:flush])\n\n        {url, state} = pop_in(state.tasks[ref])\n        IO.puts \"Got #{inspect(result)} for URL #{inspect url}\"\n        {:noreply, state}\n      end\n\n      # If the task fails...\n      def handle_info({:DOWN, ref, _, _, reason}, state) do\n        {url, state} = pop_in(state.tasks[ref])\n        IO.puts \"URL #{inspect url} failed with reason #{inspect(reason)}\"\n        {:noreply, state}\n      end\n    end\n\nWith the server defined, you will want to start the task supervisor\nabove and the GenServer in your supervision tree:\n\n    children = [\n      {Task.Supervisor, name: MyApp.TaskSupervisor},\n      {GenServerTaskExample, name: MyApp.GenServerTaskExample}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)","prompt":"Can you write a docstring for the following Elixir function? await(task, timeout \\\\ 5000)"}
{"completion":"Awaits replies from multiple tasks and returns them.\n\nThis function receives a list of tasks and waits for their replies in the\ngiven time interval. It returns a list of the results, in the same order as\nthe tasks supplied in the `tasks` input argument.\n\nIf any of the task processes dies, the caller process will exit with the same\nreason as that task.\n\nA timeout, in milliseconds or `:infinity`, can be given with a default value\nof `5000`. If the timeout is exceeded, then the caller process will exit.\nAny task processes that are linked to the caller process (which is the case\nwhen a task is started with `async`) will also exit. Any task processes that\nare trapping exits or not linked to the caller process will continue to run.\n\nThis function assumes the tasks' monitors are still active or the monitor's\n`:DOWN` message is in the message queue. If any tasks have been demonitored,\nor the message already received, this function will wait for the duration of\nthe timeout.\n\nThis function can only be called once for any given task. If you want to be\nable to check multiple times if a long-running task has finished its\ncomputation, use `yield_many/2` instead.\n\n## Compatibility with OTP behaviours\n\nIt is not recommended to `await` long-running tasks inside an OTP behaviour\nsuch as `GenServer`. See `await/2` for more information.\n\n## Examples\n\n    iex> tasks = [\n    ...>   Task.async(fn -> 1 + 1 end),\n    ...>   Task.async(fn -> 2 + 3 end)\n    ...> ]\n    iex> Task.await_many(tasks)\n    [2, 5]","prompt":"Can you write a docstring for the following Elixir function? await_many(tasks, timeout \\\\ 5000)"}
{"completion":"Returns a specification to start a task under a supervisor.\n\n`arg` is passed as the argument to `Task.start_link/1` in the `:start` field\nof the spec.\n\nFor more information, see the `Supervisor` module,\nthe `Supervisor.child_spec/2` function and the `t:Supervisor.child_spec/0` type.","prompt":"Can you write a docstring for the following Elixir function? child_spec(arg)"}
{"completion":"Starts a task that immediately completes with the given `result`.\n\nUnlike `async/1`, this task does not spawn a linked process. It can\nbe awaited or yielded like any other task.\n\n## Usage\n\nIn some cases, it is useful to create a \"completed\" task that represents\na task that has already run and generated a result. For example, when\nprocessing data you may be able to determine that certain inputs are\ninvalid before dispatching them for further processing:\n\n    def process(data) do\n      tasks =\n        for entry <- data do\n          if invalid_input?(entry) do\n            Task.completed({:error, :invalid_input})\n          else\n            Task.async(fn -> further_process(entry) end)\n          end\n        end\n\n      Task.await_many(tasks)\n    end\n\nIn many cases, `Task.completed/1` may be avoided in favor of returning the\nresult directly.  You should generally only require this variant when working\nwith mixed asynchrony, when a group of inputs will be handled partially\nsynchronously and partially asynchronously.","prompt":"Can you write a docstring for the following Elixir function? completed(result)"}
{"completion":"Ignores an existing task.\n\nThis means the task will continue running, but it will be unlinked\nand you can no longer yield, await or shut it down.\n\nReturns `{:ok, reply}` if the reply is received before ignoring the task,\n`{:exit, reason}` if the task died before ignoring it, otherwise `nil`.\n\nImportant: avoid using [`Task.async/1,3`](`async/1`) and then immediately ignoring\nthe task. If you want to start tasks you don't care about their\nresults, use `Task.Supervisor.start_child/2` instead.\n\nRequires Erlang/OTP 24+.","prompt":"Can you write a docstring for the following Elixir function? ignore(task)"}
{"completion":"Unlinks and shuts down the task, and then checks for a reply.\n\nReturns `{:ok, reply}` if the reply is received while shutting down the task,\n`{:exit, reason}` if the task died, otherwise `nil`. Once shut down,\nyou can no longer await or yield it.\n\nThe second argument is either a timeout or `:brutal_kill`. In case\nof a timeout, a `:shutdown` exit signal is sent to the task process\nand if it does not exit within the timeout, it is killed. With `:brutal_kill`\nthe task is killed straight away. In case the task terminates abnormally\n(possibly killed by another process), this function will exit with the same reason.\n\nIt is not required to call this function when terminating the caller, unless\nexiting with reason `:normal` or if the task is trapping exits. If the caller is\nexiting with a reason other than `:normal` and the task is not trapping exits, the\ncaller's exit signal will stop the task. The caller can exit with reason\n`:shutdown` to shut down all of its linked processes, including tasks, that\nare not trapping exits without generating any log messages.\n\nIf a task's monitor has already been demonitored or received and there is not\na response waiting in the message queue this function will return\n`{:exit, :noproc}` as the result or exit reason can not be determined.","prompt":"Can you write a docstring for the following Elixir function? shutdown(task, shutdown \\\\ 5000)"}
{"completion":"Starts a task.\n\n`fun` must be a zero-arity anonymous function.\n\nThis should only used when the task is used for side-effects\n(like I/O) and you have no interest on its results nor if it\ncompletes successfully.\n\nIf the current node is shutdown, the node will terminate even\nif the task was not completed. For this reason, we recommend\nto use `Task.Supervisor.start_child/2` instead, which allows\nyou to control the shutdown time via the `:shutdown` option.","prompt":"Can you write a docstring for the following Elixir function? start(fun)"}
{"completion":"Starts a task.\n\nThis should only used when the task is used for side-effects\n(like I/O) and you have no interest on its results nor if it\ncompletes successfully.\n\nIf the current node is shutdown, the node will terminate even\nif the task was not completed. For this reason, we recommend\nto use `Task.Supervisor.start_child/2` instead, which allows\nyou to control the shutdown time via the `:shutdown` option.","prompt":"Can you write a docstring for the following Elixir function? start(module, function_name, args)"}
{"completion":"Starts a task as part of a supervision tree with the given `fun`.\n\n`fun` must be a zero-arity anonymous function.\n\nThis is used to start a statically supervised task under a supervision tree.","prompt":"Can you write a docstring for the following Elixir function? start_link(fun)"}
{"completion":"Starts a task as part of a supervision tree with the given\n`module`, `function`, and `args`.\n\nThis is used to start a statically supervised task under a supervision tree.","prompt":"Can you write a docstring for the following Elixir function? start_link(module, function, args)"}
{"completion":"Temporarily blocks the caller process waiting for a task reply.\n\nReturns `{:ok, reply}` if the reply is received, `nil` if\nno reply has arrived, or `{:exit, reason}` if the task has already\nexited. Keep in mind that normally a task failure also causes\nthe process owning the task to exit. Therefore this function can\nreturn `{:exit, reason}` if at least one of the conditions below apply:\n\n  * the task process exited with the reason `:normal`\n  * the task isn't linked to the caller (the task was started\n    with `Task.Supervisor.async_nolink/2` or `Task.Supervisor.async_nolink/4`)\n  * the caller is trapping exits\n\nA timeout, in milliseconds or `:infinity`, can be given with a default value\nof `5000`. If the time runs out before a message from the task is received,\nthis function will return `nil` and the monitor will remain active. Therefore\n`yield/2` can be called multiple times on the same task.\n\nThis function assumes the task's monitor is still active or the\nmonitor's `:DOWN` message is in the message queue. If it has been\ndemonitored or the message already received, this function will wait\nfor the duration of the timeout awaiting the message.\n\nIf you intend to shut the task down if it has not responded within `timeout`\nmilliseconds, you should chain this together with `shutdown/1`, like so:\n\n    case Task.yield(task, timeout) || Task.shutdown(task) do\n      {:ok, result} ->\n        result\n\n      nil ->\n        Logger.warn(\"Failed to get a result in #{timeout}ms\")\n        nil\n    end\n\nIf you intend to check on the task but leave it running after the timeout,\nyou can chain this together with `ignore/1`, like so:\n\n    case Task.yield(task, timeout) || Task.ignore(task) do\n      {:ok, result} ->\n        result\n\n      nil ->\n        Logger.warn(\"Failed to get a result in #{timeout}ms\")\n        nil\n    end\n\nThat ensures that if the task completes after the `timeout` but before `shutdown/1`\nhas been called, you will still get the result, since `shutdown/1` is designed to\nhandle this case and return the result.","prompt":"Can you write a docstring for the following Elixir function? yield(task, timeout \\\\ 5000)"}
{"completion":"Yields to multiple tasks in the given time interval.\n\nThis function receives a list of tasks and waits for their\nreplies in the given time interval. It returns a list\nof two-element tuples, with the task as the first element\nand the yielded result as the second. The tasks in the returned\nlist will be in the same order as the tasks supplied in the `tasks`\ninput argument.\n\nSimilarly to `yield/2`, each task's result will be\n\n  * `{:ok, term}` if the task has successfully reported its\n    result back in the given time interval\n  * `{:exit, reason}` if the task has died\n  * `nil` if the task keeps running past the timeout\n\nA timeout, in milliseconds or `:infinity`, can be given with a default value\nof `5000`.\n\nCheck `yield/2` for more information.\n\n## Example\n\n`Task.yield_many/2` allows developers to spawn multiple tasks\nand retrieve the results received in a given timeframe.\nIf we combine it with `Task.shutdown/2` (or `Task.ignore/1`),\nit allows us to gather those results and cancel (or ignore)\nthe tasks that have not replied in time.\n\nLet's see an example.\n\n    tasks =\n      for i <- 1..10 do\n        Task.async(fn ->\n          Process.sleep(i * 1000)\n          i\n        end)\n      end\n\n    tasks_with_results = Task.yield_many(tasks, 5000)\n\n    results =\n      Enum.map(tasks_with_results, fn {task, res} ->\n        # Shut down the tasks that did not reply nor exit\n        res || Task.shutdown(task, :brutal_kill)\n      end)\n\n    # Here we are matching only on {:ok, value} and\n    # ignoring {:exit, _} (crashed tasks) and `nil` (no replies)\n    for {:ok, value} <- results do\n      IO.inspect(value)\n    end\n\nIn the example above, we create tasks that sleep from 1\nup to 10 seconds and return the number of seconds they slept for.\nIf you execute the code all at once, you should see 1 up to 5\nprinted, as those were the tasks that have replied in the\ngiven time. All other tasks will have been shut down using\nthe `Task.shutdown/2` call.","prompt":"Can you write a docstring for the following Elixir function? yield_many(tasks, timeout \\\\ 5000)"}
{"completion":"Conveniences for spawning and awaiting tasks.\n\nTasks are processes meant to execute one particular\naction throughout their lifetime, often with little or no\ncommunication with other processes. The most common use case\nfor tasks is to convert sequential code into concurrent code\nby computing a value asynchronously:\n\n    task = Task.async(fn -> do_some_work() end)\n    res = do_some_other_work()\n    res + Task.await(task)\n\nTasks spawned with `async` can be awaited on by their caller\nprocess (and only their caller) as shown in the example above.\nThey are implemented by spawning a process that sends a message\nto the caller once the given computation is performed.\n\nBesides `async/1` and `await/2`, tasks can also be\nstarted as part of a supervision tree and dynamically spawned\non remote nodes. We will explore these scenarios next.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Task"}
{"completion":"async and await\n\nOne of the common uses of tasks is to convert sequential code\ninto concurrent code with `Task.async/1` while keeping its semantics.\nWhen invoked, a new process will be created, linked and monitored\nby the caller. Once the task action finishes, a message will be sent\nto the caller with the result.\n\n`Task.await/2` is used to read the message sent by the task.\n\nThere are two important things to consider when using `async`:\n\n  1. If you are using async tasks, you **must await** a reply\n     as they are *always* sent. If you are not expecting a reply,\n     consider using `Task.start_link/1` as detailed below.\n\n  2. async tasks link the caller and the spawned process. This\n     means that, if the caller crashes, the task will crash\n     too and vice-versa. This is on purpose: if the process\n     meant to receive the result no longer exists, there is\n     no purpose in completing the computation.\n\n     If this is not desired, you will want to use supervised\n     tasks, described next.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Task"}
{"completion":"Dynamically supervised tasks\n\nThe `Task.Supervisor` module allows developers to dynamically\ncreate multiple supervised tasks.\n\nA short example is:\n\n    {:ok, pid} = Task.Supervisor.start_link()\n\n    task =\n      Task.Supervisor.async(pid, fn ->\n        # Do something\n      end)\n\n    Task.await(task)\n\nHowever, in the majority of cases, you want to add the task supervisor\nto your supervision tree:\n\n    Supervisor.start_link([\n      {Task.Supervisor, name: MyApp.TaskSupervisor}\n    ], strategy: :one_for_one)\n\nAnd now you can use async/await by passing the name of\nthe supervisor instead of the pid:\n\n    Task.Supervisor.async(MyApp.TaskSupervisor, fn ->\n      # Do something\n    end)\n    |> Task.await()\n\nWe encourage developers to rely on supervised tasks as much as possible.\nSupervised tasks improves the visibility of how many tasks are running\nat a given moment and enable a huge variety of patterns that gives you\nexplicit control on how to handle the results, errors, and timeouts.\nHere is a summary:\n\n  * Using `Task.Supervisor.start_child/2` allows you to start a fire-and-forget\n    task that you don't care about its results or if it completes successfully or not.\n\n  * Using `Task.Supervisor.async/2` + `Task.await/2` allows you to execute\n    tasks concurrently and retrieve its result. If the task fails,\n    the caller will also fail.\n\n  * Using `Task.Supervisor.async_nolink/2` + `Task.yield/2` + `Task.shutdown/2`\n    allows you to execute tasks concurrently and retrieve their results\n    or the reason they failed within a given time frame. If the task fails,\n    the caller won't fail. You will receive the error reason either on\n    `yield` or `shutdown`.\n\nFurthermore, the supervisor guarantee all tasks first terminate, within a\nconfigurable shutdown period, when your application shuts down. See the\n`Task.Supervisor` module for details on the supported operations.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Task"}
{"completion":"# Distributed tasks\n\nWith `Task.Supervisor`, it is easy to dynamically start tasks across nodes:\n\n    # On the remote node named :remote@local\n    Task.Supervisor.start_link(name: MyApp.DistSupervisor)\n\n    # On the client\n    supervisor = {MyApp.DistSupervisor, :remote@local}\n    Task.Supervisor.async(supervisor, MyMod, :my_fun, [arg1, arg2, arg3])\n\nNote that, when working with distributed tasks, one should use the\n`Task.Supervisor.async/5` function that expects explicit module, function,\nand arguments, instead of `Task.Supervisor.async/3` that works with anonymous\nfunctions. That's because anonymous functions expect the same module version\nto exist on all involved nodes. Check the `Agent` module documentation for\nmore information on distributed processes as the limitations described there\napply to the whole ecosystem.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Task"}
{"completion":"Statically supervised tasks\n\nThe `Task` module implements the `child_spec/1` function, which\nallows it to be started directly under a regular `Supervisor` -\ninstead of a `Task.Supervisor` - by passing a tuple with a function\nto run:\n\n    Supervisor.start_link([\n      {Task, fn -> :some_work end}\n    ], strategy: :one_for_one)\n\nThis is often useful when you need to execute some steps while\nsetting up your supervision tree. For example: to warm up caches,\nlog the initialization status, and such.\n\nIf you don't want to put the Task code directly under the `Supervisor`,\nyou can wrap the `Task` in its own module, similar to how you would\ndo with a `GenServer` or an `Agent`:\n\n    defmodule MyTask do\n      use Task\n\n      def start_link(arg) do\n        Task.start_link(__MODULE__, :run, [arg])\n      end\n\n      def run(arg) do\n        # ...\n      end\n    end\n\nAnd then passing it to the supervisor:\n\n    Supervisor.start_link([\n      {MyTask, arg}\n    ], strategy: :one_for_one)\n\nSince these tasks are supervised and not directly linked to the caller,\nthey cannot be awaited on. By default, the functions `Task.start/1`\nand `Task.start_link/1` are for fire-and-forget tasks, where you don't\ncare about the results or if it completes successfully or not.\n\n`use Task` defines a `child_spec/1` function, allowing the\ndefined module to be put under a supervision tree. The generated\n`child_spec/1` can be customized with the following options:\n\n  * `:id` - the child specification identifier, defaults to the current module\n  * `:restart` - when the child should be restarted, defaults to `:temporary`\n  * `:shutdown` - how to shut down the child, either immediately or by giving it time to shut down\n\nOpposite to `GenServer`, `Agent` and `Supervisor`, a Task has\na default `:restart` of `:temporary`. This means the task will\nnot be restarted even if it crashes. If you desire the task to\nbe restarted for non-successful exits, do:\n\n    use Task, restart: :transient\n\nIf you want the task to always be restarted:\n\n    use Task, restart: :permanent\n\nSee the \"Child specification\" section in the `Supervisor` module\nfor more detailed information. The `@doc` annotation immediately\npreceding `use Task` will be attached to the generated `child_spec/1`\nfunction.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Task"}
{"completion":"Ancestor and Caller Tracking\n\nWhenever you start a new process, Elixir annotates the parent of that process\nthrough the `$ancestors` key in the process dictionary. This is often used to\ntrack the hierarchy inside a supervision tree.\n\nFor example, we recommend developers to always start tasks under a supervisor.\nThis provides more visibility and allows you to control how those tasks are\nterminated when a node shuts down. That might look something like\n`Task.Supervisor.start_child(MySupervisor, task_function)`. This means\nthat, although your code is the one invoking the task, the actual ancestor of\nthe task is the supervisor, as the supervisor is the one effectively starting it.\n\nTo track the relationship between your code and the task, we use the `$callers`\nkey in the process dictionary. Therefore, assuming the `Task.Supervisor` call\nabove, we have:\n\n    [your code] -- calls --> [supervisor] ---- spawns --> [task]\n\nWhich means we store the following relationships:\n\n    [your code]              [supervisor] <-- ancestor -- [task]\n        ^                                                  |\n        |--------------------- caller ---------------------|\n\nThe list of callers of the current process can be retrieved from the Process\ndictionary with `Process.get(:\"$callers\")`. This will return either `nil` or\na list `[pid_n, ..., pid2, pid1]` with at least one entry Where `pid_n` is\nthe PID that called the current process, `pid2` called `pid_n`, and `pid2` was\ncalled by `pid1`.\n\nIf a task crashes, the callers field is included as part of the log message\nmetadata under the `:callers` key.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Task"}
{"completion":"Adds the `amount_to_add` of `unit`s to the given `time`.\n\nAccepts an `amount_to_add` in any `unit`. `unit` can be `:day`,\n`:hour`, `:minute`, `:second` or any subsecond precision from\n`t:System.time_unit/0`. It defaults to `:second`. Negative values\nwill move backwards in time.\n\nThis function always consider the unit to be computed according\nto the `Calendar.ISO`.\n\nNote the result value represents the time of day, meaning that it is cyclic,\nfor instance, it will never go over 24 hours for the ISO calendar.\n\n## Examples\n\n    iex> Time.add(~T[10:00:00], 27000)\n    ~T[17:30:00]\n    iex> Time.add(~T[11:00:00.005], 2400)\n    ~T[11:40:00.005]\n    iex> Time.add(~T[00:00:00.000], 86_399_999, :millisecond)\n    ~T[23:59:59.999]\n\nNegative values are allowed:\n\n    iex> Time.add(~T[23:00:00], -60)\n    ~T[22:59:00]\n\nNote that the time is cyclic:\n\n    iex> Time.add(~T[17:10:05], 86400)\n    ~T[17:10:05]\n\nHours and minutes are also supported:\n\n    iex> Time.add(~T[17:10:05], 2, :hour)\n    ~T[19:10:05]\n    iex> Time.add(~T[17:10:05], 30, :minute)\n    ~T[17:40:05]\n\nThis operation merges the precision of the time with the given unit:\n\n    iex> result = Time.add(~T[00:29:10], 21, :millisecond)\n    ~T[00:29:10.021]\n    iex> result.microsecond\n    {21000, 3}","prompt":"Can you write a docstring for the following Elixir function? add(time, amount_to_add, unit \\\\ :second)"}
{"completion":"Compares two time structs.\n\nReturns `:gt` if first time is later than the second\nand `:lt` for vice versa. If the two times are equal\n`:eq` is returned.\n\n## Examples\n\n    iex> Time.compare(~T[16:04:16], ~T[16:04:28])\n    :lt\n    iex> Time.compare(~T[16:04:16], ~T[16:04:16])\n    :eq\n    iex> Time.compare(~T[16:04:16.01], ~T[16:04:16.001])\n    :gt\n\nThis function can also be used to compare across more\ncomplex calendar types by considering only the time fields:\n\n    iex> Time.compare(~N[1900-01-01 16:04:16], ~N[2015-01-01 16:04:16])\n    :eq\n    iex> Time.compare(~N[2015-01-01 16:04:16], ~N[2015-01-01 16:04:28])\n    :lt\n    iex> Time.compare(~N[2015-01-01 16:04:16.01], ~N[2000-01-01 16:04:16.001])\n    :gt","prompt":"Can you write a docstring for the following Elixir function? compare(time1, time2)"}
{"completion":"Converts given `time` to a different calendar.\n\nReturns `{:ok, time}` if the conversion was successful,\nor `{:error, reason}` if it was not, for some reason.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> Time.convert(~T[13:30:15], Calendar.Holocene)\n    {:ok, %Time{calendar: Calendar.Holocene, hour: 13, minute: 30, second: 15, microsecond: {0, 0}}}","prompt":"Can you write a docstring for the following Elixir function? convert(time, calendar)"}
{"completion":"Similar to `Time.convert/2`, but raises an `ArgumentError`\nif the conversion between the two calendars is not possible.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> Time.convert!(~T[13:30:15], Calendar.Holocene)\n    %Time{calendar: Calendar.Holocene, hour: 13, minute: 30, second: 15, microsecond: {0, 0}}","prompt":"Can you write a docstring for the following Elixir function? convert!(time, calendar)"}
{"completion":"Returns the difference between two times, considering only the hour, minute,\nsecond and microsecond.\n\nAs with the `compare/2` function both `Time` structs and other structures\ncontaining time can be used. If for instance a `NaiveDateTime` or `DateTime`\nis passed, only the hour, minute, second, and microsecond is considered. Any\nadditional information about a date or time zone is ignored when calculating\nthe difference.\n\nThe answer can be returned in any `:hour`, `:minute`, `:second` or any\nsubsecond `unit` available from `t:System.time_unit/0`. If the first time\nvalue is earlier than the second, a negative number is returned.\n\nThe unit is measured according to `Calendar.ISO` and defaults to `:second`.\nFractional results are not supported and are truncated.\n\n## Examples\n\n    iex> Time.diff(~T[00:29:12], ~T[00:29:10])\n    2\n\n    # When passing a `NaiveDateTime` the date part is ignored.\n    iex> Time.diff(~N[2017-01-01 00:29:12], ~T[00:29:10])\n    2\n\n    # Two `NaiveDateTime` structs could have big differences in the date\n    # but only the time part is considered.\n    iex> Time.diff(~N[2017-01-01 00:29:12], ~N[1900-02-03 00:29:10])\n    2\n\n    iex> Time.diff(~T[00:29:12], ~T[00:29:10], :microsecond)\n    2_000_000\n    iex> Time.diff(~T[00:29:10], ~T[00:29:12], :microsecond)\n    -2_000_000\n\n    iex> Time.diff(~T[02:29:10], ~T[00:29:10], :hour)\n    2\n    iex> Time.diff(~T[02:29:10], ~T[00:29:11], :hour)\n    1","prompt":"Can you write a docstring for the following Elixir function? diff(time1, time2, unit \\\\ :second)"}
{"completion":"Converts an Erlang time tuple to a `Time` struct.\n\n## Examples\n\n    iex> Time.from_erl({23, 30, 15}, {5000, 3})\n    {:ok, ~T[23:30:15.005]}\n    iex> Time.from_erl({24, 30, 15})\n    {:error, :invalid_time}","prompt":"Can you write a docstring for the following Elixir function? from_erl(tuple, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO)"}
{"completion":"Converts an Erlang time tuple to a `Time` struct.\n\n## Examples\n\n    iex> Time.from_erl!({23, 30, 15})\n    ~T[23:30:15]\n    iex> Time.from_erl!({23, 30, 15}, {5000, 3})\n    ~T[23:30:15.005]\n    iex> Time.from_erl!({24, 30, 15})\n    ** (ArgumentError) cannot convert {24, 30, 15} to time, reason: :invalid_time","prompt":"Can you write a docstring for the following Elixir function? from_erl!(tuple, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO)"}
{"completion":"Parses the extended \"Local time\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nTime zone offset may be included in the string but they will be\nsimply discarded as such information is not included in times.\n\nAs specified in the standard, the separator \"T\" may be omitted if\ndesired as there is no ambiguity within this function.\n\n## Examples\n\n    iex> Time.from_iso8601(\"23:50:07\")\n    {:ok, ~T[23:50:07]}\n    iex> Time.from_iso8601(\"23:50:07Z\")\n    {:ok, ~T[23:50:07]}\n    iex> Time.from_iso8601(\"T23:50:07Z\")\n    {:ok, ~T[23:50:07]}\n\n    iex> Time.from_iso8601(\"23:50:07,0123456\")\n    {:ok, ~T[23:50:07.012345]}\n    iex> Time.from_iso8601(\"23:50:07.0123456\")\n    {:ok, ~T[23:50:07.012345]}\n    iex> Time.from_iso8601(\"23:50:07.123Z\")\n    {:ok, ~T[23:50:07.123]}\n\n    iex> Time.from_iso8601(\"2015:01:23 23-50-07\")\n    {:error, :invalid_format}\n    iex> Time.from_iso8601(\"23:50:07A\")\n    {:error, :invalid_format}\n    iex> Time.from_iso8601(\"23:50:07.\")\n    {:error, :invalid_format}\n    iex> Time.from_iso8601(\"23:50:61\")\n    {:error, :invalid_time}","prompt":"Can you write a docstring for the following Elixir function? from_iso8601(string, calendar \\\\ Calendar.ISO)"}
{"completion":"Parses the extended \"Local time\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nRaises if the format is invalid.\n\n## Examples\n\n    iex> Time.from_iso8601!(\"23:50:07,123Z\")\n    ~T[23:50:07.123]\n    iex> Time.from_iso8601!(\"23:50:07.123Z\")\n    ~T[23:50:07.123]\n    iex> Time.from_iso8601!(\"2015:01:23 23-50-07\")\n    ** (ArgumentError) cannot parse \"2015:01:23 23-50-07\" as time, reason: :invalid_format","prompt":"Can you write a docstring for the following Elixir function? from_iso8601!(string, calendar \\\\ Calendar.ISO)"}
{"completion":"Converts a number of seconds after midnight to a `Time` struct.\n\n## Examples\n\n    iex> Time.from_seconds_after_midnight(10_000)\n    ~T[02:46:40]\n    iex> Time.from_seconds_after_midnight(30_000, {5000, 3})\n    ~T[08:20:00.005]\n    iex> Time.from_seconds_after_midnight(-1)\n    ~T[23:59:59]\n    iex> Time.from_seconds_after_midnight(100_000)\n    ~T[03:46:40]","prompt":"Can you write a docstring for the following Elixir function? from_seconds_after_midnight(seconds, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO)"}
{"completion":"Builds a new time.\n\nExpects all values to be integers. Returns `{:ok, time}` if each\nentry fits its appropriate range, returns `{:error, reason}` otherwise.\n\nMicroseconds can also be given with a precision, which must be an\ninteger between 0 and 6.\n\nThe built-in calendar does not support leap seconds.\n\n## Examples\n\n    iex> Time.new(0, 0, 0, 0)\n    {:ok, ~T[00:00:00.000000]}\n    iex> Time.new(23, 59, 59, 999_999)\n    {:ok, ~T[23:59:59.999999]}\n\n    iex> Time.new(24, 59, 59, 999_999)\n    {:error, :invalid_time}\n    iex> Time.new(23, 60, 59, 999_999)\n    {:error, :invalid_time}\n    iex> Time.new(23, 59, 60, 999_999)\n    {:error, :invalid_time}\n    iex> Time.new(23, 59, 59, 1_000_000)\n    {:error, :invalid_time}\n\n    # Invalid precision\n    Time.new(23, 59, 59, {999_999, 10})\n    {:error, :invalid_time}","prompt":"Can you write a docstring for the following Elixir function? new(hour, minute, second, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO)"}
{"completion":"Builds a new time.\n\nExpects all values to be integers. Returns `time` if each\nentry fits its appropriate range, raises if the time is invalid.\n\nMicroseconds can also be given with a precision, which must be an\ninteger between 0 and 6.\n\nThe built-in calendar does not support leap seconds.\n\n## Examples\n\n    iex> Time.new!(0, 0, 0, 0)\n    ~T[00:00:00.000000]\n    iex> Time.new!(23, 59, 59, 999_999)\n    ~T[23:59:59.999999]\n    iex> Time.new!(24, 59, 59, 999_999)\n    ** (ArgumentError) cannot build time, reason: :invalid_time","prompt":"Can you write a docstring for the following Elixir function? new!(hour, minute, second, microsecond \\\\ {0, 0}, calendar \\\\ Calendar.ISO)"}
{"completion":"Converts given `time` to an Erlang time tuple.\n\nWARNING: Loss of precision may occur, as Erlang time tuples\nonly contain hours/minutes/seconds.\n\n## Examples\n\n    iex> Time.to_erl(~T[23:30:15.999])\n    {23, 30, 15}\n\n    iex> Time.to_erl(~N[2010-04-17 23:30:15.999])\n    {23, 30, 15}","prompt":"Can you write a docstring for the following Elixir function? to_erl(time)"}
{"completion":"Converts the given time to\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nBy default, `Time.to_iso8601/2` returns times formatted in the \"extended\"\nformat, for human readability. It also supports the \"basic\" format through\npassing the `:basic` option.\n\n### Examples\n\n    iex> Time.to_iso8601(~T[23:00:13])\n    \"23:00:13\"\n\n    iex> Time.to_iso8601(~T[23:00:13.001])\n    \"23:00:13.001\"\n\n    iex> Time.to_iso8601(~T[23:00:13.001], :basic)\n    \"230013.001\"\n\n    iex> Time.to_iso8601(~N[2010-04-17 23:00:13])\n    \"23:00:13\"","prompt":"Can you write a docstring for the following Elixir function? to_iso8601(time, format \\\\ :extended)"}
{"completion":"Converts a `Time` struct to a number of seconds after midnight.\n\nThe returned value is a two-element tuple with the number of seconds and microseconds.\n\n## Examples\n\n    iex> Time.to_seconds_after_midnight(~T[23:30:15])\n    {84615, 0}\n    iex> Time.to_seconds_after_midnight(~N[2010-04-17 23:30:15.999])\n    {84615, 999000}","prompt":"Can you write a docstring for the following Elixir function? to_seconds_after_midnight(time)"}
{"completion":"Converts the given `time` to a string.\n\n### Examples\n\n    iex> Time.to_string(~T[23:00:00])\n    \"23:00:00\"\n    iex> Time.to_string(~T[23:00:00.001])\n    \"23:00:00.001\"\n    iex> Time.to_string(~T[23:00:00.123456])\n    \"23:00:00.123456\"\n\n    iex> Time.to_string(~N[2015-01-01 23:00:00.001])\n    \"23:00:00.001\"\n    iex> Time.to_string(~N[2015-01-01 23:00:00.123456])\n    \"23:00:00.123456\"","prompt":"Can you write a docstring for the following Elixir function? to_string(time)"}
{"completion":"Returns the given time with the microsecond field truncated to the given\nprecision (`:microsecond`, `millisecond` or `:second`).\n\nThe given time is returned unchanged if it already has lower precision than\nthe given precision.\n\n## Examples\n\n    iex> Time.truncate(~T[01:01:01.123456], :microsecond)\n    ~T[01:01:01.123456]\n\n    iex> Time.truncate(~T[01:01:01.123456], :millisecond)\n    ~T[01:01:01.123]\n\n    iex> Time.truncate(~T[01:01:01.123456], :second)\n    ~T[01:01:01]","prompt":"Can you write a docstring for the following Elixir function? truncate(time, precision)"}
{"completion":"Returns the current time in UTC.\n\n## Examples\n\n    iex> time = Time.utc_now()\n    iex> time.hour >= 0\n    true","prompt":"Can you write a docstring for the following Elixir function? utc_now(calendar \\\\ Calendar.ISO)"}
{"completion":"A Time struct and functions.\n\nThe Time struct contains the fields hour, minute, second and microseconds.\nNew times can be built with the `new/4` function or using the\n`~T` (see `sigil_T/2`) sigil:\n\n    iex> ~T[23:00:07.001]\n    ~T[23:00:07.001]\n\nBoth `new/4` and sigil return a struct where the time fields can\nbe accessed directly:\n\n    iex> time = ~T[23:00:07.001]\n    iex> time.hour\n    23\n    iex> time.microsecond\n    {1000, 3}\n\nThe functions on this module work with the `Time` struct as well\nas any struct that contains the same fields as the `Time` struct,\nsuch as `NaiveDateTime` and `DateTime`. Such functions expect\n`t:Calendar.time/0` in their typespecs (instead of `t:t/0`).\n\nDevelopers should avoid creating the Time structs directly\nand instead rely on the functions provided by this module as well\nas the ones in third-party calendar libraries.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Time"}
{"completion":"Comparing times\n\nComparisons in Elixir using `==/2`, `>/2`, `</2` and similar are structural\nand based on the `Time` struct fields. For proper comparison between\ntimes, use the `compare/2` function. The existence of the `compare/2`\nfunction in this module also allows using `Enum.min/2` and `Enum.max/2`\nfunctions to get the minimum and maximum time of an `Enum`. For example:\n\n    iex> Enum.min([~T[23:00:07.001], ~T[10:00:07.001]], Time)\n    ~T[10:00:07.001]","prompt":"Can you write a docstring for the following Elixir function? Elixir.Time"}
{"completion":"Inserts an element at the end of a tuple.\n\nReturns a new tuple with the element appended at the end, and contains\nthe elements in `tuple` followed by `value` as the last element.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> tuple = {:foo, :bar}\n    iex> Tuple.append(tuple, :baz)\n    {:foo, :bar, :baz}","prompt":"Can you write a docstring for the following Elixir function? append(tuple, value)"}
{"completion":"Removes an element from a tuple.\n\nDeletes the element at the given `index` from `tuple`.\nRaises an `ArgumentError` if `index` is negative or greater than\nor equal to the length of `tuple`. Index is zero-based.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> tuple = {:foo, :bar, :baz}\n    iex> Tuple.delete_at(tuple, 0)\n    {:bar, :baz}","prompt":"Can you write a docstring for the following Elixir function? delete_at(tuple, index)"}
{"completion":"Creates a new tuple.\n\nCreates a tuple of `size` containing the\ngiven `data` at every position.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Tuple.duplicate(:hello, 3)\n    {:hello, :hello, :hello}","prompt":"Can you write a docstring for the following Elixir function? duplicate(data, size)"}
{"completion":"Inserts an element into a tuple.\n\nInserts `value` into `tuple` at the given `index`.\nRaises an `ArgumentError` if `index` is negative or greater than the\nlength of `tuple`. Index is zero-based.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> tuple = {:bar, :baz}\n    iex> Tuple.insert_at(tuple, 0, :foo)\n    {:foo, :bar, :baz}\n    iex> Tuple.insert_at(tuple, 2, :bong)\n    {:bar, :baz, :bong}","prompt":"Can you write a docstring for the following Elixir function? insert_at(tuple, index, value)"}
{"completion":"Computes a product of tuple elements.\n\n## Examples\n\n    iex> Tuple.product({255, 255})\n    65025\n    iex> Tuple.product({255, 1.0})\n    255.0\n    iex> Tuple.product({})\n    1","prompt":"Can you write a docstring for the following Elixir function? product(tuple)"}
{"completion":"Computes a sum of tuple elements.\n\n## Examples\n\n    iex> Tuple.sum({255, 255})\n    510\n    iex> Tuple.sum({255, 0.0})\n    255.0\n    iex> Tuple.sum({})\n    0","prompt":"Can you write a docstring for the following Elixir function? sum(tuple)"}
{"completion":"Converts a tuple to a list.\n\nReturns a new list with all the tuple elements.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> tuple = {:foo, :bar, :baz}\n    iex> Tuple.to_list(tuple)\n    [:foo, :bar, :baz]","prompt":"Can you write a docstring for the following Elixir function? to_list(tuple)"}
{"completion":"Functions for working with tuples.\n\nPlease note the following functions for tuples are found in `Kernel`:\n\n  * `elem/2` - accesses a tuple by index\n  * `put_elem/3` - inserts a value into a tuple by index\n  * `tuple_size/1` - gets the number of elements in a tuple\n\nTuples are intended as fixed-size containers for multiple elements.\nTo manipulate a collection of elements, use a list instead. `Enum`\nfunctions do not work on tuples.\n\nTuples are denoted with curly braces:\n\n    iex> {}\n    {}\n    iex> {1, :two, \"three\"}\n    {1, :two, \"three\"}\n\nA tuple may contain elements of different types, which are stored\ncontiguously in memory. Accessing any element takes constant time,\nbut modifying a tuple, which produces a shallow copy, takes linear time.\nTuples are good for reading data while lists are better for traversals.\n\nTuples are typically used either when a function has multiple return values\nor for error handling. `File.read/1` returns `{:ok, contents}` if reading\nthe given file is successful, or else `{:error, reason}` such as when\nthe file does not exist.\n\nThe functions in this module that add and remove elements from tuples are\nrarely used in practice, as they typically imply tuples are being used as\ncollections. To append to a tuple, it is preferable to extract the elements\nfrom the old tuple with pattern matching, and then create a new tuple:\n\n    tuple = {:ok, :example}\n\n    # Avoid\n    result = Tuple.insert_at(tuple, 2, %{})\n\n    # Prefer\n    {:ok, atom} = tuple\n    result = {:ok, atom, %{}}","prompt":"Can you write a docstring for the following Elixir function? Elixir.Tuple"}
{"completion":"The URI struct.\n\nThe fields are defined to match the following URI representation\n(with field names between brackets):\n\n    [scheme]://[userinfo]@[host]:[port][path]?[query]#[fragment]\n\n\nNote the `authority` field is deprecated. `parse/1` will still\npopulate it for backwards compatibility but you should generally\navoid setting or getting it.","prompt":"Can you write a docstring for the following Elixir function? %URI{}"}
{"completion":"Appends `query` to the given `uri`.\n\nThe given `query` is not automatically encoded, use `encode/2` or `encode_www_form/1`.\n\n## Examples\n\n    iex> URI.append_query(URI.parse(\"http://example.com/\"), \"x=1\") |> URI.to_string()\n    \"http://example.com/?x=1\"\n\n    iex> URI.append_query(URI.parse(\"http://example.com/?x=1\"), \"y=2\") |> URI.to_string()\n    \"http://example.com/?x=1&y=2\"\n\n    iex> URI.append_query(URI.parse(\"http://example.com/?x=1\"), \"x=2\") |> URI.to_string()\n    \"http://example.com/?x=1&x=2\"","prompt":"Can you write a docstring for the following Elixir function? append_query(uri, query)"}
{"completion":"Checks if `character` is a reserved one in a URI.\n\nAs specified in [RFC 3986, section 2.2](https://tools.ietf.org/html/rfc3986#section-2.2),\nthe following characters are reserved: `:`, `/`, `?`, `#`, `[`, `]`, `@`, `!`, `$`, `&`, `'`, `(`, `)`, `*`, `+`, `,`, `;`, `=`\n\n## Examples\n\n    iex> URI.char_reserved?(?+)\n    true","prompt":"Can you write a docstring for the following Elixir function? char_reserved?(character)"}
{"completion":"Checks if `character` is allowed unescaped in a URI.\n\nThis is the default used by `URI.encode/2` where both\n[reserved](`char_reserved?/1`) and [unreserved characters](`char_unreserved?/1`)\nare kept unescaped.\n\n## Examples\n\n    iex> URI.char_unescaped?(?{)\n    false","prompt":"Can you write a docstring for the following Elixir function? char_unescaped?(character)"}
{"completion":"Checks if `character` is an unreserved one in a URI.\n\nAs specified in [RFC 3986, section 2.3](https://tools.ietf.org/html/rfc3986#section-2.3),\nthe following characters are unreserved:\n\n  * Alphanumeric characters: `A-Z`, `a-z`, `0-9`\n  * `~`, `_`, `-`, `.`\n\n## Examples\n\n    iex> URI.char_unreserved?(?_)\n    true","prompt":"Can you write a docstring for the following Elixir function? char_unreserved?(character)"}
{"completion":"Percent-unescapes a URI.\n\n## Examples\n\n    iex> URI.decode(\"https%3A%2F%2Felixir-lang.org\")\n    \"https://elixir-lang.org\"","prompt":"Can you write a docstring for the following Elixir function? decode(uri)"}
{"completion":"Decodes `query` into a map.\n\nGiven a query string in the form of `key1=value1&key2=value2...`, this\nfunction inserts each key-value pair in the query string as one entry in the\ngiven `map`. Keys and values in the resulting map will be binaries. Keys and\nvalues will be percent-unescaped.\n\nYou can specify one of the following `encoding` options:\n\n  * `:www_form` - (default, since v1.12.0) keys and values are decoded as per\n    `decode_www_form/1`. This is the format typically used by browsers on\n    query strings and form data. It decodes \"+\" as \" \".\n\n  * `:rfc3986` - (since v1.12.0) keys and values are decoded as per\n    `decode/1`. The result is the same as `:www_form` except for leaving \"+\"\n    as is in line with [RFC 3986](https://tools.ietf.org/html/rfc3986).\n\nEncoding defaults to `:www_form` for backward compatibility.\n\nUse `query_decoder/1` if you want to iterate over each value manually.\n\n## Examples\n\n    iex> URI.decode_query(\"foo=1&bar=2\")\n    %{\"bar\" => \"2\", \"foo\" => \"1\"}\n\n    iex> URI.decode_query(\"percent=oh+yes%21\", %{\"starting\" => \"map\"})\n    %{\"percent\" => \"oh yes!\", \"starting\" => \"map\"}\n\n    iex> URI.decode_query(\"percent=oh+yes%21\", %{}, :rfc3986)\n    %{\"percent\" => \"oh+yes!\"}","prompt":"Can you write a docstring for the following Elixir function? decode_query(query, map \\\\ %{}, encoding \\\\ :www_form)"}
{"completion":"Decodes `string` as \"x-www-form-urlencoded\".\n\nNote \"x-www-form-urlencoded\" is not specified as part of\nRFC 3986. However, it is a commonly used format to encode\nquery strings and form data by browsers.\n\n## Examples\n\n    iex> URI.decode_www_form(\"%3Call+in%2F\")\n    \"<all in/\"","prompt":"Can you write a docstring for the following Elixir function? decode_www_form(string)"}
{"completion":"Returns the default port for a given `scheme`.\n\nIf the scheme is unknown to the `URI` module, this function returns\n`nil`. The default port for any scheme can be configured globally\nvia `default_port/2`.\n\n## Examples\n\n    iex> URI.default_port(\"ftp\")\n    21\n\n    iex> URI.default_port(\"ponzi\")\n    nil","prompt":"Can you write a docstring for the following Elixir function? default_port(scheme)"}
{"completion":"Registers the default `port` for the given `scheme`.\n\nAfter this function is called, `port` will be returned by\n`default_port/1` for the given scheme `scheme`. Note that this function\nchanges the default port for the given `scheme` *globally*, meaning for\nevery application.\n\nIt is recommended for this function to be invoked in your\napplication's start callback in case you want to register\nnew URIs.","prompt":"Can you write a docstring for the following Elixir function? default_port(scheme, port)"}
{"completion":"Percent-escapes all characters that require escaping in `string`.\n\nThis means reserved characters, such as `:` and `/`, and the\nso-called unreserved characters, which have the same meaning both\nescaped and unescaped, won't be escaped by default.\n\nSee `encode_www_form/1` if you are interested in escaping reserved\ncharacters too.\n\nThis function also accepts a `predicate` function as an optional\nargument. If passed, this function will be called with each byte\nin `string` as its argument and should return a truthy value (anything other\nthan `false` or `nil`) if the given byte should be left as is, or return a\nfalsy value (`false` or `nil`) if the character should be escaped. Defaults\nto `URI.char_unescaped?/1`.\n\n## Examples\n\n    iex> URI.encode(\"ftp://s-ite.tld/?value=put it+\")\n    \"ftp://s-ite.tld/?value=put%20it+%D0%B9\"\n\n    iex> URI.encode(\"a string\", &(&1 != ?i))\n    \"a str%69ng\"","prompt":"Can you write a docstring for the following Elixir function? encode(string, predicate \\\\ &char_unescaped?/1)"}
{"completion":"Encodes `enumerable` into a query string using `encoding`.\n\nTakes an enumerable that enumerates as a list of two-element\ntuples (for instance, a map or a keyword list) and returns a string\nin the form of `key1=value1&key2=value2...`.\n\nKeys and values can be any term that implements the `String.Chars`\nprotocol with the exception of lists, which are explicitly forbidden.\n\nYou can specify one of the following `encoding` strategies:\n\n  * `:www_form` - (default, since v1.12.0) keys and values are URL encoded as\n    per `encode_www_form/1`. This is the format typically used by browsers on\n    query strings and form data. It encodes \" \" as \"+\".\n\n  * `:rfc3986` - (since v1.12.0) the same as `:www_form` except it encodes\n    \" \" as \"%20\" according [RFC 3986](https://tools.ietf.org/html/rfc3986).\n    This is the best option if you are encoding in a non-browser situation,\n    since encoding spaces as \"+\" can be ambiguous to URI parsers. This can\n    inadvertently lead to spaces being interpreted as literal plus signs.\n\nEncoding defaults to `:www_form` for backward compatibility.\n\n## Examples\n\n    iex> query = %{\"foo\" => 1, \"bar\" => 2}\n    iex> URI.encode_query(query)\n    \"bar=2&foo=1\"\n\n    iex> query = %{\"key\" => \"value with spaces\"}\n    iex> URI.encode_query(query)\n    \"key=value+with+spaces\"\n\n    iex> query = %{\"key\" => \"value with spaces\"}\n    iex> URI.encode_query(query, :rfc3986)\n    \"key=value%20with%20spaces\"\n\n    iex> URI.encode_query(%{key: [:a, :list]})\n    ** (ArgumentError) encode_query/2 values cannot be lists, got: [:a, :list]","prompt":"Can you write a docstring for the following Elixir function? encode_query(enumerable, encoding \\\\ :www_form)"}
{"completion":"Encodes `string` as \"x-www-form-urlencoded\".\n\nNote \"x-www-form-urlencoded\" is not specified as part of\nRFC 3986. However, it is a commonly used format to encode\nquery strings and form data by browsers.\n\n## Example\n\n    iex> URI.encode_www_form(\"put: it+\")\n    \"put%3A+it%2B%D0%B9\"","prompt":"Can you write a docstring for the following Elixir function? encode_www_form(string)"}
{"completion":"Merges two URIs.\n\nThis function merges two URIs as per\n[RFC 3986, section 5.2](https://tools.ietf.org/html/rfc3986#section-5.2).\n\n## Examples\n\n    iex> URI.merge(URI.parse(\"http://google.com\"), \"/query\") |> to_string()\n    \"http://google.com/query\"\n\n    iex> URI.merge(\"http://example.com\", \"http://google.com\") |> to_string()\n    \"http://google.com\"","prompt":"Can you write a docstring for the following Elixir function? merge(uri, rel)"}
{"completion":"Creates a new URI struct from a URI or a string.\n\nIf a `%URI{}` struct is given, it returns `{:ok, uri}`. If a string is\ngiven, it will parse and validate it. If the string is valid, it returns\n`{:ok, uri}`, otherwise it returns `{:error, part}` with the invalid part\nof the URI. For parsing URIs without further validation, see `parse/1`.\n\nThis function can parse both absolute and relative URLs. You can check\nif a URI is absolute or relative by checking if the `scheme` field is\n`nil` or not.\n\nWhen a URI is given without a port, the value returned by `URI.default_port/1`\nfor the URI's scheme is used for the `:port` field. The scheme is also\nnormalized to lowercase.\n\n## Examples\n\n    iex> URI.new(\"https://elixir-lang.org/\")\n    {:ok, %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"//elixir-lang.org/\")\n    {:ok, %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"/foo/bar\")\n    {:ok, %URI{\n      fragment: nil,\n      host: nil,\n      path: \"/foo/bar\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"foo/bar\")\n    {:ok, %URI{\n      fragment: nil,\n      host: nil,\n      path: \"foo/bar\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"//[fe80::]/\")\n    {:ok, %URI{\n      fragment: nil,\n      host: \"fe80::\",\n      path: \"/\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"https:?query\")\n    {:ok, %URI{\n      fragment: nil,\n      host: nil,\n      path: nil,\n      port: 443,\n      query: \"query\",\n      scheme: \"https\",\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"/invalid_greater_than_in_path/>\")\n    {:error, \">\"}\n\nGiving an existing URI simply returns it wrapped in a tuple:\n\n    iex> {:ok, uri} = URI.new(\"https://elixir-lang.org/\")\n    iex> URI.new(uri)\n    {:ok, %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }}","prompt":"Can you write a docstring for the following Elixir function? new(uri)"}
{"completion":"Similar to `new/1` but raises `URI.Error` if an invalid string is given.\n\n## Examples\n\n    iex> URI.new!(\"https://elixir-lang.org/\")\n    %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }\n\n    iex> URI.new!(\"/invalid_greater_than_in_path/>\")\n    ** (URI.Error) cannot parse due to reason invalid_uri: \">\"\n\nGiving an existing URI simply returns it:\n\n    iex> uri = URI.new!(\"https://elixir-lang.org/\")\n    iex> URI.new!(uri)\n    %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }","prompt":"Can you write a docstring for the following Elixir function? new!(uri)"}
{"completion":"Parses a URI into its components, without further validation.\n\nThis function can parse both absolute and relative URLs. You can check\nif a URI is absolute or relative by checking if the `scheme` field is\nnil or not. Furthermore, this function expects both absolute and\nrelative URIs to be well-formed and does not perform any validation.\nSee the \"Examples\" section below. Use `new/1` if you want to validate\nthe URI fields after parsing.\n\nWhen a URI is given without a port, the value returned by `URI.default_port/1`\nfor the URI's scheme is used for the `:port` field. The scheme is also\nnormalized to lowercase.\n\nIf a `%URI{}` struct is given to this function, this function returns it\nunmodified.\n\n> Note: this function sets the field :authority for backwards\n> compatibility reasons but it is deprecated.\n\n## Examples\n\n    iex> URI.parse(\"https://elixir-lang.org/\")\n    %URI{\n      authority: \"elixir-lang.org\",\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }\n\n    iex> URI.parse(\"//elixir-lang.org/\")\n    %URI{\n      authority: \"elixir-lang.org\",\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }\n\n    iex> URI.parse(\"/foo/bar\")\n    %URI{\n      fragment: nil,\n      host: nil,\n      path: \"/foo/bar\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }\n\n    iex> URI.parse(\"foo/bar\")\n    %URI{\n      fragment: nil,\n      host: nil,\n      path: \"foo/bar\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }\n\nIn contrast to `URI.new/1`, this function will parse poorly-formed\nURIs, for example:\n\n    iex> URI.parse(\"/invalid_greater_than_in_path/>\")\n    %URI{\n      fragment: nil,\n      host: nil,\n      path: \"/invalid_greater_than_in_path/>\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }\n\nAnother example is a URI with brackets in query strings. It is accepted\nby `parse/1`, it is commonly accepted by browsers, but it will be refused\nby `new/1`:\n\n    iex> URI.parse(\"/?foo[bar]=baz\")\n    %URI{\n      fragment: nil,\n      host: nil,\n      path: \"/\",\n      port: nil,\n      query: \"foo[bar]=baz\",\n      scheme: nil,\n      userinfo: nil\n    }","prompt":"Can you write a docstring for the following Elixir function? parse(uri)"}
{"completion":"Returns a stream of two-element tuples representing key-value pairs in the\ngiven `query`.\n\nKey and value in each tuple will be binaries and will be percent-unescaped.\n\nYou can specify one of the following `encoding` options:\n\n  * `:www_form` - (default, since v1.12.0) keys and values are decoded as per\n    `decode_www_form/1`. This is the format typically used by browsers on\n    query strings and form data. It decodes \"+\" as \" \".\n\n  * `:rfc3986` - (since v1.12.0) keys and values are decoded as per\n    `decode/1`. The result is the same as `:www_form` except for leaving \"+\"\n    as is in line with [RFC 3986](https://tools.ietf.org/html/rfc3986).\n\nEncoding defaults to `:www_form` for backward compatibility.\n\n## Examples\n\n    iex> URI.query_decoder(\"foo=1&bar=2\") |> Enum.to_list()\n    [{\"foo\", \"1\"}, {\"bar\", \"2\"}]\n\n    iex> URI.query_decoder(\"food=bread%26butter&drinks=tap%20water+please\") |> Enum.to_list()\n    [{\"food\", \"bread&butter\"}, {\"drinks\", \"tap water please\"}]\n\n    iex> URI.query_decoder(\"food=bread%26butter&drinks=tap%20water+please\", :rfc3986) |> Enum.to_list()\n    [{\"food\", \"bread&butter\"}, {\"drinks\", \"tap water+please\"}]","prompt":"Can you write a docstring for the following Elixir function? query_decoder(query, encoding \\\\ :www_form)"}
{"completion":"Returns the string representation of the given [URI struct](`t:t/0`).\n\n## Examples\n\n    iex> uri = URI.parse(\"http://google.com\")\n    iex> URI.to_string(uri)\n    \"http://google.com\"\n\n    iex> uri = URI.parse(\"foo://bar.baz\")\n    iex> URI.to_string(uri)\n    \"foo://bar.baz\"","prompt":"Can you write a docstring for the following Elixir function? to_string(uri)"}
{"completion":"Utilities for working with URIs.\n\nThis module provides functions for working with URIs (for example, parsing\nURIs or encoding query strings). The functions in this module are implemented\naccording to [RFC 3986](https://tools.ietf.org/html/rfc3986).","prompt":"Can you write a docstring for the following Elixir function? Elixir.URI"}
{"completion":"A struct that holds version requirement information.\n\nThe struct fields are private and should not be accessed.\n\nSee the \"Requirements\" section in the `Version` module\nfor more information.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Version.Requirement"}
{"completion":"The Version struct.\n\nIt contains the fields `:major`, `:minor`, `:patch`, `:pre`, and\n`:build` according to SemVer 2.0, where `:pre` is a list.\n\nYou can read those fields but you should not create a new `Version`\ndirectly via the struct syntax. Instead use the functions in this\nmodule.","prompt":"Can you write a docstring for the following Elixir function? %Version{}"}
{"completion":"Compares two versions.\n\nReturns `:gt` if the first version is greater than the second one, and `:lt`\nfor vice versa. If the two versions are equal, `:eq` is returned.\n\nPre-releases are strictly less than their corresponding release versions.\n\nPatch segments are compared lexicographically if they are alphanumeric, and\nnumerically otherwise.\n\nBuild segments are ignored: if two versions differ only in their build segment\nthey are considered to be equal.\n\nRaises a `Version.InvalidVersionError` exception if any of the two given\nversions are not parsable. If given an already parsed version this function\nwon't raise.\n\n## Examples\n\n    iex> Version.compare(\"2.0.1-alpha1\", \"2.0.0\")\n    :gt\n\n    iex> Version.compare(\"1.0.0-beta\", \"1.0.0-rc1\")\n    :lt\n\n    iex> Version.compare(\"1.0.0-10\", \"1.0.0-2\")\n    :gt\n\n    iex> Version.compare(\"2.0.1+build0\", \"2.0.1\")\n    :eq\n\n    iex> Version.compare(\"invalid\", \"2.0.1\")\n    ** (Version.InvalidVersionError) invalid version: \"invalid\"","prompt":"Can you write a docstring for the following Elixir function? compare(version1, version2)"}
{"completion":"Compiles a requirement to an internal representation that may optimize matching.\n\nThe internal representation is opaque.","prompt":"Can you write a docstring for the following Elixir function? compile_requirement(requirement)"}
{"completion":"Checks if the given version matches the specification.\n\nReturns `true` if `version` satisfies `requirement`, `false` otherwise.\nRaises a `Version.InvalidRequirementError` exception if `requirement` is not\nparsable, or a `Version.InvalidVersionError` exception if `version` is not parsable.\nIf given an already parsed version and requirement this function won't\nraise.\n\n## Options\n\n  * `:allow_pre` (boolean) - when `false`, pre-release versions will not match\n    unless the operand is a pre-release version. Defaults to `true`.\n    For examples, please refer to the table above under the \"Requirements\" section.\n\n## Examples\n\n    iex> Version.match?(\"2.0.0\", \"> 1.0.0\")\n    true\n\n    iex> Version.match?(\"2.0.0\", \"== 1.0.0\")\n    false\n\n    iex> Version.match?(\"2.1.6-dev\", \"~> 2.1.2\")\n    true\n\n    iex> Version.match?(\"2.1.6-dev\", \"~> 2.1.2\", allow_pre: false)\n    false\n\n    iex> Version.match?(\"foo\", \"== 1.0.0\")\n    ** (Version.InvalidVersionError) invalid version: \"foo\"\n\n    iex> Version.match?(\"2.0.0\", \"== == 1.0.0\")\n    ** (Version.InvalidRequirementError) invalid requirement: \"== == 1.0.0\"","prompt":"Can you write a docstring for the following Elixir function? match?(version, requirement, opts \\\\ [])"}
{"completion":"Parses a version string into a `Version` struct.\n\n## Examples\n\n    iex> Version.parse(\"2.0.1-alpha1\")\n    {:ok, %Version{major: 2, minor: 0, patch: 1, pre: [\"alpha1\"]}}\n\n    iex> Version.parse(\"2.0-alpha1\")\n    :error","prompt":"Can you write a docstring for the following Elixir function? parse(string)"}
{"completion":"Parses a version string into a `Version`.\n\nIf `string` is an invalid version, a `Version.InvalidVersionError` is raised.\n\n## Examples\n\n    iex> Version.parse!(\"2.0.1-alpha1\")\n    %Version{major: 2, minor: 0, patch: 1, pre: [\"alpha1\"]}\n\n    iex> Version.parse!(\"2.0-alpha1\")\n    ** (Version.InvalidVersionError) invalid version: \"2.0-alpha1\"","prompt":"Can you write a docstring for the following Elixir function? parse!(string)"}
{"completion":"Parses a version requirement string into a `Version.Requirement` struct.\n\n## Examples\n\n    iex> {:ok, requirement} = Version.parse_requirement(\"== 2.0.1\")\n    iex> requirement\n    Version.parse_requirement!(\"== 2.0.1\")\n\n    iex> Version.parse_requirement(\"== == 2.0.1\")\n    :error","prompt":"Can you write a docstring for the following Elixir function? parse_requirement(string)"}
{"completion":"Parses a version requirement string into a `Version.Requirement` struct.\n\nIf `string` is an invalid requirement, a `Version.InvalidRequirementError` is raised.\n\n# Examples\n\n    iex> Version.parse_requirement!(\"== 2.0.1\")\n    Version.parse_requirement!(\"== 2.0.1\")\n\n    iex> Version.parse_requirement!(\"== == 2.0.1\")\n    ** (Version.InvalidRequirementError) invalid requirement: \"== == 2.0.1\"","prompt":"Can you write a docstring for the following Elixir function? parse_requirement!(string)"}
{"completion":"Converts the given version to a string.\n\n### Examples\n\n    iex> Version.to_string(%Version{major: 1, minor: 2, patch: 3})\n    \"1.2.3\"\n    iex> Version.to_string(Version.parse!(\"1.14.0-rc.0+build0\"))\n    \"1.14.0-rc.0+build0\"","prompt":"Can you write a docstring for the following Elixir function? to_string(version)"}
{"completion":"Functions for parsing and matching versions against requirements.\n\nA version is a string in a specific format or a `Version`\ngenerated after parsing via `Version.parse/1`.\n\nAlthough Elixir projects are not required to follow SemVer,\nthey must follow the format outlined on [SemVer 2.0 schema](https://semver.org/).","prompt":"Can you write a docstring for the following Elixir function? Elixir.Version"}
{"completion":"Versions\n\nIn a nutshell, a version is represented by three numbers:\n\n    MAJOR.MINOR.PATCH\n\nPre-releases are supported by optionally appending a hyphen and a series of\nperiod-separated identifiers immediately following the patch version.\nIdentifiers consist of only ASCII alphanumeric characters and hyphens (`[0-9A-Za-z-]`):\n\n    \"1.0.0-alpha.3\"\n\nBuild information can be added by appending a plus sign and a series of\ndot-separated identifiers immediately following the patch or pre-release version.\nIdentifiers consist of only ASCII alphanumeric characters and hyphens (`[0-9A-Za-z-]`):\n\n    \"1.0.0-alpha.3+20130417140000.amd64\"","prompt":"Can you write a docstring for the following Elixir function? Elixir.Version"}
{"completion":"Requirements\n\nRequirements allow you to specify which versions of a given\ndependency you are willing to work against. Requirements support the common\ncomparison operators such as `>`, `>=`, `<`, `<=`, and `==` that work as one\nwould expect, and additionally the special operator `~>` described in detail\nfurther below.\n\n    # Only version 2.0.0\n    \"== 2.0.0\"\n\n    # Anything later than 2.0.0\n    \"> 2.0.0\"\n\nRequirements also support `and` and `or` for complex conditions:\n\n    # 2.0.0 and later until 2.1.0\n    \">= 2.0.0 and < 2.1.0\"\n\nSince the example above is such a common requirement, it can\nbe expressed as:\n\n    \"~> 2.0.0\"\n\n`~>` will never include pre-release versions of its upper bound,\nregardless of the usage of the `:allow_pre` option, or whether the operand\nis a pre-release version. It can also be used to set an upper bound on only the major\nversion part. See the table below for `~>` requirements and\ntheir corresponding translations.\n\n`~>`           | Translation\n:------------- | :---------------------\n`~> 2.0.0`     | `>= 2.0.0 and < 2.1.0`\n`~> 2.1.2`     | `>= 2.1.2 and < 2.2.0`\n`~> 2.1.3-dev` | `>= 2.1.3-dev and < 2.2.0`\n`~> 2.0`       | `>= 2.0.0 and < 3.0.0`\n`~> 2.1`       | `>= 2.1.0 and < 3.0.0`\n\nThe requirement operand after the `~>` is allowed to omit the patch version,\nallowing us to express `~> 2.1` or `~> 2.1-dev`, something that wouldn't be allowed\nwhen using the common comparison operators.\n\nWhen the `:allow_pre` option is set `false` in `Version.match?/3`, the requirement\nwill not match a pre-release version unless the operand is a pre-release version.\nThe default is to always allow pre-releases but note that in\nHex `:allow_pre` is set to `false`. See the table below for examples.\n\nRequirement    | Version     | `:allow_pre`      | Matches\n:------------- | :---------- | :---------------- | :------\n`~> 2.0`       | `2.1.0`     | `true` or `false` | `true`\n`~> 2.0`       | `3.0.0`     | `true` or `false` | `false`\n`~> 2.0.0`     | `2.0.5`     | `true` or `false` | `true`\n`~> 2.0.0`     | `2.1.0`     | `true` or `false` | `false`\n`~> 2.1.2`     | `2.1.6-dev` | `true`            | `true`\n`~> 2.1.2`     | `2.1.6-dev` | `false`           | `false`\n`~> 2.1-dev`   | `2.2.0-dev` | `true` or `false` | `true`\n`~> 2.1.2-dev` | `2.1.6-dev` | `true` or `false` | `true`\n`>= 2.1.0`     | `2.2.0-dev` | `true`            | `true`\n`>= 2.1.0`     | `2.2.0-dev` | `false`           | `false`\n`>= 2.1.0-dev` | `2.2.6-dev` | `true` or `false` | `true`","prompt":"Can you write a docstring for the following Elixir function? Elixir.Version"}
{"completion":"Adds a new backend.\n\nAdding a backend calls the `init/1` function in that backend\nwith the name of the backend as its argument. For example,\ncalling\n\n    Logger.add_backend(MyBackend)\n\nwill call `MyBackend.init(MyBackend)` to initialize the new\nbackend. If the backend's `init/1` callback returns `{:ok, _}`,\nthen this function returns `{:ok, pid}`. If the handler returns\n`{:error, :ignore}` from `init/1`, this function still returns\n`{:ok, pid}` but the handler is not started. If the handler\nreturns `{:error, reason}` from `init/1`, this function returns\n`{:error, {reason, info}}` where `info` is more information on\nthe backend that failed to start.\n\nBackends added by this function are not persisted. Therefore\nif the Logger application or supervision tree is restarted,\nthe backend won't be available. If you need this guarantee,\nthen configure the backend via the application environment:\n\n    config :logger, :backends, [MyBackend]\n\n## Options\n\n  * `:flush` - when `true`, guarantees all messages currently sent\n    to `Logger` are processed before the backend is added\n\n## Examples\n\n    {:ok, _pid} = Logger.add_backend(MyBackend, flush: true)","prompt":"Can you write a docstring for the following Elixir function? add_backend(backend, opts \\\\ [])"}
{"completion":"Adds a new translator.","prompt":"Can you write a docstring for the following Elixir function? add_translator(translator)"}
{"completion":"Logs a message dynamically.\n\nOpposite to `log/3`, `debug/2`, `info/2`, and friends, the arguments\ngiven to `bare_log/3` are always evaluated. However, you can pass\nanonymous functions to `bare_log/3` and they will only be evaluated\nif there is something to be logged.","prompt":"Can you write a docstring for the following Elixir function? bare_log(level, message_or_fun, metadata \\\\ [])"}
{"completion":"Compares log levels.\n\nReceives two log levels and compares the `left` level\nagainst the `right` level and returns:\n\n  * `:lt` if `left` is less than `right`\n  * `:eq` if `left` and `right` are equal\n  * `:gt` if `left` is greater than `right`\n\n## Examples\n\n    iex> Logger.compare_levels(:debug, :warning)\n    :lt\n    iex> Logger.compare_levels(:error, :info)\n    :gt","prompt":"Can you write a docstring for the following Elixir function? compare_levels(left, right)"}
{"completion":"Configures the logger.\n\nSee the \"Runtime Configuration\" section in the `Logger` module\ndocumentation for the available options. The changes done here\nare automatically persisted to the `:logger` application\nenvironment.","prompt":"Can you write a docstring for the following Elixir function? configure(options)"}
{"completion":"Configures the given backend.\n\nThe backend needs to be started and running in order to\nbe configured at runtime.","prompt":"Can you write a docstring for the following Elixir function? configure_backend(backend, options)"}
{"completion":"Resets the logging level for all modules to the primary level.","prompt":"Can you write a docstring for the following Elixir function? delete_all_module_levels()"}
{"completion":"Resets logging level for all modules in the given application to the primary level.\n\nEquivalent of:\n\n    appname |> Application.spec(:modules) |> Logger.delete_module_level()","prompt":"Can you write a docstring for the following Elixir function? delete_application_level(appname)"}
{"completion":"Resets the logging level for a given module to the primary level.","prompt":"Can you write a docstring for the following Elixir function? delete_module_level(module)"}
{"completion":"Resets logging level for the current process to the primary level.\n\nCurrently the only accepted PID is `self()`.","prompt":"Can you write a docstring for the following Elixir function? delete_process_level(pid)"}
{"completion":"Disables logging for the current process.\n\nCurrently the only accepted PID is `self()`.\n\nEquivalent of:\n\n    put_process_level(pid, :none)","prompt":"Can you write a docstring for the following Elixir function? disable(pid)"}
{"completion":"Enables logging for the current process.\n\nCurrently the only accepted PID is `self()`.\n\nEquivalent of:\n\n    delete_process_level(pid)","prompt":"Can you write a docstring for the following Elixir function? enable(pid)"}
{"completion":"Returns whether the logging is enabled for a given process.\n\nCurrently the only accepted PID is `self()`.","prompt":"Can you write a docstring for the following Elixir function? enabled?(pid)"}
{"completion":"Flushes the logger.\n\nThis guarantees all messages sent to `Logger` prior to this call will\nbe processed. This is useful for testing and it should not be called\nin production code.","prompt":"Can you write a docstring for the following Elixir function? flush()"}
{"completion":"Gets logging level for given module.\n\nThe returned value will be the effective value used. If no value\nwas set for a given module, then it will not be present in\nthe returned list.","prompt":"Can you write a docstring for the following Elixir function? get_module_level(mod)"}
{"completion":"Gets logging level for the current process.\n\nCurrently the only accepted PID is `self()`.\n\nThe returned value will be the effective value used. If no value\nwas set for a given process, then `nil` is returned.","prompt":"Can you write a docstring for the following Elixir function? get_process_level(pid)"}
{"completion":"Retrieves the `Logger` level.\n\nThe `Logger` level can be changed via `configure/1`.","prompt":"Can you write a docstring for the following Elixir function? level()"}
{"completion":"Reads the current process metadata.","prompt":"Can you write a docstring for the following Elixir function? metadata()"}
{"completion":"Alters the current process metadata according to the given keyword list.\n\nThis function will merge the given keyword list into the existing metadata,\nwith the exception of setting a key to `nil`, which will remove that key\nfrom the metadata.","prompt":"Can you write a docstring for the following Elixir function? metadata(keyword)"}
{"completion":"Puts logging level for modules in a given application.\n\nThis will take priority over the primary level set, so it can be\nused to increase or decrease verbosity of some parts of the project.\n\nEquivalent of:\n\n    appname |> Application.spec(:modules) |> Logger.put_module_level(level)","prompt":"Can you write a docstring for the following Elixir function? put_application_level(appname, level)"}
{"completion":"Puts logging level for given module.\n\nThis will take priority over the primary level set, so it can be\nused to increase or decrease verbosity of some parts of the project.\n\n## Example\n\n    defmodule Foo do\n      require Logger\n\n      def log, do: Logger.debug(\"foo\")\n    end\n\n    Logger.configure(level: :error)\n    Logger.put_module_level(Foo, :all)\n\n    Foo.log()\n    # This will print the message even if global level is :error","prompt":"Can you write a docstring for the following Elixir function? put_module_level(mod, level)"}
{"completion":"Puts logging level for the current process.\n\nCurrently the only accepted PID is `self()`.\n\nThis will take priority over the primary level set, so it can be\nused to increase or decrease verbosity of some parts of the running system.","prompt":"Can you write a docstring for the following Elixir function? put_process_level(pid, level)"}
{"completion":"Removes a backend.\n\n## Options\n\n  * `:flush` - when `true`, guarantees all messages currently sent\n    to `Logger` are processed before the backend is removed","prompt":"Can you write a docstring for the following Elixir function? remove_backend(backend, opts \\\\ [])"}
{"completion":"Removes a translator.","prompt":"Can you write a docstring for the following Elixir function? remove_translator(translator)"}
{"completion":"Resets the current process metadata to the given keyword list.","prompt":"Can you write a docstring for the following Elixir function? reset_metadata(keyword \\\\ [])"}
{"completion":"A logger for Elixir applications.\n\nIt includes many features:\n\n  * Provides debug, info, warn, and error levels.\n\n  * Supports multiple backends which are automatically\n    supervised when plugged into `Logger`.\n\n  * Formats and truncates messages on the client\n    to avoid clogging `Logger` backends.\n\n  * Alternates between sync and async modes to remain\n    performant when required but also apply backpressure\n    when under stress.\n\n  * Integrates with Erlang's [`:logger`](`:logger`)\n    to convert terms to Elixir syntax.\n\n  * Allows overriding the logging level for a specific module,\n    application or process.\n\nLogging is useful for tracking when an event of interest happens in your\nsystem. For example, it may be helpful to log whenever a user is deleted.\n\n    def delete_user(user) do\n      Logger.info(\"Deleting user from the system: #{inspect(user)}\")\n      # ...\n    end\n\nThe `Logger.info/2` macro emits the provided message at the `:info`\nlevel. Note the arguments given to `info/2` will only be evaluated\nif a message is logged. For instance, if the Logger level is\nset to `:warning`, `:info` messages are never logged and therefore\nthe arguments given above won't even be executed.\n\nThere are additional macros for other levels.\n\nLogger also allows log commands to be removed altogether via the\n`:compile_time_purge_matching` option (see below).\n\nFor dynamically logging messages, see `bare_log/3`. But note that\n`bare_log/3` always evaluates its arguments (unless the argument\nis an anonymous function).","prompt":"Can you write a docstring for the following Elixir function? Elixir.Logger"}
{"completion":"Levels\n\nThe supported levels, ordered by importance, are:\n\n  * `:emergency` - when system is unusable, panics\n  * `:alert` - for alerts, actions that must be taken immediately,\n    ex. corrupted database\n  * `:critical` - for critical conditions\n  * `:error` - for errors\n  * `:warning` - for warnings\n  * `:notice` - for normal, but significant, messages\n  * `:info` - for information of any kind\n  * `:debug` - for debug-related messages\n\nFor example, `:info` takes precedence over `:debug`. If your log\nlevel is set to `:info`, then all `:info`, `:notice` and above will\nbe passed to backends. If your log level is set to `:alert`, only\n`:alert` and `:emergency` will be printed.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Logger"}
{"completion":"Message\n\nLogger can be used for logging both unstructured and structured data.\n\nUnstructured data is a string or a list of strings:\n\n    Logger.info(\"hello world!\")\n    Logger.info([\"hello \", \"world!\"])\n\nStructured data, also known as reports, are keyword lists and maps:\n\n    Logger.info([new_user: user.id, account_type: :admin])\n    Logger.info(%{new_user: user.id, account_type: :admin})\n\nLog functions also accept a zero-arity anonymous function as a message:\n\n    Logger.info(fn -> \"hello world!\" end)\n\nThe anonymous function can return a message or a tuple containing\nthe message and additional metadata (to be described in the next\nsection).\n\nIn all cases, the arguments given to the `Logger` macros are only\nevaluated if required by the current log level. The exception is\nthe `bare_log/3` function, which is the raw mechanism for logging.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Logger"}
{"completion":"Metadata\n\nWhenever a message is logged, additional information can be given\nvia metadata. Each log operation, such as `Logger.info/2`, allows\nmetadata to be given as an argument.\n\nFurthermore, metadata can be set per process with `Logger.metadata/1`.\n\nSome metadata, however, is always added automatically by Logger\nwhenever possible. Those are:\n\n  * `:application` - the current application\n\n  * `:mfa` - the current module, function and arity\n\n  * `:file` - the current file\n\n  * `:line` - the current line\n\n  * `:pid` - the current process identifier\n\n  * `:initial_call` - the initial call that started the process\n\n  * `:registered_name` - the process registered name as an atom\n\n  * `:domain` - a list of domains for the logged message. For example,\n    all Elixir reports default to `[:elixir]`. Erlang reports may start\n    with `[:otp]` or `[:sasl]`\n\n  * `:crash_reason` - a two-element tuple with the throw/error/exit reason\n    as first argument and the stacktrace as second. A throw will always be\n    `{:nocatch, term}`. An error is always an `Exception` struct. All other\n    entries are exits. The console backend ignores this metadata by default\n    but it can be useful to other backends, such as the ones that report\n    errors to third-party services\n\nNote that all metadata is optional and may not always be available.\nThe `:mfa`, `:file`, `:line`, and similar metadata are automatically\nincluded when using `Logger` macros. `Logger.bare_log/3` does not include\nany metadata beyond the `:pid` by default. Other metadata, such as\n`:crash_reason`, `:initial_call`, and `:registered_name` are available\nonly inside behaviours such as GenServer, Supervisor, and others.\n\nFor example, you might wish to include a custom `:error_code` metadata in\nyour logs:\n\n    Logger.error(\"We have a problem\", [error_code: :pc_load_letter])\n\nIn your app's logger configuration, you would need to include the\n`:error_code` key and you would need to include `$metadata` as part of\nyour log format template:\n\n    config :logger, :console,\n     format: \"[$level] $message $metadata\\n\",\n     metadata: [:error_code, :file]\n\nYour logs might then receive lines like this:\n\n    [error] We have a problem error_code=pc_load_letter file=lib/app.ex","prompt":"Can you write a docstring for the following Elixir function? Elixir.Logger"}
{"completion":"Configuration\n\n`Logger` supports a wide range of configurations.\n\nThis configuration is split in three categories:\n\n  * Application configuration - must be set before the `:logger`\n    application is started\n\n  * Runtime configuration - can be set before the `:logger`\n    application is started, but may be changed during runtime\n\n  * Erlang configuration - options that handle integration with\n    Erlang's logging facilities","prompt":"Can you write a docstring for the following Elixir function? Elixir.Logger"}
{"completion":"# Application configuration\n\nThe following configuration must be set via config files (such as\n`config/config.exs`) before the `:logger` application is started.\n\n  * `:backends` - the backends to be used. Defaults to `[:console]`.\n    See the \"Backends\" section for more information.\n\n  * `:compile_time_application` - sets the `:application` metadata value\n    to the configured value at compilation time. This configuration is\n    automatically set by Mix and made available as metadata when logging.\n\n  * `:compile_time_purge_matching` - purges *at compilation time* all calls\n    that match the given conditions. This means that `Logger` calls with\n    level lower than this option will be completely removed at compile time,\n    accruing no overhead at runtime. This configuration expects a list of\n    keyword lists. Each keyword list contains a metadata key and the matching\n    value that should be purged. Some special keys are supported:\n\n      * `:level_lower_than` - purges all messages with a lower logger level\n      * `:module` - purges all messages with the matching module\n      * `:function` - purges all messages with the \"function/arity\"\n\n    Remember that if you want to purge log calls from a dependency, the\n    dependency must be recompiled.\n\n  * `:start_options` - passes start options to Logger's main process, such\n    as `:spawn_opt` and `:hibernate_after`. All options in `t:GenServer.option/0`\n    are accepted, except `:name`.\n\nFor example, to configure the `:backends` and purge all calls that happen\nat compile time with level lower than `:info` in a `config/config.exs` file:\n\n    config :logger,\n      backends: [:console],\n      compile_time_purge_matching: [\n        [level_lower_than: :info]\n      ]\n\nIf you want to purge all log calls from an application named `:foo` and only\nkeep errors from `Bar.foo/3`, you can set up two different matches:\n\n    config :logger,\n      compile_time_purge_matching: [\n        [application: :foo],\n        [module: Bar, function: \"foo/3\", level_lower_than: :error]\n      ]","prompt":"Can you write a docstring for the following Elixir function? Elixir.Logger"}
{"completion":"# Runtime Configuration\n\nAll configuration below can be set via config files (such as\n`config/config.exs`) but also changed dynamically during runtime via\n`Logger.configure/1`.\n\n  * `:level` - the logging level. Attempting to log any message\n    with severity less than the configured level will simply\n    cause the message to be ignored. Keep in mind that each backend\n    may have its specific level, too. In addition to levels mentioned\n    above it also supports 2 \"meta-levels\":\n\n      - `:all` - all messages will be logged, conceptually identical to\n        `:debug`\n      - `:none` - no messages will be logged at all\n\n  * `:utc_log` - when `true`, uses UTC in logs. By default it uses\n    local time (i.e., it defaults to `false`).\n\n  * `:truncate` - the maximum message size to be logged (in bytes).\n    Defaults to 8192 bytes. Note this configuration is approximate.\n    Truncated messages will have `\" (truncated)\"` at the end.\n    The atom `:infinity` can be passed to disable this behavior.\n\n  * `:sync_threshold` - if the `Logger` manager has more than\n    `:sync_threshold` messages in its queue, `Logger` will change\n    to *sync mode*, to apply backpressure to the clients.\n    `Logger` will return to *async mode* once the number of messages\n    in the queue is reduced to one below the `sync_threshold`.\n    Defaults to 20 messages. `:sync_threshold` can be set to `0` to\n    force *sync mode*.\n\n  * `:discard_threshold` - if the `Logger` manager has more than\n    `:discard_threshold` messages in its queue, `Logger` will change\n    to *discard mode* and messages will be discarded directly in the\n    clients. `Logger` will return to *sync mode* once the number of\n    messages in the queue is reduced to one below the `discard_threshold`.\n    Defaults to 500 messages.\n\n  * `:discard_threshold_periodic_check` - a periodic check that\n    checks and reports if logger is discarding messages. It logs a warning\n    message whenever the system is (or continues) in discard mode and\n    it logs a warning message whenever if the system was discarding messages\n    but stopped doing so after the previous check. By default it runs\n    every `30_000` milliseconds.\n\n  * `:translator_inspect_opts` - when translating OTP reports and\n    errors, the last message and state must be inspected in the\n    error reports. This configuration allow developers to change\n    how much and how the data should be inspected.\n\nFor example, to configure the `:level` and `:truncate` options in a\n`config/config.exs` file:\n\n    config :logger,\n      level: :warning,\n      truncate: 4096","prompt":"Can you write a docstring for the following Elixir function? Elixir.Logger"}
{"completion":"# Erlang/OTP integration\n\nFrom Elixir v1.10, Elixir's Logger is fully integrated with Erlang's\nlogger. They share the same `Logger.level/0`, any metadata set with\n`Logger.metadata/1` applies to both, and so on.\n\nElixir also supports formatting Erlang reports using Elixir syntax.\nThis can be controlled with two configurations:\n\n  * `:handle_otp_reports` - redirects OTP reports to `Logger` so\n    they are formatted in Elixir terms. This effectively disables\n    Erlang standard logger. Defaults to `true`.\n\n  * `:handle_sasl_reports` - redirects supervisor, crash and\n    progress reports to `Logger` so they are formatted in Elixir\n    terms. Your application must guarantee `:sasl` is started before\n    `:logger`. This means you may see some initial reports written\n    in Erlang syntax until the Logger application kicks in.\n    Defaults to `false`. This option only has an effect if\n    `:handle_otp_reports` is true.\n\nFor example, to configure `Logger` to redirect all Erlang messages using a\n`config/config.exs` file:\n\n    config :logger,\n      handle_otp_reports: true,\n      handle_sasl_reports: true\n\nFurthermore, `Logger` allows messages sent by Erlang to be translated\ninto an Elixir format via translators. Translators can be added at any\ntime with the `add_translator/1` and `remove_translator/1` APIs. Check\n`Logger.Translator` for more information.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Logger"}
{"completion":"Backends\n\n`Logger` supports different backends where log messages are written to.\n\nThe available backends by default are:\n\n  * `:console` - logs messages to the console (enabled by default).\n    `:console` is simply a shortcut for `Logger.Backends.Console`\n    (see its documentation for more information)\n\nDevelopers may also implement their own backends, an option that\nis explored in more detail below.\n\nThe initial backends are loaded via the `:backends` configuration,\nwhich must be set before the `:logger` application is started.\nHowever, by the time the Logger application starts, the code for your\nown and third-party backends may not yet be available. For this reason,\nit is preferred to add and remove backends via `add_backend/2` and\n`remove_backend/2` functions. This is often done in your\n`c:Application.start/2` callback:\n\n    @impl true\n    def start(_type, _args) do\n      Logger.add_backend(MyCustomBackend)\n\nThe backend can be configured either on the `add_backend/2` call:\n\n    @impl true\n    def start(_type, _args) do\n      Logger.add_backend(MyCustomBackend, some_config: ...)\n\nOr in your config files:\n\n    config :logger, MyCustomBackend,\n      some_config: ...","prompt":"Can you write a docstring for the following Elixir function? Elixir.Logger"}
{"completion":"# Elixir custom backends\n\nAny developer can create their own `Logger` backend. Since `Logger`\nis an event manager powered by `:gen_event`, writing a new backend\nis a matter of creating an event handler, as described in the\n[`:gen_event`](`:gen_event`) documentation.\n\nFrom now on, we will be using the term \"event handler\" to refer\nto your custom backend, as we head into implementation details.\n\nOnce the `:logger` application starts, it installs all event handlers\nlisted under the `:backends` configuration into the `Logger` event\nmanager. The event manager and all added event handlers are automatically\nsupervised by `Logger`.\n\nNote that if a backend fails to start by returning `{:error, :ignore}`\nfrom its `init/1` callback, then it's not added to the backends but\nnothing fails. If a backend fails to start by returning `{:error, reason}`\nfrom its `init/1` callback, the `:logger` application will fail to start.\n\nOnce initialized, the handler should be designed to handle the\nfollowing events:\n\n  * `{level, group_leader, {Logger, message, timestamp, metadata}}` where:\n    * `level` is one of `:debug`, `:info`, `:warn`, or `:error`, as previously\n      described (for compatibility with pre 1.10 backends the `:notice` will\n      be translated to `:info` and all messages above `:error` will be translated\n      to `:error`)\n    * `group_leader` is the group leader of the process which logged the message\n    * `{Logger, message, timestamp, metadata}` is a tuple containing information\n      about the logged message:\n      * the first element is always the atom `Logger`\n      * `message` is the actual message (as chardata)\n      * `timestamp` is the timestamp for when the message was logged, as a\n        `{{year, month, day}, {hour, minute, second, millisecond}}` tuple\n      * `metadata` is a keyword list of metadata used when logging the message\n\n  * `:flush`\n\nIt is recommended that handlers ignore messages where the group\nleader is in a different node than the one where the handler is\ninstalled. For example:\n\n    def handle_event({_level, gl, {Logger, _, _, _}}, state)\n        when node(gl) != node() do\n      {:ok, state}\n    end\n\nIn the case of the event `:flush` handlers should flush any pending\ndata. This event is triggered by `Logger.flush/0`.\n\nFurthermore, backends can be configured via the `configure_backend/2`\nfunction which requires event handlers to handle calls of the\nfollowing format:\n\n    {:configure, options}\n\nwhere `options` is a keyword list. The result of the call is the result\nreturned by `configure_backend/2`. The recommended return value for\nsuccessful configuration is `:ok`. For example:\n\n    def handle_call({:configure, options}, state) do\n      new_state = reconfigure_state(state, options)\n      {:ok, :ok, new_state}\n    end\n\nIt is recommended that backends support at least the following configuration\noptions:\n\n  * `:level` - the logging level for that backend\n  * `:format` - the logging format for that backend\n  * `:metadata` - the metadata to include in that backend\n\nCheck the `Logger.Backends.Console` implementation in Elixir's codebase\nfor examples on how to handle the recommendations in this section and\nhow to process the existing options.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Logger"}
{"completion":"# Erlang/OTP handlers\n\nWhile Elixir Logger provides backends, Erlang/OTP logger provides handlers.\nThey represent the same concept: the ability to integrate into the logging\nsystem to handle each logged message/event.\n\nHowever, implementation-wise, they have the following differences:\n\n  * Elixir backends run in a separate process which comes with overload\n    protection. However, because this process is a single GenEvent, any\n    long running action should be avoided, as it can lead to bottlenecks\n    in the system\n\n  * Erlang handlers run in the same process as the process logging the\n    message/event. This gives developers more flexibility but they should\n    avoid performing any long running action in such handlers, as it may\n    slow down the action being executed considerably. At the moment, there\n    is no built-in overload protection for Erlang handlers, so it is your\n    responsibility to implement it\n\nThe good news is that developers can use third-party implementations of\nboth Elixir backends and Erlang handlers. We have already covered Elixir\nbackends, so let's see how to add Erlang/OTP handlers.\n\nErlang/OTP handlers must be listed under your own application:\n\n    config :my_app, :logger, [\n      {:handler, :name_of_the_handler, ACustomHandler, configuration = %{}}\n    ]\n\nAnd then, explicitly attached in your `c:Application.start/2` callback:\n\n    :logger.add_handlers(:my_app)\n\nNote we do not recommend configuring Erlang/OTP's logger directly under\nthe `:kernel` application in your `config/config.exs`, like this:\n\n    # Not recommended:\n    config :kernel, :logger, ...\n\nThis is because by the time Elixir starts, Erlang's kernel has already\nbeen started, which means the configuration above would have no effect.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Logger"}
{"completion":"Stops the application without sending messages to error logger.","prompt":"Can you write a docstring for the following Elixir function? stop()"}
{"completion":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","prompt":"Can you write a docstring for the following Elixir function? child_spec(init_arg)"}
{"completion":"Starts the backend supervisor.","prompt":"Can you write a docstring for the following Elixir function? start_link(_)"}
{"completion":"Translates the shortcut backend name into its handler.","prompt":"Can you write a docstring for the following Elixir function? translate_backend(other)"}
{"completion":"Removes the given `backend`.","prompt":"Can you write a docstring for the following Elixir function? unwatch(backend)"}
{"completion":"Watches the given `backend`.","prompt":"Can you write a docstring for the following Elixir function? watch(backend)"}
{"completion":"A logger backend that logs messages by printing them to the console.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Logger.Backends.Console"}
{"completion":"Options\n\n  * `:level` - the level to be logged by this backend.\n    Note that messages are filtered by the general\n    `:level` configuration for the `:logger` application first.\n\n  * `:format` - the format message used to print logs.\n    Defaults to: `\"\\n$time $metadata[$level] $message\\n\"`.\n    It may also be a `{module, function}` tuple that is invoked\n    with the log level, the message, the current timestamp and\n    the metadata and must return `t:IO.chardata/0`. See\n    `Logger.Formatter`.\n\n  * `:metadata` - the metadata to be printed by `$metadata`.\n    Defaults to an empty list (no metadata).\n    Setting `:metadata` to `:all` prints all metadata. See\n    the \"Metadata\" section for more information.\n\n  * `:colors` - a keyword list of coloring options.\n\n  * `:device` - the device to log error messages to. Defaults to\n    `:user` but can be changed to something else such as `:standard_error`.\n\n  * `:max_buffer` - maximum events to buffer while waiting\n    for a confirmation from the IO device (default: 32).\n    Once the buffer is full, the backend will block until\n    a confirmation is received.\n\nThe supported keys in the `:colors` keyword list are:\n\n  * `:enabled` - boolean value that allows for switching the\n    coloring on and off. Defaults to: `IO.ANSI.enabled?/0`\n\n  * `:debug` - color for debug messages. Defaults to: `:cyan`\n\n  * `:info` - color for info and notice messages. Defaults to: `:normal`\n\n  * `:warning` - color for warning messages. Defaults to: `:yellow`\n\n  * `:error` - color for error and higher messages. Defaults to: `:red`\n\nSee the `IO.ANSI` module for a list of colors and attributes.\n\nHere is an example of how to configure the `:console` backend in a\n`config/config.exs` file:\n\n    config :logger, :console,\n      format: \"\\n$time $metadata[$level] $message\\n\",\n      metadata: [:user_id]","prompt":"Can you write a docstring for the following Elixir function? Elixir.Logger.Backends.Console"}
{"completion":"Filter messages logged via `Logger` module when not logging OTP reports.","prompt":"Can you write a docstring for the following Elixir function? filter_elixir_domain(map, extra)"}
{"completion":"Filter out logs if current process opted out of certain levels.","prompt":"Can you write a docstring for the following Elixir function? process_level(map, extra)"}
{"completion":"A filter that waits until Logger exits and then removes itself.","prompt":"Can you write a docstring for the following Elixir function? silence_logger_exit(arg1, extra)"}
{"completion":"Compiles a format string into a data structure that `format/5` can handle.\n\nCheck the module doc for documentation on the valid parameters that\nwill be interpolated in the pattern. If you pass `nil` as the pattern,\nthe pattern defaults to:\n\n    \"\\n$time $metadata[$level] $message\\n\"\n\nIf you want to customize formatting through a custom formatter, you can\npass a `{module, function}` tuple as the `pattern`.\n\n    iex> Logger.Formatter.compile(\"$time $metadata [$level] $message\\n\")\n    [:time, \" \", :metadata, \" [\", :level, \"] \", :message, \"\\n\"]\n\n    iex> Logger.Formatter.compile({MyLoggerFormatter, :format})\n    {MyLoggerFormatter, :format}","prompt":"Can you write a docstring for the following Elixir function? compile(pattern)"}
{"completion":"Takes a compiled format and injects the level, timestamp, message, and\nmetadata keyword list and returns a properly formatted string.\n\nIf `pattern_or_function` is a `{module, function_name}` tuple,\nthen `module.function_name(level, message, timestamp, metadata)` is\ninvoked to get the message. See `Logger.Backends.Console` for more\ninformation on this.\n\n## Examples\n\n    iex> pattern = Logger.Formatter.compile(\"[$level] $message\")\n    iex> timestamp = {{1977, 01, 28}, {13, 29, 00, 000}}\n    iex> formatted = Logger.Formatter.format(pattern, :info, \"hello\", timestamp, [])\n    iex> IO.chardata_to_string(formatted)\n    \"[info] hello\"","prompt":"Can you write a docstring for the following Elixir function? format(pattern_or_function, level, message, timestamp, metadata)"}
{"completion":"Formats date as chardata.","prompt":"Can you write a docstring for the following Elixir function? format_date(arg)"}
{"completion":"Formats time as chardata.","prompt":"Can you write a docstring for the following Elixir function? format_time(arg)"}
{"completion":"Prunes invalid Unicode code points from lists and invalid UTF-8 bytes.\n\nTypically called after formatting when the data cannot be printed.","prompt":"Can you write a docstring for the following Elixir function? prune(binary)"}
{"completion":"Conveniences for formatting data for logs.\n\nThis module allows developers to specify a `{module, function}`\nor a string that serves as template for log messages.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Logger.Formatter"}
{"completion":"Formatting string\n\nThe log messages can be controlled by a formatting string.\nHere is an example of how to configure the `:console` backend\nin a `config/config.exs` file:\n\nFor example:\n\n    config :logger, :console,\n      format: \"$time $metadata[$level] $message\\n\"\n\nThe above will print error messages as:\n\n    18:43:12.439 user_id=13 [error] Hello\\n\n\nThe valid parameters you can use are:\n\n  * `$time`     - the time the log message was sent\n  * `$date`     - the date the log message was sent\n  * `$message`  - the log message\n  * `$level`    - the log level\n  * `$node`     - the node that prints the message\n  * `$metadata` - user controlled data presented in `\"key=val key2=val2 \"` format\n\nBackends typically allow developers to supply such control\nstrings via configuration files. This module provides `compile/1`,\nwhich compiles the string into a format for fast operations at\nruntime and `format/5` to format the compiled pattern into an\nactual IO data.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Logger.Formatter"}
{"completion":"Formatting function\n\nYou can also customize the format of your log messages to a\n`{module, function}` tuple if you wish to provide your own\nformat function. Here is an example of how to configure the\n`:console` backend in a `config/config.exs` file:\n\n    config :logger, :console,\n      format: {MyConsoleLogger, :format}\n\nAnd here is an example of how you can define `MyConsoleLogger.format/4`\nfrom the above configuration:\n\n    defmodule MyConsoleLogger do\n      @spec format(atom, term, Logger.Formatter.time(), keyword()) :: IO.chardata()\n      def format(level, message, timestamp, metadata) do\n        # Custom formatting logic that must return chardata.\n        # ...\n      end\n    end\n\n**The `format/4` function must not fail**. If it does, it will bring\nthat particular logger instance down, causing your system to temporarily\nlose log messages. If necessary, wrap the function in a `rescue` and\nlog a default message instead:\n\n    defmodule MyConsoleLogger do\n      def format(level, message, timestamp, metadata) do\n        # Custom formatting logic\n      rescue\n        _ -> \"could not format: #{inspect({level, message, metadata})}\"\n      end\n    end\n\nThe `{module, function}` will be invoked with four arguments:\n\n  * the log level: an atom (`t:atom/0`)\n  * the message: this is usually `t:IO.chardata/0`, but in some cases it\n    may contain invalid data. Since the formatting function must\n    *never* fail, you need to prepare for the message being anything\n  * the current timestamp: a term of type `t:Logger.Formatter.time/0`\n  * the metadata: a keyword list (`t:keyword/0`)\n\nThe `{module, function}` must return a term of type `t:IO.chardata/0`.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Logger.Formatter"}
{"completion":"Metadata\n\nMetadata to be sent to the logger can be read and written with\nthe `Logger.metadata/0` and `Logger.metadata/1` functions. For example,\nyou can set `Logger.metadata([user_id: 13])` to add user_id metadata\nto the current process. The user can configure the backend to choose\nwhich metadata it wants to print and it will replace the `$metadata`\nvalue.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Logger.Formatter"}
{"completion":"Built-in translation function.","prompt":"Can you write a docstring for the following Elixir function? translate(min_level, level, kind, message)"}
{"completion":"Default translation for Erlang log messages.\n\nLogger allows developers to rewrite log messages provided by\nOTP applications into a format more compatible with Elixir\nlog messages by providing a translator.\n\nA translator is simply a tuple containing a module and a function\nthat can be added and removed via the `Logger.add_translator/1` and\n`Logger.remove_translator/1` functions and is invoked for every Erlang\nmessage above the minimum log level with four arguments:\n\n  * `min_level` - the current Logger level\n  * `level` - the level of the message being translated\n  * `kind` - if the message is a `:report` or `:format`\n  * `message` - the message to format. If it is `:report`, it is a tuple\n    with `{report_type, report_data}`, if it is `:format`, it is a\n    tuple with `{format_message, format_args}`.\n\nThe function must return:\n\n  * `{:ok, chardata, metadata}` - if the message translation with its metadata\n  * `{:ok, chardata}` - the translated message\n  * `:skip` - if the message is not meant to be translated nor logged\n  * `:none` - if there is no translation, which triggers the next translator\n\nSee the function `translate/4` in this module for an example implementation\nand the default messages translated by Logger.","prompt":"Can you write a docstring for the following Elixir function? Elixir.Logger.Translator"}
{"completion":"Receives a format string and arguments, scans them, and then replace `~p`,\n`~P`, `~w` and `~W` by its inspected variants.\n\nFor information about format scanning and how to consume them,\ncheck `:io_lib.scan_format/2`","prompt":"Can you write a docstring for the following Elixir function? scan_inspect(format, args, truncate, opts \\\\ %Inspect.Opts{})"}
{"completion":"Returns a timestamp that includes milliseconds.","prompt":"Can you write a docstring for the following Elixir function? timestamp(timestamp \\\\ :os.system_time(:microsecond), utc_log?)"}
{"completion":"Truncates a `chardata` into `n` bytes.\n\nThere is a chance we truncate in the middle of a grapheme\ncluster but we never truncate in the middle of a binary\ncode point. For this reason, truncation is not exact.","prompt":"Can you write a docstring for the following Elixir function? truncate(chardata, n)"}
{"completion":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","prompt":"Can you write a docstring for the following Elixir function? child_spec(init_arg)"}
{"completion":"Starts a watcher server.\n\nThis is useful when there is a need to start a handler\noutside of the handler supervision tree.","prompt":"Can you write a docstring for the following Elixir function? start_link(tuple)"}
